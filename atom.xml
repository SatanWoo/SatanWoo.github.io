<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://satanwoo.github.io/"/>
  <updated>2016-07-10T09:08:26.000Z</updated>
  <id>http://satanwoo.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从Immutable来谈谈对于线程安全的理解误区]]></title>
    <link href="http://satanwoo.github.io/2016/07/10/immutable-thread/"/>
    <id>http://satanwoo.github.io/2016/07/10/immutable-thread/</id>
    <published>2016-07-10T09:03:47.000Z</published>
    <updated>2016-07-10T09:08:26.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线程安全中真正起到的作用。</p>
<p>所以今天就以这篇文章来谈谈我所理解的线程安全。</p>
<p>首先就允许我从Immutable来开始整篇话题吧。</p>
<h3 id="Swift中的Immutable">Swift中的Immutable</h3><p>用过Swift的人都知道，Swift相较于Objective-C有一个比较明显的改动就是将结构体（Struct）和类型（Class）进行了分离。从某种方面来说，Swift将值类型和引用类型进行了明显的区分。为什么要这么做？</p>
<ol>
<li>避免了引用类型在被作为参数传递后被他人持有后修改，从而引发比较难以排查的问题。</li>
<li>在某些程度上提供了一定的线程安全（因为多线程本身的问题很大程序上出在<strong>写修改</strong>的不确定性）。而Immutable 数据的好处在于一旦创建结束就无法修改，因此相当于任一一个线程在使用它的过程中仅仅是使用了读的功能。</li>
</ol>
<p>看到这，很多人开始欢呼了（嘲讽下WWDC那些“托”一般的粉丝，哈哈），觉得线程安全的问题迎刃而解了。</p>
<p>但事实上，我想说的是<strong>使用Immutable不直接等同于线程安全</strong>，不然在使用NSArray，NSDictionary等等Immutable对象之后，为啥还会有那么多奇怪的bug出现？</p>
<h3 id="指针与对象">指针与对象</h3><p>有些朋友会问，Immutable都将一个对象变为不可变的“固态”了，为什么还是不安全呢，在各个线程间传递的只是一份只读文件啊。</p>
<p>是的，对于一个Immutable的对象来说，它自身是不可变了。但是在我们的程序里，我们总是需要有“东西”去指向我们的对象的吧，那这个“东西”是什么？<strong>指向对象的指针</strong>。</p>
<p>指针想必大家都不会陌生。对于指针来说，其实它本质也是一种对象，我们更改指针的指向的时候，实质上就是对于指针的一种赋值。所以想象这样一种场景，当你用一个指针指向一个Immutable对象的时候，在多线程更改的时候，你觉得你的指针修改是线程安全的吗？这也就是为什么有些人碰到一些跟<strong>NSArray</strong>这种Immutable对象的在多线程出现奇怪bug的时候会显得一脸懵逼。</p>
<p>举例：  </p>
<pre><code><span class="comment">// Thread A 其中immutableArrayA count 7</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayA;

<span class="comment">// Thread B 其中immutableArrayB count 4</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayB 

<span class="comment">// main Thread</span>
<span class="preprocessor">[</span><span class="built_in">self</span><span class="built_in">.</span>xxx objectAtIndex:<span class="number">5</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述这个代码片段，绝对是存在线程的安全的隐患的。</p>
<h3 id="锁">锁</h3><p>既然想到了多线程对于指针（或者对象）的修改，我们很理所当然的就会想到用锁。在现如今iOS博客泛滥的年代，大家都知道NSLock, OSSpinLock之类的可以用于短暂的Critical Section竞态的锁保护。</p>
<p>所以对于一些多线程中需要使用共享数据源并支持修改操作的时候，比如NSMutableArray添加一些object的时候，我们可以写出如下代码：</p>
<pre><code>OSSpinLock(&amp;_lock)<span class="comment">;</span>
[self.array addObject:@"hahah"]<span class="comment">;</span>
OSSpinUnlock(&amp;_lock)<span class="comment">;</span>
</code></pre><p>乍一看，这个没问题了，这个就是最基本的写保护锁。如果有多个代码同时尝试添加进入<code>self.array</code>，是会通过锁抢占的方式一个一个的方式的添加。</p>
<p>但是，这个东西有啥卵用吗？原子锁只能解决Race Condition的问题，但是它并不能解决任何你代码中需要有时序保证的逻辑。</p>
<p>比如如下这段代码：</p>
<pre><code>if (<span class="literal">self</span>.xxx) {
    [<span class="literal">self</span>.dict <span class="built_in">set</span>Object:@<span class="string">"ah"</span> <span class="keyword">for</span>Key:<span class="literal">self</span>.xxx];
}
</code></pre><p>大家第一眼看到这样的代码，是不是会认为是正确的？因为在设置key的时候已经提前进行了<code>self.xxx</code>为<strong>非nil</strong>的判断，只有非nil得情况下才会执行后续的指令。<strong>但是，如上代码只有在单线程的前提下才是正确的。</strong></p>
<p>假设我们将上述代码目前执行的线程为<code>Thread A</code>，当我们执行完<code>if (self.xxx)</code>的语句之后，此时CPU将执行权切换给了<code>Thread B</code>，而这个时候Thread B中调用了一句<strong><em><code>self.xxx = nil</code></em></strong>。<div style="color:red"><b>嘿嘿，后果如何，想必我不用多说了吧。</b></div></p>
<p>那对于这种问题，我们有没有比较好的解决方案呢？答案是存在的，就是使用<strong>局部变量</strong>。<br>针对上述代码，我们进行如下修改：</p>
<pre><code>__strong id <span class="function"><span class="keyword">val</span> =</span> self.xxx;
<span class="keyword">if</span> (<span class="function"><span class="keyword">val</span>) {</span>
    [self.dict setObject:@<span class="string">"ah"</span> forKey:<span class="function"><span class="keyword">val</span>];</span>
}
</code></pre><p>这样，无论多少线程尝试对<code>self.xxx</code>进行修改，本质上的<code>val</code>都会保持现有的状态，符合非nil的判断。</p>
<h3 id="Objective-C的Property_Setter多线程并发bug">Objective-C的Property Setter多线程并发bug</h3><p>最后我们回到经常使用的Objective-C来谈谈现实生活中经常出现的问题。相信各位对于Property的Setter概念都不陌生，<code>self.xxx = @&quot;kks&quot;</code>其实就是调用了<code>xxx</code>的setter方法。而Setter方法本质上就是如下这样一段代码逻辑：</p>
<pre><code>- (void)setXxx:(NSString *)newXXX {
      if (newXXX != _xxx) {
          [newXXX retain]<span class="comment">;</span>
          [_xxx release]<span class="comment">;</span>
          _userName = newXXX<span class="comment">;</span>
      }
}
</code></pre><p>比如<strong>Thread A 和 B</strong>同时对<code>self.xxx</code>进行了赋值，当两者都越过了<code>if (newXXX != _xxx)</code>的判断的时候，就会产生<code>[_xxx release]</code>执行了两次，造成过度释放的crash危险。</p>
<p>有人说，呵呵，你这是MRC时代的写法，我用了ARC，没问题了吧。</p>
<p>ok，那让我们来看看ARC时代是怎么处理的，对于ARC中不复写Setter的属性（我相信是绝大多数情况），Objective-C的<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm" target="_blank" rel="external">底层源码</a>是这么处理的。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, 
  ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) 
{
    <span class="keyword">id</span> oldValue;
    <span class="comment">// 计算结构体中的偏移量</span>
    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);

    <span class="keyword">if</span> (<span class="keyword">copy</span>) {
        newValue = [newValue copyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> {
        <span class="comment">// 某些程度的优化</span>
        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;
        newValue = objc_retain(newValue);
    }

    <span class="comment">// 危险区</span>
    <span class="keyword">if</span> (!atomic) {
         <span class="comment">// 第一步</span>
        oldValue = *slot;

        <span class="comment">// 第二步</span>
        *slot = newValue;
    } <span class="keyword">else</span> {
        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
        _spin_lock(slotlock);
        oldValue = *slot;
        *slot = newValue;        
        _spin_unlock(slotlock);
    }

    objc_release(oldValue);
}
</code></pre><p>由于我们一般声明的对象都是<strong>nonatomic</strong>，所以逻辑会走到上述注释<strong>危险区</strong>处。还是设想一下多线程对一个属性同时设置的情况，我们首先在线程A处获取到了执行第一步代码后的<strong>oldValue</strong>，然后此时线程切换到了B，B也获得了第一步后的oldValue，所以此时就有两处持有oldValue。然后无论是线程A或者线程B执行到最后都会执行<strong>objc_release(oldValue);</strong>。</p>
<div style="color:red"><b>于是，重复释放的场景就出现了，crash在向你招手哦！</b></div>

<p>如果不相信的话，可以尝试如下这个小例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>相信你很容易就能看到如下错误log：<strong>error for object: pointer being freed was not allocated</strong>。</p>
<h3 id="结语">结语</h3><p>说了这么多，本质上线程安全是个一直存在并且相对来说是个比较困难的问题，没有绝对的银弹。用了Immutable不代表可以完全抛弃锁，用了锁也不代表高枕无忧了。希望这篇文章能够帮助大家更深入的思考下相关的问题，不要见到线程安全相关的问题就直接回答加锁、使用Immutable数据之类的。</p>
<p><strong>当然，其实Stick To GCD (dispatch_barrier)是最好的解决方案。</strong></p>
<p>本文写于头昏脑涨之中，写错之处请大神多多指出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么Spotify的付费用户转化率惊人的高？]]></title>
    <link href="http://satanwoo.github.io/2016/05/02/Spotify/"/>
    <id>http://satanwoo.github.io/2016/05/02/Spotify/</id>
    <published>2016-05-02T08:34:03.000Z</published>
    <updated>2016-05-02T08:38:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文由本人独自翻译，同步发表在稀土上</strong></p>
<p>在 2015 年的时候，The Fader <a href="http://www.thefader.com/2015/06/10/new-spotify-statistics" target="_blank" rel="external">报道</a>了一则关于 Spotify 的重磅新闻：在其 7500 万月活跃用户中，有 2000 万左右是付费用户。</p>
<p>26.6% 的转化率对于免费增值产品来说是令人难以置信的。正如 Jason Chen <a href="http://blog.asmartbear.com/freemium.html" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>“如果说免费用户到收费用户的转化率可以达到 4%，那就已经可以说是很不错了，比如 DropBox。但是通常来说，转化率一般都处于 1% 上下浮动，这还是用户十分活跃的情况下才会达到。”</p>
</blockquote>
<p>如果说 1% 是普遍的水准，然后 <a href="https://www.process.st/dropbox-vs-google-drive/" target="_blank" rel="external">DropBox</a> 4% 的转化率是非常不错的话，那26.6%绝对可以称的上是令人匪夷所思了。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/1.jpg" alt=""></p>
<p>至于用户留存率，<a href="http://expandedramblings.com/index.php/spotify-statistics/" target="_blank" rel="external">80%</a>的用户（包括免费用户和付费用户）每周都会多次使用 Spotify。</p>
<p>我写这篇文章的原因在于我在使用 Spotify 仅仅 11 天后，就成为了它的付费用户（似乎我当时还经历了一个 7 天 A/B 测试的试用阶段）。所以，我想从产品、<a href="https://medium.com/@benjbrandall/astonishment-expectations-and-reality-in-user-experience-decb6cc18e28" target="_blank" rel="external">用户体验</a>和市场运营的视角来真正探究一下其中深层次的原因，究竟是什么导致了 Spotify 有如此大的魔力让用户乐意为其付费。</p>
<p>所以，出于这次研究的目的，我又重新注册了一个账号。</p>
<p>我用了一个新账号并且从一个新用户的视角来使用 Spotify，一个个去剖析那些容易激发用户付费的诱因，并调查这些诱因是如何保证如此高的转化率以及用户留存率。</p>
<p><em>在我们开始前，我们需要留意一点:</em> <a href="https://www.process.st/slack-review/" target="_blank" rel="external">Slack</a> 也因为它那令人咋舌的用户转化率而出名，<a href="http://www.nirandfar.com/2014/11/slack.html" target="_blank" rel="external">最新的数据</a>显示它们的转化率达到了 30% 左右。但要注意的是，Slack 是一个 B2B 软件，它的用户群体相对来说是付费能力和意愿比较强的高端用户。但是Spotify 有超过 <a href="http://www.statista.com/statistics/475821/spotify-users-age-usa/" target="_blank" rel="external">20%</a>的用户是处于 13 到 18 岁年龄段。与企业精英不惜代价寻找一种合适的解决方案相比，这个年龄段的用户一般能成为付费用户的可能性很低的…所以，Spotify 真的很令人难以置信。</p>
<h2 id="步骤_1：减少使用障碍，通过_Facebook_注册来形成病毒式营销">步骤 1：减少使用障碍，通过 Facebook 注册来形成病毒式营销</h2><p>Spotfiy 通过 Facebook 获取信息的注册方法是令人称道的。对于那些已经在手机上登录 Facebook 的用户来说，这种注册方式可以直接从 Facebook 获取你的用户数据，意味着你就不用再笨拙地输入你的邮件地址和密码。这无疑会减少用户注册账号的抵触心理。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/2.png" alt=""></p>
<p>只要仅仅一次点击，允许数据导入，你就注册成功了。</p>
<p>除了作为一种注册方式以外，导入 Facebook 的数据还完成了其余两件事：</p>
<ul>
<li>将用户的喜好展示给他们的朋友</li>
<li>可以让你的朋友了解 Spotify，并吸引他们也来注册使用 Spotify</li>
</ul>
<p>正如 Helpshift <a href="https://www.helpshift.com/blog/app-retention-20000-mau/" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>80% 的手机用户拥有 Facebook 账户。所以，当一个应用的注册只需要轻轻点击蓝色按钮的时候，用户的转化率瞬间就能有 20% 的提升。</p>
</blockquote>
<p>所以使用 Facebook 进行注册，对于 Spotify 的营销来说是起了一个非常关键的作用。正如报道中所说的那样，<strong><a href="https://www.digitalmusicnews.com/2015/06/16/for-every-paying-subscriber-spotify-adds-5-free-accounts/" target="_blank" rel="external">每一个付费用户都带来了3个免费用户</a></strong></p>
<h2 id="步骤_2：精挑细选的播放列表可以满足特定的需求">步骤 2：精挑细选的播放列表可以满足特定的需求</h2><p>Spotify 的目的就是帮助用户发现音乐。它在你初次使用的时候会鼓励你使用它“精心调配”的播放列表。</p>
<p>通过选择一个包含你熟悉歌曲的播放列表，或者一个和你品味相契合的主题，Spotify 会循环播放这些歌，并在其中穿插播放一些你所不了解的歌。</p>
<p>对于一首喜爱却又不了解的歌，人们通常的反应是会去寻找这首歌的歌手、所属专辑或者其他具有相似特征的播放列表。这种寻找的流程在 Spotify 的应用中被设计的极其简单，并且会被推荐到你看到的第一屏当中。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/3.png" alt=""></p>
<p>但这里有个需要注意的点：<strong>如果你是一个免费用户，那么你就无法在任意时刻切换到你想听的歌。</strong>即使你已经制作了你自己的播放列表，歌曲也会是随机出现的。</p>
<p>所以对于我来说，我成为付费用户的一个主要原因就在于：在 Spotify 那不可思议却又十分“对味”的推荐算法指引下，我就很自然而然的养成了一种新的并在不断改进的听歌风格。在这个过程中，许许多多的歌曲都会被加入到你的听歌列表中。但一旦加入，随机播放列表就再也不会将其剔除。因此，其中有部分可能是你不怎么想要再听到的歌曲。比如我就不再想听到任何 Brain Food 里的歌。我想要的是可以自由自在的挑选歌曲、对它们进行排序，并对我自己的歌曲列表有绝对的控制权。如果我不是付费用户的话，即使我特别想听 Stars Wars Headspace 专辑中的几首歌，但是我所能做的仅仅是不断地随机跳过我不喜欢的歌曲，直到从 Spotify 听到我想听的歌。</p>
<p>人们会尝试去“挑战”这个系统来听到他们想要听的歌，但是 Spotify 让这种想法近乎不可能。一般来说，在一个随机播放的列表中，你可能需要跳过8首歌才能听到你想要的歌。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/4.png" alt=""></p>
<h2 id="步骤3：Spotify_会强调歌曲和你息息相关的">步骤3：Spotify 会强调歌曲和你息息相关的</h2><p>首页下面是根据心情情况和流派推荐的播放列表。作为一名有音乐文化背景的研究生，我了解到人们听音乐的根本原因在于音乐能够加强情感共鸣。最好的音乐作曲家，如 <a href="https://en.wikipedia.org/wiki/Lester_Bangs" target="_blank" rel="external">Lester Bangs</a>，就曾写到这样的乐评:音乐就像一剂猛药，伴随并强化着你的听音乐体验。</p>
<p>Spotify 通过一些描述性的分类，并在其中播放与描述非常贴切的音乐来引发共鸣，让听众产生一种“音乐就是我人生不可分割的轨迹”、或“这就是我现在的感受”的心境。</p>
<p>比如在 Chill 心情分类中可以找到一些让你冷静下来的歌曲，每首歌曲又会与地点、’亚情绪’及个人听歌品味相契合。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/5.png" alt=""></p>
<p>歌曲列表包含艺术、排版以及<a href="http://blog.tryadhawk.com/content-marketing/headline-checklist/" target="_blank" rel="external">文案</a>。这些东西对于拥有不同审美的用户来说充满诱惑力。因此对用户来说，很容易就会忽略掉那些不重要的。然后立刻识别出那些诉诸于你的音乐。</p>
<p>通过鼓励你多使用播放列表，并将其和你平时的生活习惯紧紧联系到一起，Spotify 就会变得越来越智能：成为一个能够生成适应任何场景的音乐播放器。<strong>构建一个能融入用户日常生活习惯的产品是一个非常有效<a href="https://www.process.st/customer-retention-strategies/" target="_blank" rel="external">提升用户留存率</a>的方法。</strong>而 Spotify 又采用了非常人性化的手段来达成这个目的：通过理解你听音乐时候的场景和心情。比如你聚会时听得音乐；抑或是跑步、学习时听的音乐。一旦你因为这些目的使用过一次播放列表，当失去它的时候你就会非常想念它。</p>
<h2 id="步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。">步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。</h2><p>我之前看过一篇关于<a href="http://usabilitygeek.com/first-time-use-how-to-reduce-initial-friction-of-app-usage/" target="_blank" rel="external"> Flipboard 的入职流程</a>的分析，让用户将应用“培养”<br>成迎合他们自身的喜好是一个久经考验能够提升用户留存率的办法。因为在这个过程中，用户相当于在应用内做了一笔“投资”：如果他们不升级成付费用户，就意味着他们之前所耗费的精力和时间都白白浪费了。</p>
<p>Spotify 也采用了这个策略。他们的做法是允许用户将音乐存储到自己的账户中、建立自己的音乐合集、通过 Facebook 以及Spotify 自己的社交网络和朋友进行分享。</p>
<p><strong>当然，这种投资并是金钱投资，因此你不会感到是被强制消费了。（事实上，现在如果还采用收费合同来绑定用户的行为是不能被容忍的）。但是这种投资对于个人来说，却显得更为重要，因为这是一种跟时间相关的投资，每个人都很珍惜时间，不是吗?</strong></p>
<p>将 Spotify 和 Facebook 打通又是另外一种投资。在不同的应用之间建立依赖关系意味着你需要承担更多的责任。比如，你的朋友喜欢你的播放列表、喜欢听你喜欢的歌。这就意味着你在你的朋友圈中成为了一个传播品味的大师，可以给朋友宣传最新最酷的潮流。我想，你肯定不会因为不想成为付费用户就失去这得之不易的品味大师的头衔吧！</p>
<p>Spotify 并不会强求你选择一个你喜欢的音乐类型，也不会给你许多听歌的建议，它所做的只是让你自行探索音乐。因为自行探索出来的音乐会让你更加感同身受，而且和别人分享这些音乐的时候，也会让你更有成就感。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/6.png" alt="Spotify Personalization"></p>
<p>当你在你自己的设备上使用 Spotify 的时候，除了生成个性化的播放列表，Spotify 并不会耗费你大量的精力。事实上，它根本就不需要。Spotify 的推荐算法已经足够强大，能够理解你的需求。而且多半时候，推荐出来的东西都正是你想要的。所以，你只需要在培养属于你自己喜好的 Spotify 的时候耗费一点精力而已。<strong>_你的_Spotify其实比你自己更懂你的喜好</strong></p>
<h2 id="这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感">这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感</h2><p>另一个能让 Spotify 的付费策略成功伪装成是不激进的原因的是（实际上是非常激进的）你没有意识到你究竟会被一些负面因素激怒到何种程度。</p>
<p><img src="http://i.imgur.com/CIKcZnV.jpg" alt=""></p>
<p>音乐一个非常关键的作用就是它给人带来的代入感。在 Spotify 上，有一些非常流行的播放列表来帮助用户专注于工作，比如学习、<a href="https://www.process.st/writing-process/" target="_blank" rel="external">写作</a>或者要求注意力非常集中的情形。</p>
<p>_你听了15分钟的 chill Brian Eno soundscape。突然，一个刺耳的、极不匹配的流行音乐开始播放。紧跟着出现了一个广告，一个人告诉了你一个你现在毫不关心的东西。然后又过了 30 秒，这些乱七八糟的东西终于结束了，你终于可以听你想要的音乐了。如果是你，你是什么感受？。</p>
<p>对我来说，摆脱广告的烦扰并不是一个足够有说服力可以让我进行付费的理由。我并不把它们当成是对听音乐有着巨大负面影响的因素。因为只要等广告结束了，我就能继续听我想听的音乐。</p>
<p>而且和 <strong>Spotify 会让你跳过 8 首歌才能听过你想要的歌曲</strong>相比，广告是微不足道的，更何况它出现的频率也很低，低到很容易被忽略。但尽管如此，广告对于转化率也有着很大的作用。</p>
<h2 id="允许用户在30天的试用期下载离线音乐是极其明智的">允许用户在30天的试用期下载离线音乐是极其明智的</h2><p>没有什么可以比把你曾经拥有的东西强行夺走更会让你抓狂。</p>
<p>通过允许用户下载歌曲离线使用，又在一段时间后限制他们只能听在线音乐，<strong>这 30 天试用期带来的自由绝对你产生巨大的落差感</strong>。</p>
<p>一个月的试用期对于用户来说完全足够在这段时间内建立起一个音乐合集。更何况 Spotify 大大减少了探索音乐需要耗费的时间：它每天给用户推荐 20 张专辑，而且还会根据你当前的品味和习惯变化。所以 Spotify 通过试用期，给用户画了很大的一个“饼”：如果你们升级成付费用户的话，你们就能享受到多么棒听歌的特权啊。</p>
<p>一旦获得了离线听歌的特权，用户就会囤积尽可能多的歌曲。用他们的话来说，这是<em>属于你的音乐</em>。但囤积的越多，就会让你陷得越深，你再也不会愿意变回免费用户了。</p>
<h2 id="无论用户如何使用_Spotify,_最后都会被引导向升级付费">无论用户如何使用 Spotify, 最后都会被引导向升级付费</h2><p>在用户的使用过程中，有时候 Spotify 会明确的要求用户升级为会员，或者提示这个功能仅仅开放给付费用户。</p>
<p>其中，明确的要求你升级（或者说强迫式的推荐）出现在<strong>一些看似可用的功能实质上仅仅开放给付费用户</strong></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/8.jpg" alt=""></p>
<p>而在如下几种情况当中，Spotify 会采用暗示的方式提示你如果升级到付费用户，使用体验会更好：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/9.jpg" alt=""></p>
<p>所以即使 Spofity 有着巨大基数的免费用户，也很容易就能说明为什么它的付费转化率如此之高。</p>
<p><strong>只要你是音乐的发烧友、渴望发现那些令你狂热的音乐、存储音乐并想要打造出专属你品味的 Spotify。那么，是时候升级成付费用户了。（当然，你也可以选择不升级）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文由本人独自翻译，同步发表在稀土上</strong></p>
<p>在 2015 年的时候，The Fader <a href="http://www.thefader.com/2015/06/10/new-spotify-statistics" targ]]>
    </summary>
    
      <category term="Growth" scheme="http://satanwoo.github.io/tags/Growth/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML中的“空白符”，你真的懂了吗？]]></title>
    <link href="http://satanwoo.github.io/2016/04/26/blank-space-in-html/"/>
    <id>http://satanwoo.github.io/2016/04/26/blank-space-in-html/</id>
    <published>2016-04-26T15:21:22.000Z</published>
    <updated>2016-04-26T16:03:25.000Z</updated>
    <content type="html"><![CDATA[<p>这几天由于某项任务，暂时转型了成为了前端码农（实际上就是个写初级CSS的屌丝）。在这期间，我有一个需求大致是这样的：</p>
<p>我有一个父类容器，比如<strong>div</strong>，这个<strong>div</strong>的宽度是固定的。我现在要在这个<strong>div</strong>中插入5个<strong>img</strong>，这5个<strong>img</strong>等宽。同时伴随这5个<strong>img</strong>的当然还有四个间隙，这四个间隙也是等宽的。</p>
<p><strong>当然</strong>，需要根据百分比宽度进行简单适配。<br>是不是觉得很简单呢？呵呵，别说专业的前端工程师，我这种半吊子都觉得简单。<br>根据PSD效果图，我量出了对应的百分比尺寸，于是写出来如下的<strong>HTML</strong>和<strong>CSS</strong>代码：</p>
<pre><code><span class="comment">// HTML 文件</span>
&lt;div <span class="keyword">class</span>=<span class="string">"parent"</span>&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
&lt;/div&gt;

<span class="comment">// css 文件</span>
.parent {
    width:x%;
}

.parent img {
    width:y%;
    height:auto;
    margin-left:k%;
}

.parent img:first-child {
    margin-left:<span class="number">0</span>;
}
</code></pre><p>这段代码相当简洁明了吧，我通过量好的百分比，对各个图片和之间的间距进行了控制，基本上业界大多数也是这么做的吧。</p>
<p>按理说事情到这基本就结束了，毕竟img是个<strong>行内可替换元素</strong>，会自动布局在一行之内，<strong>当然前提是父容器宽度足够的前提下</strong>。不过既然我都身体力行的量过了，那自然不应该出现问题。</p>
<p>但是，卧槽，你越担心的事就越会发生。整个界面出现了非常奇葩的现象：</p>
<pre><code>这是正常情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图] 

这是实际情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>］
图]
</code></pre><p>卧槽，竟然宽度不够，换行了。尝试了很长时间，后来发现，将<code>.parent img</code>中添加<code>float:left</code>就可以完美解决，但这什么原因呢?</p>
<h3 id="原因">原因</h3><p>经过一番探索研究，我发现，这是由于<strong>空白符</strong>对<strong>inline</strong>类型的元素造成的影响。</p>
<ul>
<li>首先，<strong>img</strong>元素是一种行内可替代元素，效果基本可以理解为<strong>inline-block</strong>。</li>
<li><p>第二，我们在HTML的时候，为了在编辑器内写的美观，常常会使用回车，而回车在HTML中会被识别为空白符。</p>
<pre><code>比如
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;（空白符）
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;
</code></pre></li>
<li><p>第三，空白符具备宽度（和font-size有关），不具备高度。</p>
</li>
</ul>
<p><strong>所以，表面上我们根据设计好的图片进行了</strong>精准<strong>的测量，构造了完全匹配父类宽度的元素和间距，但是实际上却由于空白符所具备的宽度而产生了偏差。</strong></p>
<p>用一张图来表示拥有空白符后的效果：</p>
<pre><code><span class="list">[<span class="keyword">图</span><span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;
图&lt;-&gt;］</span>
</code></pre><h3 id="为什么float可以解决这个问题">为什么float可以解决这个问题</h3><blockquote>
<p>A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float</p>
</blockquote>
<p>看到这个关于float的定义了吗？<strong>float要么依赖前一个（或者后一个）float元素的边界，要么就依赖于父元素的边界。而一个空白符，既不是包含块（父容器）的边界，也不是另一个float元素，因此不受影响，也不会对其余float元素有影响。</strong></p>
<p>所以，当你对<code>.parent img</code>启用<code>float:left</code>之后，效果就成了下图所示：</p>
<pre><code>[<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>]
[空白符]
</code></pre><p>这次我们测量的宽度正好匹配完全，所以将空白符自然而然的挤到了下一行。还记得我们前面说过空白符不具备高度吗？因此，这个空白符压根没起作用！</p>
<blockquote>
<p>文中的 [] 代表父容器，&lt;-&gt; 代表间隔。</p>
</blockquote>
<h3 id="其余方案">其余方案</h3><ol>
<li>将父容器的<code>font-size</code>设置为<strong>0</strong>。</li>
<li>避免换行，写出<img src=""><img src=""><img src=""><img src=""> 这样的代码。</li>
<li>启用HTML压缩。</li>
</ol>
<p>最后：<strong>感谢美团大神FTR和淘宝大神YWJ对本菜比的指导。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天由于某项任务，暂时转型了成为了前端码农（实际上就是个写初级CSS的屌丝）。在这期间，我有一个需求大致是这样的：</p>
<p>我有一个父类容器，比如<strong>div</strong>，这个<strong>div</strong>的宽度是固定的。我现在要在这个<s]]>
    </summary>
    
      <category term="JavaScript" scheme="http://satanwoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[滥用单例之dispatch_once死锁]]></title>
    <link href="http://satanwoo.github.io/2016/04/11/dispatch-once/"/>
    <id>http://satanwoo.github.io/2016/04/11/dispatch-once/</id>
    <published>2016-04-10T16:41:09.000Z</published>
    <updated>2016-08-01T15:10:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="现象">现象</h3><p>上周排查了一个bug，现象很简单，就是个Crash问题。但是读了一下crash Log以后，却发现堆栈报的错误信息却是第一次见到（<strong>吹牛的说，我在国内的iOS也能算第十二人了</strong>），包含以下还未符号化信息：</p>
<pre><code>Application Specific Information:
com.xxx.yyy failed to scene-<span class="operator"><span class="keyword">create</span> <span class="keyword">in</span> <span class="keyword">time</span>

Elapsed total CPU <span class="keyword">time</span> (seconds): hhh秒 (<span class="keyword">user</span> hhh, <span class="keyword">system</span> <span class="number">0.000</span>), <span class="keyword">k</span>% CPU
Elapsed application CPU <span class="keyword">time</span> (seconds): <span class="number">0.</span>h秒, <span class="keyword">k</span>% CPU

<span class="keyword">Thread</span> <span class="number">0</span> <span class="keyword">name</span>:  Dispatch queue: com.apple.<span class="keyword">main</span>-<span class="keyword">thread</span>
<span class="keyword">Thread</span> <span class="number">0</span>:
<span class="number">0</span>   libsystem_kernel.dylib            <span class="number">0x36cb2540</span> semaphore_wait_trap + <span class="number">8</span>
<span class="number">1</span>   libsystem_platform.dylib          <span class="number">0x36d3d430</span> _os_semaphore_wait + <span class="number">8</span>
<span class="number">2</span>   libdispatch.dylib                 <span class="number">0x36be04a6</span> dispatch_once_f + <span class="number">250</span>
<span class="number">3</span>   xxxx                              偏移量 <span class="number">0x4000</span> + <span class="number">947290</span>
...
...</span>
</code></pre><p>无符号化的crash 堆栈暂时不去管它，我们重点关注<strong>com.xxx.yyy failed to scene-create in time</strong>。如果理解无误的话，这句话提示我们：我们的应用程序在规定的时间没能加载成功，无法显示。看起来这个原因是启动加载过长直接被干掉。那么问题来了，原因具体是啥？</p>
<h3 id="查看堆栈">查看堆栈</h3><p>首先我们需要符号化一下，这里涉及公司内部信息，所以我们自己构造个demo试试。<br>demo的代码很简单，如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">"ManageA.h"</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageA</span></span>

+ (ManageA *)sharedInstance
{
    <span class="keyword">static</span> ManageA *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageA alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageB sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageB</span></span>

+ (ManageB *)sharedInstance
{
    <span class="keyword">static</span> ManageB *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageB alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageA sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>运行后的堆栈基本如下：</p>
<pre><code><span class="preprocessor">#<span class="number">0</span>    <span class="number">0x000000011054acd2</span> in semaphore_wait_trap ()</span>
<span class="preprocessor">#<span class="number">1</span>    <span class="number">0x00000001101b1b1a</span> in _dispatch_thread_semaphore_wait ()</span>
<span class="preprocessor">#<span class="number">2</span>    <span class="number">0x00000001101b1d48</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">3</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">4</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">5</span>    <span class="number">0x000000010d01cad8</span> in -[ManageB init] at ManageA.m:<span class="number">54</span></span>
<span class="preprocessor">#<span class="number">6</span>    <span class="number">0x000000010d01ca42</span> in __25+[ManageB sharedInstance]_block_invoke at ManageA.m:<span class="number">44</span></span>
<span class="preprocessor">#<span class="number">7</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">8</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">9</span>    <span class="number">0x000000010d01c9e7</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">10</span>    <span class="number">0x000000010d01c9c9</span> in +[ManageB sharedInstance] at ManageA.m:<span class="number">43</span></span>
<span class="preprocessor">#<span class="number">11</span>    <span class="number">0x000000010d01c948</span> in -[ManageA init] at ManageA.m:<span class="number">29</span></span>
<span class="preprocessor">#<span class="number">12</span>    <span class="number">0x000000010d01c8b2</span> in __25+[ManageA sharedInstance]_block_invoke at ManageA.m:<span class="number">19</span></span>
<span class="preprocessor">#<span class="number">13</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">14</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">15</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">16</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at /ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">17</span>    <span class="number">0x000000010d01c5cc</span> in -[AppDelegate application:didFinishLaunchingWithOptions:]         at /AppDelegate.m:<span class="number">21</span></span>
</code></pre><p>从中我们可以发现，的确在这段调用栈中，出现了多次敏感字样<code>sharedInstance</code>和<code>dispatch_once_f</code>字样。</p>
<p>在查阅相关资料后，感觉是<code>dispatch_once_f</code>函数造成了信号量的永久等待，从而引发死锁。那么，为什么<code>dispatch_once</code>会死锁呢？以前说的<strong>最安全的单例构造方式</strong>还正确不正确呢？</p>
<p>所以，我们一起来看看下面关于<code>dispatch_once</code>的源码分析。</p>
<h3 id="dispatch_once源码分析">dispatch_once源码分析</h3><p>从<a href="git://git.macosforge.org/libdispatch.git" target="_blank" rel="external">libdispatch</a>获取最新版本代码，进入对应的文件<strong>once.c</strong>。去除注释后代码如下，共<strong>66</strong>行代码，但是真的是有很多奇妙的地方。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"internal.h"</span></span>

<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once</span>
<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once_f</span>

<span class="keyword">struct</span> _dispatch_once_waiter_s {
    <span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;
    <span class="keyword">_dispatch_thread_semaphore_t</span> dow_sema;
};

<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~<span class="number">0l</span>)</span>

<span class="preprocessor">#<span class="keyword">ifdef</span> __BLOCKS__</span>
<span class="comment">// 1. 我们的应用程序调用的入口</span>
<span class="function"><span class="keyword">void</span>
<span class="title">dispatch_once</span><span class="params">(dispatch_once_t *val, dispatch_block_t block)</span>
</span>{
    <span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;

    <span class="comment">// 2. 内部逻辑</span>
    dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span>
<span class="title">dispatch_once_f</span><span class="params">(dispatch_once_t *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span>
</span>{
    <span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval =
            (<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;

    <span class="comment">// 3. 地址类似于简单的哨兵位</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = { <span class="literal">NULL</span>, <span class="number">0</span> };

    <span class="comment">// 4. 在Dispatch_Once的block执行期进入的dispatch_once_t更改请求的链表</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;

    <span class="comment">// 5.局部变量，用于在遍历链表过程中获取每一个在链表上的更改请求的信号量</span>
    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;

    <span class="comment">// 6. Compare and Swap（用于首次更改请求）</span>
    <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, <span class="literal">NULL</span>, &amp;dow)) {
        dispatch_atomic_acquire_barrier();

        <span class="comment">// 7.调用dispatch_once的block</span>
        _dispatch_client_callout(ctxt, func);

        dispatch_atomic_maximally_synchronizing_barrier();
        <span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span>

        <span class="comment">// 8. 更改请求成为DISPATCH_ONCE_DONE(原子性的操作)</span>
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);
        tail = &amp;dow;

        <span class="comment">// 9. 发现还有更改请求，继续遍历</span>
        <span class="keyword">while</span> (tail != tmp) {

            <span class="comment">// 10. 如果这个时候tmp的next指针还没更新完毕，等一会</span>
            <span class="keyword">while</span> (!tmp-&gt;dow_next) {
                _dispatch_hardware_pause();
            }

            <span class="comment">// 11. 取出当前的信号量，告诉等待者，我这次更改请求完成了，轮到下一个了</span>
            sema = tmp-&gt;dow_sema;
            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 12. 非首次请求，进入这块逻辑块</span>
        dow.dow_sema = _dispatch_get_thread_semaphore();
        <span class="keyword">for</span> (;;) {
            <span class="comment">// 13. 遍历每一个后续请求，如果状态已经是Done，直接进行下一个</span>
            <span class="comment">// 同时该状态检测还用于避免在后续wait之前，信号量已经发出(signal)造成</span>
            <span class="comment">// 的死锁</span>
            tmp = *vval;
            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) {
                <span class="keyword">break</span>;
            }
            dispatch_atomic_store_barrier();
            <span class="comment">// 14. 如果当前dispatch_once执行的block没有结束，那么就将这些</span>
            <span class="comment">// 后续请求添加到链表当中</span>
            <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) {
                dow.dow_next = tmp;
                _dispatch_thread_semaphore_wait(dow.dow_sema);
            }
        }
        _dispatch_put_thread_semaphore(dow.dow_sema);
    }
}
</code></pre><p>根据以上注释对源代码的分析，我们可以大致知道如下几点：</p>
<ol>
<li><code>dispatch_once</code>并不是简单的只执行一次那么简单</li>
<li><code>dispatch_once</code>本质上可以接受多次请求，会对此维护一个请求链表</li>
<li>如果在block执行期间，多次进入调用同类的<code>dispatch_once</code>函数（即单例函数），会导致整体链表无限增长，造成永久性死锁。(<strong>其实只要进入两次就完蛋，其原因在于<code>block_invoke</code>的完成依赖于第二次进入的请求的完成，而第二次请求的完成又必须依赖之前信号量的出发。可是第一次block不结束，信号量压根不会触发</strong>)</li>
</ol>
<h3 id="备注">备注</h3><ol>
<li>根据以上分析，相对应地写了一个简易的死锁Demo，就是在两个单例的初始化调用中直接相互调用。A&lt;-&gt;B。也许这个Demo过于简单，大家轻易不会犯。但是如果是A-&gt;B-&gt;C-&gt;A，甚至是更多个模块的相互引用，那又该如何轻易避免呢？</li>
<li>以上的Demo，如果在Xcode模拟器测试环境下，是不会死锁从而导致应用启动被杀。这是因为模拟器不具备守护进程，如果要观察现象，可以输出Log或者直接利用真机进行测试。</li>
<li>有时候，启动耗时是因为占用了太多的CPU资源。但是从我们的Crash Log中可以发现，我们仅仅占用了<strong>Elapsed application CPU time (seconds): 0.h秒, k% CPU</strong>。通过这个，我们也可以发现，CPU占用率高并不是导致启动阶段APP Crash的唯一原因。</li>
</ol>
<h3 id="反思">反思</h3><p>虽然这次的问题直接原因是<code>dispatch_once</code>引出的<strong>死锁</strong>问题，但是个人认为，这却是滥用单例造成的后果。各位可以打开自己公司的app源代码查看一下，究竟存在着多少的单例。</p>
<p>实话实说，单例和全局变量几乎没有任何区别，不仅仅占用了全生命周期的内存，还对解耦造成了巨大的负作用。写起来容易，但是对于整个项目的架构梳理却是有着巨大的影响，因为在不读完整个相关代码的前提下，你压根不知道究竟哪里会触发单例的调用。</p>
<p>因此在这里，谈谈个人认为可以不使用单例的几个方面：</p>
<ol>
<li>仅仅使用一次的模块，可以不使用单例，<strong>可以采用在对应的周期内维护成员实例变量进行替换</strong>。</li>
<li>和状态无关的模块，<strong>可以采用静态（类）方法直接替换</strong>。</li>
<li>可以通过页面跳转进行依赖注入的模块，<strong>可以采用依赖注入或者变量传递等方式解决</strong>。</li>
</ol>
<p><strong>当然，的确有一些情况我们仍然需要使用单例。那在这种情况，也请将<code>dispatch_once</code>调用的block内减少尽可能多的任务，最好是仅仅负责初始化，剩下的配置、调用等等在后续进行。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="现象">现象</h3><p>上周排查了一个bug，现象很简单，就是个Crash问题。但是读了一下crash Log以后，却发现堆栈报的错误信息却是第一次见到（<strong>吹牛的说，我在国内的iOS也能算第十二人了</strong>），包含以下还未符号化信息：<]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的静态Dispatch VS 动态Dispatch]]></title>
    <link href="http://satanwoo.github.io/2016/03/22/dispatch-in-swift/"/>
    <id>http://satanwoo.github.io/2016/03/22/dispatch-in-swift/</id>
    <published>2016-03-22T09:14:34.000Z</published>
    <updated>2016-03-28T14:24:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="C++_VS_Swift">C++ VS Swift</h3><p>虽然我很早就了解了Swift（2014年的WWDC），但是在粗略看了一下Swift的语法后，我认为这不过是许多语言语法的大杂烩，感觉和C++没有啥区别。但是实际上，在我使用Swift的这几个月中，我发现了许多问题值得注意的地方，比如</p>
<ul>
<li>函数的返回值可以作为推断函数签名的依据。</li>
<li>Swift中的函数静态Dispatch VS 动态函数Dispatch</li>
</ul>
<p>而第二点，也是本文要阐述的重点。</p>
<p>在展开本文的内容前，如果你曾经有C++的开发背景，不妨回忆下C++中RTTI机制，这也是多态发生的先决条件。简单来说，就是C++的多态函数是基于运行时的，我们可以看看下面这个例子：</p>
<pre><code><span class="keyword">class</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm A"</span>;}
}

<span class="keyword">class</span> B: <span class="keyword">public</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm B"</span>;}
}

A *b = <span class="keyword">new</span> B();
b-&gt;print();
</code></pre><p>相信大家一眼就能知道这个答案，会输出<code>I&#39;m B</code>。那么，Swift中也存在<code>class</code>，那么对于Swift中的函数调用是否和C++一致呢？</p>
<h3 id="Swift_Class">Swift Class</h3><p>首先我们先来验证下最基本的<code>class</code>中的行为。我们采用和C++中相同例子，定义如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>根据Swift的<code>Type Inference</code> 我们分别验证了如下几种调用方式：</p>
<pre><code>let b1:B = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let b2:A = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a1:A = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let a2 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b3 = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b3.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>如果你自己的思考结果和这个一模一样，至少你理解了运行期和编译期的概念，恭喜你，你的C++是过关了。以<code>class B</code>举例，无论是<strong>b1, b2, b3中的哪一个，尽管其中有部分声明的类型是A，但是在实际运行时还是会走类似virtual function那套确认实际类型为B</strong>。但是，事情在Swift中真是这么简单吗？让我们接着往下看。 </p>
<h3 id="Protocol_Extension">Protocol Extension</h3><p>去年，<strong>Swift 2.0</strong>发布，随之而来，一个概念悄然兴起：面向协议的编程。而这种编程范式不可或缺的必要条件就是<strong>Protocol Extension</strong>。在<code>Swift &lt; 2.0</code> 时代，<code>Protocol</code>的作用更类似于一种表征特征的约束。而有了<code>Protocol Extension</code>以后，<code>Protocol</code>更类似于一种插件装配的概念（写过Ruby的人相信会有体会），可以在无须编写代码的情况下，更自定义的元素添加行为能力。</p>
<p>哎？你上面说了这么一大段废话，和我们的文章主题有啥关系？</p>
<p>好，首先我们先看如下定义：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span> {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>然后，我们进行如下调用：</p>
<pre><code>let a1 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b1 = <span class="function"><span class="title">B</span><span class="params">()</span></span>     
b1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a2:Testable = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b2:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>到这里，事情还是还是按照C++那套逻辑在走，如果你把<code>class B</code>中的<code>dynamicInfo</code>删除，那么对应B类型的<code>dynamicInfo</code>函数调用就会输出<strong>I’m Testable</strong>。</p>
<p>好，现在问题来了，如果我们将<code>Testable Protocol Extension</code>添加一下东西，同时保持<code>protocol Testable</code>不变，如下所示：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }

    <span class="comment">// ### 新添加的 ###</span>
    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable Static"</span>)
    }
}
</code></pre><p>如果这个时候，我们进行如下代码的测试：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }

    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A Static"</span>)
    }
}

<span class="keyword">let</span> a1 = <span class="type">A</span>()     
a1.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a2:<span class="type">A</span> = <span class="type">A</span>()
a2.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a3:<span class="type">Testable</span> = <span class="type">A</span>()
a3.staticInfo() <span class="comment">// I'm Testable Static</span>
</code></pre><p>看到没？最后一行的输出是不是出乎了大家的意料，竟然输出了<strong>I’m Testable Static</strong>。 </p>
<p>这是咋回事？回顾下之前我们改变的地方，发现我们在<strong>Protocol Extension中添加了一个<code>func staticInfo()</code>，但是却没在对应的<code>Testable Protocol</code>进行声明</strong>。但是这还不够，我们必须将调用<code>staticInfo</code>的地方的类型显式的声明成<strong>let a3:Testable</strong>。</p>
<p><div style="color:red">也就是说，Swift方法的静态Dispatch必须严格满足如下条件：</div>  </p>
<ul>
<li>方法在Extension中提供了实现，但是在对应的protocol中没有声明。</li>
<li>调用方法的时候必须显示的声明成protocol的类型。</li>
</ul>
<p>如果不好理解，我画了张图帮助大家加深印象：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/Slice%201.png" alt=""></p>
<p><strong>还有一点需要注意的是，Swift中的静态Dispatch不以类的层级和override而转移</strong>，也就是说，如下这种定义：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B Static"</span>)
    }
}
</code></pre><p>当我们使用  </p>
<pre><code>let a4:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
a4.<span class="function"><span class="title">staticInfo</span><span class="params">()</span></span>
</code></pre><p>一样会输出<code>I&#39;m Testable Static</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="C++_VS_Swift">C++ VS Swift</h3><p>虽然我很早就了解了Swift（2014年的WWDC），但是在粗略看了一下Swift的语法后，我认为这不过是许多语言语法的大杂烩，感觉和C++没有啥区别。但是实际上，在我使用Swift的这几个月中，]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxSwift的第一印象]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/RxSwift/"/>
    <id>http://satanwoo.github.io/2016/03/14/RxSwift/</id>
    <published>2016-03-13T16:21:50.000Z</published>
    <updated>2016-03-13T16:48:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>声明：本文由本人独立翻译完成，同步发表在稀土掘金</strong></p>
<p>去年整整一年，我都在试图理解响应式编程的原理是什么，并且试图验证如果在我的app中使用这种编程范式是否会带来好处。于是，我查询了许多相关的解决方案，从<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> &amp; Objective-C开始，及其Swift版本<a href="https://blog.alltheflow.com/reactive-swift-upgrading-to-reactivecocoa-3-0/" target="_blank" rel="external">ReactiveCocoa with Swift</a>，再到我朋友实现的一个轻量级的框架<a href="https://github.com/bvic23/VinceRP" target="_blank" rel="external">VinceRP</a>。上述这些都是令人赞叹不已的项目，ReactiveCocoa的项目成熟度非常高，但是十分复杂；而VinceRP的实现非常容易，所以理解起来非常简单。</p>
<p>在学习的过程中，我写了一系列关于<a href="https://blog.alltheflow.com/tag/reactive" target="_blank" rel="external">我学习响应式编程的经历</a>的文章，所以经常会被读者问到一些关于<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>的问题。惭愧地说，我还从没有使用RxSwift来编写一个项目。实际上我还从来没用过任何语言的<a href="http://reactivex.io/languages.html" target="_blank" rel="external">Rx</a>框架，所以我一直认为，对于那些曾在别的开发环境中有使用Rx经历的人来说，理解RxSwift是非常容易的。既然如此，我也是时候来尝试一把了。</p>
<h2 id="Rx">Rx</h2><p>Rx是最常使用的一个响应式编程框架。它与其他RP框架的一大不同是它的跨平台特性，同时，它有着最大的开源社区，无数的文档以及有参考价值的问题讨论，许许多多的人不断地对其进行改进。</p>
<h2 id="Swift">Swift</h2><p>这门语言在去年一年中飞速的成长，并且现在也进行了<a href="https://github.com/apple/swift" target="_blank" rel="external">开源</a>了。一些像RxSwift之类的项目也随着其一起成长。因此，没有什么理由可以再阻止你去使用这些框架。当然，一些重大的改动仍然被列在radar上，但它们很可能在短时间内不会被解决，这就意味着这个项目会不断地被改进，这不是很好吗？</p>
<h2 id="使用RxSwift开发一个app">使用RxSwift开发一个app</h2><p>如果你从未阅读过<a href="https://blog.alltheflow.com" target="_blank" rel="external">我的博客</a>，可能你现在会猜我使用RxSwift开发了一个app。没错，你是对的。这是个很耗时的习惯，但是我不喜欢依赖于一个理想的环境，所以通常我都会写一个例子来让我有那么一点感觉。通过这种方式，我可以学会如何让成功得运行这个框架。（意译：这里我想说一点个人感受，对于解决问题来说，你所选用的框架只是万千可用方案中的一种，因此，方案的选择是因人而异的。而这些选择所带来的多样性，正是我如此热爱编程的一大原因。）</p>
<p>我所写的这个应用名叫<a href="https://github.com/alltheflow/iCopyPasta" target="_blank" rel="external">iCopyPasta</a>，是一个在去年<a href="http://2015.funswiftconf.com/" target="_blank" rel="external">Functional Swift Conf</a>上展示的免费Mac剪贴板应用<a href="https://github.com/alltheflow/copypasta" target="_blank" rel="external">CopyPasta</a>的iOS姐妹版。显而易见，它们并不是一个完整的产品所以并不可以被用来上架。我现在每天都使用Mac版本的CopyPasta，但是我可能存在某些偏见。我的计划是将来会发布Mac版本和iOS版本的CopyPasta应用，并可能会将这两个版本进行打通。</p>
<blockquote>
<p>难道这不是我一直以来的计划吗？  </p>
</blockquote>
<h3 id="Observables">Observables</h3><p>我首先对<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPasteboard_Class/index.html" target="_blank" rel="external"><code>UIPasteboard</code></a>注册了观察者。 这些观察者会对你拷贝东西时出现在<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>类型进行观察。</p>
<pre><code><span class="keyword">let</span> pasteboard = <span class="type">NSNotificationCenter</span>.defaultCenter().rx_notification(<span class="string">"UIPasteboardChangedNotification"</span>, object: <span class="literal">nil</span>)
<span class="number">_</span> = pasteboard.<span class="built_in">map</span> { [<span class="keyword">weak</span> <span class="keyword">self</span>] (notification: <span class="type">NSNotification</span>) -&gt; <span class="type">PasteboardItem</span>? <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> pb = notification.object <span class="keyword">as</span>? <span class="type">UIPasteboard</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> string = pb.valueForPasteboardType(kUTTypeUTF8PlainText <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(string)
        }
        <span class="keyword">if</span> <span class="keyword">let</span> image = pb.valueForPasteboardType(kUTTypeImage <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(image)
        }
    }
    <span class="keyword">return</span> <span class="literal">nil</span>
}
</code></pre><p>之前我的方法是直接对<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>直接进行观察，但是这个方法是不正确的。原因在于<code>UIPasteboard</code>可能不是一个KVO安全的类型（具体请看下方的评论）。参考别人的建议后，我使用RxSwift另一个非常棒的功能<a href="https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxCocoa/Common/Observables/NSNotificationCenter%2BRx.swift#L23" target="_blank" rel="external"><code>rx_notification</code></a>来监听<code>UIPasteboardChangedNotification</code></p>
<pre><code>.subscribeNext { [<span class="keyword">weak</span> <span class="keyword">self</span>] pasteboardItem <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> item = pasteboardItem {
        <span class="keyword">self</span>?.addPasteboardItem(item)
    }
}
</code></pre><p>这里的<code>pasteboard</code>是一个<code>Observable&lt;NSNotification&gt;</code>，这也是为什么可以很容易得订阅其<code>.Next</code>事件同时相应地去更新<code>tableView</code>。而<code>map</code>则是从监听到的通知所涉及的对象中获取字符串或者图像，并将获取到的结果转换成<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>。</p>
<h3 id="Dispose_bags">Dispose bags</h3><p>订阅信号会产生<code>Disposable</code>。如果不终止订阅，那么这些生成的<code>Disposable</code>将会一直存在，这无疑是非常耗内存的。所以，你要么对这些订阅调用<code>dispose</code>，要么你可以像我一样，使用<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#dispose-bags" target="_blank" rel="external">dispose bags</a>来自动销毁相关的订阅。</p>
<pre><code>.<span class="function"><span class="title">addDisposableTo</span><span class="params">(disposeBag)</span></span>
</code></pre><h3 id="UIKit/Appkit_bindings">UIKit/Appkit bindings</h3><p>你可以很容易地通过<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L46" target="_blank" rel="external"><code>rx_itemsWithCellIdentifier</code></a>将<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences" target="_blank" rel="external"><code>Observable</code></a>序列绑定到table view上。<code>element</code>来自于我定义的<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>枚举类型，这也是为什么我会采用Switch来处理这个对象，这样可以根据其具体的枚举值来显示不同的样式。</p>
<pre><code>pasteViewModel.pasteboardItems()
    .bindTo(tableView.rx_itemsWithCellIdentifier(<span class="string">"pasteCell"</span>, cellType: UITableViewCell.self)) { (row, element, cell) <span class="keyword">in</span>
     <span class="keyword">switch</span> element {
     <span class="keyword">case</span> .Text(let <span class="keyword">string</span>):
         cell.textLabel?.<span class="keyword">text</span> = String(<span class="keyword">string</span>)
     <span class="keyword">case</span> .Image(let <span class="keyword">image</span>):
         cell.imageView?.<span class="keyword">image</span> = <span class="keyword">image</span>
}.addDisposableTo(disposeBag)
</code></pre><p>另外一个很棒的补充是<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L204" target="_blank" rel="external"><code>rx_modelSelected</code></a>。你可以通过它来获取你触发选择事件时对应的<code>element</code>。简单来说，它是一个对<code>tableView:didSelectRowAtIndexPath:</code>的封装，可以将代码变得非常简洁。</p>
<pre><code><span class="tag">tableView</span>
    <span class="class">.rx_modelSelected</span>(PasteboardItem)
    <span class="class">.subscribeNext</span> { <span class="attr_selector">[weak self]</span> <span class="tag">element</span> <span class="tag">in</span>
        <span class="tag">self</span>?<span class="class">.pasteViewModel</span><span class="class">.addItemsToPasteboard</span>(element)
    }<span class="class">.addDisposableTo</span>(disposeBag)
</code></pre><p>你可以通过如下链接来查看所以关于UIKit/AppKit（RxCocoa）的扩展<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md#rxcocoa-extensions" target="_blank" rel="external">RxSwift’s GitHub</a>。</p>
<h2 id="总体感受">总体感受</h2><p>到目前为止，我还只是探索了RxSwift能力的一小部分，但是我已经感受到RxSwift是一个非常棒的框架。如果能够更深入理解它的机制并学会基于它的设计思路进行思考，那肯定会更好。</p>
<p>我非常喜欢一些像<a href="https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground" target="_blank" rel="external">Rx.playground</a>，<a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>这样的资料及<a href="https://github.com/ReactiveX" target="_blank" rel="external">great community</a>这样的社区。这些资料给了我很多的灵感，所以我也乐于将我的学习经验分享给<a href="http://bitrise.io" target="_blank" rel="external">bitrise.io</a>的用户。还有一些比较重要的内容，比如<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md#custom-schedulers" target="_blank" rel="external">schedulers</a>还未被涉及，但是绝对值得研究一番。</p>
<p>对我来说，我还需要一段时间来更好地理解Rx。与我尝试ReactiveCocoa只有个把小时不同，我现在可以每天都在工作中使用RxSwift，并且坚持使用超过了一年。这都得感谢<a href="https://twitter.com/bvic23" target="_blank" rel="external">在Prezi的伙伴们</a>.</p>
<p>作为一个曾经学习过ReactiveCocoa的人来说，我现在更倾向于使用RxSwift，可能是因为我现在自认为已经对于RxSwift已经足够了解，并且使用它可以很快得完成我的编码任务。当然，在将来我可能会同时使用两者，但是我认为对于两者之间任一框架的熟练使用不代表会在学习另外一个框架的时候给你带来很大的优势。它们在几个方面有着<a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons/32581824#32581824" target="_blank" rel="external">不同</a>。同时，这两个框架（概括来说应该是所有的响应式编程框架）都有着陡峭的学习曲线。对于我来说，我已经度过了学习ReactiveCocoa最难的那段时光，但如果你是一个初学者，我建议你自己动手尝试这两种框架，甚至更多。</p>
<h2 id="深入阅读">深入阅读</h2><p>如果你还在思考应该使用哪个响应式编程的框架，那么我建议你去读一读Ash Furrow所写的关于如何挑选响应式编程框架的<a href="https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/" target="_blank" rel="external">文章</a>。</p>
<p>你也可以看看其他一些在iOS中使用响应式编程的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6" target="_blank" rel="external">视频及文章</a>，这些内容都非常得棒，相信你会受益匪浅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>声明：本文由本人独立翻译完成，同步发表在稀土掘金</strong></p>
<p>去年整整一年，我都在试图理解响应式编程的原理是什么，并且试图验证如果在我的app中使用这种编程范式是否会带来好处。于是，我查询了许多相关的解决方案，从<a href="http]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向工程SizeUp]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/SizeUp/"/>
    <id>http://satanwoo.github.io/2016/03/14/SizeUp/</id>
    <published>2016-03-13T16:20:57.000Z</published>
    <updated>2016-03-22T12:48:47.000Z</updated>
    <content type="html"><![CDATA[<p>这几天把《汇编语言》好好复习一遍，心里痒痒，就想找个软件来逆向破解一发。破啥好呢？网上逆向工程的教程一大堆，主要都是<em>Sketch</em>啦，<em>Reveal</em>啦，那我照着做一遍也没啥意思啊，体现不出我中国iOS第12人的特点啊。干脆我找个小众一点的软件破解吧。于是，我就盯上了我每天都非常喜欢使用的<strong>SizeUp</strong>，这是一款非常快速的窗口管理软件，可以通过快捷键将窗口扩展到指定的大小和位置，配合外接显示屏简直酷炫到飞起。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-09%20%E4%B8%8B%E5%8D%8810.46.45.png" alt=""></p>
<p>但是这个App有个很大的问题，虽然它是免费的，但是它每次启动的时候，包括你使用的过程中，都会时不时蹦出一个提示你购买的弹框，而且弹框上的取消按钮一定要过5秒才能点击关闭，真是让人蛋疼。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.22.04.png" alt=""></p>
<p>所以，我就讲逆向的目标定在了将这个<strong>可恶的</strong>弹窗给干掉。</p>
<h4 id="准备工作">准备工作</h4><p>首先破解必须要准备的就是逆向工具了，由于这是个Mac app，所以我们无需使用到iPhone。所以，我简单的将SizeUp进行了一次备份就开始了。</p>
<p>逆向一个app，我们当然要去分析其汇编代码，因此必不可少的工具就是IDA或者<strong>Hopper</strong>。在这里，请允许我个人强烈推荐Hopper，那傻瓜式的操作，非常适合我这种高智商人才，哇哈哈。Hopper也是支持免费的，但是免费版不能重新生成可执行文件，所以我先从网上下载了一个破解版的Hopper。</p>
<h4 id="逆向开始">逆向开始</h4><p>首先我们将SizeUp拖入Hopper，得到一系列的汇编代码。这么多的代码我们从哪里下手呢? 答案是<strong>关键字</strong>。在弹窗提示我们购买的界面中，出现了很多关键字，比如<code>license</code>抑或是<code>demo</code>。首先让我们从license开始尝试。我们在Hopper界面左上侧的搜索框中输入license，会得到如下结果：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.09.png" alt=""></p>
<p>从结果来看，我们大致猜测SizeUp的逻辑如下：</p>
<ol>
<li>初始化程序</li>
<li>检查存储的license</li>
<li>（如果有）多个，检查最好的一个（可能是有效期最长的）</li>
<li>和服务器进行验证</li>
</ol>
<p>上述这段逻辑主要来自于高亮的<code>+[License xxx]</code>函数调用。</p>
<p>从上述这段逻辑，我们可以看出，想要伪造license是不可能的了，这是因为牵涉了服务器验证。所以我们只能把想法转变成，干掉本地相关的逻辑。本地逻辑不外乎判断某种分支条件，根据结果进行某些页面的跳转，<strong>比如弹出Demo界面</strong>。</p>
<p>好，现在我们来试试<strong>Demo</strong>关键字，搜索结果如下：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.28.png" alt=""></p>
<p>从这个关键字的搜索结果来看，我们得到了不少有价值的信息，比如<strong>DemoDialogController</strong>。哈哈哈哈，苹果经典的MVC设计模式这时候起了很大的作用，搞过开发的人一般都会知道Controller一般对应的就是一个ViewController。如果你不信，我们继续往下看，可以看到一个<code>-[DemoDialogController showDemoDialog]</code>，这个提示够明显了吧，这分明就是说：老子就是那个界面，你快来把我干掉吧。</p>
<p>好，大功告成一半了，我们已经找到了我们要干掉的界面，现在我们只要干掉分支判断逻辑就好了。于是，我们继续跟着Demo关键字走，不久，我们发现了<code>+[License isDemo]</code>这个嫌疑犯。卧槽，这时候，我这天赋异禀的大脑中形成了这样一段代码：</p>
<pre><code><span class="tag">if</span> ([License isDemo]) {
    <span class="attr_selector">[[[DemoDialogController alloc]</span> <span class="tag">init</span>] <span class="tag">showDemoDialog</span>]
} <span class="tag">else</span> {
    <span class="comment">// Follow your heart</span>
}
</code></pre><p>是不是和我猜测的一样呢？</p>
<p>去掉前面的函数压栈，我们来着重看看这段代码：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.51.30.png" alt=""></p>
<pre><code><span class="keyword">mov</span> <span class="literal">edx</span>, <span class="number">0x1</span>
<span class="keyword">test</span> <span class="literal">al</span>, <span class="literal">al</span>
<span class="keyword">je</span> <span class="number">0x1000008bd9</span>
....
....
<span class="keyword">mov</span> <span class="literal">eax</span>, <span class="literal">edx</span>
</code></pre><p>这段代码不熟悉汇编的人可能不太懂，我将其转换一下。</p>
<pre><code>edx = <span class="literal">true</span>(YES)
<span class="keyword">if</span> al == <span class="number">0</span>
{
    <span class="keyword">goto</span> <span class="number">0x1000008bd9</span>
}

... <span class="number">0x1000008bd9</span>:
val = edx(<span class="literal">true</span>)
<span class="keyword">return</span> val
</code></pre><p>理解了吧，就是首先将0x1（即YES）放入<code>edx</code>寄存器，然后判断<code>al</code>代表的某种分支条件是不是0，如果是0，通过<code>je</code>命令跳转到<code>0x1000008bd9</code>地址。这个地址后面的指令就是讲<code>edx</code>的值塞入<code>eax</code>中，而<code>eax</code>是<strong>x86指令集中默认存放函数返回值的寄存器</strong>。</p>
<p>事情到这，是不是基本理清思路了？我们只需要将je跳转的条件极其后面语句干掉就好了。我在这里采用了更暴力的做法，直接在函数一开始就讲false塞入<code>eax</code>寄存器，然后直接调用<code>ret</code>进行返回。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-14%20%E4%B8%8A%E5%8D%8812.00.45.png" alt=""></p>
<h4 id="结语">结语</h4><p>是不是逆向工程看起来也没那么难呢？其实，SizeUp这种利用函数返回至做文章的逆向是最简单的，下次我们来挑战下更难的逆向目标！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天把《汇编语言》好好复习一遍，心里痒痒，就想找个软件来逆向破解一发。破啥好呢？网上逆向工程的教程一大堆，主要都是<em>Sketch</em>啦，<em>Reveal</em>啦，那我照着做一遍也没啥意思啊，体现不出我中国iOS第12人的特点啊。干脆我找个小众一点的软件]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DXXcodeConsoleUnicodePlugin源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/"/>
    <id>http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/</id>
    <published>2016-03-13T16:18:52.000Z</published>
    <updated>2016-03-13T16:19:38.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Xcode插件开发">Xcode插件开发</h4><p>嘿嘿，今天带大家学习一下基于Xcode的插件开发。可能很多人一听到插件开发，想到的都是Sublime Text，Atom这样轻量级的编辑器的扩展插件，但是实际上，无论是VisualStudio, Eclipse以及Xcode这样重量级的IDE，都是支持自定义的插件开发的。学习好了Xcode的插件开发，不仅可以打造度身定做的<strong>神器</strong>，也有助于你将来进行<strong>Mac OS</strong>的应用开发。</p>
<h4 id="DXXcodeConsoleUnicodePlugin">DXXcodeConsoleUnicodePlugin</h4><p>DXXcodeConsoleUnicodePlugin是一个帮助你自动将<code>\u6061</code>这样的unicode码转换成对应的汉字的插件。</p>
<p>这个有什么用呢？想想看，我们在网络传输的时候，服务器如果返回的数据是中文（<strong>或者非ASCII码</strong>），通过NSLog在console输出的内容是不直观的，基本都是类似<code>\u6061</code>这种，这对于我们开发调试来说是非常困难的。</p>
<p>因此，这款插件可以自动帮助我们将检测到的Unicode字符进行转换，直接输出成我们想要的对应内容。怎么样？让我们赶快来一探究竟吧！</p>
<p><strong> 在开始探讨实现之前，我个人首先强调一点，基于Unicode检测对应的字符是一个非常难的问题。不仅仅是中文，韩文、日文、big-5字符等等都属于Unicode，这些字符集之间好常常有交集。现有比较好的开源实现是</strong>Mozilla的UcharSet**。</p>
<h4 id="实现">实现</h4><p>首先打开工程，文件结构如下：</p>
<ul>
<li>DXXcodeConsoleUnicodePlugin.h/.m</li>
<li>RegExCategories.h/.m</li>
</ul>
<p>其中，<code>DXXcodeConsoleUnicodePlugin</code>是入口。同传统的iOS/Mac OS开发不同，插件开发并不存在传统意义上的main函数，更多的是利用所谓的<code>Template Method</code>设计模式将你需要的自定义部分进行复写。</p>
<p>于是，我们可以看到如下三段函数：</p>
<pre><code>+ (<span class="keyword">void</span>)pluginDidLoad:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
  <span class="built_in">NSString</span> *currentApplicationName = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleName"</span>];
  <span class="keyword">if</span> ([currentApplicationName isEqual:<span class="string">@"Xcode"</span>]) {
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
      sharedPlugin = [[<span class="keyword">self</span> alloc] initWithBundle:plugin];

      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
                                               selector:<span class="keyword">@selector</span>(menuDidChange)
                                                   name:<span class="built_in">NSMenuDidChangeItemNotification</span>
                                                 object:<span class="literal">nil</span>];
    });
  }
}

- (<span class="keyword">id</span>)initWithBundle:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
    <span class="comment">// reference to plugin's bundle, for resource acccess</span>
    <span class="keyword">self</span><span class="variable">.bundle</span> = plugin;

    <span class="comment">// Create menu items, initialize UI, etc.</span>

    <span class="comment">// Sample Menu Item:</span>
    [<span class="keyword">self</span> createMenu];

    I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span> = ReplaceInstanceMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEConsoleItem"</span>), <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:),
                                                                   [XcodeConsoleUnicode_IDEConsoleItem class], <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:));
  }

  <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)createMenu
{
  <span class="built_in">NSMenuItem</span> *menuItem = [[<span class="built_in">NSApp</span> mainMenu] itemWithTitle:<span class="string">@"Edit"</span>];
  <span class="keyword">if</span> (menuItem &amp;&amp; !<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>) {
    [[menuItem submenu] addItem:[<span class="built_in">NSMenuItem</span> separatorItem]];

    <span class="built_in">NSMenuItem</span> *convertItem = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicode"</span> action:<span class="keyword">@selector</span>(convertAction) keyEquivalent:<span class="string">@"c"</span>];
    [convertItem setKeyEquivalentModifierMask:<span class="built_in">NSAlternateKeyMask</span>];
    [convertItem setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:convertItem];

    <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicodeInConsole"</span>
                                                           action:<span class="keyword">@selector</span>(convertUnicodeInConsoleAction)
                                                    keyEquivalent:<span class="string">@""</span>];
    [<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>];

    sIsConvertInConsoleEnabled = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:sConvertInConsoleEnableKey];
    <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOnState</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOffState</span>;
    }
  }
}
</code></pre><p>上面三段函数我们一一进行解析。</p>
<ol>
<li><p><code>pluginDidLoad</code>，大家可以理解为插件的程序入口，在这个入口中我们通过单例进行我们自己开发的插件加载。**之所以使用单例是因为这个<code>pluginDidLoad</code>可能会由于加载多个插件而被多次触发。</p>
</li>
<li><p><code>initWithBundle</code>函数是我们自定义插件的构造函数，我们通过它进行自己任务的创建和调用。</p>
</li>
<li><p><code>createMenu</code>则是对Xcode编辑器上的菜单添加属于我们自己的选项。</p>
</li>
</ol>
<p>在这里，作者在<strong>Edit</strong>菜单下创建了属于自己的<strong>ConvertUnicode</strong>以及<strong>ConvertUnicodeInConsole</strong>，并对这些选项进行了快捷键绑定。</p>
<p>这些东西，除了自定义的菜单项及操作需要我们自己写以外，我们都可以通过<code>Plugin Template</code>这个插件自动生成。</p>
<p>到现在，我们还没有看到任何实质性的转换内容，别急，在<code>initWithBundle</code>中，作者通过<strong>Method Swizzling</strong>将<code>IDEConsoleItem</code>的<code>- (id)initWithAdaptorType:(id)arg1 content:(id)arg2 kind:(int)arg3</code>和自己实现的<code>XcodeConsoleUnicode_IDEConsoleItem</code>进行的调换。</p>
<p>然后在替换后的方法中，实现解析，代码如下：</p>
<pre><code>- (<span class="keyword">id</span>)initWithAdaptorType:(<span class="keyword">id</span>)arg1 content:(<span class="keyword">id</span>)arg2 kind:(<span class="keyword">int</span>)arg3
{
  <span class="keyword">id</span> item = I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span>(<span class="keyword">self</span>, _cmd, arg1, arg2, arg3);

  <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
    <span class="built_in">NSString</span> *logText = [item valueForKey:<span class="string">@"content"</span>];
    <span class="built_in">NSString</span> *resultText = [DXXcodeConsoleUnicodePlugin convertUnicode:logText];
    [item setValue:resultText forKey:<span class="string">@"content"</span>];
  }

  <span class="keyword">return</span> item;
}
</code></pre><p>这个方法非常简单，通过原方法获取console中的<strong>item</strong>，并获取对应的<strong>content</strong>进行解析。而解析也仅仅是采用了<code>UTF8StringEncoding</code>直接进行转换。</p>
<h4 id="补充知识：NSRegularExpression和正则表达式">补充知识：NSRegularExpression和正则表达式</h4><p>在本文的实现当中，作者对于中文字符的Unicode的表达方式<strong>\u4582</strong>这样的格式，采用了正则表达式进行了提取。在传统的Unicode的格式中，<strong>单独一个<code>\</code></strong>表示为转义字符，不能直接表达一般字符。所以，在正则表达式中，我们需要采用<strong><code>\\</code></strong>来表示一个<code>\</code>。同时，对于4582这样的字符，我们当然可以认为其模式为四个连续的字符，所以我们可以采用<code>\w{4}</code>。（<strong>切记，不能采用<code>\W</code></strong>。大写的<code>\W</code>表征的是非字符。）然后<code>{4}</code>表示前面的模式重复<strong>4次</strong>，即<code>\w</code>连续出现4次。</p>
<p>好了，综上所述，我们不难写出针对中文Unicode提取的正则表达式：<strong><code>\\u\w{4}</code></strong></p>
<p>但是，在作者的代码中，作者的正则表达式却是：<code>\\\\[uU]\\w{4}</code>，那这个是怎么回事呢？<br>原因在于， 对于在字符串形式出现的正则表达式，首先解析的是字符串规则，然后才是正则表达式引擎的解析。</p>
<p>所以，<code>\\\\</code>被字符串解析成<code>\\</code>，然后正则解析成<code>\</code>。然后对于<code>[uU]</code>，是一个组，表示或者u或者U，因为有些输出的文本里，对于U的大小写并没有规定，所以两种情况都需要考虑。</p>
<p>后面的就不再赘述了，原理一致。大家有兴趣的自己深入学习下吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Xcode插件开发">Xcode插件开发</h4><p>嘿嘿，今天带大家学习一下基于Xcode的插件开发。可能很多人一听到插件开发，想到的都是Sublime Text，Atom这样轻量级的编辑器的扩展插件，但是实际上，无论是VisualStudio, Eclips]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Check Pods Manifest.lock]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/check-manifest/"/>
    <id>http://satanwoo.github.io/2016/02/27/check-manifest/</id>
    <published>2016-02-27T10:23:21.000Z</published>
    <updated>2016-02-27T10:31:40.000Z</updated>
    <content type="html"><![CDATA[<p>初次看到这个题目的你，可能还不了解这是个啥。但是，我想下面这个错误提示，你肯定会非常熟悉：</p>
<pre><code><span class="keyword">error</span>: The sandbox <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> sync <span class="keyword">with</span> <span class="keyword">the</span>  
Podfile.lock. Run 'pod install' <span class="keyword">or</span> update 
your CocoaPods installation.
</code></pre><p>没错，当我们使用<code>cocoapods</code>的时候，经常会遇到的一个问题。其原因在于我们本地的<code>manifest.lock</code>和通过<code>git</code>同步的<code>Pod.lock</code>的产生了差异。</p>
<p><strong>注：manifest.lock简单可以理解为我们在本地执行一次<code>pod install</code>后生成的当前Podfile的状态的表征文件。而Pod.lock是同步他人更新过Podfile后的状态。</strong></p>
<p>那么，这个差异报错的原因是什么呢？我们可以打开Xcode项目中对应的<code>Target</code>的<code>Build Phase</code>，可以发现，其中存在在一项名为<code>Check Pods Manifest.lock</code>，是一个<code>shell script</code>，内容如下：</p>
<pre><code>// <span class="number">1.</span>
diff <span class="string">"${PODS_ROOT}/../Podfile.lock"</span> <span class="string">"${PODS_ROOT}/Manifest.lock"</span> &gt; /dev/null

// <span class="number">2.</span>
<span class="keyword">if</span> <span class="string">[[ $? != 0 ]]</span> ; <span class="keyword">then</span>

// <span class="number">3.</span>
    cat &lt;&lt; EOM
<span class="built_in">error</span>: The sandbox is <span class="keyword">not</span> <span class="keyword">in</span> sync with the Podfile.lock. Run <span class="string">'pod install'</span> <span class="keyword">or</span> update your CocoaPods installation.
EOM
    exit <span class="number">1</span>
fi
</code></pre><p>我们来解读下这段代码的意思：</p>
<ol>
<li><p>通过diff命令来检查<code>Podfile.lock</code>和<code>Manifest.lock</code>的区别。这个命令中的<code>&gt; /dev/null</code> 可以视为一个<strong>黑洞</strong>，等价于一个只读文件，所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到。由于在执行<code>diff</code>命令的过程中可能产生大量的标准输出，可能会干扰我们的的工作流程执行，所以我们将它们全部丢弃给<strong>黑洞</strong>，只关心<strong>返回值</strong>。</p>
</li>
<li><p><code>if [[ $? != 0 ]] then</code>这个命令指的上一个命令的返回值如果不等于0，就执行xxxx。其中$?也就代表着上一个命令<code>diff</code>的返回值。</p>
</li>
<li><p>好，如果返回值不为0，说明有差异，因此通过<code>cat &lt;&lt; EOM</code> 和 <code>EOM</code>将处于这两者之前的内容输出到标准输出。</p>
</li>
</ol>
<h3 id="改造脚本">改造脚本</h3><p>好，既然我们已经读懂了上述的<code>shell script</code>，我们不如将这个错误的提示来进行整改，当有差异的情况下，自动去进行<code>pod install</code>。</p>
<p>整体改造后的代码如下：</p>
<pre><code><span class="comment">// 1.</span>
diff <span class="string">"<span class="subst">${PODS_ROOT}</span>/../Podfile.lock"</span> <span class="string">"<span class="subst">${PODS_ROOT}</span>/Manifest.lock"</span> &gt; /dev/<span class="keyword">null</span>

<span class="comment">// 2.</span>
<span class="keyword">if</span> [[ $? != <span class="number">0</span> ]] ; then

<span class="comment">// 3.</span>
    pod install --project-directory=<span class="string">"<span class="subst">${PODS_ROOT}</span>/../"</span>
fi
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初次看到这个题目的你，可能还不了解这是个啥。但是，我想下面这个错误提示，你肯定会非常熟悉：</p>
<pre><code><span class="keyword">error</span>: The sandbox <span class="keyword">is</sp]]>
    </summary>
    
      <category term="shell" scheme="http://satanwoo.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发一个简单的Pod Install 插件]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/pod-install-plugin/"/>
    <id>http://satanwoo.github.io/2016/02/27/pod-install-plugin/</id>
    <published>2016-02-27T10:23:09.000Z</published>
    <updated>2016-02-27T10:25:35.000Z</updated>
    <content type="html"><![CDATA[<p>前几天刚刚粗略了学习了一下Xcode的插件开发，一时心痒，就准备做个简单的插件练练手。</p>
<p>哎哟我擦，正当我准备大展身手的时候，我突然想到我该做个啥呢?  我这真是有了程序员，只差一个好Idea了。</p>
<p>好吧，正巧这个时候，我发现我和朋友协作的一个iOS项目在两个分支上同步开发，每次要合并后拉下分支，都发现Pod.lock文件都产生了变化，无法编译成功。每当这个时候，我都要进入<code>terminal</code>输入一大堆的<code>cd ..</code>进入对应的文件目录执行<code>pod install</code>命令，甚是繁琐。</p>
<p>当然啦，你可以通过<code>alias</code> 配置快速的执行命令，但是，你仍然得切换出Xcode的窗口，对于我们这种效率控来说不能接受。</p>
<p>所以，我就想到了，在Xcode中利用插件集成一下关于pod的一些功能，同时绑定快捷键提高操作效率。</p>
<p>说干就干。</p>
<p>首先我们利用Xcode的plugin template生成项目的一些基本流程结构。关于插件的具体思路可以参考我之前的一篇文章《DXXcodeConsoleUnicodePlugin源码解析》</p>
<p>在这里，我们着重介绍一下利用 <code>NSTask</code> 去执行诸如<code>pod install</code>这样的命令。</p>
<h4 id="实现思路">实现思路</h4><p>在实现真正的<code>Objective-C</code>代码之前，我们首先现在<code>terminal</code>中随便找个安全的目录敲入<code>pod install</code>来试试看结果，如下所说：</p>
<pre><code>pod install
[!] <span class="keyword">No</span> <span class="label">`Podfile'</span> found <span class="keyword">in</span> the project directory.
</code></pre><p>从这个错误提示中我们可以大致了解，<code>pod install</code>的命令依赖于所谓的<code>Podfile</code>。于是，我们输入<code>pod install --help</code>查看其对应的帮助手册：</p>
<pre><code>-<span class="ruby">-project-directory=<span class="regexp">/project/dir</span><span class="regexp">/   The path to the root of the project
</span></span>                                       directory
-<span class="ruby"><span class="regexp">-no-clean                          Leave SCM dirs like `.git` and `.svn`
</span></span>                                       intact after downloading
-<span class="ruby"><span class="regexp">-no-integrate                      Skip integration of the Pods libraries
</span></span>                                       in the Xcode project(s)
-<span class="ruby"><span class="regexp">-no-repo-update                    Skip running `pod repo update` before
</span></span>                                       install
-<span class="ruby"><span class="regexp">-silent                            Show nothing
</span></span>-<span class="ruby"><span class="regexp">-verbose                           Show more debugging information
</span></span>-<span class="ruby"><span class="regexp">-no-ansi                           Show output without ANSI codes
</span></span>-<span class="ruby"><span class="regexp">-help                              Show help banner of specified command</span></span>
</code></pre><p>从第一条帮助命令张，我们可以看到，我们需要通过<strong>–project-directory=</strong>来设置<code>pod install</code>的根目录，也即<code>Podfile</code>的所在。</p>
<p>好，事情到这里，我们在编写插件前需要的准备工作就基本完成了，我们现在只需利用<code>NSTask</code>将我们在命令行中输入的命令执行即可。</p>
<p>让我们来看看实现的代码：</p>
<pre><code> <span class="comment">// 1.</span>
 [<span class="keyword">self</span> searchMainProjectPath];

 <span class="comment">// 2.</span>
 <span class="built_in">NSTask</span> *podInstallAction = [[<span class="built_in">NSTask</span> alloc] init];
 podInstallAction<span class="variable">.currentDirectoryPath</span> = <span class="keyword">self</span><span class="variable">.mainProjectPath</span>;
 podInstallAction<span class="variable">.arguments</span> = @[<span class="string">@"install"</span>];
 podInstallAction<span class="variable">.launchPath</span> = <span class="string">@"/usr/bin/pod"</span>;

 <span class="comment">// 3.</span>
 <span class="built_in">NSPipe</span> *pipeOut = [<span class="built_in">NSPipe</span> pipe];
 [podInstallAction setStandardOutput:pipeOut];
 <span class="built_in">NSFileHandle</span> *output = [pipeOut fileHandleForReading];

 [output setReadabilityHandler:^(<span class="built_in">NSFileHandle</span> * _Nonnull fileHandler) {
   <span class="built_in">NSData</span> *data = [fileHandler availableData];
   <span class="built_in">NSString</span> *text = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSASCIIStringEncoding</span>];

   <span class="built_in">NSLog</span>(<span class="string">@"text is %@"</span>, text);
 }];

[podInstallAction launch];
[podInstallAction waitUntilExit];
</code></pre><ol>
<li>我们首先要寻找到当前项目的主目录，也就是<code>Podfile</code>的路径</li>
<li>然后我们构建NSTask，将其的执行目录设置成我们的主目录，然后<code>/usr/bin</code>中调出<code>pod</code>的可执行文件，执行<code>pod install</code>。</li>
<li>我们利用NSPipe将默认的NSTask的输出(stdout)重定向到我们的指定的地方，这样有助于我们查看log或者进行流程工程。</li>
</ol>
<p>到这里，基本上一个简单的小插件就完成了，但是我在这里想要强调一点关于主工程路径搜索的一些问题，我们首先来看代码：</p>
<pre><code><span class="built_in">NSArray</span> *workspaceWindowControllers = [<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEWorkspaceWindowController"</span>) workspaceWindowControllers];
[workspaceWindowControllers enumerateObjectsUsingBlock:^(<span class="keyword">id</span> controller, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) {
  <span class="keyword">if</span> ([[controller valueForKey:<span class="string">@"window"</span>] isMainWindow]) {
    <span class="keyword">id</span> workspace = [controller valueForKey:<span class="string">@"_workspace"</span>];
    <span class="built_in">NSString</span> *filePath = [[workspace valueForKey:<span class="string">@"representingFilePath"</span>] valueForKey:<span class="string">@"pathString"</span>];
    <span class="built_in">NSString</span> *projectName = [[filePath lastPathComponent] stringByDeletingPathExtension];
    <span class="built_in">NSLog</span>(<span class="string">@"CocoaPodUI::ProjectName::%@"</span>, projectName);

    <span class="built_in">NSString</span> *text = [[filePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:<span class="string">@"Podfile"</span>];

    <span class="keyword">self</span><span class="variable">.mainProjectPath</span> = [filePath stringByDeletingLastPathComponent];

    <span class="built_in">NSLog</span>(<span class="string">@"pod ifle is %@"</span>, text);
  }
}];
</code></pre><p><strong>基于Xcode的插件开发实际上利用了大量的私有头文件。由于Objective-C著名的runtime特性，因此，很多时候，我们可以利用key-value-coding的方式获取我们普通途径下无法得到的结果。<br>同时，当有一个类的方法是私有方法的时候，你可以利用一个<code>category</code>声明同样的函数签名，不需要实现，<code>Objective-C</code>的runtime会自动帮你转发对应的<code>message passing</code>。</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天刚刚粗略了学习了一下Xcode的插件开发，一时心痒，就准备做个简单的插件练练手。</p>
<p>哎哟我擦，正当我准备大展身手的时候，我突然想到我该做个啥呢?  我这真是有了程序员，只差一个好Idea了。</p>
<p>好吧，正巧这个时候，我发现我和朋友协作的一个iOS]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FBKVOController 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/FBKVOController/"/>
    <id>http://satanwoo.github.io/2016/02/27/FBKVOController/</id>
    <published>2016-02-27T10:21:55.000Z</published>
    <updated>2016-02-27T10:24:22.000Z</updated>
    <content type="html"><![CDATA[<p>开发过iOS的app已经不计其数了，在不同的项目中采用的架构也各不相同，有传统的<strong>MVC</strong>，简化的<strong>VIPER</strong>，以及一些简单的<strong>MVVM</strong>。</p>
<p>这其中，我最不推荐的就是<strong>VIPER</strong>，谁写谁知道，，绝对是增加了项目的复杂性。<strong>MVVM</strong>由于自己总是受限于传统的<code>Object-Oriented</code>的思路，总是想不出真正的Functional Programming的代码，因此，绝大多数情况，写着写着都回归到了<strong>MVC</strong>。</p>
<p>其实，相较于网上大家总喜欢提到的<strong>Massive View Controller</strong>问题，我更想说的是这种传统架构中对于信息流的不友好。</p>
<p>在一个典型的iOS的问题中，我们的代码执行流程，通常都是从View Controller的<strong>生命周期</strong>开始，如果是一个完全基于顺序执行的应用，那整个app的信息流是<strong>单向可跟踪的</strong>。但是往往事情并不会那么简单，我们会包含至少如下这些潜在打乱信息流的<em>坏蛋</em></p>
<ul>
<li>Delegate回调</li>
<li>NSNotification</li>
<li>UIView控件的Target-Action</li>
<li>KVO</li>
</ul>
<p>在这里，你可能会以为我想谈谈<strong>ReactiveCocoa</strong>和<strong>RxSwift</strong>，那你错啦，那个开源项目我暂时还没有能力去深究，所以我想从KVO事件入手，读一读Facebook出品的<strong>FBKVOController</strong>。</p>
<h4 id="FBKVOController">FBKVOController</h4><p>简单来说，FBKVOController是对KVO机制的一层封装，同时提供了线程安全的特性和并对如下这个<strong>臭名昭著</strong>的函数进行了封装，提供了干净的block的回调，避免了处理这个函数的逻辑散落的到处都是。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary *)change <span class="string">context:</span>(<span class="typename">void</span> *)context
</code></pre><h4 id="源码分析">源码分析</h4><p>整个项目的结构非常简单，包含如下四个文件：</p>
<ul>
<li>FBKVOController.h/.m</li>
<li>NSObject+FBKVOController.h/.m</li>
</ul>
<p>其中，<code>NSObject+FBKVOController</code>只是通过<code>AssociateObject</code>给NSObject提供了一个<code>retain</code>及一个<code>非retain</code>型的KVOController。</p>
<p>这两种不同类型的KVOController有啥区别，我们稍后再提，我们将重点投向<code>FBKVOController</code>这个文件。</p>
<p>打开这个<code>FBKVOController.m</code>文件，哎呀，600多行文件，有点蛋疼。没事，配合头文件粗略扫一眼以后，可以发现其中很多方法都是<code>convenience method</code>。</p>
<p>简单剥离一下数据结构以后，我们可以发现，主要的数据结构有如下三个。</p>
<ul>
<li>FBKVOInfo</li>
<li>FBKVOSharedController</li>
<li>FBKVOController</li>
</ul>
<h4 id="FBKVOController-1">FBKVOController</h4><p>既然我们前面通过<code>NSObject+FBKVOController</code>知道了每个对象都会有其对应的<code>FBKVOController</code>，那我们就先来看看这个类吧。</p>
<pre><code><span class="comment">//1.</span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span></span>
{
  <span class="built_in">NSMapTable</span> *_objectInfosMap;
  OSSpinLock _lock;
}

<span class="comment">//2.</span>
- (instancetype)initWithObserver:(<span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved
{
  <span class="keyword">self</span> = [<span class="keyword">super</span> init];
  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) {
    <span class="comment">// 2.</span>
    _observer = observer;

    <span class="comment">// 3.</span>
    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;
    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];

    <span class="comment">// 4.</span>
    _lock = OS_SPINLOCK_INIT;
  }
  <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><ol>
<li><p>首先我们看到，这个对象持有一个<code>OSSpinLock</code>及一个<code>NSMapTable</code>。其中<code>OSSpinLock</code>即为自旋锁，当多个线程竞争相同的<strong>critical section</strong>时，起到保护作用。<code>NSMapTable</code>可能大家接触不是很多，我们在后文会详细介绍，这里大家可以先理解为一个高级的NSDictionary。</p>
</li>
<li><p>在构造函数中，首先将传入的observer进行<code>weak</code>持有，这主要为了避免<strong>Retain Cycle</strong>。</p>
</li>
<li><p>这一段的内容可能大家不太熟悉，<code>NSPointerFunctionsOptions</code>简单来说就是定义<code>NSMapTable</code>中的key和value采用何种内存管理策略，包括<code>strong</code>强引用，<code>weak</code>弱引用以及<code>copy</code>（要支持NSCopying协议）</p>
</li>
<li><p>初始化自旋锁  </p>
</li>
</ol>
<p>接下来，使我们通过<code>FBKVOController</code>来对一个对象的某个或者某些keypath进行观察。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block
{
  NSAssert(<span class="number">0</span> != keyPath.length &amp;&amp; NULL != block, @<span class="string">"missing required parameters observe:%@ keyPath:%@ block:%p"</span>, object, keyPath, block);
  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// 1. create info</span>
  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];

  <span class="comment">// 2. observe object with info</span>
  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];
}
</code></pre><ol>
<li>对于传入的参数，构建一个内部的FBKVOInfo数据结构</li>
<li>调用<code>[self _observe:object info:info];</code></li>
</ol>
<p>接下来，我们来跟踪一下<code>[self _observe:object info:info];</code>，内容如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">_observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="comment">// lock</span>
  OSSpinLockLock(&amp;_lock);

  <span class="comment">// 1.</span>
  NSMutableSet *infos = [_objectInfosMap <span class="string">objectForKey:</span>object];

  <span class="comment">// 2. </span>
  _FBKVOInfo *existingInfo = [infos <span class="string">member:</span>info];
  <span class="keyword">if</span> (nil != existingInfo) {
    NSLog(@<span class="string">"observation info already exists %@"</span>, existingInfo);

    <span class="comment">// unlock and return</span>
    OSSpinLockUnlock(&amp;_lock);
    <span class="keyword">return</span>;
  }

  <span class="comment">// lazilly create set of infos</span>
  <span class="keyword">if</span> (nil == infos) {
    infos = [NSMutableSet set];
    [_objectInfosMap <span class="string">setObject:</span>infos <span class="string">forKey:</span>object];
  }

  <span class="comment">// add info and oberve</span>
  [infos <span class="string">addObject:</span>info];

  <span class="comment">// unlock prior to callout</span>
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 3.</span>
  [[_FBKVOSharedController sharedController] <span class="string">observe:</span>object <span class="string">info:</span>info];
}
</code></pre><p>抛开Facebook自身标记的注释，有三处比较值得我们注意：</p>
<ol>
<li><p>根据被观察的object获取其对应的<strong>infos set</strong>。这个主要作用在于避免多次对同一个keyPath添加多次观察，避免crash。<strong>因为每调用一次<code>addObserverForKeyPath</code>就要有一个对应的<code>removeObserverForKey</code>。</strong></p>
</li>
<li><p>从<strong>infos set</strong>判断是不是已经有了与此次info相同的观察。</p>
</li>
<li><p>如果以上都顺利通过，将观察的信息及关系注册到<code>_FBKVOSharedController</code>中。</p>
</li>
</ol>
<p>至此，FBKVOController的任务基本都结束，<code>unObserve</code>相关的任务逻辑大同小异，不再赘述。</p>
<h4 id="FBKVOSharedController">FBKVOSharedController</h4><p>初次看到这个类的时候，我的脑海中浮现了两个问题，FBKVOSharedController是干嘛的?为什么FBKVOController还需要将观察的信息转交呢？</p>
<p><strong>其实我个人觉得这一层不是必要的</strong>，但是按照Facebook的理念来说就是将所有的观察信息统一交由一个<code>FBKVOSharedController</code>的<strong>单例</strong>进行维护。如果大家读过Facebook出品的<strong>Flux</strong>架构，也会发现，Facebook经常喜欢维护一个类似于中间件的注册表，在这里，<code>FBKVOSharedController</code>承担的也是类似的职责。</p>
<p>于是，通过如下方法，我们像使用注册表一样将对KVOInfo注册。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="keyword">if</span> (nil == info) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// register info</span>
  OSSpinLockLock(&amp;_lock);
  [_infos <span class="string">addObject:</span>info];
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 1.</span>
  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="typename">void</span> *)info];
}
</code></pre><ol>
<li>代表所有的观察信息都首先由<code>FBKVOSharedController</code>进行接受，随后进行转发。</li>
</ol>
<p>实现<code>observeValueForKeyPath:ofObject:Change:context</code><br>来接收通知。</p>
<pre><code>- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context
{
  <span class="built_in">NSAssert</span>(context, <span class="string">@"missing context keyPath:%@ object:%@ change:%@"</span>, keyPath, object, change);

  _FBKVOInfo *info;

  {
    <span class="comment">// 1. </span>
    OSSpinLockLock(&amp;_lock);
    info = [_infos member:(__bridge <span class="keyword">id</span>)context];
    OSSpinLockUnlock(&amp;_lock);
  }

  <span class="keyword">if</span> (<span class="literal">nil</span> != info) {

    <span class="comment">// take strong reference to controller</span>
    FBKVOController *controller = info-&gt;_controller;
    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) {

      <span class="comment">// take strong reference to observer</span>
      <span class="keyword">id</span> observer = controller<span class="variable">.observer</span>;
      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) {

        <span class="comment">// dispatch custom block or action, fall back to default action</span>
        <span class="keyword">if</span> (info-&gt;_block) {
          info-&gt;_block(observer, object, change);
        } <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) {
<span class="preprocessor">#pragma clang diagnostic push</span>
<span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span>
          [observer performSelector:info-&gt;_action withObject:change withObject:object];
<span class="preprocessor">#pragma clang diagnostic pop</span>
        } <span class="keyword">else</span> {
          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];
        }
      }
    }
  }
}
</code></pre><ol>
<li>根据context上下文获取对应的KVOInfo</li>
<li>判断当前<code>info</code>的<code>observer</code>和<code>controller</code>，是否仍然存在（因为之前我们采用的weak持有）</li>
<li>根据    <code>info</code>的<code>block</code>或者<code>selector</code>或者<code>override</code>进行消息转发。</li>
</ol>
<p>到这里，<code>FBKVOController</code>整体的实现就介绍完了，怎么样，是不是局部看自己都会实现，但是一结合起完整的设计思路，就觉得，不亏是Facebook呢。</p>
<h3 id="NSMapTable">NSMapTable</h3><p>之前我们在前文中提到了<code>NSMapTable</code>，现在我们来详细介绍他一下。<br>我们在平常的开发中都使用过<code>NSDictionary</code>或者<code>NSMutableDictionary</code>，但是这两种数据结构有其的局限性。</p>
<p>以<code>NSDictionary</code>为例，<code>NSDictionary</code>将<code>key</code>的<code>hash</code>值作为索引，存储对应的<code>value</code>。因此，<code>key</code>的要求是不能更改。所以，<code>NSDictionary</code>为了确保安全，对于<code>key</code>采用了<strong>copy</strong>的策略。</p>
<p>默认情况下，支持<strong>NSCopying</strong>协议的类型都可以作为key。但是考虑到copy带来的开销，一般情况下我们都使用简单的诸如数字或者字符串作为key。</p>
<p>那么，如果要使用<code>Object</code>作为key，想构建<strong>Object to Object</strong>的关系怎么办呢？这个时候就用到<code>NSMapTable</code>。我们可以通过NSFunctionsPointer来分别定义对key和value的储存关系，简单可以分类为<code>strong</code>,<code>weak</code>以及<code>copy</code>。而当利用<code>object</code>作为key的时候，可以定义评判相等的标准，如：<strong>use shifted pointer hash and direct equality, object description或者size</strong>。</p>
<p>具体你需要去override如下几种方法：</p>
<pre><code><span class="comment">// pointer personality functions</span>
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">BOOL</span> (*isEqualFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item1, <span class="keyword">const</span> <span class="keyword">void</span>*item2, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*sizeFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
<span class="keyword">@property</span> (nullable) <span class="built_in">NSString</span> * __nullable (*descriptionFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
</code></pre><p>在<code>FBKVOController</code>自定义的可以作为key的结构<code>FBKVOInfo</code>，就复写了</p>
<pre><code>- (<span class="type">NSUInteger</span>)hash
{
  <span class="keyword">return</span> [_keyPath hash];
}

- (<span class="type">BOOL</span>)isEqual:(id)<span class="class"><span class="keyword">object</span>
</span>{
  <span class="keyword">if</span> (nil == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">if</span> (self == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">YES</span>;
  }
  <span class="keyword">if</span> (![<span class="class"><span class="keyword">object</span> <span class="title">isKindOfClass</span>:</span>[self <span class="class"><span class="keyword">class</span>]]) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="class"><span class="keyword">object</span>)<span class="title">-&gt;_keyPath</span>];</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>开发过iOS的app已经不计其数了，在不同的项目中采用的架构也各不相同，有传统的<strong>MVC</strong>，简化的<strong>VIPER</strong>，以及一些简单的<strong>MVVM</strong>。</p>
<p>这其中，我最不推荐的就是<]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DGRunKeeperSwitch 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/"/>
    <id>http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/</id>
    <published>2016-02-05T14:35:57.000Z</published>
    <updated>2016-02-05T14:38:35.000Z</updated>
    <content type="html"><![CDATA[<p>DGRunKeeperSwitch是非常有趣的自定义的<em>Segment Control</em>的实现，从其Github上的展现效果来看，可以发现在 <em>同一个</em> UILabel中的文本竟然可以展现出两种不同的颜色，是不是很奇妙？今天就让我们来看看它是如何实现的。</p>
<p><img src="https://raw.githubusercontent.com/gontovnik/DGRunkeeperSwitch/master/DGRunkeeperSwitch.gif" alt=""></p>
<h3 id="源码分析">源码分析</h3><p>打开项目，发现这个项目真的很简单，就一个文件，<code>DGRunkeeperSwitch.swift</code>，并且实现也只有接近260行左右。</p>
<p>既然这个项目是个UI的开源库，我们主要还是先从界面层级入手。和<a href="http:glowing.com" target="_blank" rel="external">Glow的开源库(GLCalendar)</a>不同，这个是纯手写的控件，因此无法从<strong>.xib</strong>文件来快速了解，所以我们把目标首先投向相关的UIKit子属性，包括如下：</p>
<pre><code><span class="comment">// 1. </span>
private <span class="tag">var</span> titleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> leftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> rightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 2.</span>
private <span class="tag">var</span> selectedTitleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedLeftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedRightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 3.</span>
<span class="function"><span class="title">private</span><span class="params">(set)</span></span> <span class="tag">var</span> selectedBackgroundView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span> 
private <span class="tag">var</span> titleMaskView: UIView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
</code></pre><p>其中第一部分我们一看命名就很容易理解了，有一个<code>ContentView</code>作为<code>container</code>，包含了<code>segment control</code>对应的左右两个Label。</p>
<p>然后来看第二部分，第二部分从命名上也很直观，感觉上和第一部分是一致的，但是却<strong>可能代表的是选中的状态</strong>。不过我们很奇怪，作者为什么要构建一个一模一样的来表征不同的状态呢，直接用一个变量比如 <code>var selected = false</code> 进行样式的控制不可以吗？</p>
<p>好，先别急，这里卖个关子，我们继续往下看。</p>
<p>第三部分，<code>selectedBackgroundView</code>和<code>titleMaskView</code>，从名字看，也不能一下子了解含义，我们先全局搜索下相关连的代码，与<code>titleMaskView</code>相关的内容如下：</p>
<pre><code>titleMaskView<span class="class">.backgroundColor</span> = .<span class="function"><span class="title">blackColor</span><span class="params">()</span></span>
selectedTitleLabelsContentView<span class="class">.layer</span><span class="class">.mask</span> = titleMaskView.layer
</code></pre><p>看起来是用<code>titleMaskView</code>给之前<strong>可能的选中状态的</strong><code>selectedTitleLabelsContentView</code>加了一层遮罩。</p>
<p>由于遮罩是白色的地方不显示，黑色的地方（准确来说是非白色的区域）显示，因此我们可以理解上述代码是通过<code>titleMaskView</code>来显示<code>selectedTitleLabelsContentView</code>中的内容（<strong>也就是两个UILabel</strong>），非<code>titleMaskView</code>区域自动隐藏了。</p>
<pre><code>addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"selectedBackgroundView.frame"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)

<span class="keyword">override</span> public <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> {
    <span class="keyword">if</span> keyPath == <span class="string">"selectedBackgroundView.frame"</span> {
        titleMaskView.frame = selectedBackgroundView.frame
    }
}
</code></pre><p>哦，看完上述这段代码，我开始有点恍然大悟了，通过监听<code>selectedBackgroundView.frame</code>，我们实时改变<code>titleMaskView</code>的<code>frame</code>。而通过实际运行项目，我们可以很容易理解<code>selectedBackgroundView</code>就是用户可拖拽的选项高亮条。</p>
<p>到这，我渐渐有点理解作者为什么要构建两个完全一样的contentView，并都包含左右两个UILabel了。</p>
<p>作者应该是对于<code>titleLabelsContentView</code>设定为普通状态的Label，左右两个Label都是未选中的颜色状态，同时将<code>selectedTitleLabelsContentView</code>设定为选定状态，左右Label都使用了选中时候的颜色状态，然后通过<code>titleMaskView</code>进行遮罩，这样，<code>selectedTitleLabelsContentView</code>其余部分就被隐藏，会显示出下部<code>titleLabelsContentView</code>普通状态的Label颜色。</p>
<p>嘿嘿，读一下剩下的源代码，和我的猜测一致，不得不说，<strong>我真是太聪明了</strong>，这个思路真是太赞了。</p>
<h3 id="如何真正实现一个好的UI库">如何真正实现一个好的UI库</h3><p>看到这个小标题，可能有人会产生疑惑，实现好一个UI库不就是功能正确，效果正常吗？错！</p>
<p>我认为这只是基本的两点，还有如下几点需要包含：</p>
<ul>
<li>使用正确的类型</li>
<li>在正确的函数中做正确的事</li>
<li>暴露不过多也不过少的属性</li>
<li>抛出、监听相对应的事件</li>
<li>根据不同屏幕大小、屏幕方向进行适配</li>
<li>横竖屏情况都能展示良好</li>
</ul>
<ol>
<li><p>第一，从DGRunkeeperSwitch来看，首先由于其模仿的是UISegmentControl，所以自然而然的应该继承与<strong>UIControl</strong>而不是UIView。有人要问有啥区别，简单来说就是<strong>UIControl将UIView中能接受的Touch事件，转换成了更高级的UIEvent，比如UITouchUpInside。</strong></p>
</li>
<li><p>第二，作者通过init函数进行初始化，通过layoutSubview进行页面布局，而不是像很多人自己写代码时将很多东西一窝蜂的堆到了init中。</p>
</li>
<li><p>提供了颜色、字体、边距以及动画弹性等属性给外部调用，同时将不应该暴露的内部UIKit变量进行私有化，并将<code>selectedIndex</code>通过<code>private(set)</code>对外设置为只读。</p>
</li>
<li><p>在切换Segment选择后，抛出了相应的<code>sendActionsForControlEvents(.ValueChanged)</code> 用于给外部监听。</p>
</li>
</ol>
<h3 id="效果之外的重点">效果之外的重点</h3><p>作者在实现这个项目之中，有几点是比较值得注意的：</p>
<h4 id="利用元组同时赋值多个属性">利用元组同时赋值多个属性</h4><pre><code><span class="keyword">public</span> var leftTitle: <span class="keyword">String</span> {
    <span class="built_in">set</span> { (leftTitleLabel.<span class="built_in">text</span>, selectedLeftTitleLabel.<span class="built_in">text</span>) = (newValue, newValue) }
    <span class="built_in">get</span> { <span class="keyword">return</span> leftTitleLabel.<span class="built_in">text</span>! }
}
</code></pre><p>在Swift中引入了一个元组的新类型，我们可以利用这个数据结构同时给多个属性赋值。</p>
<h4 id="private(set)">private(set)</h4><pre><code><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="variable"><span class="keyword">var</span> selectedIndex</span>: <span class="typename">Int</span> = <span class="number">0</span>
</code></pre><p>作者在实现过程中保留了一个<code>selectedIndex</code> 变量，但是这个类对外只读，对内可以读写，因此用了<strong>private(set)</strong>。</p>
<p><strong>这相当于在Objective-C时代，我们在.h文件中声明  <code>@property(nonatomic, strong, readonly) Class *A</code><br>然后又在.m文件中，声明  <code>@property(nonatomic, strong, readwrite) Class *A</code></strong></p>
<h4 id="UIView和CALayer">UIView和CALayer</h4><p>很多人写iOS的时候，分不清UIView和CALayer之间的区别，很多人都理解成了继承的关系。大错特错！</p>
<ul>
<li>实际上UIView里面有个成员变量是CALayer，而CALayer的delegate是UIView(这会涉及到很多的隐式动画之类的，不展开了)</li>
<li>UIView可以接受Touch事件，而Layer不行</li>
<li>UIView有个layerClass的类型方法，可以被复写，用于改变这个UIView对应的基础Layer类型，比如你可以将赋值CAGradientLayer给这个View</li>
</ul>
<p>在本项目中，作者复写了layerClass，如下：</p>
<pre><code><span class="keyword">override</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">layerClass</span>() -&gt; <span class="title">AnyClass</span> </span>{
    <span class="keyword">return</span> DGRunkeeperSwitchRoundedLayer.self
}
</code></pre><p>好啦，今天就差不多到这啦~下周再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>DGRunKeeperSwitch是非常有趣的自定义的<em>Segment Control</em>的实现，从其Github上的展现效果来看，可以发现在 <em>同一个</em> UILabel中的文本竟然可以展现出两种不同的颜色，是不是很奇妙？今天就让我们来看看它是如何]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PureLayout 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/05/PureLayout/"/>
    <id>http://satanwoo.github.io/2016/02/05/PureLayout/</id>
    <published>2016-02-05T14:33:20.000Z</published>
    <updated>2016-02-05T14:34:46.000Z</updated>
    <content type="html"><![CDATA[<p>在开始这篇文章之前，想必大家都应该使用过Autolayout方式的界面布局，相信大家都有过类似于如下这样的API调用：    </p>
<pre><code>[NSLayoutConstraint(item: self.viewA, attribute: .CenterY, relatedBy: .Equal, toItem: self.viewB, attribute: .CenterY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0.0</span>)]
</code></pre><p>抑或是Visual Format Language</p>
<pre><code>NSLayoutConstraint.constraintsWithVisualFormat(<span class="string">"|-(leftPadding)-[imageView(imageViewWidth)]-(rigntPadding)-[labelA]-(4)-[labelB]-(&gt;=44)-|"</span>, <span class="string">options:</span> NSLayoutFormatOptions(<span class="string">rawValue:</span> <span class="number">0</span>), <span class="string">metrics:</span> methics, <span class="string">views:</span> views)
</code></pre><p>这种冗长而又晦涩的代码，真是恶心人啊。因此在Github上涌现了一大堆简化布局的开源库，如SnapKit, Mansory以及今天我们要说的PureLayout。  </p>
<p>在这之中，PureLayout是最轻量级的，它仅仅是对Autolayout现成的语法进行了一层封装，相较于Mansory引入的一些<strong>新概念</strong>，Purelayout更直接易懂。</p>
<h3 id="源码解析">源码解析</h3><p>Purelayout的源码基本没什么难懂的地方，我们首先来看一下其项目结构：</p>
<ul>
<li>PurelayoutDefines.h</li>
<li>ALView + PureLayout.h/.m</li>
<li>NSArray + PureLayout.h/.m</li>
<li>NSLayoutConstraint + Purelayout.h/.m</li>
</ul>
<h4 id="PurelayoutDefines">PurelayoutDefines</h4><p>首先从PurelayoutDefines上入手，这个文件主要是进行一些类似<strong>Domain Specific Language</strong>定义的转化，如：</p>
<pre><code>typedef NS_ENUM(NSInteger, ALEdge) {
    /** The <span class="built_in">left</span> edge of the view. */
    ALEdgeLeft = NSLayoutAttributeLeft,
    /** The <span class="built_in">right</span> edge of the view. */
    ALEdgeRight = NSLayoutAttributeRight,
    /** The top edge of the view. */
    ALEdgeTop = NSLayoutAttributeTop,
    /** The bottom edge of the view. */
    ALEdgeBottom = NSLayoutAttributeBottom,
    /** The leading edge of the view (<span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeLeading = NSLayoutAttributeLeading,
    /** The trailing edge of the view (<span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeTrailing = NSLayoutAttributeTrailing
};
</code></pre><p>上述这段代码，就是将传统的UIKit中的NSLayoutAttribute的枚举类型全部转换成对应的PureLayout中的定义，如ALEdgeRight对应到NSLayoutAttributeRight。</p>
<p><strong>LayoutMargins</strong><br>在这里补充一点题外知识，在iOS8中，苹果为Autolayout引入了LayoutMargins这一概念。这个概念乍一听可能都不了解，但是大家回忆下，比如在Storyboard中，我们拖拽一个UIView到ViewController的view并设置边距的时候，上边距和下边距对应的限制都是layout guide，如下图所示：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.55.37.png" alt=""></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.23.png" alt=""><br><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.13.png" alt=""></p>
<p><strong>简单来说，在iOS7上就已经存在了LayoutMargin了，当时的作用是用来限制view的真实内容不会被UINavigationBar（上部）以及UIToolbar（下部）所遮盖</strong>。而从iOS8中开始，苹果将这一技术引入到了任意一个UIView中。</p>
<h4 id="ALView_+_Purelayout">ALView + Purelayout</h4><p><strong>ALView实际上是UIView或者NSView的别名，通过添加ALView的分类，可以通过Define在编译期进行替换，避免为NSView和UIView各创建一份重复的代码</strong>。这个类中的API过多，因此我们以轴对齐为典型的例子来分解下源码：</p>
<ol>
<li>轴对齐<br>在PureLayout中，包括<code>Vertical</code>, <code>Horizontal</code>, <code>Baseline</code>等几种轴对齐方式，其中Baseline指的是View中潜在包含文字的Baseline。</li>
</ol>
<p>好，我们来看看相关的API</p>
<pre><code><span class="comment">/** Aligns an axis of the view to the same axis of another view. */</span>
<span class="tag">-</span> (<span class="tag">NSLayoutConstraint</span> *)<span class="rule"><span class="attribute">autoAlignAxis</span>:<span class="value">(ALAxis)axis toSameAxisOfView:(ALView *)otherView</span></span>;
</code></pre><p>从该API的名称，我们可以直观的感觉出其作用是用于将两个View按照同一个轴对齐。这个API是一个<strong>Convenience Init</strong>，其层层传递</p>
<pre><code>- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView
{
    <span class="keyword">return</span> [self <span class="string">autoAlignAxis:</span>axis <span class="string">toSameAxisOfView:</span>otherView <span class="string">withOffset:</span><span class="number">0.0</span>];
}

- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView <span class="string">withOffset:</span>(CGFloat)offset
{
    <span class="keyword">return</span> [self <span class="string">autoConstrainAttribute:</span>(ALAttribute)axis <span class="string">toAttribute:</span>(ALAttribute)axis <span class="string">ofView:</span>otherView <span class="string">withOffset:</span>offset];
}
</code></pre><p>最后调用了</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoConstrainAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>attribute toAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>toAttribute ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView withOffset:<span class="params">(<span class="variable">CGFloat</span>)</span>offset`</span>
</code></pre><p>好，那就让我们来看看这个上述这个函数的实现，如下所示：</p>
<pre><code><span class="comment">//1.</span>
self.translatesAutoresizingMaskIntoConstraints = NO;

<span class="comment">//2.</span>
NSLayoutAttribute layoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>attribute];
NSLayoutAttribute toLayoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>toAttribute];

<span class="comment">//3.</span>
NSLayoutConstraint *constraint = [NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>layoutAttribute <span class="string">relatedBy:</span>relation <span class="string">toItem:</span>otherView <span class="string">attribute:</span>toLayoutAttribute <span class="string">multiplier:</span><span class="number">1.0</span> <span class="string">constant:</span>offset];

<span class="comment">//4.</span>
[constraint autoInstall];
<span class="keyword">return</span> constraint;
</code></pre><ul>
<li>1.首先将translatesAutoresizingMaskIntoConstraints设置为false，对于要使用autolayout的UIView，必须设置为false，也就是不将传统frame布局中的Autoresizing Mask转换成约束。</li>
<li>2.根据传入的<strong>PureLayout属性</strong>转换成对应的NSLayoutAttribute</li>
<li>3.调用冗长恶心的Autolayout API构建约束</li>
<li>4.添加约束</li>
</ul>
<p>在这里，我们需要注意一下这个<code>[constraint autoInstall]</code>，让我们来探一探实现：</p>
<pre><code>- (<span class="keyword">void</span>)autoInstall
{
<span class="comment">// 1. iOS8+</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10</span>
    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setActive:)]) {
        [<span class="built_in">NSLayoutConstraint</span> al_applyGlobalStateToConstraint:<span class="keyword">self</span>];
        <span class="comment">// 1.1</span>
        <span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_preventAutomaticConstraintInstallation]) {         
            [[<span class="built_in">NSLayoutConstraint</span> al_currentArrayOfCreatedConstraints] addObject:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
        <span class="comment">// 1.2 </span>
            <span class="keyword">self</span><span class="variable">.active</span> = <span class="literal">YES</span>;
        }
        <span class="keyword">return</span>;
    }
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10 */</span>

<span class="comment">// 2. iOS 7</span>
    <span class="built_in">NSAssert</span>(<span class="keyword">self</span><span class="variable">.firstItem</span> || <span class="keyword">self</span><span class="variable">.secondItem</span>, <span class="string">@"Can't install a constraint with nil firstItem and secondItem."</span>);
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.firstItem</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.secondItem</span>) {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]] &amp;&amp; [<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if both items are views."</span>);
            ALView *commonSuperview = [<span class="keyword">self</span><span class="variable">.firstItem</span> al_commonSuperviewWithView:<span class="keyword">self</span><span class="variable">.secondItem</span>];
            [commonSuperview al_addConstraint:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
            [<span class="keyword">self</span><span class="variable">.firstItem</span> al_addConstraint:<span class="keyword">self</span>];
        }
    } <span class="keyword">else</span> {
        <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
        [<span class="keyword">self</span><span class="variable">.secondItem</span> al_addConstraint:<span class="keyword">self</span>];
    }
}
</code></pre><p>整个实现的部分被一分为二，上半部分专门针对iOS8+的，下半部分针对iOS7（<strong>事实上在整个PureLayout的设计中，大部分地方的处理方式都一分为二了</strong>）</p>
<p>我们暂时也不管<code>al_applyGlobalStateToConstraint:self</code> 以及 <code>al_preventAutomaticConstraintInstallation</code>的作用，我们从1.2看起。</p>
<ul>
<li>在iOS8上，启用或者禁用一个AutoLayout的Constraint变得更加容易了，仅仅需要设置active即可</li>
<li>在iOS7上，需要手动的addConstraint或者removeConstraint</li>
<li>在处理iOS7的逻辑当中，需要判断当前这个Constraint是否是针对两个Item的，如果是，找到他们的公共父View，在父View在添加约束，比如添加View A和View B之间的间距；而如果是单一一个View，比如是设置高度或者宽度的，直接在当前View添加即可。</li>
<li>通过调用<code>al_addConstraint</code>进行约束实际的添加。</li>
</ul>
<p>而<strong>al_addConstraint</strong>的实现则如下所示：</p>
<pre><code><span class="attr_selector">[NSLayoutConstraint al_applyGlobalStateToConstraint:constraint]</span>;
<span class="tag">if</span> ([NSLayoutConstraint al_preventAutomaticConstraintInstallation]) {
    <span class="attr_selector">[[NSLayoutConstraint al_currentArrayOfCreatedConstraints]</span> <span class="tag">addObject</span><span class="pseudo">:constraint</span>];
} <span class="tag">else</span> {
    <span class="attr_selector">[self addConstraint:constraint]</span>;
}
</code></pre><p>这里又出现了<code>al_applyGlobalStateToConstraint:constraint</code>以及<code>al_preventAutomaticConstraintInstallation</code>了，这次我们可不能再躲着它了，赶紧瞧一瞧。</p>
<p>首先是<code>al_applyGlobalStateToConstraint:constraint</code>，这个参数对应的是一个全局静态变量，用于判断：</p>
<pre><code><span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_isExecutingPriorityConstraintsBlock]) {
    constraint<span class="variable">.priority</span> = [<span class="built_in">NSLayoutConstraint</span> al_currentGlobalConstraintPriority];
}
</code></pre><p>而这个<code>al_isExecutingPriorityConstraintsBlock</code>则是用于如下这个函数：</p>
<pre><code>+ (void)autoSetPriority:(ALLayoutPriority)priority forConstraints:(ALConstraintsBlock)<span class="keyword">block
</span>{
    NSAssert(<span class="keyword">block, </span><span class="comment">@"The constraints block cannot be nil.");</span>
    <span class="preprocessor">if</span> (<span class="keyword">block) </span>{
        [[<span class="keyword">self </span>al_globalConstraintPriorities] <span class="keyword">addObject:@(priority)];
</span>        <span class="keyword">block();
</span>        [[<span class="keyword">self </span>al_globalConstraintPriorities] removeLastObject]<span class="comment">;</span>
    }
}
</code></pre><p>这里可能大家有点晦涩，主要在于PureLayout对于给Constraint设置Priority定义了一个Block-based的方法，也就是<code>autoSetPriority</code>。在回调的Block中，可以对多个Constraint设置同一个大小的Priority。（<strong>其实我也不是很理解这个集体加Priority设计的目的</strong>）</p>
<p><strong>不过需要有一点可以肯定的是，设置Constraint的Priority的时机一定要在<code>addConstraint</code>或者<code>active = true</code>之前</strong></p>
<p>而对于<code>al_preventAutomaticConstraintInstallation</code>这个变量，作者在API中描述了如下一段话：</p>
<blockquote>Creates all of the constraints in the block, then installs (activates) them all at once.<br> All constraints created from calls to the PureLayout API in the block are returned in a single array.<br> This may be more efficient than installing (activating) each constraint one-by-one.</blockquote>

<p>简而言之，一次性添加所有约束（实际上调用了UIKit的API<code>activateConstraints</code>），比一个个添加要有效率。<strong>然而，Purelayout的这个特性对于iOS7来说，用不上，只能通过<code>addConstraint</code>一个个装，哈哈，么么哒</strong></p>
<h4 id="NSArray_+_Purelayout">NSArray + Purelayout</h4><p>说完了ALView的layout，我们接下来说说另外的NSArray + Purelayout。顾名思义，该分类的主要目的就是给一个NSArray中的所有UIView添加约束。</p>
<p>比如这个API：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoDistributeViewsAlongAxis:<span class="list">(<span class="keyword">ALAxis</span>)</span>axis
                                                           alignedTo:<span class="list">(<span class="keyword">ALAttribute</span>)</span>alignment
                                                    withFixedSpacing:<span class="list">(<span class="keyword">CGFloat</span>)</span>spacing
                                                        insetSpacing:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldSpaceInsets
                                                        matchedSizes:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldMatchSizes</span>
</code></pre><p>其实现如下：</p>
<pre><code><span class="built_in">NSAssert</span>([<span class="keyword">self</span> al_containsMinimumNumberOfViews:<span class="number">1</span>], <span class="string">@"This array must contain at least 1 view to distribute."</span>);

<span class="comment">//1. 第一部分</span>
    ALDimension matchedDimension;
    ALEdge firstEdge, lastEdge;
    <span class="keyword">switch</span> (axis) {
        <span class="keyword">case</span> ALAxisHorizontal:
        <span class="keyword">case</span> ALAxisBaseline: <span class="comment">// same value as ALAxisLastBaseline</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0</span>
        <span class="keyword">case</span> ALAxisFirstBaseline:
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 */</span>
            matchedDimension = ALDimensionWidth;
            firstEdge = ALEdgeLeading;
            lastEdge = ALEdgeTrailing;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ALAxisVertical:
            matchedDimension = ALDimensionHeight;
            firstEdge = ALEdgeTop;
            lastEdge = ALEdgeBottom;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="built_in">NSAssert</span>(<span class="literal">nil</span>, <span class="string">@"Not a valid ALAxis."</span>);
            <span class="keyword">return</span> <span class="literal">nil</span>;
    }
    <span class="built_in">CGFloat</span> leadingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;
    <span class="built_in">CGFloat</span> trailingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;

<span class="comment">//2. 第二部分  </span>
    __<span class="built_in">NSMutableArray_of</span>(<span class="built_in">NSLayoutConstraint</span> *) *constraints = [<span class="built_in">NSMutableArray</span> new];
    ALView *previousView = <span class="literal">nil</span>;
    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>) {
        <span class="keyword">if</span> ([object isKindOfClass:[ALView class]]) {
            ALView *view = (ALView *)object;
            view<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;
            <span class="keyword">if</span> (previousView) {
                <span class="comment">// Second, Third, ... View</span>
                [constraints addObject:[view autoPinEdge:firstEdge toEdge:lastEdge ofView:previousView withOffset:spacing]];
                <span class="keyword">if</span> (shouldMatchSizes) {
                    [constraints addObject:[view autoMatchDimension:matchedDimension toDimension:matchedDimension ofView:previousView]];
                }
                [constraints addObject:[view al_alignAttribute:alignment toView:previousView forAxis:axis]];
            }
            <span class="keyword">else</span> {
                <span class="comment">// First view</span>
                [constraints addObject:[view autoPinEdgeToSuperviewEdge:firstEdge withInset:leadingSpacing]];
            }
            previousView = view;
        }
    }
    <span class="keyword">if</span> (previousView) {
        <span class="comment">// Last View</span>
        [constraints addObject:[previousView autoPinEdgeToSuperviewEdge:lastEdge withInset:trailingSpacing]];
    }
    <span class="keyword">return</span> constraints;            
</code></pre><ol>
<li>这个API的目的是将一组UIView按照Spacing间距进行均分，同时每个UIView的宽度或者高度保持一致。</li>
<li>第一部分是根据传入的轴，进行判断，是在竖直方向均分还是水平方向均分，同时影响的还有是宽度一致还是高度一致。</li>
<li>第二部分是根据传入的轴（比如水平方向），将前一个View的右边距和后一个View的左边距添加间距，循环添加，直至最后一个View的右边距和父View的右边距添加完成约束。  </li>
</ol>
<p>其他方面，这个分类的作用基本和<code>ALView + PureLayout一致</code>，也就不再重复解释了。<br>至此，PureLayout的源码解析基本上差不多了，其余类似于边对齐的API，如：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoPinEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>edge toEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>toEdge ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView;</span>
</code></pre><p>又或者是约束尺寸的，如：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoSetDimensionsToSize:<span class="list">(<span class="keyword">CGSize</span>)</span>size<span class="comment">;</span></span>
</code></pre><p>都大同小异，在此就不一一赘述了。</p>
<p>最后，<strong>强调一点</strong>：</p>
<ol>
<li>PureLayout必须在主线程使用，其本身实现非常依赖于静态的全局变量。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开始这篇文章之前，想必大家都应该使用过Autolayout方式的界面布局，相信大家都有过类似于如下这样的API调用：    </p>
<pre><code>[NSLayoutConstraint(item: self.viewA, attribute: .CenterY,]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重构你的ViewController]]></title>
    <link href="http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/"/>
    <id>http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/</id>
    <published>2015-12-29T16:37:56.000Z</published>
    <updated>2015-12-29T16:48:37.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章来自阅读<a href="https://realm.io/news/andy-matuschak-refactor-mega-controller/" target="_blank" rel="external">Let’s Play: Refactor the Mega Controller!</a></p>
<p>在该文中，作者阐述了如何使用Swift重构一个臭名昭著的Massive View Controller。从中，我们可以一窥Swift诸多优秀的特性以及如何利用这些特性将ViewController的职责进行解耦。</p>
<p>但是作者由于时间有限，并没有讲述完全，因此本文是我阅读<a href="https://github.com/andymatuschak/refactor-the-mega-controller" target="_blank" rel="external">源码</a>后的理解。</p>
<p><strong>建议大家在阅读本文之前，能够先去看看链接中的视频。</strong></p>
<h3 id="Let’s_get_started">Let’s get started</h3><p>首先我们下载源码，可以看到如下文件：</p>
<pre><code>-<span class="ruby"> <span class="constant">NavigationController</span>.swift
</span>-<span class="ruby"> <span class="constant">ViewController</span>.swift
</span>-<span class="ruby"> <span class="constant">AddViewController</span>.swift</span>
</code></pre><p>其中，<code>ViewController.swift</code>是项目的核心，代码行数超过<strong>246</strong>行。在这里我要强调一下，并不是代码行数多不好，而是要看你这个职责是不是相关。如果246行都是在实现一个数据结构或者算法，当然可行。但是如果246行里面包含了逻辑业务、网络请求、数据持久化，那必然是可以分离一部分职责出去。</p>
<p>在本文的<code>ViewController.swift</code>，这个类在初始状态下包含了<code>UITableViewDataSource</code>, <code>UITableViewDelegate</code>, <code>UIViewControllerTransitioningDelegate</code>, <code>UIViewControllerAnimatedTransitioning</code>, <code>NSFetchedResultsController</code>以及一系类跟UI显示相关的代码。</p>
<h4 id="1-_干掉UINavigationBar相关的内容">1. 干掉UINavigationBar相关的内容</h4><p>作者在app中构建了可变化的NavigationBar，因此bar的样式是根据不同状态进行改变的。原来的逻辑整体写在了<code>ViewController.swift</code>中，如下所示：</p>
<pre><code> func updateNavigationBar() {
        <span class="keyword">switch</span> fetchedResultsController!<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
        <span class="keyword">case</span> <span class="number">0.</span>.<span class="number">.3</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        <span class="keyword">default</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }

override func preferredStatusBarStyle() -&gt; <span class="built_in">UIStatusBarStyle</span> {
    <span class="keyword">switch</span> fetchedResultsController?<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
    <span class="keyword">case</span> <span class="variable">.Some</span>(<span class="number">0.</span>.<span class="number">.3</span>), <span class="variable">.None</span>:
        <span class="keyword">return</span> <span class="variable">.Default</span>
    <span class="keyword">case</span> <span class="variable">.Some</span>(_):
        <span class="keyword">return</span> <span class="variable">.LightContent</span>
    }
}
</code></pre><p>同时，还在几个事件回调的地方，如Core Data的<code>controllerDidChange</code>，调用了<code>setNeedsStatusBarAppearanceUpdate()</code>。</p>
<p>这个想法粗略想想并没什么问题，因为我们需要根据一系列的事件变化来改变我们的界面样式，这是很明显的业务逻辑。而我们都很清楚，ViewController就是用来写业务逻辑的地方。</p>
<p>先抛开ViewController是否是应该写业务逻辑的地方这一个有待商榷的论点之外，我们先看看，我们可以如何重构现有代码。</p>
<p><strong>首先</strong>，<code>updateNavigationBar</code>中多个case中的代码有了重复，因此我们可以将其重构成一个函数，接受三个关于样式的参数，如下：</p>
<pre><code>func applyTheme(<span class="string">barTintColor:</span>newBarTintColor, <span class="string">tintColor:</span>newTintColor, <span class="string">titleTextAttributes:</span>newTextAttributes) {
    barTintColor = <span class="string">barTintColor:</span>newBarTintColor
    tintColor = <span class="string">tintColor:</span>newTintColor
    titleTextAttributes = <span class="string">titleTextAttributes:</span>newTextAttributes
}
</code></pre><p>重构完函数以后，我们发现在多个样式中用到了switch case进行业务逻辑参数转换样式参数的过程。<strong>这说明什么，我们可以将转换逻辑和switch case一起通过Enum进行重构（这里说的东西都是基于你懂Enum）</strong></p>
<pre><code><span class="keyword">enum</span> NavigationTheme {
    <span class="keyword">case</span> Normal
    <span class="keyword">case</span> Warning
    <span class="keyword">case</span> Doomed

    var statusBarStyle: <span class="built_in">UIStatusBarStyle</span> {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>: <span class="keyword">return</span> <span class="variable">.Default</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>: <span class="keyword">return</span> <span class="variable">.LightContent</span>
        }
    }

    var barTintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        <span class="keyword">case</span> <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        }
    }

    var titleTextAttributes: [String: <span class="built_in">NSObject</span>]? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
        }
    }

    var tintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }
}

extension NavigationTheme {
    init(numberOfImminentTasks: Int) {
        <span class="keyword">switch</span> numberOfImminentTasks {
        <span class="keyword">case</span> -Int<span class="variable">.max</span> ... <span class="number">3</span>:
            <span class="keyword">self</span> = <span class="variable">.Normal</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            <span class="keyword">self</span> = <span class="variable">.Warning</span>
        <span class="keyword">default</span>:
            <span class="keyword">self</span> = <span class="variable">.Doomed</span>
        }
    }
}    
</code></pre><p>由于Enum在swift中是一等公民，因此可以可以在其中构建大量的<strong>Computed Properties</strong>，这些计算变量依赖于当前enum的状态。不仅如此，我们还将之前分散的三种样式，组合成了一个<strong>紧凑的结构体</strong>，大大简化了变量传输。</p>
<p>重构结束后，我们在<code>Viewcontroller.swift</code>中设置一个计算变量<code>navigationTheme</code>，其的构造函数是之前的<code>fetchedResultsController?.fetchedObjects?.count</code>。</p>
<p>最后是在相应的事件后触发更新UINavigationBar即可，在本文的视线中，是采用了closure的形式完成：</p>
<pre><code>navigationThemeDidChangeHandler = { [<span class="keyword">weak</span> <span class="keyword">self</span>] theme <span class="keyword">in</span>
            <span class="keyword">if</span> <span class="keyword">let</span> navigationController = <span class="keyword">self</span>?.navigationController {
                navigationController.navigationBar.applyTheme(theme)
                navigationController.statusBarStyle = theme.statusBarStyle
            }
        }
</code></pre><h3 id="2-_干掉时间相关的转换逻辑">2. 干掉时间相关的转换逻辑</h3><p>相信很多人做app的时候遇到过，服务器返回的是一系列标准时间参数，而你需要将其转换成界面需要的生日、星座、年龄等等，这又是一大堆的业务逻辑。为了解决这种逻辑代码和ViewController的耦合，很多人提出了<code>ViewModel</code>，将部分弱业务逻辑代码剥离出来，单独写在一个地方。</p>
<p><strong>但是，我需要强调一点，这种形式的剥离，并不能叫ViewModal，而是一个简单的adapter而已。</strong></p>
<p>在本文中，列表Cell里面需要根据日期距离当前时间的差距显示成昨天、今天、明天等等。因此，其构建了一个单独的的DateFormatter，根据传入的两个Date进行转换，代码如下：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">RelativeTimeDateFormatter</span> </span>{
    <span class="keyword">let</span> calendar: <span class="type">NSCalendar</span>

    <span class="keyword">init</span>(calendar: <span class="type">NSCalendar</span> = <span class="type">NSCalendar</span>.autoupdatingCurrentCalendar()) {
        <span class="keyword">self</span>.calendar = calendar
    }

    <span class="func"><span class="keyword">func</span> <span class="title">stringForDate</span><span class="params">(date: NSDate, relativeToDate baseDate: NSDate)</span></span> -&gt; <span class="type">String</span> {
        <span class="keyword">var</span> beginningOfDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>
        <span class="keyword">var</span> beginningOfBaseDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>

        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfDate, interval: <span class="literal">nil</span>, forDate: date)
        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfBaseDate, interval: <span class="literal">nil</span>, forDate: baseDate)
        <span class="keyword">let</span> numberOfCalendarDaysBetweenDates = calendar.components(<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, fromDate: beginningOfBaseDate!, toDate: beginningOfDate!, options: <span class="type">NSCalendarOptions</span>()).day

        <span class="keyword">switch</span> numberOfCalendarDaysBetweenDates {
        <span class="keyword">case</span> -<span class="type">Int</span>.<span class="built_in">max</span> ... -<span class="number">2</span>:
            <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="built_in">abs</span>(numberOfCalendarDaysBetweenDates)</span>) days ago"</span>
        <span class="keyword">case</span> -<span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Yesterday"</span>
        <span class="keyword">case</span> <span class="number">0</span>:
            <span class="keyword">return</span> <span class="string">"Today"</span>
        <span class="keyword">case</span> <span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Tomorrow"</span>
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="string">"In <span class="subst">\(numberOfCalendarDaysBetweenDates)</span> days"</span>
        }
    }
}
</code></pre><p><strong>这里需要注意的是，NSCalendar的初始化非常耗时，过去在Objective-C时代常常使用dispatch_once构建单例传输，在这里通过结构体中的成员变量维护了一份，作用是同样的。</strong></p>
<h3 id="3-_干掉NSPredicate">3. 干掉NSPredicate</h3><p>对于NSPredicate，有些人可能还不熟悉，他就是类似于SQLite中的查询语句，只不过其应用范围是CoreData。咦，查询语句还能重构？</p>
<p>其实在本文中，对于NSPredicate的使用只有原先这一句  <code>fetchRequest.predicate = NSPredicate(format: &quot;dueDate &lt;= %@&quot;, argumentArray: [NSCalendar.currentCalendar().dateByAddingUnit(.Day, value: 10, toDate: NSDate(), options: NSCalendarOptions())!])</code></p>
<p>这段代码从重复性上来说是不需要重构的。但是，我们可以看到，在这里的构造参数里面，我们还是进行了一定的业务逻辑转换。所以，和DateFormatter一样，我们也可以将这部分所谓为的”弱业务逻辑”代码进行剥离：</p>
<pre><code>extension NSPredicate {
    convenience init(forTasksWithinNumberOfDays <span class="string">numberOfDays:</span> Int, ofDate <span class="string">date:</span> NSDate, <span class="string">calendar:</span> NSCalendar = NSCalendar.currentCalendar()) {
        self.init(<span class="string">format:</span> <span class="string">"dueDate &lt;= %@"</span>, <span class="string">argumentArray:</span> [calendar.dateByAddingUnit(.Day, <span class="string">value:</span> numberOfDays, <span class="string">toDate:</span> date, <span class="string">options:</span> NSCalendarOptions())!])
    }
}
</code></pre><p><strong>除了业务逻辑剥离之外，其实我们也可以看到，在这个NSPredicate的新构造参数，可以接受一个<code>calendar</code>，这对于测试用例编写的依赖注入是非常有好处的。</strong></p>
<h3 id="4-_Core_Data_Stack">4. Core Data Stack</h3><p>用过Core Data的人都知道，Core Data的使用非常麻烦，需要配置大量的选项，照着苹果源码写的经历相信大家都有过，那恶心的200-300行配置代码，真是么么哒了。</p>
<p><strong>但是，这几百行代码又是无法省略的</strong>，那该怎么办呢？</p>
<p>一个比较好的解决方案就<code>Core Data Stack</code>    。意为将CoreData的初始化以及多个NSManagerObjectContext封装进<code>CoreDataStack</code> 维护。 </p>
<p>在本文中，因为只是使用了一个主线程的NSManagerObjectContext，所以可能读者在阅读源码的时候可能觉得这个重构只是将CoreData配置从View剥离了。但是实际上，使用CoreDataStack可以做到更多，建议大家阅读Github上相关项目。</p>
<h3 id="5-_干掉NSFetchedResultsControllerDelegate">5. 干掉NSFetchedResultsControllerDelegate</h3><p>NSFetchedResultsController大家可以简单理解为获取CoreData数据的一个中介层。根据传输进入的谓语NSPredicate进行查询，查询结束后通过相应的Delegate事件回调。</p>
<p>在作者的代码中，作者通过构建<code>manager</code>的方式剥离了NSFetchedResultsController的职责，将NSFetchedResultsController的初始化、回调封装进了<code>UpcomingTaskDataManager.swift</code>中。</p>
<p><strong>不过值得注意的一点是，尽管作者封装的NSFetchedResultsControllerDelegate的回调，但是为了让调用者可以自定义处理事件，实际上作者还是需要暴露一些的Delegate，当然，新的回调相对来说进行了一定的简化，同时在数据回调时经过了业务转化。</strong></p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerWillChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerDidChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didInsertRowAtIndexPath indexPath: NSIndexPath)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didDeleteRowAtIndexPath indexPath: NSIndexPath)</span></span>
}
</code></pre><h3 id="6-_CoreDataModel_&lt;=&gt;_Model">6. CoreDataModel &lt;=&gt; Model</h3><p>这一步是将从Core Data中获取的NSManagedObject Model 转换成业务中使用的Model。为什么要这么做呢？原因有三个：  </p>
<ul>
<li>CoreData中的属性一更改，就会触发NSFetchedResultsController，这会很影响性能。</li>
<li>CoreData中的属性存在很多bug</li>
<li>NSManagedObject不是一个struct类型，很有可能<strong>误伤</strong></li>
</ul>
<pre>
import CoreData  
import Foundation

struct Task: Equatable {
    var id: String
    var title: String
    var dueDate: NSDate
}

func ==(lhs: Task, rhs: Task) -> Bool {
    return lhs.id == rhs.id && lhs.title == rhs.title && lhs.dueDate == rhs.dueDate
}

extension Task {
    init(managedTask: NSManagedObject) {
        self.id = managedTask.valueForKey("id") as! String
        self.title = managedTask.valueForKey("title") as! String
        self.dueDate = managedTask.valueForKey("dueDate") as! NSDate
    }
}
</pre>

<p>作者用以上的Task类型替换了CoreData中的ManagedObject，可以有效的避免以上问题。</p>
<h3 id="7-封装数据结构">7.封装数据结构</h3><p>在这一步里，我将作者自定义<code>TaskTableViewCell</code>和构建<code>AddCompletionSegue</code>合并到了一块说。</p>
<p>这两步的重构，看似简单，但是其实也蕴含了一个思想：<strong>类型越确定，编程越容易，运行越安全</strong></p>
<p>在原文的实现，一开始作者都是通过采用基础的数据结构UITableViewCell和UISegue。这样带来的坏处就是类型不明确导致的职责不明确。对于基础的数据结构，我们常常还要进行类型判断和转换，容易犯错。</p>
<h3 id="8-干掉UITableViewDelegate和UITableViewDataSource">8.干掉UITableViewDelegate和UITableViewDataSource</h3><p>这一步想必大家都很熟悉了，微博上整天热传了<em>用ViewModel重构你的ViewController</em>经常提及的就是干掉UITableViewDelegate和UITableViewDataSource。</p>
<p>那说了那么多，我们来看看究竟如何干掉它。</p>
<p>毫无以为，我们首先要构建一个类型，来实现UITableViewDelegate和DataSource，如下所示：</p>
<pre><code><span class="comment">// 1. </span>
<span class="class"><span class="keyword">class</span> <span class="title">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="title">CellType</span>: <span class="title">UITableViewCell</span>&gt;: <span class="title">NSObject</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    private <span class="keyword">let</span> tableView: <span class="type">UITableView</span>
    private <span class="keyword">let</span> upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>
    private <span class="keyword">let</span> cellReuseIdentifier: <span class="type">String</span>
    private <span class="keyword">let</span> cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; ()
    private <span class="keyword">let</span> didChangeHandler: () -&gt; <span class="type">Void</span>

<span class="comment">// .2</span>
    <span class="keyword">init</span>(tableView: <span class="type">UITableView</span>, upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>, cellReuseIdentifier: <span class="type">String</span>, cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; (), didChangeHandler: () -&gt; <span class="type">Void</span>) {
        <span class="keyword">self</span>.tableView = tableView
        <span class="keyword">self</span>.upcomingTaskDataManager = upcomingTaskDataManager
        <span class="keyword">self</span>.cellReuseIdentifier = cellReuseIdentifier
        <span class="keyword">self</span>.cellConfigurationHandler = cellConfigurationHandler
        <span class="keyword">self</span>.didChangeHandler = didChangeHandler

        <span class="keyword">super</span>.<span class="keyword">init</span>()
    }

<span class="comment">// 3.</span>
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> {
        upcomingTaskDataManager.deleteTask(upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row])
    }

    <span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].title
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].items.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> {
        <span class="keyword">let</span> task = upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row]
        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellReuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">CellType</span>
        cellConfigurationHandler(cell, task)
        <span class="keyword">return</span> cell
    }
</code></pre><ol>
<li>这个<code>UpcomingTaskDataManagerTableViewAdapter</code>通过传入一个CellType支持泛型。  </li>
<li>通过接受几个closure来进行自定义的配置，包括cell的样式配置以及tableview数据更新后的回调。  </li>
<li>实现的UITableViewDataSource</li>
</ol>
<p>同样，由于职责的重新分配，我们要将跟<code>TaskManager</code>（包括NSFetchedResultsController）相关的划入到这个adapter中。</p>
<h3 id="大结局">大结局</h3><p>最后重构后的ViewController，只有<strong>37</strong>代码，效果如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UITableViewController</span> </span>{
    <span class="keyword">var</span> navigationThemeDidChangeHandler: ((<span class="type">NavigationTheme</span>) -&gt; <span class="type">Void</span>)?
    <span class="keyword">var</span> navigationTheme: <span class="type">NavigationTheme</span> {
        <span class="keyword">return</span> <span class="type">NavigationTheme</span>(numberOfImminentTasks: upcomingTaskDataManager.totalNumberOfTasks)
    }

    private <span class="keyword">let</span> upcomingTaskDataManager = <span class="type">UpcomingTaskDataManager</span>()
    private <span class="keyword">var</span> upcomingTaskDataManagerTableViewAdapter: <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="type">TaskTableViewCell</span>&gt;!

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
        <span class="keyword">super</span>.viewDidLoad()

        upcomingTaskDataManagerTableViewAdapter = <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>(
            tableView: tableView,
            upcomingTaskDataManager: upcomingTaskDataManager,
            cellReuseIdentifier: <span class="string">"Cell"</span>,
            cellConfigurationHandler: { cell, task <span class="keyword">in</span>
                cell.viewData = <span class="type">TaskTableViewCell</span>.<span class="type">ViewData</span>(task: task, relativeToDate: <span class="type">NSDate</span>())
            },
            didChangeHandler: { [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="keyword">self</span>?.updateNavigationBar() }
        )
        upcomingTaskDataManager.delegate = upcomingTaskDataManagerTableViewAdapter
        tableView.dataSource = upcomingTaskDataManagerTableViewAdapter

        updateNavigationBar()
    }

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> <span class="literal">true</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">updateNavigationBar</span><span class="params">()</span></span> {
        navigationThemeDidChangeHandler?(navigationTheme)
    }

    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">unwindFromAddController</span><span class="params">(segue: AddCompletionSegue)</span></span> {
        upcomingTaskDataManager.createTaskWithTitle(segue.taskTitle, dueDate: segue.taskDueDate)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章来自阅读<a href="https://realm.io/news/andy-matuschak-refactor-mega-controller/" target="_blank" rel="external">Let’s Play: Refactor the ]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步步学R（2）]]></title>
    <link href="http://satanwoo.github.io/2015/12/20/Learn-R-2/"/>
    <id>http://satanwoo.github.io/2015/12/20/Learn-R-2/</id>
    <published>2015-12-20T08:43:31.000Z</published>
    <updated>2015-12-26T17:14:13.000Z</updated>
    <content type="html"><![CDATA[<h3 id="系列连载">系列连载</h3><p><a href="http://satanwoo.github.io/2015/12/13/Learn-R-1/">一步步学R（1）</a><br><a href="http://satanwoo.github.io/2015/12/20/Learn-R-2/">一步步学R（2）</a></p>
<h3 id="If-Else">If-Else</h3><p>R 种的If-Else结构并没有比较特殊的地方，仍然支持两种结构：</p>
<pre><code><span class="tag">if</span> (condition) {
    <span class="comment">// Do Something</span>
} <span class="tag">else</span> {
   <span class="comment">// Do Otherthing</span>
}
</code></pre><p>或者如下：</p>
<pre><code><span class="keyword">if</span> (condition) {
    // <span class="keyword">Do</span> Something
} <span class="keyword">else</span> <span class="keyword">if</span> (condition2) {
   // <span class="keyword">Do</span> Otherthing
} <span class="keyword">else</span> {
   // <span class="keyword">Do</span> <span class="keyword">Else</span>
}
</code></pre><p>但是在R中，对于If-else有一个可以简化的地方，如：</p>
<pre><code><span class="keyword">if</span> (x &gt; <span class="number">100</span>) {
    y &lt;- <span class="number">10</span>
} <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">100</span>) {
   y &lt;- <span class="number">11</span>
} <span class="keyword">else</span> {
   y &lt;- <span class="number">5</span>
}
</code></pre><p>可以简化成：</p>
<pre><code>y &lt;- <span class="keyword">if</span> (x &gt; <span class="number">100</span>) {
    <span class="number">10</span>
} <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">100</span>) {
   <span class="number">11</span>
} <span class="keyword">else</span> {
   <span class="number">5</span>
}
</code></pre><h3 id="For">For</h3><p>For语句的语法也非常简单：</p>
<pre><code><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) {
    <span class="built_in">print</span>(i)
}
</code></pre><p><strong>seq_along</strong> 函数是for循环中可以注意的一个点。它的参数是一个vector，如<code>x &lt;- c(&#39;a&#39;, &#39;b&#39;)</code>，调用<code>seq_along(x)</code>会得到一个序列，长度为2，值为1，2。因此，<code>print(x[1])</code> 就等于 <code>a</code>。</p>
<h3 id="While">While</h3><p>同样简单：</p>
<pre><code><span class="keyword">while</span> <span class="comment">(condition)</span> {
   <span class="comment">// Do studyy</span>
}
</code></pre><h3 id="Repeat">Repeat</h3><p>repeat是R中特有的一种逻辑结构，简单来理解就是<strong>死循环</strong>，想要退出的唯一方式是<strong>显式使用<code>break</code>。</strong></p>
<pre><code>repeat {
    x &lt;- something()

    <span class="keyword">if</span> (<span class="literal">A</span>) {
        <span class="keyword">break</span>
    } <span class="keyword">else</span> {
        x &lt;- x + <span class="number">1</span>
    }
}
</code></pre><h3 id="Next">Next</h3><p><code>next</code>就是其他语言中的<code>continue</code></p>
<pre><code><span class="keyword">for</span> (i in <span class="number">1</span>:<span class="number">100</span>) {
     <span class="keyword">if</span> (i &lt; <span class="number">20</span>) {
         next
     }

     <span class="comment">// Do other</span>
}
</code></pre><h3 id="函数">函数</h3><p>R中的函数可以没有显式的<code>return</code>，默认返回最后一句语句。</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>{
     x + y
}
</code></pre><p>和其他语言一样，你可以给参数设置默认值，如</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y = 10)</span> </span>{
     x + y
}
</code></pre><p>R中的函数参数优点类似于JavaScript，<strong>可以不用赋值完全，前提是你用不到</strong>。而且，对于R中的参数，你可以打乱参数传递，只要你前面加上了行参的名称，</p>
<p>比如</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>{
     x + y
}
</code></pre><p>你可以通过<code>add2(y = 5, x = 7)</code>来进行调用。</p>
<h4 id="可变参数">可变参数</h4><p>在R中也是有可变参数的，即<code>...</code>。</p>
<pre><code>myplot &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y, type = 1, <span class="rest_arg">...) {
    plot</span>(x, y, type, <span class="rest_arg">...)
}</span></span></span>
</code></pre><p>同样，<code>...</code>也可以用在泛型函数中，后续学习中我们会说到。</p>
<p>**不过，与其他编程语言所不同的是，R中的可变参数可以放在函数列表的前面，如</p>
<p><code>function(..., sep = &quot; &quot;, collsape = NULL)</code></p>
<p>调用如上的这种函数，必须<strong>显式的</strong>通过函数参数名称来调用后续参数，如</p>
<p><code>function(&quot;haha&quot;, &quot;heihei&quot;, sep = &quot;,&quot;)</code></p>
<h3 id="变量作用域">变量作用域</h3><h4 id="使用变量">使用变量</h4><p>当你使用一个R语言中的变量时，比如x，你有没有想过x究竟是存在于哪里呢？</p>
<p>有些人会说，我定义的呀，比如<code>x &lt;- 5</code>，那么对于那些默认函数，比如<code>vector()</code>呢？</p>
<p>所以，这就涉及到R中的<strong>Symbol binding</strong>（其他语言的变量查找）了。</p>
<p>在R中，查找顺序是这样的。</p>
<pre><code>[<span class="number">1</span>] <span class="string">".GlobalEnv"</span>        <span class="string">"tools:rstudio"</span>     <span class="string">"package:stats"</span>     <span class="string">"package:graphics"</span>  <span class="string">"package:grDevices"</span>
[<span class="number">6</span>] <span class="string">"package:utils"</span>     <span class="string">"package:datasets"</span>  <span class="string">"package:methods"</span>   <span class="string">"Autoloads"</span>         <span class="string">"package:base"</span> 
</code></pre><p>默认查找的是<strong>.GlobalEnv</strong>，依次类推。</p>
<p>如果你还通过<code>library()</code>函数加载了其他package，如ggplot2，那么查找顺序是</p>
<pre><code> [<span class="number">1</span>] <span class="string">".GlobalEnv"</span>        <span class="string">"package:ggplot2"</span>   <span class="string">"tools:rstudio"</span>     <span class="string">"package:stats"</span>     <span class="string">"package:graphics"</span> 
 [<span class="number">6</span>] <span class="string">"package:grDevices"</span> <span class="string">"package:utils"</span>     <span class="string">"package:datasets"</span>  <span class="string">"package:methods"</span>   <span class="string">"Autoloads"</span>        
[<span class="number">11</span>] <span class="string">"package:base"</span>     
</code></pre><p>也就是用户加载的package会自动加到除了<strong>.GlobalEnv</strong>之外的任意搜索顺序前。</p>
<p>如果要查看最新的搜索顺序，可以通过<code>search()</code></p>
<h4 id="作用域">作用域</h4><p>R中的作用域，是Lexical Scoping，也就是静态作用域，也就是<strong>JavaScript的作用域</strong>。</p>
<p>好了，我不多说了，如果想学习更多冠以静态作用域的话，看我的JavaScript博客部分。</p>
<p>当然，如果你不懂，你可以通过如下函数帮助你理解。</p>
<p><code>ls(environment(functionName))</code><br><code>get(variableName, environment(functionName))</code></p>
<p><strong>一言以蔽之，lexcial scoping可以简单理解为你函数中需要的变量，是通过其定义时环境进行查找。</strong></p>
<h4 id="Data_and_Times">Data and Times</h4><p>R中的时间表示，采用了一种特殊的数据结构。</p>
<p>Date是通过<strong>Date</strong>这一数据结构表示，而Time是通过POSIXct或者POSIXlt表示。</p>
<ul>
<li>Date是不包含Time的，只显示年、月、日。</li>
<li>Date的内部储存是计算1970-01-01到当前时间之间的天数。</li>
<li>Time的内部储存是计算1979-01-01到当前时间之间的秒数。</li>
</ul>
<p>可以采用<code>as.Date</code>构建Date，如<code>as.Date(&quot;1970-01-01&quot;)</code></p>
<p>而Time相对来说比较复杂，我们首先来看看<code>Posixlt</code>的表现形式。</p>
<p>我们输入<code>p&lt;- Sys.time()</code>获取当前时间，结果是<code>&quot;2015-12-27 00:59:18 CST&quot;</code>，然后我们调用<code>unclass(p)</code>来看看其构成，结果如下：</p>
<pre><code>[<span class="number">1</span>] <span class="string">"sec"</span>    <span class="string">"min"</span>    <span class="string">"hour"</span>   <span class="string">"mday"</span>   <span class="string">"mon"</span>    <span class="string">"year"</span>   <span class="string">"wday"</span>   <span class="string">"yday"</span>   <span class="string">"isdst"</span>  <span class="string">"zone"</span>   <span class="string">"gmtoff"</span>
</code></pre><p><strong>这表明，通过<code>Posixlt</code>表征的<code>Time</code></strong>，其内部是由一系列成分组成的集合。我们可以通过<br><code>p$wday</code> 来查看今天是周几。  </p>
<p>而<code>Posixct</code>就是就算1970-01-01到当前时间的描述，是个非常大的<strong>Integer</strong>。</p>
<p>你可以对Date或者Time进行大小比较操作，但是注意，<strong>不能讲Date和Time混合操作</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="系列连载">系列连载</h3><p><a href="http://satanwoo.github.io/2015/12/13/Learn-R-1/">一步步学R（1）</a><br><a href="http://satanwoo.github.io/2015/]]>
    </summary>
    
      <category term="R" scheme="http://satanwoo.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Regression Model]]></title>
    <link href="http://satanwoo.github.io/2015/12/15/Regression-Model-1/"/>
    <id>http://satanwoo.github.io/2015/12/15/Regression-Model-1/</id>
    <published>2015-12-14T16:31:35.000Z</published>
    <updated>2015-12-14T17:36:17.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Regression_Model是什么">Regression Model是什么</h3><p>Regression Model是一种基本的数据分析模型，通俗点来说就是我们在中学时期学习的截距式直线方程。通过斜率和截距来定义一种诸如 <code>y = kx + b</code>的方程。一旦有了这样的方程，我们就可以通过我们现有的数据集，比如一堆<code>x</code> 来预测y。</p>
<p>今天就让我们来研究研究这一种数据模型</p>
<h4 id="Centering">Centering</h4><p>Centering是一种常用的数学用语，意为 <em>集中化</em>。什么意思呢？就是说如果我有从x1, x2 … xn 这n个数据构成的数据集{x}，我可以求出他们的平均值为<em>XM</em>。我可以构建 <code>bi = xi - XM</code> 这样一个数列，这样的话，{b}这个数据集的平均值就为0，这一个过程就叫Centering。</p>
<h4 id="Variances（方差）">Variances（方差）</h4><p>方式的定义是:</p>
<blockquote>
<p>求出一个数据集的平均数XM, 对于{x} 中的每一个数，求其与平均数差的平方。再这这些差的平房加在一起求和，最后用和除以n - 1，这里的n是数据集中数据的个数。</p>
</blockquote>
<p>而标准差就是方差的平方根。 <strong>通过构建<code>bi = xi / 标准差s</code> 可以得到{b}数据集，它的标准差为1，这一过程也叫做Scaling</strong></p>
<h4 id="Normalization">Normalization</h4><p>将数据集先Centering再Scaling的过程叫做Normalization。</p>
<h4 id="Covariance（协方差）">Covariance（协方差）</h4><p>协方差的定义其实和方差类似，只不过针对的是一对数据集{x, y}。</p>
<blockquote>
<p>求出数据集{x}的平均数M，求出数据集{y}的平均数N，对于每一个i，求和<code>(xi - M) * (yi - N)</code>，最后和除以<code>n - 1</code>，其中n是数据集中数据的个数。</p>
</blockquote>
<h4 id="Corrleation（两个数据集的关联）">Corrleation（两个数据集的关联）</h4><p>Correlation就是将两个数据集的协方差除以{x}的标准差和{y}的标准差的乘积。<br><strong>Correlation的值域从－1到1，越接近两端表示两个数据集关联度越大，越靠近0表示越小。</strong></p>
<h3 id="重点">重点</h3><p>对于 y = kx + b 来说，可以通过如下公式求解方程：</p>
<p><code>k = cor(y, x) * s(y) / s(x)</code>  以及 <code>b = mean(y) - k * mean(x)</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Regression_Model是什么">Regression Model是什么</h3><p>Regression Model是一种基本的数据分析模型，通俗点来说就是我们在中学时期学习的截距式直线方程。通过斜率和截距来定义一种诸如 <code>y = kx + ]]>
    </summary>
    
      <category term="Math" scheme="http://satanwoo.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步步学R（1）]]></title>
    <link href="http://satanwoo.github.io/2015/12/13/Learn-R-1/"/>
    <id>http://satanwoo.github.io/2015/12/13/Learn-R-1/</id>
    <published>2015-12-13T07:03:36.000Z</published>
    <updated>2015-12-26T17:13:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="系列连载">系列连载</h3><p><a href="http://satanwoo.github.io/2015/12/13/Learn-R-1/">一步步学R（1）</a><br><a href="http://satanwoo.github.io/2015/12/20/Learn-R-2/">一步步学R（2）</a></p>
<p>嘿嘿，作为一名天才，当然要掌握一定的数据分析能力啦，所以从今天起，我们来一步步学习R这门有意思的语言。</p>
<p>这一系列的文章的开发环境都是基于Mac的。</p>
<h3 id="安装">安装</h3><ol>
<li>首先你要安装R语言的环境 <a href="https://cran.r-project.org/" target="_blank" rel="external">安装点我</a></li>
<li>可选：安装RStudio（类似于Matlab），安装之前必须已经安装了R <a href="https://www.rstudio.com/" target="_blank" rel="external">安装点我</a></li>
</ol>
<h3 id="基础知识">基础知识</h3><h4 id="R里面的基础类型">R里面的基础类型</h4><ul>
<li>Character，如 “a”，”haha”</li>
<li>Number（实数），如 5， 5.5</li>
<li><p>Integer（整数），如 5，6</p>
<p>  <strong>要注意的是，默认情况，所有的整数类型都为实数，如果要特定为整数，需要加L，如5L</strong></p>
</li>
<li><p>Logical，如TRUE, FALSE</p>
<p>  <strong>FALSE = 0，TRUE为一切非0数，可以简写为F/T</strong></p>
</li>
<li><p>Complex（复数），如 5 + 7i</p>
</li>
</ul>
<h4 id="操作">操作</h4><p><code>x &lt;- 5</code> 表示将5赋值给x<br><code>x</code>      表示输出x，效果等同于<code>print(x)</code></p>
<h4 id="向量">向量</h4><p>虽然向量不是一个基本类型，但是却是R语言中非常关键的一种数据结构</p>
<p><code>x &lt;- 5</code> 这句语句虽然表面上看起来是定义了一个<strong>Number</strong>类型的x，值为5。但是实质上却是构建了一个大小为1的向量，通过<code>x</code>语句我们可以得到一下结果：</p>
<pre><code>&gt; x
[<span class="number">1</span>] <span class="number">5</span>
</code></pre><p>所以<code>x</code> 等同于语句 <code>x[1]</code>，会输出5。</p>
<p><strong>注意：R语言里面的数据索引从1开始</strong></p>
<p>除了默认构造的向量以外，我们可以通过<code>vector(class, size)</code>来构建指定类型和大小的向量，如：</p>
<pre><code>&gt; k &lt;- <span class="function"><span class="title">vector</span><span class="params">(<span class="string">'logical'</span>, <span class="number">5</span>L)</span></span>
&gt; z &lt;- <span class="function"><span class="title">vector</span><span class="params">(<span class="string">"complex"</span>, <span class="number">7</span>)</span></span>
</code></pre><p>以上两句我们分别构建了一个名为k的logical向量，大小5以及一个复数向量，大小为7。</p>
<p><strong>注意：在R的向量里，同一个向量只能包含相同类型的对象，如果包含了不相同，会进行隐式转换，如果不能转换就会报错。</strong></p>
<p>如：</p>
<pre><code>&gt; k &lt;- <span class="function"><span class="title">c</span><span class="params">(T, <span class="string">"a"</span>)</span></span>
&gt; k
[<span class="number">1</span>] <span class="string">"TRUE"</span> <span class="string">"a"</span> 
</code></pre><p>当然也可以强制转换：</p>
<p><code>as.character</code>， <code>as.logical</code>， <code>as.numeric</code>，<code>as.complex</code>，<code>as.integer</code></p>
<h4 id="list">list</h4><p>list是一种可以同时保存多个类型对象的数据结构，通过<code>list(a, b, c, d)</code>进行构建。</p>
<h4 id="Matrix">Matrix</h4><p>matrix就是多维向量，通过函数<code>matrix(data, nrows, ncols)</code> 构建，默认是按列排列数据，可以通过更改byrow=T来按照行来构建。</p>
<h4 id="Factor">Factor</h4><p>简单理解，就是分类定义的数组，比如，<code>x &lt;- factor(c(&#39;yes&#39;, &#39;no&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;yes&#39;))</code>  ，虽然看起来构建了一个和Character类型的向量差不多，但是实质上，我们可以通过</p>
<pre><code>&gt; x &lt;- <span class="function"><span class="title">factor</span><span class="params">(c(<span class="string">'yes'</span>, <span class="string">'no'</span>, <span class="string">'yes'</span>)</span></span>)
&gt; <span class="function"><span class="title">levels</span><span class="params">(x)</span></span>
[<span class="number">1</span>] <span class="string">"no"</span>  <span class="string">"yes"</span>
</code></pre><p>这个向量代表了几种分类。</p>
<h4 id="Missing_Values">Missing Values</h4><p>Na和NaN, <strong>NaN仅代表数值计算的不存在，而Na是代表一切的不存在，即Na包含NaN</strong><br>我们可以通过<code>is.Na</code>和<code>is.NaN</code>来进行判断。</p>
<h4 id="Data_Frames">Data Frames</h4><p>Data Frames简单理解就是一个表格，但是与Matrix不同的是，她可以包含不同类型的data，也就是说，<strong>DataFrames的每一列都是一个list</strong>。</p>
<pre><code>&gt; k &lt;- data.<span class="function"><span class="title">frame</span><span class="params">(foo = <span class="number">1</span>:<span class="number">3</span>, w = c(T, F, F)</span></span>, row<span class="class">.names</span> = <span class="function"><span class="title">c</span><span class="params">(<span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'k'</span>)</span></span>)
&gt; k
  foo     w
<span class="number">1</span>   <span class="number">1</span>  TRUE
<span class="tag">a</span>   <span class="number">2</span> FALSE
k   <span class="number">3</span> FALSE
</code></pre><p><strong>需要注意的是，每一个list的长度，都必须完全一样</strong>。</p>
<h4 id="Names（别名）">Names（别名）</h4><p>对于一个向量、list或者matrix等等，我们都可以为里面的元素加上别名，如:</p>
<pre><code>&gt; x &lt;- <span class="number">1</span>:<span class="number">3</span>
&gt; <span class="function"><span class="title">names</span><span class="params">(x)</span></span> &lt;- <span class="function"><span class="title">c</span><span class="params">(T, F, <span class="string">"ha"</span>)</span></span>
&gt; x
 TRUE FALSE    ha 
    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span> 
</code></pre><p>其中，这些别名都会以字符串的形式存在，因此，你可以通过x[“TRUE”]来访问元素1。</p>
<hr>
<h3 id="进阶的R_哈哈哈">进阶的R 哈哈哈</h3><h4 id="Partical_Matching">Partical Matching</h4><p>R里面有个很酷的特性叫做Partial Matching。比如你定义了如下的list：<code>x &lt;- list(caonikljslkdfj = 5)</code>，每次都要输入<code>caonikljslkdfj</code>势必很麻烦，因此你可以使用<strong>$</strong>来获取，如<code>x$c</code> 即可以得到5了。</p>
<h4 id="Subset">Subset</h4><p>在R里面，获取数据或者构建数据简直就是a piece of cake。(哈哈哈，英语好就是屌啊)</p>
<p>比如有这样一个向量<code>x &lt;- c(1, 2, 3, 4, 5)</code>，</p>
<p>你可以<code>x[1]</code> 来获取元素1，也可以通过<code>x[1:3]</code>来获取元素1到元素3。同样，你也可以通过<code>x[x &gt; 2]</code> 来获取元素中值比2大的元素。</p>
<p>你也可以通过logical来构建另外的向量，如：</p>
<pre><code>&gt; u &lt;- x &gt; <span class="number">2</span>
&gt; u
[<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>
</code></pre><p>而对于Matrix类型来说，<code>c &lt;- matrix(1:3, nrows = 3, ncols = 1)</code>，你可以使用<code>c[1, ]</code>来获取第一行所有列的数据，或者<code>c[,1]</code>来获取第一列所有行的数据。</p>
<h4 id="[]_vs_[[]]_vs_$">[] vs [[]] vs $</h4><p>首先，这三个符号都可以获取元素，但是区别在于：</p>
<ul>
<li>[]返回的是和变量本身类型相同的东西，如果对list使用[]，那么返回的就是list，如果对向量使用，返回的就是向量，无关取出的元素本身的类型。</li>
<li>[]可以获取多个元素，而[[]]和$不行。</li>
<li>$可以模糊匹配（Partial Matching），而[[]]不行，如果要启用模糊匹配，得使用[[name, exact = F]]</li>
<li>$不可以使用计算值，[[]]可以</li>
</ul>
<p>是不是很拗口？让我们来看几个例子，在看例子之前强调一点，</p>
<p><strong>元素并非特指一个，而是一个基本的数据结构，比如对于向量 <code>x &lt;- 1:5</code>来说，里面的元素1到元素5分别都是一个元素。而对于<code>c&lt;- list(foo = 1:3, bar = 0.5)</code>来说，foo和bar都分别是一个元素，尽管foo本身仍然是个向量。</strong></p>
<h5 id="例子">例子</h5><p>对于<code>c &lt;- list(foo = 1:3, bar = 0.6)</code>定义的一个list，我们分别使用：</p>
<pre><code>&gt; c[<span class="string">"foo"</span>]
$foo
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>

&gt; c[[<span class="string">"foo"</span>]]
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
&gt; c$foo
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
</code></pre><p>可以看到，通过［］取出的foo元素仍然是list，而[[]]和$取出的都是向量元素本身了。</p>
<p>再比如计算变量的差别：</p>
<pre><code>&gt; name &lt;- <span class="string">"foo"</span>
&gt; c[[name]]
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
&gt; c$name
<span class="literal">NULL</span>
</code></pre><p>可以看到，[[]]可以使用计算变量，而$不可以。<strong>这点其实和JavaScript里面的dot和[]操作符很类似的</strong></p>
<p>模糊匹配差别：</p>
<pre><code>&gt; c$f
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
&gt; c[[<span class="string">"f"</span>]]
<span class="literal">NULL</span>
&gt; c[[<span class="string">"f"</span>, exact = F]]
[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>
</code></pre><h4 id="向量化操作">向量化操作</h4><p><strong>R里面的所有计算操作都是并行的</strong>。</p>
<p>因此，如果要计算两个Matrix的乘积，需要使用<code>%*%</code>，否则如果直接使用<code>*</code>就是对应位置的元素相乘而已。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="系列连载">系列连载</h3><p><a href="http://satanwoo.github.io/2015/12/13/Learn-R-1/">一步步学R（1）</a><br><a href="http://satanwoo.github.io/2015/]]>
    </summary>
    
      <category term="R" scheme="http://satanwoo.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅入浅出LLDB（1）]]></title>
    <link href="http://satanwoo.github.io/2015/12/11/LLDB-1/"/>
    <id>http://satanwoo.github.io/2015/12/11/LLDB-1/</id>
    <published>2015-12-11T08:50:04.000Z</published>
    <updated>2015-12-11T12:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>这周开始好好钻研一下LLDB相关的知识，这是一系列的文章。有些初级知识可能大家都有所涉猎，嘿嘿，懂得自然懂，看我的博客，什么时候会收获小。</p>
<h3 id="基础语法">基础语法</h3><p>1.<code>help</code> 有啥不会，就直接输入help，你会得到如下的一系列信息，</p>
<pre><code>command           -- A <span class="keyword">set</span> <span class="keyword">of</span> commands <span class="keyword">for</span> managing <span class="keyword">or</span> customizing the
                   debugger commands.
disassemble       -- Disassemble bytes <span class="keyword">in</span> the current <span class="keyword">function</span>, <span class="keyword">or</span> elsewhere
                   <span class="keyword">in</span> the executable program <span class="keyword">as</span> specified <span class="keyword">by</span> the user.
</code></pre><p>2.<code>print</code> 输出变量值<br>比如，对于如下的程序语句 <code>let haha = 5;</code> 你只要在LLDB里面输入 <code>print haha</code> 就可以得到如下输出结果。</p>
<pre><code>(lldb) p haha
(Int) <span class="variable">$R0</span> = <span class="number">5</span>
</code></pre><p><strong>请注意</strong>，在<a href="http://objccn.io/issue-19-2/" target="_blank" rel="external">与调试器共舞- LLDB 的华尔兹</a>一文中曾经提出会输出类似于 <code>$0 = 5</code>，并指出<strong>$0是当前的输出值</strong>。这个说话其实是不严谨的，正确的说法是，应该是<strong>当前的haha的值5存在了R0寄存器里。</strong></p>
<p>比如，当我们构建如下的程序语句时，</p>
<pre><code><span class="keyword">let</span> haha = <span class="number">5</span>;
<span class="keyword">let</span> <span class="keyword">object</span> = <span class="string">"jkjksdjf"</span>;
</code></pre><p>我们在分别<code>print haha</code>以及    <code>print object</code>就会分别得到<code>(Int) $R0 = 5</code>和<code>(String) $R1 = &quot;jkjksdjf&quot;</code></p>
<p>这说明haha的值和object的值分别以int型和string型存在了R0和R1寄存器之中。</p>
<p><strong>当然，图快速的话</strong>，可以像我上面一样将print简写成p。</p>
<p>3.<code>po</code><br>输出变量值  </p>
<p>哎，有人奇怪了，po也是输出变量值，那和p有啥区别啊？本质上没啥区别，如果真要说，就是<strong>po = e -O –</strong>，具体我们后续再说啦。</p>
<p>4.<code>breakpoubt l</code> 输出所有的断点，可以得到如下的结果</p>
<pre><code>Current breakpoints:
<span class="number">1</span>: file = <span class="string">'xxx/ViewController.swift'</span>, line = <span class="number">19</span>, locations = <span class="number">1</span>, resolved = <span class="number">1</span>, hit count = <span class="number">1</span>

<span class="number">1.1</span>: where = xxx<span class="class">.ViewController</span><span class="class">.viewDidLoad</span> (xxx.ViewController)() -&gt; () + <span class="number">131</span> at ViewController<span class="class">.swift</span>:<span class="number">19</span>, <span class="tag">address</span> = <span class="number">0</span>x0000000108d0a443, resolved, hit count = <span class="number">1</span> 
</code></pre><p>其中 <strong>1: file</strong>的这个1就是ID号。<br>那这里的1.1是什么鬼？<strong>嘿嘿，当里使用Symbolic Breakpoint的时候，你一个断点很有可能截获了多个地方，比如AViewController和BViewController的viewDidLoad都被加上了断点，这个时候就需要靠诸如1.1和1.2之类的细分ID来进行区别了。</strong></p>
<p>当然，有人会问，输出这个断点有什么用啊。嘿嘿，当你使用<strong>Xcode Symbolic Breakpoint</strong>的时候，你就会发现究竟在多少个地方下了断点了。</p>
<p><strong>同样的</strong>，你可以将breakpoint简写成br。</p>
<p>5.<code>br delete ID</code> 这里的ID就是之前的断点的ID号<br>通过这个命令，可以删除ID对应的断点</p>
<p>6.<code>br e ID</code> 启用一个ID号对应的断点</p>
<p>7.<code>br di ID</code> 禁用一个ID号对应的断点</p>
<p>8.<code>b xxx.swift:lineY</code> 在xxx文件的第lineY行设置一个断点<br>如 <code>b ViewController.swift:10</code> 就是在ViewController的第10号下了一个断点。</p>
<p><strong>需要注意的是，</strong>通过b命令设置的断点，无法直观的在Xcode界面上显示出来，而<code>br delete</code>删除一个断点可以直接在Xcode上看出效果。</p>
<p>9.<code>br set -n functionName</code> 对functionName设置Symbolic Breakpoint<br>如<code>br set -n viewDidLoad</code> 就是对所有的viewDidLoad设置了Symboloc Breakpoint</p>
<p>10.<code>br mod -C &quot;Condition&quot; ID</code> 对ID号对应的breakpoint添加条件触发<br>假设我们有下面这样的一段代码</p>
<pre><code><span class="number">1.</span> <span class="comment">//ViewController.swift</span>
<span class="number">2.</span> <span class="keyword">for</span> var value in money {
<span class="number">3.</span>     totalValue += value
<span class="number">4.</span> }
</code></pre><p>我们首先先使用<code>b ViewController.swift:3</code>设置一个断点，然后使用<code>br l</code>查询到对应的ID为3。<br>然后我们使用<code>br mod -C &quot;totalValue &gt; 50&quot; 3</code>对这个断点设置条件触发，条件为<strong>当totalValue 大于50时候才触发</strong>。</p>
<p>当然，可能有些人会问，如果我不想删除断点，只是想移除条件触发怎么办？很简单，只要输入<code>br mod -C &quot;&quot; ID</code>，将其中的Condition部分设置为空即可。</p>
<p>11.<code>continue</code> 继续运行程序<br>12.<code>n</code>        step over单步调试<br>13.<code>s</code>        step in进行函数<br>14.<code>finish</code>   step out退出函数</p>
<h3 id="大杀器">大杀器</h3><p>上面的命令是不是很多，一个个敲实在是太麻烦，那如果我想对一个断点执行多条语句怎么办？<br>嘿嘿，大杀器来了。</p>
<p><code>br com add ID</code> 对ID对应的断点进入交互式指定。如：</p>
<pre><code><span class="keyword">br</span> <span class="keyword">com</span> <span class="built_in">add</span> <span class="number">2</span>
&gt; bt
&gt; <span class="keyword">continue</span>
&gt; DONE
</code></pre><p> 上面的语句指的是，对2号断点进行交互式指定，当这个断点触发的时候，首先执行<code>bt</code>(具体bt命令的意思我们后续再说，粗略理解就是backtrace输出调用栈，可以简单看下面的例子)，然后执行<code>continue</code>，最后通过关键字<strong>Done</strong>退出指定，这里的Done类似于shell里面的exit。</p>
<pre><code>frame <span class="preprocessor">#<span class="number">0</span>: xxx`xxx.ViewController.viewDidLoad (self=<span class="number">0x00007faf52439c20</span>)() -&gt; () + <span class="number">470</span> at ViewController.swift:<span class="number">27</span></span>
frame <span class="preprocessor">#<span class="number">1</span>: xxx`@objc xxx.ViewController.viewDidLoad (xxx.ViewController)() -&gt; () + <span class="number">34</span> at ViewController.swift:<span class="number">0</span></span>
frame <span class="preprocessor">#<span class="number">2</span>: UIKit`-[UIViewController loadViewIfRequired] + <span class="number">1198</span></span>
frame <span class="preprocessor">#<span class="number">3</span>: UIKit`-[UIViewController view] + <span class="number">27</span></span>
frame <span class="preprocessor">#<span class="number">4</span>: UIKit`-[UIWindow addRootViewControllerViewIfPossible] + <span class="number">61</span></span>
frame <span class="preprocessor">#<span class="number">5</span>: UIKit`-[UIWindow _setHidden:forced:] + <span class="number">282</span></span>
frame <span class="preprocessor">#<span class="number">6</span>: UIKit`-[UIWindow makeKeyAndVisible] + <span class="number">42</span></span>
frame <span class="preprocessor">#<span class="number">7</span>: UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + <span class="number">4131</span></span>
frame <span class="preprocessor">#<span class="number">8</span>: UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + <span class="number">1760</span></span>
frame <span class="preprocessor">#<span class="number">9</span>: UIKit`-[UIApplication workspaceDidEndTransaction:] + <span class="number">188</span></span>
frame <span class="preprocessor">#<span class="number">10</span>: FrontBoardServices`-[FBSSerialQueue _performNext] + <span class="number">192</span></span>
frame <span class="preprocessor">#<span class="number">11</span>: FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + <span class="number">45</span></span>
frame <span class="preprocessor">#<span class="number">12</span>: CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + <span class="number">17</span></span>
frame <span class="preprocessor">#<span class="number">13</span>: CoreFoundation`__CFRunLoopDoSources0 + <span class="number">556</span></span>
frame <span class="preprocessor">#<span class="number">14</span>: CoreFoundation`__CFRunLoopRun + <span class="number">867</span></span>
frame <span class="preprocessor">#<span class="number">15</span>: CoreFoundation`CFRunLoopRunSpecific + <span class="number">488</span></span>
frame <span class="preprocessor">#<span class="number">16</span>: UIKit`-[UIApplication _run] + <span class="number">402</span></span>
frame <span class="preprocessor">#<span class="number">17</span>: UIKit`UIApplicationMain + <span class="number">171</span></span>
frame <span class="preprocessor">#<span class="number">18</span>: xxx`main + <span class="number">109</span> at AppDelegate.swift:<span class="number">12</span></span>
frame <span class="preprocessor">#<span class="number">19</span>: libdyld.dylib`start + <span class="number">1</span></span>
frame <span class="preprocessor">#<span class="number">20</span>: libdyld.dylib`start + <span class="number">1</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这周开始好好钻研一下LLDB相关的知识，这是一系列的文章。有些初级知识可能大家都有所涉猎，嘿嘿，懂得自然懂，看我的博客，什么时候会收获小。</p>
<h3 id="基础语法">基础语法</h3><p>1.<code>help</code> 有啥不会，就直接输入help，你会]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TBAnnotationClustering源码解析]]></title>
    <link href="http://satanwoo.github.io/2015/12/11/TBAnnotationClustering/"/>
    <id>http://satanwoo.github.io/2015/12/11/TBAnnotationClustering/</id>
    <published>2015-12-10T16:56:04.000Z</published>
    <updated>2015-12-11T09:38:46.000Z</updated>
    <content type="html"><![CDATA[<p>毕设这两天飞一般的加速，终于可以写写源码解析了，嘿嘿，这周读两个跟性能相关的源码，首先是一个跟地图相关的，今天来看看一个数据结构在iOS开发中的妙用。</p>
<h3 id="TBAnnotationClustering">TBAnnotationClustering</h3><p>我们都知道，MapView的实现机制其实和UITableView类似，首先他们都是基于UIScrollView支持滑动的，此外，他们都采用了循环服用的机制了来保持内存的开销。</p>
<p><strong>但是</strong>，两者之间有个很大的区别就是数量级的差距，UITableView就算充满整个屏幕，充其量也就是10多个同时可见的VisibleCell，因此就多维护一个大小是VisibleCells数量 ＋ 2的这样一个循环队列，进行复用。但是MapView就不一样了，地图上同时展示一段范围内几千个Point of Interest是非常有可能的，这一下子的内存开销和性能卡顿就非常不得了，因此我们需要一种合理的手段来避免，这就是我们今天要讲解的TBAnnotationClustering的由来。</p>
<p><a href="https://github.com/thoughtbot/TBAnnotationClustering" target="_blank" rel="external">Github地址</a></p>
<h3 id="Level_of_Detail">Level of Detail</h3><p>首先，让我们先介绍一下相关背景知识。</p>
<p>根据图像渲染的理论我们可以知道，人的视野存在焦点区域和盲点区域，总是更倾向于关注处于视线左上角到视线中心部分的。因此，在现实应用中，如游戏场景，当场景需要展现的模型距离视线焦点非常近时，就采用高精度的模型来进行展示；而到模型处于较远位置时，比如体育游戏的场外观众，就可以采用低精度模型进行替换，减少渲染时候的计算量；而到模型所处位置基本可以考虑成为背景时，则会采用基本图元进行展示。通过这种方法，即保证了场景的真实观感，同时又大大减少了不必要的计算量。这也就是通常计算机图形学领域所谓的Level Of Detail技术。</p>
<h3 id="QuadTree">QuadTree</h3><p>QuadTree可能很多人会比较陌生，但是一提到他的哥哥 － 二叉树，想必大家不会陌生，所以QuadTree又被称为四叉树，关于四叉树的定义，</p>
<blockquote><br>A quadtree is a tree data structure in which each internal node has exactly four children.<br></blockquote>

<p>四叉树被广泛的运用于空间划分。通过将空间递归划分不同层次的子结构，可以达到较高的空间数据插入和查询效果。</p>
<p>下面就是一张比较经典的四叉树构造，首先先将一个大空间划分为四个字空间 a b c d。然后根据每一个子空间内的节点个数再进行细分。<strong>这里要强调一点，四叉树的细分没有具体要求，你可以按你的需求划分成每个节点能只包含一个，也可以根据平衡减少划分次数。</strong></p>
<p><img src="http://img.blog.csdn.net/20131005154434687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvdXh1Z3VhbmcyMzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h3 id="TBAnnotationClustering源码讲解">TBAnnotationClustering源码讲解</h3><p>打开这个项目，粗略过一下项目结构，大致需要关注的代码如下：</p>
<ul>
<li>TBQuadTree.h/.m</li>
<li>TBCoordinateQuadTree.h/.m</li>
</ul>
<p>让我们一个个来分析</p>
<h4 id="TBQuadTree">TBQuadTree</h4><p>毫无疑问，从文件名称来看，我们就知道，这个类就代表基础的四叉树数据结构，首先让我们来看看数据结构的定义</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBQuadTreeNodeData</span> </span>{
    <span class="built_in">double</span> x;
    <span class="built_in">double</span> y;
    <span class="keyword">void</span>* data;
} TBQuadTreeNodeData;
TBQuadTreeNodeData TBQuadTreeNodeDataMake(<span class="built_in">double</span> x, <span class="built_in">double</span> y, <span class="keyword">void</span>* data);
</code></pre><p>这个毫无疑问，就是代表的坐标系的<strong>数据节点</strong>。 (x, y)表征坐标点，void *data自由的指向附加的数据。</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBBoundingBox</span> </span>{
    <span class="built_in">double</span> x0; <span class="built_in">double</span> y0;
    <span class="built_in">double</span> xf; <span class="built_in">double</span> yf;
} TBBoundingBox;
TBBoundingBox TBBoundingBoxMake(<span class="built_in">double</span> x0, <span class="built_in">double</span> y0, <span class="built_in">double</span> xf, <span class="built_in">double</span> yf);
</code></pre><p>这个同样很简单，用两个对角点限定了一个长方形区域，也就是一个四叉树的节点究竟包含哪些范围。</p>
<pre><code><span class="label">typedef</span> <span class="keyword">struct </span>quadTreeNode {
    <span class="keyword">struct </span>quadTreeNode* northWest<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* northEast<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* southWest<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* southEast<span class="comment">;</span>
    <span class="keyword">TBBoundingBox </span><span class="keyword">boundingBox;
</span>    int <span class="keyword">bucketCapacity;
</span>    TBQuadTreeNodeData *points<span class="comment">;</span>
    int count<span class="comment">;</span>
} TBQuadTreeNode<span class="comment">;</span>
<span class="label">TBQuadTreeNode</span>* TBQuadTreeNodeMake(<span class="keyword">TBBoundingBox </span><span class="keyword">boundary, </span>int <span class="keyword">bucketCapacity);</span>
</code></pre><p>这个稍微复杂点，是四叉树的树节点，其中</p>
<ul>
<li>northWest, northEast, southWest, southEast分别代表四叉树的四个子细分区域。</li>
<li>bondingBox代表的当前这个树节点的涵盖区域。</li>
<li>bucketCapacity表示这个树节点最大容纳的数据节点个数</li>
<li>points 数据节点数组</li>
<li>count 当前包含了数据节点。</li>
</ul>
<p><strong>再次强调，千万不要把树节点和数据节点搞混。树节点指的是四叉树上的数据结构，每个树节点最多有四个子树节点，但是可以有bucketCapacity大小的数据节点，数据节点仅仅是用来封装坐标系和其相关的数据的一个数据结构，非四叉树特有。</strong></p>
<p>看完了数据定义，我们再来看看其实现部分。</p>
<pre><code><span class="preprocessor">#<span class="keyword">pragma</span> mark - Constructors</span>

<span class="function">TBQuadTreeNodeData <span class="title">TBQuadTreeNodeDataMake</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">void</span>* data)</span>
</span>{
    TBQuadTreeNodeData d; d.x = x; d.y = y; d.data = data;
    <span class="keyword">return</span> d;
}

<span class="function">TBBoundingBox <span class="title">TBBoundingBoxMake</span><span class="params">(<span class="keyword">double</span> x0, <span class="keyword">double</span> y0, <span class="keyword">double</span> xf, <span class="keyword">double</span> yf)</span>
</span>{
    TBBoundingBox bb; bb.x0 = x0; bb.y0 = y0; bb.xf = xf; bb.yf = yf;
    <span class="keyword">return</span> bb;
}

<span class="function">TBQuadTreeNode* <span class="title">TBQuadTreeNodeMake</span><span class="params">(TBBoundingBox boundary, <span class="keyword">int</span> bucketCapacity)</span>
</span>{
    TBQuadTreeNode* node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBQuadTreeNode));
    node-&gt;northWest = <span class="literal">NULL</span>;
    node-&gt;northEast = <span class="literal">NULL</span>;
    node-&gt;southWest = <span class="literal">NULL</span>;
    node-&gt;southEast = <span class="literal">NULL</span>;

    node-&gt;boundingBox = boundary;
    node-&gt;bucketCapacity = bucketCapacity;
    node-&gt;count = <span class="number">0</span>;
    node-&gt;points = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBQuadTreeNodeData) * bucketCapacity);

    <span class="keyword">return</span> node;
}
</code></pre><p>这三个构造函数，分别是构造<span style="color:red">数据节点</span>、长方形以及<span style="color:blue">四叉树节点</span>，默认情况下四叉树的节点<strong>并非满构造</strong>，而是初始化为空，根据需要插入新节点。</p>
<pre><code><span class="label">#pragma</span> <span class="keyword">mark </span>- <span class="keyword">Bounding </span><span class="keyword">Box </span>Functions

<span class="keyword">bool </span><span class="keyword">TBBoundingBoxContainsData(TBBoundingBox </span><span class="keyword">box, </span>TBQuadTreeNodeData <span class="preprocessor">data</span>)
{
    <span class="keyword">bool </span>containsX = <span class="keyword">box.x0 </span>&lt;= <span class="preprocessor">data</span>.x &amp;&amp; <span class="preprocessor">data</span>.x &lt;= <span class="keyword">box.xf;
</span>    <span class="keyword">bool </span>containsY = <span class="keyword">box.y0 </span>&lt;= <span class="preprocessor">data</span>.y &amp;&amp; <span class="preprocessor">data</span>.y &lt;= <span class="keyword">box.yf;
</span>
    return containsX &amp;&amp; containsY<span class="comment">;</span>
}

<span class="keyword">bool </span><span class="keyword">TBBoundingBoxIntersectsBoundingBox(TBBoundingBox </span><span class="keyword">b1, </span><span class="keyword">TBBoundingBox </span><span class="keyword">b2)
</span>{
    return (<span class="keyword">b1.x0 </span>&lt;= <span class="keyword">b2.xf </span>&amp;&amp; <span class="keyword">b1.xf </span>&gt;= <span class="keyword">b2.x0 </span>&amp;&amp; <span class="keyword">b1.y0 </span>&lt;= <span class="keyword">b2.yf </span>&amp;&amp; <span class="keyword">b1.yf </span>&gt;= <span class="keyword">b2.y0);
</span>}
</code></pre><p>随后就是上面两个判断长方形包含和相交的方法了，包含自然是整个包围。而相交的补集是不相交，即在横坐标上一个长方形的xf另一个长方形的x0抑或是一个长方形的x0完全大于另一个长方形的xf，当然在y轴上也是同理，因此通过补集很容易就理解TBBoundingBoxIntersectsBoundingBox的实现了。</p>
<p>然后来看看非常重要的几个函数，首先是<strong>TBQuadTreeNodeSubdivide</strong></p>
<pre><code><span class="label">void</span> TBQuadTreeNodeSubdivide(TBQuadTreeNode* node)
{
    <span class="keyword">TBBoundingBox </span><span class="keyword">box </span>= node-&gt;<span class="keyword">boundingBox;
</span>
    double xMid = (<span class="keyword">box.xf </span>+ <span class="keyword">box.x0) </span>/ <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span>
    double yMid = (<span class="keyword">box.yf </span>+ <span class="keyword">box.y0) </span>/ <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span>

    <span class="keyword">TBBoundingBox </span>northWest = <span class="keyword">TBBoundingBoxMake(box.x0, </span><span class="keyword">box.y0, </span>xMid, yMid)<span class="comment">;</span>
    node-&gt;northWest = TBQuadTreeNodeMake(northWest, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>northEast = <span class="keyword">TBBoundingBoxMake(xMid, </span><span class="keyword">box.y0, </span><span class="keyword">box.xf, </span>yMid)<span class="comment">;</span>
    node-&gt;northEast = TBQuadTreeNodeMake(northEast, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>southWest = <span class="keyword">TBBoundingBoxMake(box.x0, </span>yMid, xMid, <span class="keyword">box.yf);
</span>    node-&gt;southWest = TBQuadTreeNodeMake(southWest, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>southEast = <span class="keyword">TBBoundingBoxMake(xMid, </span>yMid, <span class="keyword">box.xf, </span><span class="keyword">box.yf);
</span>    node-&gt;southEast = TBQuadTreeNodeMake(southEast, node-&gt;<span class="keyword">bucketCapacity);
</span>}
</code></pre><p>这个函数负责将四叉树节点进行细分。首先获取当前节点负责的长方形区域的中点，然后根据中点到原有长方形的四个顶点，分成四个象限，进行划分。<strong>这个时候请注意</strong>，还只是进行四叉树节点的细分，还没重新更改数据节点的分布。</p>
<pre><code><span class="keyword">bool</span> TBQuadTreeNodeInsertData(TBQuadTreeNode* node, TBQuadTreeNodeData data)
{
    <span class="keyword">if</span> (!TBBoundingBoxContainsData(node-&gt;boundingBox, data)) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">if</span> (node-&gt;count &lt; node-&gt;bucketCapacity) {
        node-&gt;points[node-&gt;count++] = data;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (node-&gt;northWest == <span class="keyword">NULL</span>) {
        TBQuadTreeNodeSubdivide(node);
    }

    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;northWest, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;northEast, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;southWest, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;southEast, data)) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>这个函数则是真正的将数据插入到节点中。</p>
<ul>
<li>首先先判断这个数据是否落在该长方形中，不是直接滚蛋。</li>
<li>如果当前包含的数据节点个数没有超过最大数目，直接应用在其中。</li>
<li>如果四个子节点为空，就先创建</li>
<li>然后再递归插入</li>
</ul>
<pre><code><span class="type">void</span> <span class="type">TBQuadTreeGatherDataInRange</span>(<span class="type">TBQuadTreeNode</span>* node, <span class="type">TBBoundingBox</span> <span class="type">range</span>, <span class="type">TBDataReturnBlock</span> <span class="keyword">block</span>)
{
    <span class="keyword">if</span> (!<span class="type">TBBoundingBoxIntersectsBoundingBox</span>(node-&gt;boundingBox, <span class="type">range</span>)) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;count; i++) {
        <span class="keyword">if</span> (<span class="type">TBBoundingBoxContainsData</span>(<span class="type">range</span>, node-&gt;points[i])) {
            <span class="keyword">block</span>(node-&gt;points[i]);
        }
    }

    <span class="keyword">if</span> (node-&gt;northWest == <span class="type">NULL</span>) {
        <span class="keyword">return</span>;
    }

    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;northWest, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;northEast, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;southWest, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;southEast, <span class="type">range</span>, <span class="keyword">block</span>);
}
</code></pre><p>这个就是通过DFS进行节点的遍历，一旦有落在range内的数据节点，就进行回调。</p>
<p><strong>综上所述，就是一个基本的四叉树，可以很明显的看到，在四叉树的构建、遍历中，都用了树的递归，也就是俗称的DFS算法。</strong></p>
<h4 id="TBCoordinateQuadTree">TBCoordinateQuadTree</h4><p>这个类呢，和实质上的四叉树或者性能优化并无太大关系，只是一层简单的封装，我们大致来了解一下就好。</p>
<pre><code><span class="keyword">TBBoundingBox </span><span class="keyword">TBBoundingBoxForMapRect(MKMapRect </span>mapRect)
{
    CLLocationCoordinate2D topLeft = MKCoordinateForMapPoint(mapRect.origin)<span class="comment">;</span>
    CLLocationCoordinate2D <span class="keyword">botRight </span>= MKCoordinateForMapPoint(MKMapPointMake(MKMapRectGetMaxX(mapRect), MKMapRectGetMaxY(mapRect)))<span class="comment">;</span>

    CLLocationDegrees minLat = <span class="keyword">botRight.latitude;
</span>    CLLocationDegrees maxLat = topLeft.latitude<span class="comment">;</span>

    CLLocationDegrees minLon = topLeft.longitude<span class="comment">;</span>
    CLLocationDegrees maxLon = <span class="keyword">botRight.longitude;
</span>
    return <span class="keyword">TBBoundingBoxMake(minLat, </span>minLon, maxLat, maxLon)<span class="comment">;</span>
}

<span class="label">MKMapRect</span> TBMapRectForBoundingBox(<span class="keyword">TBBoundingBox </span><span class="keyword">boundingBox)
</span>{
    MKMapPoint topLeft = MKMapPointForCoordinate(CLLocationCoordinate2DMake(<span class="keyword">boundingBox.x0, </span><span class="keyword">boundingBox.y0));
</span>    MKMapPoint <span class="keyword">botRight </span>= MKMapPointForCoordinate(CLLocationCoordinate2DMake(<span class="keyword">boundingBox.xf, </span><span class="keyword">boundingBox.yf));
</span>
    return MKMapRectMake(topLeft.x, <span class="keyword">botRight.y, </span>fabs(<span class="keyword">botRight.x </span>- topLeft.x), fabs(<span class="keyword">botRight.y </span>- topLeft.y))<span class="comment">;</span>
}
</code></pre><p>这两个函数就是MKMapRect和我们的BoundingBox之间的转换，难度很小，但是很有意思啊。从中我们可以一窥MapView的一些实现。比如MapView不仅仅是传统的ContentView和ContainerView，更重要的其坐标系和传统的CGRect之间的无法换算，<strong>简而言之，就是，在MapView中，所有的东西都要拿经度纬度来谈。</strong></p>
<pre><code>- (<span class="built_in">NSArray</span> *)clusteredAnnotationsWithinMapRect:(<span class="built_in">MKMapRect</span>)rect withZoomScale:(<span class="keyword">double</span>)zoomScale
{
     <span class="comment">// 1.</span>
    <span class="keyword">double</span> TBCellSize = TBCellSizeForZoomScale(zoomScale);
    <span class="keyword">double</span> scaleFactor = zoomScale / TBCellSize;

     <span class="comment">// 2.</span>
    <span class="built_in">NSInteger</span> minX = floor(<span class="built_in">MKMapRectGetMinX</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> maxX = floor(<span class="built_in">MKMapRectGetMaxX</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> minY = floor(<span class="built_in">MKMapRectGetMinY</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> maxY = floor(<span class="built_in">MKMapRectGetMaxY</span>(rect) * scaleFactor);

    <span class="built_in">NSMutableArray</span> *clusteredAnnotations = [[<span class="built_in">NSMutableArray</span> alloc] init];
    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> x = minX; x &lt;= maxX; x++) {
        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> y = minY; y &lt;= maxY; y++) {
            <span class="built_in">MKMapRect</span> mapRect = <span class="built_in">MKMapRectMake</span>(x / scaleFactor, y / scaleFactor, <span class="number">1.0</span> / scaleFactor, <span class="number">1.0</span> / scaleFactor);

            __block <span class="keyword">double</span> totalX = <span class="number">0</span>;
            __block <span class="keyword">double</span> totalY = <span class="number">0</span>;
            __block <span class="keyword">int</span> count = <span class="number">0</span>;

            <span class="built_in">NSMutableArray</span> *names = [[<span class="built_in">NSMutableArray</span> alloc] init];
            <span class="built_in">NSMutableArray</span> *phoneNumbers = [[<span class="built_in">NSMutableArray</span> alloc] init];

              <span class="comment">// 3.</span>
            TBQuadTreeGatherDataInRange(<span class="keyword">self</span><span class="variable">.root</span>, TBBoundingBoxForMapRect(mapRect), ^(TBQuadTreeNodeData data) {
                totalX += data<span class="variable">.x</span>;
                totalY += data<span class="variable">.y</span>;
                count++;

                TBHotelInfo hotelInfo = *(TBHotelInfo *)data<span class="variable">.data</span>;
                [names addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, hotelInfo<span class="variable">.hotelName</span>]];
                [phoneNumbers addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, hotelInfo<span class="variable">.hotelPhoneNumber</span>]];
            });

              <span class="comment">// 4.</span>
            <span class="keyword">if</span> (count == <span class="number">1</span>) {
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX, totalY);
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count];
                annotation<span class="variable">.title</span> = [names lastObject];
                annotation<span class="variable">.subtitle</span> = [phoneNumbers lastObject];
                [clusteredAnnotations addObject:annotation];
            }

           <span class="comment">// 5.</span>
            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) {
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX / count, totalY / count);
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count];
                [clusteredAnnotations addObject:annotation];
            }
        }
    }

    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:clusteredAnnotations];
}
</code></pre><p>而上述的最后一个函数，就是根据传入的MKMapRect，返回簇类数组的。</p>
<ul>
<li>1.首先根据放缩比例，或者Cell大小。</li>
<li>2.根据cell大小计算当前地图区域的范围所对应的minX - maxX，minY - maxY对应的网格。</li>
</ul>
<p>什么是网格？就是根据Cell大小将地图划分成了一块块区域，通过minX， maxX, minY - maxY找到对应的网格。类似于array[1][2]找到第二行第三列的网格（从0开始索引）。</p>
<ul>
<li>3.遍历每一个网格，获取当前网格对应的四叉树节点中的数据信息，并记录个数。</li>
<li>4.如果个数是1，那么直接显示，包含数据节点的附加信息，比如在这里就是酒店名称和酒店电话。</li>
<li>5.如果个数大于1的话，利用均值计算中心点，中心点是所有包含的数据节点平均值，同时信息只简单的显示个数。</li>
</ul>
<p>至此，整个代码就解读完整啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毕设这两天飞一般的加速，终于可以写写源码解析了，嘿嘿，这周读两个跟性能相关的源码，首先是一个跟地图相关的，今天来看看一个数据结构在iOS开发中的妙用。</p>
<h3 id="TBAnnotationClustering">TBAnnotationClustering</h]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FDFullScreenPopGesture源码解析]]></title>
    <link href="http://satanwoo.github.io/2015/11/26/FDFullScreenPopGesture-Source-Code/"/>
    <id>http://satanwoo.github.io/2015/11/26/FDFullScreenPopGesture-Source-Code/</id>
    <published>2015-11-26T03:38:42.000Z</published>
    <updated>2015-11-26T18:24:34.000Z</updated>
    <content type="html"><![CDATA[<p><em>嘿嘿，花了三天时间把自己的代码从700行缩减成了200行，终于有时间可以拜读新源码了，好开心。</em></p>
<p>好了，废话不多话，今天我们要读了百度出品的一个开源项目FDFullScreenPopGesture。</p>
<h2 id="项目介绍">项目介绍</h2><p><a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="external">FDFullScreenPopGesture</a>是一款无需改动即可整合进入现有项目的全局手势操作，使用这个即可以在左侧边缘拖拽的时候返回上一级的效果。</p>
<p>看到这，有人会问，我们这个直接用UIPanGestureRecognizer不也能达到吗？<br>没错，仅仅是返回上一级这个需求确实很简单。但是iOS7上返回上一级时候，UINavigationBar的切换效果你能实现吗？</p>
<p>而且，我要说的重点是<strong>FDFullscreenPopGesture</strong>实现思路很赞！！！</p>
<h2 id="源码分析">源码分析</h2><h3 id="结构分析">结构分析</h3><p>整个FDFullscreenPopGesture其实可以主要拆分成三块：</p>
<pre><code>-<span class="ruby">- _FDFullscreenPopGestureRecognizerDelegate
</span>-<span class="ruby">- <span class="constant">UIViewController</span> (<span class="constant">FDFullscreenPopGesturePrivate</span>)
</span>-<span class="ruby">- <span class="constant">UINavigationController</span> (<span class="constant">FDFullscreenPopGesture</span>)</span>
</code></pre><ul>
<li><p>_FDFullscreenPopGestureRecognizerDelegate虽然名字看起来像一个Protocol，但是它实质上是一个<strong>NSObject</strong>子类，同时实现了<strong>UIGestureRecognizerDelegate</strong>。这么做的好处是什么呢？不知道大家有没有经历过ViewController重构，以前很多时候，比如我们写UIScrollView，UITableView，他们的Delegate，DataSource都耦合进了ViewController，常常导致MassViewController灾难的发生。<strong>单独构建一个专门负责的Delgeate“处理器”是非常有效的手段</strong></p>
</li>
<li><p>UIViewController (FDFullscreenPopGesturePrivate)是一个Category，我们在这个分类里面主要进行<strong>viewWillAppear</strong>的Hook，具体做什么，后面章节我们细细道来。</p>
</li>
<li><p>UINavigationController (FDFullscreenPopGesture)也是一个分类，是进行<strong>pushViewController:animated:</strong>方法的hook，实现部分我们后续再看。</p>
</li>
</ul>
<h3 id="源码分析-1">源码分析</h3><h4 id="_FDFullscreenPopGestureRecognizerDelegate">_FDFullscreenPopGestureRecognizerDelegate</h4><pre><code>- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer
{
    <span class="comment">// 1.</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.count</span> &lt;= <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 2.</span>
    <span class="built_in">UIViewController</span> *topViewController = <span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.lastObject</span>;
    <span class="keyword">if</span> (topViewController<span class="variable">.fd_interactivePopDisabled</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 3. </span>
    <span class="built_in">CGPoint</span> beginningLocation = [gestureRecognizer locationInView:gestureRecognizer<span class="variable">.view</span>];
    <span class="built_in">CGFloat</span> maxAllowedInitialDistance = topViewController<span class="variable">.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge</span>;
    <span class="keyword">if</span> (maxAllowedInitialDistance &gt; <span class="number">0</span> &amp;&amp; beginningLocation<span class="variable">.x</span> &gt; maxAllowedInitialDistance) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 4.</span>
    <span class="keyword">if</span> ([[<span class="keyword">self</span><span class="variable">.navigationController</span> valueForKey:<span class="string">@"_isTransitioning"</span>] boolValue]) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 5.</span>
    <span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer<span class="variable">.view</span>];
    <span class="keyword">if</span> (translation<span class="variable">.x</span> &lt;= <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>整个类特别精简，它的职责就是维护一个UINavigationController然后根据一系列的状态判断该手势是否生效。这些状态包括</p>
<ol>
<li>当前UINavigationController的栈是否只剩最后一个ViewController了</li>
<li>当前即将出栈的topViewController是否禁用了<strong>fd_interactivePopDisabled</strong>，该变量我们稍后会说</li>
<li>当前手势的启动点是不是离左侧边缘太远了，毕竟我们是要模拟iOS原生的手势操作，原生的不支持全屏，我们为啥要支持！</li>
<li>当前是否已经处在转场过程中。在这里，可以看到它使用了valueForKey这一<strong>Key-Value-Coding</strong>技术，它可以访问私有变量<strong>_isTransitioning</strong>哦！</li>
<li>方向相反的滑动滚粗。</li>
</ol>
<h4 id="UIViewController_(FDFullscreenPopGesturePrivate)">UIViewController (FDFullscreenPopGesturePrivate)</h4><p>整个这个类也非常简单，就是通过 <strong>fd_viewWillAppear</strong> hook了 <strong>viewWillAppear</strong> 这个方法，然后插入了自己一段回调的block。</p>
<pre><code>- (<span class="keyword">void</span>)fd_viewWillAppear:(<span class="built_in">BOOL</span>)animated
{
    <span class="comment">// Forward to primary implementation.</span>
    [<span class="keyword">self</span> fd_viewWillAppear:animated];

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.fd_willAppearInjectBlock</span>) {
        <span class="keyword">self</span><span class="variable">.fd_willAppearInjectBlock</span>(<span class="keyword">self</span>, animated);
    }
}
</code></pre><h4 id="UINavigationController_(FDFullscreenPopGesture)">UINavigationController (FDFullscreenPopGesture)</h4><p>这个分类是整个项目的逻辑控制核心。它干了这么几件事：</p>
<ul>
<li>用 <strong>fd_pushViewController:animated:</strong> hook <strong>pushViewController:animated:</strong></li>
<li><strong>禁用</strong>UINavgationController的<strong>interactivePopGestureRecognizer</strong></li>
<li>构建了属于自己UIPanGestureRecognizer替换interactivePopGestureRecognizer，同时把手势的delegate赋值给了_FDFullscreenPopGestureRecognizerDelegate</li>
</ul>
<p>它的主要核心代码如下：</p>
<pre><code>- (<span class="keyword">void</span>)fd_pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated
{
    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span><span class="variable">.gestureRecognizers</span> containsObject:<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span>]) {

        <span class="comment">// 1.</span>
        [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span> addGestureRecognizer:<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span>];

        <span class="comment">// 2.</span>
        <span class="built_in">NSArray</span> *internalTargets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKey:<span class="string">@"targets"</span>];
        <span class="keyword">id</span> internalTarget = [internalTargets<span class="variable">.firstObject</span> valueForKey:<span class="string">@"target"</span>];
        SEL internalAction = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);
        <span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.fd_popGestureRecognizerDelegate</span>;
        [<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span> addTarget:internalTarget action:internalAction];

        <span class="comment">// 3.</span>
        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;
    }

    <span class="comment">// 4.</span>
    [<span class="keyword">self</span> fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];

    <span class="comment">// Forward to primary implementation.</span>
    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.viewControllers</span> containsObject:viewController]) {
        [<span class="keyword">self</span> fd_pushViewController:viewController animated:animated];
    }
}
</code></pre><p>整体来看这段源码，无非做了如下这些事：</p>
<ol>
<li>将UIPanGestureRecognizer添加到本来interactivePopGestureRecognizer所在的view上</li>
<li><div style="color:red"><strong>这段是重点的重点</strong>，一定要往下看！！！</div><br>将PanGesture的target设置为<strong>internalTarget</strong>，action设置为<br><strong>handleNavigationTransition</strong>.</li>
<li>禁用interactivePopGestureRecognizer</li>
<li><p>根据是否需要隐藏UINavigationBar来调用fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController进行之前提到过的<strong>fdwillAppearInjectBlock</strong>设置，代码如下：</p>
<pre><code>- (void)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController
{
    <span class="preprocessor">if</span> (!<span class="keyword">self.fd_viewControllerBasedNavigationBarAppearanceEnabled) </span>{
        return<span class="comment">;</span>
    }

    __weak typeof(<span class="keyword">self) </span>weakSelf = <span class="keyword">self;
</span>    _FDViewControllerWillAppearInjectBlock <span class="keyword">block </span>= ^(UIViewController *viewController, <span class="keyword">BOOL </span>animated) {
        __strong typeof(weakSelf) <span class="keyword">strongSelf </span>= weakSelf<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongSelf) </span>{
            [<span class="keyword">strongSelf </span>setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated]<span class="comment">;</span>
        }
    }<span class="comment">;</span>

    // Setup will appear inject <span class="keyword">block </span>to appearing view controller.
    // Setup disappearing view controller as well, <span class="keyword">because </span>not every view controller is <span class="keyword">added </span>into
    // stack <span class="keyword">by </span><span class="keyword">pushing, </span>maybe <span class="keyword">by </span><span class="string">"-setViewControllers:"</span>.
    appearingViewController.fd_willAppearInjectBlock = <span class="keyword">block;
</span>    UIViewController *disappearingViewController = <span class="keyword">self.viewControllers.lastObject;
</span>    <span class="preprocessor">if</span> (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) {
        disappearingViewController.fd_willAppearInjectBlock = <span class="keyword">block;
</span>    }
}
</code></pre></li>
</ol>
<p>这段代码就是将即将消失和展现的ViewController在viewWillAppear设置了一个自定义UINavigationBar的回调，用以根据进入的方式来展现NaviagtionBar，而不会出现突兀的“镂空”。</p>
<p>到这，源码就结束了，可以回家收衣服喽！</p>
<h3 id="重点">重点</h3><p>源码是不是很简单？有什么好分析的呢？<br>如果你读到这，哈哈，恭喜啦，重点分析来啦。</p>
<p>首先感谢@J_雨的天才思路，大家可以阅读<a href="http://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画</a>这篇文章，真的很赞</p>
<p>之前我们在上文用红色标注了一段内容：</p>
<div style="color:red"><br>将PanGesture的target设置为<strong>internalTarget</strong>，action设置为<br><strong>handleNavigationTransition</strong>。</div>

<p>看起来很容易理解，可是大家有没有想过为什么action的名称是handleNavigationTransition呢？</p>
<p>首先我们先打印看看NavigationController的interactivePopGestureRecognizer究竟是个什么玩意？</p>
<pre><code>&lt;<span class="built_in">UIScreenEdgePanGestureRecognizer</span>: <span class="number">0x7fea78ec5950</span>; state = Possible; delaysTouchesBegan = <span class="literal">YES</span>; view = &lt;<span class="built_in">UILayoutContainerView</span> <span class="number">0x7fea78f77960</span>&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_<span class="built_in">UINavigationInteractiveTransition</span> <span class="number">0x7fea78c1c640</span>&gt;)&gt;
</code></pre><p>这是什么玩意？让我们分别来看看它答应出来的这些属性。</p>
<ol>
<li>state = Possible，很简单，就是一个UIGestureRecognizerState = UIGestureRecognizerStatePossible。</li>
<li>view = UILayoutContainerView，不太懂，暂时也没觉得有需要，不管他。</li>
<li>target =&lt;(action=handleNavigationTransition:, target=<_uinavigationinteractivetransition 0x7fea78c1c640="">)，这个看起来很有用，因为我们都知道，Gesture就是通过<strong>Target-Action</strong>的方式进行动作触发的。</_uinavigationinteractivetransition></li>
</ol>
<p>所以我们赶紧看看这个<strong>target</strong>是个啥玩意，使用如下命令：</p>
<pre><code><span class="collection">[self.navigationController.interactivePopGestureRecognizer valueForKey:@<span class="string">"target"</span>]</span><span class="comment">;</span>
</code></pre><p>卧槽，一运行，Crash了，报找不到这个Key。咋回事，难道我记错了KVC的用户，赶紧换成valueForKey:@”View”试试。</p>
<p>哎！没错啊！成功得到了如下输出：</p>
<pre><code>-<span class="string">[UILayoutContainerView objectAtIndexedSubscript:]</span>
</code></pre><p>那咋回事，看来必须祭出屠龙刀Runtime了，嘿嘿，Objective-C面前，一切私有变量都是纸老虎。</p>
<pre><code><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;
Ivar *var = class_copyIvarList([UIGestureRecognizer <span class="keyword">class</span>], &amp;count);
<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {
     Ivar _var = *(var + i);
     NSLog(@<span class="string">"%s"</span>, ivar_getTypeEncoding(_var));
     NSLog(@<span class="string">"%s"</span>, ivar_getName(_var));
}
</code></pre><p>输出太长了，我们找我们想看的，</p>
<pre><code><span class="number">2015</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">02</span>:<span class="number">10</span>:<span class="number">03.873</span> SamplePhotosApp[<span class="number">85305</span>:<span class="number">2664323</span>] _targets
<span class="number">2015</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">02</span>:<span class="number">10</span>:<span class="number">03.873</span> SamplePhotosApp[<span class="number">85305</span>:<span class="number">2664323</span>] @<span class="string">"NSMutableArray"</span>
</code></pre><p>卧槽，这丫叫_targets，好吧，赶紧改成valueForKey:@”targets”再试试。<br>哎，等等，不是_targets吗，怎么能用targets呢？</p>
<p><strong>咳咳，吴老师又要来讲课了！对于KVC来说，它的查找顺序是key -&gt; property -&gt; ivar，也就是说，它会先按照是否有targets这个名称的key，然后targets这个property，最后再找_targets这个ivar。</strong></p>
<p>通过输出log，我们可以发现_targets是个数组，维护了一个个自定义结构维护的target-action配对。</p>
<p>因此，我们现在只要找到这个自定义结构是啥，里面包含了啥就可以了是吧。</p>
<p><strong>当头一棒</strong>，很遗憾，苹果太阴了，直接重载了这个自定义结构的debugDescription，特喵的什么都看不到。</p>
<p>事情到了这咋办呢？其实我也没想到，还好上述的参考文章告诉了我们可以依靠断点，通过断点，我们发发现了该自定义结构叫<strong>UIGestureRecognizerTarget</strong>，我们通过KVC获取其target和action即可。</p>
<h3 id="补充：关于Method_Swizzling">补充：关于Method Swizzling</h3><pre><code><span class="keyword">Class</span> <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];

SEL originalSelector = @<span class="keyword">selector</span>(pushViewController:animated:);
SEL swizzledSelector = @<span class="keyword">selector</span>(fd_pushViewController:animated:);

<span class="function"><span class="keyword">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, originalSelector)</span>;</span>
<span class="function"><span class="keyword">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, swizzledSelector)</span>;</span>

BOOL success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
<span class="keyword">if</span> (success) <span class="comment">{
    class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
}</span> <span class="keyword">else</span> <span class="comment">{
    method_exchangeImplementations(originalMethod, swizzledMethod);
}</span>
</code></pre><p>有很多人都了解Method Swizzling，但是不知道为什么这里需要进行<strong>BOOL success = class_addMethod</strong>判断。</p>
<p>其主要原因就是如果直接通过method_exchangeImplementations来进行的话，可能子类里并没有originalSelector所代表的方法，你直接和父类进行了交换，这是我们不希望看到的。</p>
<p>因此通过addMethod来判断，如果加成功了，说明原先这个函数在子类中并不存在，我们现在添加了，只要再把swizzleSelector指向旧函数即可；而如果没成功，说明这个函数在子类中存在了，我们直接替换也不会影响父类。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>嘿嘿，花了三天时间把自己的代码从700行缩减成了200行，终于有时间可以拜读新源码了，好开心。</em></p>
<p>好了，废话不多话，今天我们要读了百度出品的一个开源项目FDFullScreenPopGesture。</p>
<h2 id="项目介绍">项目介绍]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
