<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://satanwoo.github.io/"/>
  <updated>2015-12-11T12:01:20.000Z</updated>
  <id>http://satanwoo.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[浅入浅出LLDB（1）]]></title>
    <link href="http://satanwoo.github.io/2015/12/11/LLDB-1/"/>
    <id>http://satanwoo.github.io/2015/12/11/LLDB-1/</id>
    <published>2015-12-11T08:50:04.000Z</published>
    <updated>2015-12-11T12:01:20.000Z</updated>
    <content type="html"><![CDATA[<p>这周开始好好钻研一下LLDB相关的知识，这是一系列的文章。有些初级知识可能大家都有所涉猎，嘿嘿，懂得自然懂，看我的博客，什么时候会收获小。</p>
<h3 id="基础语法">基础语法</h3><p>1.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#26377;&#21861;&#19981;&#20250;&#65292;&#23601;&#30452;&#25509;&#36755;&#20837;help&#65292;&#20320;&#20250;&#24471;&#21040;&#22914;&#19979;&#30340;&#19968;&#31995;&#21015;&#20449;&#24687;&#65292;&#10;&#10;&#9;command           -- A set of commands for managing or customizing the&#10;                       debugger commands.&#10;    disassemble       -- Disassemble bytes in the current function, or elsewhere&#10;                       in the executable program as specified by the user.&#10;&#10;2.```print</span><br></pre></td></tr></table></figure></p>
<p>输出变量值<br>比如，对于如下的程序语句 <figure class="highlight"><figcaption><span>haha = 5;``` 你只要在LLDB里面输入 ``` print haha``` 就可以得到如下输出结果。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#9;(lldb) p haha&#10;&#9;(Int) $R0 = 5&#10;&#9;&#10;**&#35831;&#27880;&#24847;**&#65292;&#22312;[&#19982;&#35843;&#35797;&#22120;&#20849;&#33310;- LLDB &#30340;&#21326;&#23572;&#20857;](http://objccn.io/issue-19-2/)&#19968;&#25991;&#20013;&#26366;&#32463;&#25552;&#20986;&#20250;&#36755;&#20986;&#31867;&#20284;&#20110; ```$0 = 5```&#65292;&#24182;&#25351;&#20986;**$0&#26159;&#24403;&#21069;&#30340;&#36755;&#20986;&#20540;**&#12290;&#36825;&#20010;&#35828;&#35805;&#20854;&#23454;&#26159;&#19981;&#20005;&#35880;&#30340;&#65292;&#27491;&#30830;&#30340;&#35828;&#27861;&#26159;&#65292;&#24212;&#35813;&#26159;**&#24403;&#21069;&#30340;haha&#30340;&#20540;5&#23384;&#22312;&#20102;R0&#23492;&#23384;&#22120;&#37324;&#12290;**&#10;&#10;&#27604;&#22914;&#65292;&#24403;&#25105;&#20204;&#26500;&#24314;&#22914;&#19979;&#30340;&#31243;&#24207;&#35821;&#21477;&#26102;&#65292;&#10;&#10;&#9;let haha = 5;&#10;&#9;let object = &#34;jkjksdjf&#34;;&#10;&#9;&#10;&#25105;&#20204;&#22312;&#20998;&#21035;``` print haha ```&#20197;&#21450;&#9;``` print object```&#23601;&#20250;&#20998;&#21035;&#24471;&#21040;&#10;```(Int) $R0 = 5```&#21644;```(String) $R1 = &#34;jkjksdjf&#34;</span><br></pre></td></tr></table></figure></p>
<p>这说明haha的值和object的值分别以int型和string型存在了R0和R1寄存器之中。</p>
<p><strong>当然，图快速的话</strong>，可以像我上面一样将print简写成p。</p>
<p>3.<code>po</code><br>输出变量值  </p>
<p>哎，有人奇怪了，po也是输出变量值，那和p有啥区别啊？本质上没啥区别，如果真要说，就是<strong>po = e -O –</strong>，具体我们后续再说啦。</p>
<p>4.<code>breakpoubt l</code> 输出所有的断点，可以得到如下的结果</p>
<pre><code>Current breakpoints:
<span class="number">1</span>: file = <span class="string">'xxx/ViewController.swift'</span>, line = <span class="number">19</span>, locations = <span class="number">1</span>, resolved = <span class="number">1</span>, hit count = <span class="number">1</span>

<span class="number">1.1</span>: where = xxx<span class="class">.ViewController</span><span class="class">.viewDidLoad</span> (xxx.ViewController)() -&gt; () + <span class="number">131</span> at ViewController<span class="class">.swift</span>:<span class="number">19</span>, <span class="tag">address</span> = <span class="number">0</span>x0000000108d0a443, resolved, hit count = <span class="number">1</span> 
</code></pre><p>其中 <strong>1: file</strong>的这个1就是ID号。<br>那这里的1.1是什么鬼？<strong>嘿嘿，当里使用Symbolic Breakpoint的时候，你一个断点很有可能截获了多个地方，比如AViewController和BViewController的viewDidLoad都被加上了断点，这个时候就需要靠诸如1.1和1.2之类的细分ID来进行区别了。</strong></p>
<p>当然，有人会问，输出这个断点有什么用啊。嘿嘿，当你使用<strong>Xcode Symbolic Breakpoint</strong>的时候，你就会发现究竟在多少个地方下了断点了。</p>
<p><strong>同样的</strong>，你可以将breakpoint简写成br。</p>
<p>5.<code>br delete ID</code> 这里的ID就是之前的断点的ID号<br>通过这个命令，可以删除ID对应的断点</p>
<p>6.<code>br e ID</code> 启用一个ID号对应的断点</p>
<p>7.<code>br di ID</code> 禁用一个ID号对应的断点</p>
<p>8.<code>b xxx.swift:lineY</code> 在xxx文件的第lineY行设置一个断点<br>如 <code>b ViewController.swift:10</code> 就是在ViewController的第10号下了一个断点。</p>
<p><strong>需要注意的是，</strong>通过b命令设置的断点，无法直观的在Xcode界面上显示出来，而<code>br delete</code>删除一个断点可以直接在Xcode上看出效果。</p>
<p>9.<code>br set -n functionName</code> 对functionName设置Symbolic Breakpoint<br>如<code>br set -n viewDidLoad</code> 就是对所有的viewDidLoad设置了Symboloc Breakpoint</p>
<p>10.<code>br mod -C &quot;Condition&quot; ID</code> 对ID号对应的breakpoint添加条件触发<br>假设我们有下面这样的一段代码</p>
<pre><code><span class="number">1.</span> <span class="comment">//ViewController.swift</span>
<span class="number">2.</span> <span class="keyword">for</span> var value in money {
<span class="number">3.</span>     totalValue += value
<span class="number">4.</span> }
</code></pre><p>我们首先先使用<code>b ViewController.swift:3</code>设置一个断点，然后使用<code>br l</code>查询到对应的ID为3。<br>然后我们使用<code>br mod -C &quot;totalValue &gt; 50&quot; 3</code>对这个断点设置条件触发，条件为<strong>当totalValue 大于50时候才触发</strong>。</p>
<p>当然，可能有些人会问，如果我不想删除断点，只是想移除条件触发怎么办？很简单，只要输入<code>br mod -C &quot;&quot; ID</code>，将其中的Condition部分设置为空即可。</p>
<p>11.<code>continue</code> 继续运行程序<br>12.<code>n</code>        step over单步调试<br>13.<code>s</code>        step in进行函数<br>14.<code>finish</code>   step out退出函数</p>
<h3 id="大杀器">大杀器</h3><p>上面的命令是不是很多，一个个敲实在是太麻烦，那如果我想对一个断点执行多条语句怎么办？<br>嘿嘿，大杀器来了。</p>
<p><code>br com add ID</code> 对ID对应的断点进入交互式指定。如：</p>
<pre><code><span class="keyword">br</span> <span class="keyword">com</span> <span class="built_in">add</span> <span class="number">2</span>
&gt; bt
&gt; <span class="keyword">continue</span>
&gt; DONE
</code></pre><p> 上面的语句指的是，对2号断点进行交互式指定，当这个断点触发的时候，首先执行<code>bt</code>(具体bt命令的意思我们后续再说，粗略理解就是backtrace输出调用栈，可以简单看下面的例子)，然后执行<code>continue</code>，最后通过关键字<strong>Done</strong>退出指定，这里的Done类似于shell里面的exit。</p>
<pre><code>frame <span class="preprocessor">#<span class="number">0</span>: xxx`xxx.ViewController.viewDidLoad (self=<span class="number">0x00007faf52439c20</span>)() -&gt; () + <span class="number">470</span> at ViewController.swift:<span class="number">27</span></span>
frame <span class="preprocessor">#<span class="number">1</span>: xxx`@objc xxx.ViewController.viewDidLoad (xxx.ViewController)() -&gt; () + <span class="number">34</span> at ViewController.swift:<span class="number">0</span></span>
frame <span class="preprocessor">#<span class="number">2</span>: UIKit`-[UIViewController loadViewIfRequired] + <span class="number">1198</span></span>
frame <span class="preprocessor">#<span class="number">3</span>: UIKit`-[UIViewController view] + <span class="number">27</span></span>
frame <span class="preprocessor">#<span class="number">4</span>: UIKit`-[UIWindow addRootViewControllerViewIfPossible] + <span class="number">61</span></span>
frame <span class="preprocessor">#<span class="number">5</span>: UIKit`-[UIWindow _setHidden:forced:] + <span class="number">282</span></span>
frame <span class="preprocessor">#<span class="number">6</span>: UIKit`-[UIWindow makeKeyAndVisible] + <span class="number">42</span></span>
frame <span class="preprocessor">#<span class="number">7</span>: UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + <span class="number">4131</span></span>
frame <span class="preprocessor">#<span class="number">8</span>: UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + <span class="number">1760</span></span>
frame <span class="preprocessor">#<span class="number">9</span>: UIKit`-[UIApplication workspaceDidEndTransaction:] + <span class="number">188</span></span>
frame <span class="preprocessor">#<span class="number">10</span>: FrontBoardServices`-[FBSSerialQueue _performNext] + <span class="number">192</span></span>
frame <span class="preprocessor">#<span class="number">11</span>: FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + <span class="number">45</span></span>
frame <span class="preprocessor">#<span class="number">12</span>: CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + <span class="number">17</span></span>
frame <span class="preprocessor">#<span class="number">13</span>: CoreFoundation`__CFRunLoopDoSources0 + <span class="number">556</span></span>
frame <span class="preprocessor">#<span class="number">14</span>: CoreFoundation`__CFRunLoopRun + <span class="number">867</span></span>
frame <span class="preprocessor">#<span class="number">15</span>: CoreFoundation`CFRunLoopRunSpecific + <span class="number">488</span></span>
frame <span class="preprocessor">#<span class="number">16</span>: UIKit`-[UIApplication _run] + <span class="number">402</span></span>
frame <span class="preprocessor">#<span class="number">17</span>: UIKit`UIApplicationMain + <span class="number">171</span></span>
frame <span class="preprocessor">#<span class="number">18</span>: xxx`main + <span class="number">109</span> at AppDelegate.swift:<span class="number">12</span></span>
frame <span class="preprocessor">#<span class="number">19</span>: libdyld.dylib`start + <span class="number">1</span></span>
frame <span class="preprocessor">#<span class="number">20</span>: libdyld.dylib`start + <span class="number">1</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这周开始好好钻研一下LLDB相关的知识，这是一系列的文章。有些初级知识可能大家都有所涉猎，嘿嘿，懂得自然懂，看我的博客，什么时候会收获小。</p>
<h3 id="基础语法">基础语法</h3><p>1.<figure class="highlight"><table><t]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TBAnnotationClustering源码解析]]></title>
    <link href="http://satanwoo.github.io/2015/12/11/TBAnnotationClustering/"/>
    <id>http://satanwoo.github.io/2015/12/11/TBAnnotationClustering/</id>
    <published>2015-12-10T16:56:04.000Z</published>
    <updated>2015-12-11T09:38:46.000Z</updated>
    <content type="html"><![CDATA[<p>毕设这两天飞一般的加速，终于可以写写源码解析了，嘿嘿，这周读两个跟性能相关的源码，首先是一个跟地图相关的，今天来看看一个数据结构在iOS开发中的妙用。</p>
<h3 id="TBAnnotationClustering">TBAnnotationClustering</h3><p>我们都知道，MapView的实现机制其实和UITableView类似，首先他们都是基于UIScrollView支持滑动的，此外，他们都采用了循环服用的机制了来保持内存的开销。</p>
<p><strong>但是</strong>，两者之间有个很大的区别就是数量级的差距，UITableView就算充满整个屏幕，充其量也就是10多个同时可见的VisibleCell，因此就多维护一个大小是VisibleCells数量 ＋ 2的这样一个循环队列，进行复用。但是MapView就不一样了，地图上同时展示一段范围内几千个Point of Interest是非常有可能的，这一下子的内存开销和性能卡顿就非常不得了，因此我们需要一种合理的手段来避免，这就是我们今天要讲解的TBAnnotationClustering的由来。</p>
<p><a href="https://github.com/thoughtbot/TBAnnotationClustering" target="_blank" rel="external">Github地址</a></p>
<h3 id="Level_of_Detail">Level of Detail</h3><p>首先，让我们先介绍一下相关背景知识。</p>
<p>根据图像渲染的理论我们可以知道，人的视野存在焦点区域和盲点区域，总是更倾向于关注处于视线左上角到视线中心部分的。因此，在现实应用中，如游戏场景，当场景需要展现的模型距离视线焦点非常近时，就采用高精度的模型来进行展示；而到模型处于较远位置时，比如体育游戏的场外观众，就可以采用低精度模型进行替换，减少渲染时候的计算量；而到模型所处位置基本可以考虑成为背景时，则会采用基本图元进行展示。通过这种方法，即保证了场景的真实观感，同时又大大减少了不必要的计算量。这也就是通常计算机图形学领域所谓的Level Of Detail技术。</p>
<h3 id="QuadTree">QuadTree</h3><p>QuadTree可能很多人会比较陌生，但是一提到他的哥哥 － 二叉树，想必大家不会陌生，所以QuadTree又被称为四叉树，关于四叉树的定义，</p>
<blockquote><br>A quadtree is a tree data structure in which each internal node has exactly four children.<br></blockquote>

<p>四叉树被广泛的运用于空间划分。通过将空间递归划分不同层次的子结构，可以达到较高的空间数据插入和查询效果。</p>
<p>下面就是一张比较经典的四叉树构造，首先先将一个大空间划分为四个字空间 a b c d。然后根据每一个子空间内的节点个数再进行细分。<strong>这里要强调一点，四叉树的细分没有具体要求，你可以按你的需求划分成每个节点能只包含一个，也可以根据平衡减少划分次数。</strong></p>
<p><img src="http://img.blog.csdn.net/20131005154434687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvdXh1Z3VhbmcyMzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h3 id="TBAnnotationClustering源码讲解">TBAnnotationClustering源码讲解</h3><p>打开这个项目，粗略过一下项目结构，大致需要关注的代码如下：</p>
<ul>
<li>TBQuadTree.h/.m</li>
<li>TBCoordinateQuadTree.h/.m</li>
</ul>
<p>让我们一个个来分析</p>
<h4 id="TBQuadTree">TBQuadTree</h4><p>毫无疑问，从文件名称来看，我们就知道，这个类就代表基础的四叉树数据结构，首先让我们来看看数据结构的定义</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBQuadTreeNodeData</span> </span>{
    <span class="built_in">double</span> x;
    <span class="built_in">double</span> y;
    <span class="keyword">void</span>* data;
} TBQuadTreeNodeData;
TBQuadTreeNodeData TBQuadTreeNodeDataMake(<span class="built_in">double</span> x, <span class="built_in">double</span> y, <span class="keyword">void</span>* data);
</code></pre><p>这个毫无疑问，就是代表的坐标系的<strong>数据节点</strong>。 (x, y)表征坐标点，void *data自由的指向附加的数据。</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBBoundingBox</span> </span>{
    <span class="built_in">double</span> x0; <span class="built_in">double</span> y0;
    <span class="built_in">double</span> xf; <span class="built_in">double</span> yf;
} TBBoundingBox;
TBBoundingBox TBBoundingBoxMake(<span class="built_in">double</span> x0, <span class="built_in">double</span> y0, <span class="built_in">double</span> xf, <span class="built_in">double</span> yf);
</code></pre><p>这个同样很简单，用两个对角点限定了一个长方形区域，也就是一个四叉树的节点究竟包含哪些范围。</p>
<pre><code><span class="label">typedef</span> <span class="keyword">struct </span>quadTreeNode {
    <span class="keyword">struct </span>quadTreeNode* northWest<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* northEast<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* southWest<span class="comment">;</span>
    <span class="keyword">struct </span>quadTreeNode* southEast<span class="comment">;</span>
    <span class="keyword">TBBoundingBox </span><span class="keyword">boundingBox;
</span>    int <span class="keyword">bucketCapacity;
</span>    TBQuadTreeNodeData *points<span class="comment">;</span>
    int count<span class="comment">;</span>
} TBQuadTreeNode<span class="comment">;</span>
<span class="label">TBQuadTreeNode</span>* TBQuadTreeNodeMake(<span class="keyword">TBBoundingBox </span><span class="keyword">boundary, </span>int <span class="keyword">bucketCapacity);</span>
</code></pre><p>这个稍微复杂点，是四叉树的树节点，其中</p>
<ul>
<li>northWest, northEast, southWest, southEast分别代表四叉树的四个子细分区域。</li>
<li>bondingBox代表的当前这个树节点的涵盖区域。</li>
<li>bucketCapacity表示这个树节点最大容纳的数据节点个数</li>
<li>points 数据节点数组</li>
<li>count 当前包含了数据节点。</li>
</ul>
<p><strong>再次强调，千万不要把树节点和数据节点搞混。树节点指的是四叉树上的数据结构，每个树节点最多有四个子树节点，但是可以有bucketCapacity大小的数据节点，数据节点仅仅是用来封装坐标系和其相关的数据的一个数据结构，非四叉树特有。</strong></p>
<p>看完了数据定义，我们再来看看其实现部分。</p>
<pre><code><span class="preprocessor">#<span class="keyword">pragma</span> mark - Constructors</span>

<span class="function">TBQuadTreeNodeData <span class="title">TBQuadTreeNodeDataMake</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">void</span>* data)</span>
</span>{
    TBQuadTreeNodeData d; d.x = x; d.y = y; d.data = data;
    <span class="keyword">return</span> d;
}

<span class="function">TBBoundingBox <span class="title">TBBoundingBoxMake</span><span class="params">(<span class="keyword">double</span> x0, <span class="keyword">double</span> y0, <span class="keyword">double</span> xf, <span class="keyword">double</span> yf)</span>
</span>{
    TBBoundingBox bb; bb.x0 = x0; bb.y0 = y0; bb.xf = xf; bb.yf = yf;
    <span class="keyword">return</span> bb;
}

<span class="function">TBQuadTreeNode* <span class="title">TBQuadTreeNodeMake</span><span class="params">(TBBoundingBox boundary, <span class="keyword">int</span> bucketCapacity)</span>
</span>{
    TBQuadTreeNode* node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBQuadTreeNode));
    node-&gt;northWest = <span class="literal">NULL</span>;
    node-&gt;northEast = <span class="literal">NULL</span>;
    node-&gt;southWest = <span class="literal">NULL</span>;
    node-&gt;southEast = <span class="literal">NULL</span>;

    node-&gt;boundingBox = boundary;
    node-&gt;bucketCapacity = bucketCapacity;
    node-&gt;count = <span class="number">0</span>;
    node-&gt;points = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBQuadTreeNodeData) * bucketCapacity);

    <span class="keyword">return</span> node;
}
</code></pre><p>这三个构造函数，分别是构造<span style="color:red">数据节点</span>、长方形以及<span style="color:blue">四叉树节点</span>，默认情况下四叉树的节点<strong>并非满构造</strong>，而是初始化为空，根据需要插入新节点。</p>
<pre><code><span class="label">#pragma</span> <span class="keyword">mark </span>- <span class="keyword">Bounding </span><span class="keyword">Box </span>Functions

<span class="keyword">bool </span><span class="keyword">TBBoundingBoxContainsData(TBBoundingBox </span><span class="keyword">box, </span>TBQuadTreeNodeData <span class="preprocessor">data</span>)
{
    <span class="keyword">bool </span>containsX = <span class="keyword">box.x0 </span>&lt;= <span class="preprocessor">data</span>.x &amp;&amp; <span class="preprocessor">data</span>.x &lt;= <span class="keyword">box.xf;
</span>    <span class="keyword">bool </span>containsY = <span class="keyword">box.y0 </span>&lt;= <span class="preprocessor">data</span>.y &amp;&amp; <span class="preprocessor">data</span>.y &lt;= <span class="keyword">box.yf;
</span>
    return containsX &amp;&amp; containsY<span class="comment">;</span>
}

<span class="keyword">bool </span><span class="keyword">TBBoundingBoxIntersectsBoundingBox(TBBoundingBox </span><span class="keyword">b1, </span><span class="keyword">TBBoundingBox </span><span class="keyword">b2)
</span>{
    return (<span class="keyword">b1.x0 </span>&lt;= <span class="keyword">b2.xf </span>&amp;&amp; <span class="keyword">b1.xf </span>&gt;= <span class="keyword">b2.x0 </span>&amp;&amp; <span class="keyword">b1.y0 </span>&lt;= <span class="keyword">b2.yf </span>&amp;&amp; <span class="keyword">b1.yf </span>&gt;= <span class="keyword">b2.y0);
</span>}
</code></pre><p>随后就是上面两个判断长方形包含和相交的方法了，包含自然是整个包围。而相交的补集是不相交，即在横坐标上一个长方形的xf另一个长方形的x0抑或是一个长方形的x0完全大于另一个长方形的xf，当然在y轴上也是同理，因此通过补集很容易就理解TBBoundingBoxIntersectsBoundingBox的实现了。</p>
<p>然后来看看非常重要的几个函数，首先是<strong>TBQuadTreeNodeSubdivide</strong></p>
<pre><code><span class="label">void</span> TBQuadTreeNodeSubdivide(TBQuadTreeNode* node)
{
    <span class="keyword">TBBoundingBox </span><span class="keyword">box </span>= node-&gt;<span class="keyword">boundingBox;
</span>
    double xMid = (<span class="keyword">box.xf </span>+ <span class="keyword">box.x0) </span>/ <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span>
    double yMid = (<span class="keyword">box.yf </span>+ <span class="keyword">box.y0) </span>/ <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span>

    <span class="keyword">TBBoundingBox </span>northWest = <span class="keyword">TBBoundingBoxMake(box.x0, </span><span class="keyword">box.y0, </span>xMid, yMid)<span class="comment">;</span>
    node-&gt;northWest = TBQuadTreeNodeMake(northWest, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>northEast = <span class="keyword">TBBoundingBoxMake(xMid, </span><span class="keyword">box.y0, </span><span class="keyword">box.xf, </span>yMid)<span class="comment">;</span>
    node-&gt;northEast = TBQuadTreeNodeMake(northEast, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>southWest = <span class="keyword">TBBoundingBoxMake(box.x0, </span>yMid, xMid, <span class="keyword">box.yf);
</span>    node-&gt;southWest = TBQuadTreeNodeMake(southWest, node-&gt;<span class="keyword">bucketCapacity);
</span>
    <span class="keyword">TBBoundingBox </span>southEast = <span class="keyword">TBBoundingBoxMake(xMid, </span>yMid, <span class="keyword">box.xf, </span><span class="keyword">box.yf);
</span>    node-&gt;southEast = TBQuadTreeNodeMake(southEast, node-&gt;<span class="keyword">bucketCapacity);
</span>}
</code></pre><p>这个函数负责将四叉树节点进行细分。首先获取当前节点负责的长方形区域的中点，然后根据中点到原有长方形的四个顶点，分成四个象限，进行划分。<strong>这个时候请注意</strong>，还只是进行四叉树节点的细分，还没重新更改数据节点的分布。</p>
<pre><code><span class="keyword">bool</span> TBQuadTreeNodeInsertData(TBQuadTreeNode* node, TBQuadTreeNodeData data)
{
    <span class="keyword">if</span> (!TBBoundingBoxContainsData(node-&gt;boundingBox, data)) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">if</span> (node-&gt;count &lt; node-&gt;bucketCapacity) {
        node-&gt;points[node-&gt;count++] = data;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (node-&gt;northWest == <span class="keyword">NULL</span>) {
        TBQuadTreeNodeSubdivide(node);
    }

    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;northWest, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;northEast, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;southWest, data)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span> (TBQuadTreeNodeInsertData(node-&gt;southEast, data)) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>这个函数则是真正的将数据插入到节点中。</p>
<ul>
<li>首先先判断这个数据是否落在该长方形中，不是直接滚蛋。</li>
<li>如果当前包含的数据节点个数没有超过最大数目，直接应用在其中。</li>
<li>如果四个子节点为空，就先创建</li>
<li>然后再递归插入</li>
</ul>
<pre><code><span class="type">void</span> <span class="type">TBQuadTreeGatherDataInRange</span>(<span class="type">TBQuadTreeNode</span>* node, <span class="type">TBBoundingBox</span> <span class="type">range</span>, <span class="type">TBDataReturnBlock</span> <span class="keyword">block</span>)
{
    <span class="keyword">if</span> (!<span class="type">TBBoundingBoxIntersectsBoundingBox</span>(node-&gt;boundingBox, <span class="type">range</span>)) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;count; i++) {
        <span class="keyword">if</span> (<span class="type">TBBoundingBoxContainsData</span>(<span class="type">range</span>, node-&gt;points[i])) {
            <span class="keyword">block</span>(node-&gt;points[i]);
        }
    }

    <span class="keyword">if</span> (node-&gt;northWest == <span class="type">NULL</span>) {
        <span class="keyword">return</span>;
    }

    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;northWest, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;northEast, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;southWest, <span class="type">range</span>, <span class="keyword">block</span>);
    <span class="type">TBQuadTreeGatherDataInRange</span>(node-&gt;southEast, <span class="type">range</span>, <span class="keyword">block</span>);
}
</code></pre><p>这个就是通过DFS进行节点的遍历，一旦有落在range内的数据节点，就进行回调。</p>
<p><strong>综上所述，就是一个基本的四叉树，可以很明显的看到，在四叉树的构建、遍历中，都用了树的递归，也就是俗称的DFS算法。</strong></p>
<h4 id="TBCoordinateQuadTree">TBCoordinateQuadTree</h4><p>这个类呢，和实质上的四叉树或者性能优化并无太大关系，只是一层简单的封装，我们大致来了解一下就好。</p>
<pre><code><span class="keyword">TBBoundingBox </span><span class="keyword">TBBoundingBoxForMapRect(MKMapRect </span>mapRect)
{
    CLLocationCoordinate2D topLeft = MKCoordinateForMapPoint(mapRect.origin)<span class="comment">;</span>
    CLLocationCoordinate2D <span class="keyword">botRight </span>= MKCoordinateForMapPoint(MKMapPointMake(MKMapRectGetMaxX(mapRect), MKMapRectGetMaxY(mapRect)))<span class="comment">;</span>

    CLLocationDegrees minLat = <span class="keyword">botRight.latitude;
</span>    CLLocationDegrees maxLat = topLeft.latitude<span class="comment">;</span>

    CLLocationDegrees minLon = topLeft.longitude<span class="comment">;</span>
    CLLocationDegrees maxLon = <span class="keyword">botRight.longitude;
</span>
    return <span class="keyword">TBBoundingBoxMake(minLat, </span>minLon, maxLat, maxLon)<span class="comment">;</span>
}

<span class="label">MKMapRect</span> TBMapRectForBoundingBox(<span class="keyword">TBBoundingBox </span><span class="keyword">boundingBox)
</span>{
    MKMapPoint topLeft = MKMapPointForCoordinate(CLLocationCoordinate2DMake(<span class="keyword">boundingBox.x0, </span><span class="keyword">boundingBox.y0));
</span>    MKMapPoint <span class="keyword">botRight </span>= MKMapPointForCoordinate(CLLocationCoordinate2DMake(<span class="keyword">boundingBox.xf, </span><span class="keyword">boundingBox.yf));
</span>
    return MKMapRectMake(topLeft.x, <span class="keyword">botRight.y, </span>fabs(<span class="keyword">botRight.x </span>- topLeft.x), fabs(<span class="keyword">botRight.y </span>- topLeft.y))<span class="comment">;</span>
}
</code></pre><p>这两个函数就是MKMapRect和我们的BoundingBox之间的转换，难度很小，但是很有意思啊。从中我们可以一窥MapView的一些实现。比如MapView不仅仅是传统的ContentView和ContainerView，更重要的其坐标系和传统的CGRect之间的无法换算，<strong>简而言之，就是，在MapView中，所有的东西都要拿经度纬度来谈。</strong></p>
<pre><code>- (<span class="built_in">NSArray</span> *)clusteredAnnotationsWithinMapRect:(<span class="built_in">MKMapRect</span>)rect withZoomScale:(<span class="keyword">double</span>)zoomScale
{
     <span class="comment">// 1.</span>
    <span class="keyword">double</span> TBCellSize = TBCellSizeForZoomScale(zoomScale);
    <span class="keyword">double</span> scaleFactor = zoomScale / TBCellSize;

     <span class="comment">// 2.</span>
    <span class="built_in">NSInteger</span> minX = floor(<span class="built_in">MKMapRectGetMinX</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> maxX = floor(<span class="built_in">MKMapRectGetMaxX</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> minY = floor(<span class="built_in">MKMapRectGetMinY</span>(rect) * scaleFactor);
    <span class="built_in">NSInteger</span> maxY = floor(<span class="built_in">MKMapRectGetMaxY</span>(rect) * scaleFactor);

    <span class="built_in">NSMutableArray</span> *clusteredAnnotations = [[<span class="built_in">NSMutableArray</span> alloc] init];
    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> x = minX; x &lt;= maxX; x++) {
        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> y = minY; y &lt;= maxY; y++) {
            <span class="built_in">MKMapRect</span> mapRect = <span class="built_in">MKMapRectMake</span>(x / scaleFactor, y / scaleFactor, <span class="number">1.0</span> / scaleFactor, <span class="number">1.0</span> / scaleFactor);

            __block <span class="keyword">double</span> totalX = <span class="number">0</span>;
            __block <span class="keyword">double</span> totalY = <span class="number">0</span>;
            __block <span class="keyword">int</span> count = <span class="number">0</span>;

            <span class="built_in">NSMutableArray</span> *names = [[<span class="built_in">NSMutableArray</span> alloc] init];
            <span class="built_in">NSMutableArray</span> *phoneNumbers = [[<span class="built_in">NSMutableArray</span> alloc] init];

              <span class="comment">// 3.</span>
            TBQuadTreeGatherDataInRange(<span class="keyword">self</span><span class="variable">.root</span>, TBBoundingBoxForMapRect(mapRect), ^(TBQuadTreeNodeData data) {
                totalX += data<span class="variable">.x</span>;
                totalY += data<span class="variable">.y</span>;
                count++;

                TBHotelInfo hotelInfo = *(TBHotelInfo *)data<span class="variable">.data</span>;
                [names addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, hotelInfo<span class="variable">.hotelName</span>]];
                [phoneNumbers addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, hotelInfo<span class="variable">.hotelPhoneNumber</span>]];
            });

              <span class="comment">// 4.</span>
            <span class="keyword">if</span> (count == <span class="number">1</span>) {
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX, totalY);
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count];
                annotation<span class="variable">.title</span> = [names lastObject];
                annotation<span class="variable">.subtitle</span> = [phoneNumbers lastObject];
                [clusteredAnnotations addObject:annotation];
            }

           <span class="comment">// 5.</span>
            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) {
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX / count, totalY / count);
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count];
                [clusteredAnnotations addObject:annotation];
            }
        }
    }

    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:clusteredAnnotations];
}
</code></pre><p>而上述的最后一个函数，就是根据传入的MKMapRect，返回簇类数组的。</p>
<ul>
<li>1.首先根据放缩比例，或者Cell大小。</li>
<li>2.根据cell大小计算当前地图区域的范围所对应的minX - maxX，minY - maxY对应的网格。</li>
</ul>
<p>什么是网格？就是根据Cell大小将地图划分成了一块块区域，通过minX， maxX, minY - maxY找到对应的网格。类似于array[1][2]找到第二行第三列的网格（从0开始索引）。</p>
<ul>
<li>3.遍历每一个网格，获取当前网格对应的四叉树节点中的数据信息，并记录个数。</li>
<li>4.如果个数是1，那么直接显示，包含数据节点的附加信息，比如在这里就是酒店名称和酒店电话。</li>
<li>5.如果个数大于1的话，利用均值计算中心点，中心点是所有包含的数据节点平均值，同时信息只简单的显示个数。</li>
</ul>
<p>至此，整个代码就解读完整啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毕设这两天飞一般的加速，终于可以写写源码解析了，嘿嘿，这周读两个跟性能相关的源码，首先是一个跟地图相关的，今天来看看一个数据结构在iOS开发中的妙用。</p>
<h3 id="TBAnnotationClustering">TBAnnotationClustering</h]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FDFullScreenPopGesture源码解析]]></title>
    <link href="http://satanwoo.github.io/2015/11/26/FDFullScreenPopGesture-Source-Code/"/>
    <id>http://satanwoo.github.io/2015/11/26/FDFullScreenPopGesture-Source-Code/</id>
    <published>2015-11-26T03:38:42.000Z</published>
    <updated>2015-11-26T18:24:34.000Z</updated>
    <content type="html"><![CDATA[<p><em>嘿嘿，花了三天时间把自己的代码从700行缩减成了200行，终于有时间可以拜读新源码了，好开心。</em></p>
<p>好了，废话不多话，今天我们要读了百度出品的一个开源项目FDFullScreenPopGesture。</p>
<h2 id="项目介绍">项目介绍</h2><p><a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="external">FDFullScreenPopGesture</a>是一款无需改动即可整合进入现有项目的全局手势操作，使用这个即可以在左侧边缘拖拽的时候返回上一级的效果。</p>
<p>看到这，有人会问，我们这个直接用UIPanGestureRecognizer不也能达到吗？<br>没错，仅仅是返回上一级这个需求确实很简单。但是iOS7上返回上一级时候，UINavigationBar的切换效果你能实现吗？</p>
<p>而且，我要说的重点是<strong>FDFullscreenPopGesture</strong>实现思路很赞！！！</p>
<h2 id="源码分析">源码分析</h2><h3 id="结构分析">结构分析</h3><p>整个FDFullscreenPopGesture其实可以主要拆分成三块：</p>
<pre><code>-<span class="ruby">- _FDFullscreenPopGestureRecognizerDelegate
</span>-<span class="ruby">- <span class="constant">UIViewController</span> (<span class="constant">FDFullscreenPopGesturePrivate</span>)
</span>-<span class="ruby">- <span class="constant">UINavigationController</span> (<span class="constant">FDFullscreenPopGesture</span>)</span>
</code></pre><ul>
<li><p>_FDFullscreenPopGestureRecognizerDelegate虽然名字看起来像一个Protocol，但是它实质上是一个<strong>NSObject</strong>子类，同时实现了<strong>UIGestureRecognizerDelegate</strong>。这么做的好处是什么呢？不知道大家有没有经历过ViewController重构，以前很多时候，比如我们写UIScrollView，UITableView，他们的Delegate，DataSource都耦合进了ViewController，常常导致MassViewController灾难的发生。<strong>单独构建一个专门负责的Delgeate“处理器”是非常有效的手段</strong></p>
</li>
<li><p>UIViewController (FDFullscreenPopGesturePrivate)是一个Category，我们在这个分类里面主要进行<strong>viewWillAppear</strong>的Hook，具体做什么，后面章节我们细细道来。</p>
</li>
<li><p>UINavigationController (FDFullscreenPopGesture)也是一个分类，是进行<strong>pushViewController:animated:</strong>方法的hook，实现部分我们后续再看。</p>
</li>
</ul>
<h3 id="源码分析-1">源码分析</h3><h4 id="_FDFullscreenPopGestureRecognizerDelegate">_FDFullscreenPopGestureRecognizerDelegate</h4><pre><code>- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer
{
    <span class="comment">// 1.</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.count</span> &lt;= <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 2.</span>
    <span class="built_in">UIViewController</span> *topViewController = <span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.lastObject</span>;
    <span class="keyword">if</span> (topViewController<span class="variable">.fd_interactivePopDisabled</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 3. </span>
    <span class="built_in">CGPoint</span> beginningLocation = [gestureRecognizer locationInView:gestureRecognizer<span class="variable">.view</span>];
    <span class="built_in">CGFloat</span> maxAllowedInitialDistance = topViewController<span class="variable">.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge</span>;
    <span class="keyword">if</span> (maxAllowedInitialDistance &gt; <span class="number">0</span> &amp;&amp; beginningLocation<span class="variable">.x</span> &gt; maxAllowedInitialDistance) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 4.</span>
    <span class="keyword">if</span> ([[<span class="keyword">self</span><span class="variable">.navigationController</span> valueForKey:<span class="string">@"_isTransitioning"</span>] boolValue]) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">// 5.</span>
    <span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer<span class="variable">.view</span>];
    <span class="keyword">if</span> (translation<span class="variable">.x</span> &lt;= <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>整个类特别精简，它的职责就是维护一个UINavigationController然后根据一系列的状态判断该手势是否生效。这些状态包括</p>
<ol>
<li>当前UINavigationController的栈是否只剩最后一个ViewController了</li>
<li>当前即将出栈的topViewController是否禁用了<strong>fd_interactivePopDisabled</strong>，该变量我们稍后会说</li>
<li>当前手势的启动点是不是离左侧边缘太远了，毕竟我们是要模拟iOS原生的手势操作，原生的不支持全屏，我们为啥要支持！</li>
<li>当前是否已经处在转场过程中。在这里，可以看到它使用了valueForKey这一<strong>Key-Value-Coding</strong>技术，它可以访问私有变量<strong>_isTransitioning</strong>哦！</li>
<li>方向相反的滑动滚粗。</li>
</ol>
<h4 id="UIViewController_(FDFullscreenPopGesturePrivate)">UIViewController (FDFullscreenPopGesturePrivate)</h4><p>整个这个类也非常简单，就是通过 <strong>fd_viewWillAppear</strong> hook了 <strong>viewWillAppear</strong> 这个方法，然后插入了自己一段回调的block。</p>
<pre><code>- (<span class="keyword">void</span>)fd_viewWillAppear:(<span class="built_in">BOOL</span>)animated
{
    <span class="comment">// Forward to primary implementation.</span>
    [<span class="keyword">self</span> fd_viewWillAppear:animated];

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.fd_willAppearInjectBlock</span>) {
        <span class="keyword">self</span><span class="variable">.fd_willAppearInjectBlock</span>(<span class="keyword">self</span>, animated);
    }
}
</code></pre><h4 id="UINavigationController_(FDFullscreenPopGesture)">UINavigationController (FDFullscreenPopGesture)</h4><p>这个分类是整个项目的逻辑控制核心。它干了这么几件事：</p>
<ul>
<li>用 <strong>fd_pushViewController:animated:</strong> hook <strong>pushViewController:animated:</strong></li>
<li><strong>禁用</strong>UINavgationController的<strong>interactivePopGestureRecognizer</strong></li>
<li>构建了属于自己UIPanGestureRecognizer替换interactivePopGestureRecognizer，同时把手势的delegate赋值给了_FDFullscreenPopGestureRecognizerDelegate</li>
</ul>
<p>它的主要核心代码如下：</p>
<pre><code>- (<span class="keyword">void</span>)fd_pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated
{
    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span><span class="variable">.gestureRecognizers</span> containsObject:<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span>]) {

        <span class="comment">// 1.</span>
        [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span> addGestureRecognizer:<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span>];

        <span class="comment">// 2.</span>
        <span class="built_in">NSArray</span> *internalTargets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKey:<span class="string">@"targets"</span>];
        <span class="keyword">id</span> internalTarget = [internalTargets<span class="variable">.firstObject</span> valueForKey:<span class="string">@"target"</span>];
        SEL internalAction = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);
        <span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.fd_popGestureRecognizerDelegate</span>;
        [<span class="keyword">self</span><span class="variable">.fd_fullscreenPopGestureRecognizer</span> addTarget:internalTarget action:internalAction];

        <span class="comment">// 3.</span>
        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;
    }

    <span class="comment">// 4.</span>
    [<span class="keyword">self</span> fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];

    <span class="comment">// Forward to primary implementation.</span>
    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.viewControllers</span> containsObject:viewController]) {
        [<span class="keyword">self</span> fd_pushViewController:viewController animated:animated];
    }
}
</code></pre><p>整体来看这段源码，无非做了如下这些事：</p>
<ol>
<li>将UIPanGestureRecognizer添加到本来interactivePopGestureRecognizer所在的view上</li>
<li><div style="color:red"><strong>这段是重点的重点</strong>，一定要往下看！！！</div><br>将PanGesture的target设置为<strong>internalTarget</strong>，action设置为<br><strong>handleNavigationTransition</strong>.</li>
<li>禁用interactivePopGestureRecognizer</li>
<li><p>根据是否需要隐藏UINavigationBar来调用fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController进行之前提到过的<strong>fdwillAppearInjectBlock</strong>设置，代码如下：</p>
<pre><code>- (void)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController
{
    <span class="preprocessor">if</span> (!<span class="keyword">self.fd_viewControllerBasedNavigationBarAppearanceEnabled) </span>{
        return<span class="comment">;</span>
    }

    __weak typeof(<span class="keyword">self) </span>weakSelf = <span class="keyword">self;
</span>    _FDViewControllerWillAppearInjectBlock <span class="keyword">block </span>= ^(UIViewController *viewController, <span class="keyword">BOOL </span>animated) {
        __strong typeof(weakSelf) <span class="keyword">strongSelf </span>= weakSelf<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongSelf) </span>{
            [<span class="keyword">strongSelf </span>setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated]<span class="comment">;</span>
        }
    }<span class="comment">;</span>

    // Setup will appear inject <span class="keyword">block </span>to appearing view controller.
    // Setup disappearing view controller as well, <span class="keyword">because </span>not every view controller is <span class="keyword">added </span>into
    // stack <span class="keyword">by </span><span class="keyword">pushing, </span>maybe <span class="keyword">by </span><span class="string">"-setViewControllers:"</span>.
    appearingViewController.fd_willAppearInjectBlock = <span class="keyword">block;
</span>    UIViewController *disappearingViewController = <span class="keyword">self.viewControllers.lastObject;
</span>    <span class="preprocessor">if</span> (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) {
        disappearingViewController.fd_willAppearInjectBlock = <span class="keyword">block;
</span>    }
}
</code></pre></li>
</ol>
<p>这段代码就是将即将消失和展现的ViewController在viewWillAppear设置了一个自定义UINavigationBar的回调，用以根据进入的方式来展现NaviagtionBar，而不会出现突兀的“镂空”。</p>
<p>到这，源码就结束了，可以回家收衣服喽！</p>
<h3 id="重点">重点</h3><p>源码是不是很简单？有什么好分析的呢？<br>如果你读到这，哈哈，恭喜啦，重点分析来啦。</p>
<p>首先感谢@J_雨的天才思路，大家可以阅读<a href="http://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画</a>这篇文章，真的很赞</p>
<p>之前我们在上文用红色标注了一段内容：</p>
<div style="color:red"><br>将PanGesture的target设置为<strong>internalTarget</strong>，action设置为<br><strong>handleNavigationTransition</strong>。</div>

<p>看起来很容易理解，可是大家有没有想过为什么action的名称是handleNavigationTransition呢？</p>
<p>首先我们先打印看看NavigationController的interactivePopGestureRecognizer究竟是个什么玩意？</p>
<pre><code>&lt;<span class="built_in">UIScreenEdgePanGestureRecognizer</span>: <span class="number">0x7fea78ec5950</span>; state = Possible; delaysTouchesBegan = <span class="literal">YES</span>; view = &lt;<span class="built_in">UILayoutContainerView</span> <span class="number">0x7fea78f77960</span>&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_<span class="built_in">UINavigationInteractiveTransition</span> <span class="number">0x7fea78c1c640</span>&gt;)&gt;
</code></pre><p>这是什么玩意？让我们分别来看看它答应出来的这些属性。</p>
<ol>
<li>state = Possible，很简单，就是一个UIGestureRecognizerState = UIGestureRecognizerStatePossible。</li>
<li>view = UILayoutContainerView，不太懂，暂时也没觉得有需要，不管他。</li>
<li>target =&lt;(action=handleNavigationTransition:, target=<_uinavigationinteractivetransition 0x7fea78c1c640="">)，这个看起来很有用，因为我们都知道，Gesture就是通过<strong>Target-Action</strong>的方式进行动作触发的。</_uinavigationinteractivetransition></li>
</ol>
<p>所以我们赶紧看看这个<strong>target</strong>是个啥玩意，使用如下命令：</p>
<pre><code><span class="collection">[self.navigationController.interactivePopGestureRecognizer valueForKey:@<span class="string">"target"</span>]</span><span class="comment">;</span>
</code></pre><p>卧槽，一运行，Crash了，报找不到这个Key。咋回事，难道我记错了KVC的用户，赶紧换成valueForKey:@”View”试试。</p>
<p>哎！没错啊！成功得到了如下输出：</p>
<pre><code>-<span class="string">[UILayoutContainerView objectAtIndexedSubscript:]</span>
</code></pre><p>那咋回事，看来必须祭出屠龙刀Runtime了，嘿嘿，Objective-C面前，一切私有变量都是纸老虎。</p>
<pre><code><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;
Ivar *var = class_copyIvarList([UIGestureRecognizer <span class="keyword">class</span>], &amp;count);
<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {
     Ivar _var = *(var + i);
     NSLog(@<span class="string">"%s"</span>, ivar_getTypeEncoding(_var));
     NSLog(@<span class="string">"%s"</span>, ivar_getName(_var));
}
</code></pre><p>输出太长了，我们找我们想看的，</p>
<pre><code><span class="number">2015</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">02</span>:<span class="number">10</span>:<span class="number">03.873</span> SamplePhotosApp[<span class="number">85305</span>:<span class="number">2664323</span>] _targets
<span class="number">2015</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">02</span>:<span class="number">10</span>:<span class="number">03.873</span> SamplePhotosApp[<span class="number">85305</span>:<span class="number">2664323</span>] @<span class="string">"NSMutableArray"</span>
</code></pre><p>卧槽，这丫叫_targets，好吧，赶紧改成valueForKey:@”targets”再试试。<br>哎，等等，不是_targets吗，怎么能用targets呢？</p>
<p><strong>咳咳，吴老师又要来讲课了！对于KVC来说，它的查找顺序是key -&gt; property -&gt; ivar，也就是说，它会先按照是否有targets这个名称的key，然后targets这个property，最后再找_targets这个ivar。</strong></p>
<p>通过输出log，我们可以发现_targets是个数组，维护了一个个自定义结构维护的target-action配对。</p>
<p>因此，我们现在只要找到这个自定义结构是啥，里面包含了啥就可以了是吧。</p>
<p><strong>当头一棒</strong>，很遗憾，苹果太阴了，直接重载了这个自定义结构的debugDescription，特喵的什么都看不到。</p>
<p>事情到了这咋办呢？其实我也没想到，还好上述的参考文章告诉了我们可以依靠断点，通过断点，我们发发现了该自定义结构叫<strong>UIGestureRecognizerTarget</strong>，我们通过KVC获取其target和action即可。</p>
<h3 id="补充：关于Method_Swizzling">补充：关于Method Swizzling</h3><pre><code><span class="keyword">Class</span> <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];

SEL originalSelector = @<span class="keyword">selector</span>(pushViewController:animated:);
SEL swizzledSelector = @<span class="keyword">selector</span>(fd_pushViewController:animated:);

<span class="function"><span class="keyword">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, originalSelector)</span>;</span>
<span class="function"><span class="keyword">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, swizzledSelector)</span>;</span>

BOOL success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
<span class="keyword">if</span> (success) <span class="comment">{
    class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
}</span> <span class="keyword">else</span> <span class="comment">{
    method_exchangeImplementations(originalMethod, swizzledMethod);
}</span>
</code></pre><p>有很多人都了解Method Swizzling，但是不知道为什么这里需要进行<strong>BOOL success = class_addMethod</strong>判断。</p>
<p>其主要原因就是如果直接通过method_exchangeImplementations来进行的话，可能子类里并没有originalSelector所代表的方法，你直接和父类进行了交换，这是我们不希望看到的。</p>
<p>因此通过addMethod来判断，如果加成功了，说明原先这个函数在子类中并不存在，我们现在添加了，只要再把swizzleSelector指向旧函数即可；而如果没成功，说明这个函数在子类中存在了，我们直接替换也不会影响父类。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>嘿嘿，花了三天时间把自己的代码从700行缩减成了200行，终于有时间可以拜读新源码了，好开心。</em></p>
<p>好了，废话不多话，今天我们要读了百度出品的一个开源项目FDFullScreenPopGesture。</p>
<h2 id="项目介绍">项目介绍]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift每日一练：妙用CAReplicationLayer]]></title>
    <link href="http://satanwoo.github.io/2015/11/17/Fun-of-CAReplicationLayer/"/>
    <id>http://satanwoo.github.io/2015/11/17/Fun-of-CAReplicationLayer/</id>
    <published>2015-11-16T17:54:05.000Z</published>
    <updated>2015-11-16T19:04:45.000Z</updated>
    <content type="html"><![CDATA[<p>今天我们来学习一下一个在iOS常常被忽视的类 - CAReplicationLayer。我们要使用这个类来完成两个开起来很炫酷的加载效果。</p>
<p>老样子，先上具体的效果一看<br><img src="http://7lrzqz.com1.z0.glb.clouddn.com/LearnCAReplicationLayer.gif"></p>
<p>怎么样，效果还不错吧。一个是看起来有渐变效果的圆形加载，另外一个则是模仿Apple Music的柱状图加载。</p>
<p>接下来，就让我们一起揭开实现的面纱吧！</p>
<h3 id="CAReplicationLayer">CAReplicationLayer</h3><p>CAReplicationLayer是CALayer的子类，它与传统的CALayer系列不同，它基本不直接承担诸多效果，而是更多的承担一种“容器”的职责。</p>
<p>怎么理解呢？大家可以把CAReplicationLayer看成一个工厂，你提供给他一个产品的模型，它就可以为了源源不断的复制出纺织品。回到iOS中来说就是，你提供一个CALayer给CAReplicationLayer，并告诉它你希望它复制几份，就打造出多个具有效果样式的Layer。<strong>不仅如此，动画效果也会被一同复制</strong></p>
<p>因此，对于CAReplicationLayer，我们有几个特别需要关注的参数。</p>
<ul>
<li>instanceCount： 代表你希望将你提供它的Layer复制几份</li>
<li>instanceDelay： 这个参数在编写动画的前提下特别有用，它表明对每一个复制(或者原生)出来的Layer，启动动画之间的时间差在多少。</li>
<li>instanceTransform： 这个参数表示对于每一个Layer，它们之间的<strong>形变</strong>差距是多少。比如，每个Layer需要有相同的间隔。</li>
</ul>
<h3 id="渐变效果的圆形加载">渐变效果的圆形加载</h3><p>了解完CAReplicationLayer的基本知识以后，我们首先来看看圆形加载效果怎么实现。</p>
<p>第一步，毫无疑问的，需要构建一个CAReplicationLayer。</p>
<pre><code>let replicationLayer2 = <span class="function"><span class="title">CAReplicatorLayer</span><span class="params">()</span></span>
</code></pre><p>第二部，需要一个样品，让我们的CAReplicationLayer复制生产</p>
<pre><code>let circle = <span class="function"><span class="title">CAShapeLayer</span><span class="params">()</span></span>
circle<span class="class">.path</span> = <span class="function"><span class="title">UIBezierPath</span><span class="params">(ovalInRect: CGRect(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">10</span>, height: <span class="number">10</span>)</span></span>)<span class="class">.CGPath</span>
circle<span class="class">.lineWidth</span> = <span class="number">1</span>
circle<span class="class">.fillColor</span> = UIColor.<span class="function"><span class="title">whiteColor</span><span class="params">()</span></span><span class="class">.CGColor</span>
circle<span class="class">.transform</span> = <span class="function"><span class="title">CATransform3DMakeScale</span><span class="params">(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>)</span></span>
</code></pre><p>在这里，我们构建了一个白色小球，把初始大小设置为了0.1。</p>
<p>接下去，我们需要然CAReplicationLayer开始复制了，</p>
<pre><code>replicationLayer2<span class="class">.instanceCount</span> = <span class="number">12</span>
replicationLayer2<span class="class">.instanceTransform</span> = <span class="function"><span class="title">CATransform3DMakeRotation</span><span class="params">(CGFloat(<span class="number">2</span> * M_PI/<span class="number">12.0</span>)</span></span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)
</code></pre><p>从上述代码我们可以看出，我们首先构建了<strong>12</strong>个复制体，然后将这12个小球通过instanceTransform绕<strong>Z</strong>轴均匀的分度在圆周上。</p>
<p>现在赶快run一下你的app，看看效果是不是正如我所说的！</p>
<p>现在万事具备，只欠动画了！</p>
<p>首先我们来定义如例子中的放缩动画</p>
<pre><code><span class="component">func scaleAnimation() -&gt; CABasicAnimation {
    let animation = CABasicAnimation(keyPath: "transform<span class="string">.scale")</span>
    animation<span class="string">.duration</span> = 1.5
    animation<span class="string">.fromValue</span> = 1.0
    animation<span class="string">.toValue</span> = 0.1
    animation<span class="string">.repeatCount</span> = Float<span class="string">.infinity</span>

    return animation
}</span>
</code></pre><p>我们定义了一个针对scale属性、时常1.5s的动画，然后我们将这个动画添加到小球上。</p>
<pre><code>circle.<span class="function"><span class="title">addAnimation</span><span class="params">(scaleAnimation()</span></span>, forKey: <span class="string">"scale"</span>)
</code></pre><p>现在如果你跑一下代码的话，你会发现，所有的小球都同时启动了动画，和例子的效果不一致，怎么回事呢？</p>
<p>嘿嘿，还记得我们之前提及的属性<strong>instanceDelay</strong>吗？没错，我们需要借助它的力量。</p>
<pre><code>replicationLayer2.instanceDelay = <span class="number">1.5</span>/<span class="number">12</span>
</code></pre><p>现在再看看？哈哈，效果拔群！</p>
<h3 id="Apple_Music加载效果">Apple Music加载效果</h3><p>下面的代码，很清晰易懂，我就不逐条解析啦，有问题欢迎大家在下方评论！</p>
<pre><code><span class="comment">// 1. 创建容器ReplicationLayer</span>
let replicationLayer = CAReplicatorLayer()

<span class="comment">// 2. 创建柱状图</span>
let bar = CALayer()
bar.frame = CGRect(<span class="string">x:</span> <span class="number">0</span>, <span class="string">y:</span> <span class="number">0</span>, <span class="string">width:</span> <span class="number">8</span>, <span class="string">height:</span> <span class="number">40</span>)
bar.position = CGPoint(<span class="string">x:</span> <span class="number">10</span>, <span class="string">y:</span> <span class="number">75</span>)
bar.backgroundColor = UIColor.purpleColor().CGColor

<span class="comment">// 3. 复制生产3个，并添加水平间隔</span>
replicationLayer.addSublayer(bar)
replicationLayer.instanceCount = <span class="number">3</span>
replicationLayer.instanceTransform = CATransform3DMakeTranslation(<span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>)

<span class="comment">// 4. 创建动画，构造时间差</span>
func jumpAnimation(<span class="string">bar:</span>CALayer) -&gt; CABasicAnimation {
    let animation = CABasicAnimation(<span class="string">keyPath:</span> <span class="string">"position.y"</span>)
    animation.toValue = bar.position.y - <span class="number">35.0</span>
    animation.duration = <span class="number">0.45</span>
    animation.autoreverses = <span class="literal">true</span>
    animation.repeatCount = Float.infinity

    <span class="keyword">return</span> animation
}

bar.addAnimation(jumpAnimation(bar), <span class="string">forKey:</span> <span class="string">"jump"</span>)
replicationLayer.instanceDelay = <span class="number">0.3</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们来学习一下一个在iOS常常被忽视的类 - CAReplicationLayer。我们要使用这个类来完成两个开起来很炫酷的加载效果。</p>
<p>老样子，先上具体的效果一看<br><img src="http://7lrzqz.com1.z0.glb.clouddn]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift每日一练：自定义转场在iOS8中的那些坑]]></title>
    <link href="http://satanwoo.github.io/2015/11/12/Swift-UITransition-iOS8/"/>
    <id>http://satanwoo.github.io/2015/11/12/Swift-UITransition-iOS8/</id>
    <published>2015-11-11T18:33:50.000Z</published>
    <updated>2015-11-11T19:55:32.000Z</updated>
    <content type="html"><![CDATA[<p>之前因为面试的缘故发现了自己在自定义转场这块有点欠缺，今天拿Swift练下手，实现一个自定义转场的效果。<em>没耐心的话请直接翻到最后吧，我前面都是铺垫呢。</em></p>
<p>首先让我们先来看看最后实现的效果：<br><img src="http://7lrzqz.com1.z0.glb.clouddn.com/WZCustomTransition.gif"></p>
<p>下面就让我们一步步来看看是如何实现这个效果的。</p>
<h3 id="自定义转场">自定义转场</h3><p>要实现自定义转场动画，比较重要的就是三个部分。</p>
<ul>
<li><p>UIViewControllerContextTransition</p>
<p>这个接口主要用来提供切换上下文给开发者使用，包含了从哪个VC到哪个VC等各类信息，一般不需要开发者自己实现。</p>
<p>本文关注的包含了如下一些内容：</p>
<pre><code><span class="number">1.</span> - (<span class="built_in">UIView</span> *)containerView; 
<span class="comment">// VC切换所发生的view容器    </span>

<span class="number">2.</span> - (<span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">NSString</span> *)key;
<span class="comment">// 根据UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别返回将要切出和切入的ViewController。</span>

<span class="number">3.</span> - (<span class="keyword">void</span>)completeTransition:(<span class="built_in">BOOL</span>)didComplete; 
<span class="comment">// 报告切换已经完成。</span>
</code></pre></li>
<li><p>UIViewControllerAnimatedTransition</p>
<p>这个接口主要用来定义如何完成转场动画，同时定义转场动画的持续时间。（在本文中我们不考虑交互式的转场）</p>
<pre><code><span class="number">1.</span> - (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span> &lt; <span class="built_in">UIViewControllerContextTransitioning</span> &gt;)transitionContext; 
<span class="comment">// 返回转场动画持续的时间</span>

<span class="number">2.</span> - (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt; <span class="built_in">UIViewControllerContextTransitioning</span> &gt;)transitionContext; 
<span class="comment">// 我们自定义的转场要在这里完成</span>
</code></pre></li>
<li><p>UIViewControllerTransitionDelegate    </p>
<p>这个接口主要用于指定，我们希望采用哪种转场效果（比如你可以根据不同的状态，切换不同的自定义专场效果）</p>
<pre><code><span class="number">1.</span> - (<span class="keyword">id</span>&lt; <span class="built_in">UIViewControllerAnimatedTransitioning</span> &gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source;
<span class="comment">// 当弹出模态窗口的时候，使用什么转场效果</span>

<span class="number">2.</span> - (<span class="keyword">id</span>&lt; <span class="built_in">UIViewControllerAnimatedTransitioning</span> &gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;
<span class="comment">// 当关闭模态窗口的时候，使用什么转场效果</span>
</code></pre></li>
</ul>
<h3 id="实现">实现</h3><p>知道了转场动画需要的必要条件，我们可以很轻松分别实现三个部分。</p>
<p>第一部分UIViewControllerContextTransition在本文中并没有特殊定制化的地方，直接完成。</p>
<p>第二部分关于UIViewControllerAnimatedTransition的代码如下：</p>
<pre><code>class SwipeAnimator: <span class="built_in">NSObject</span>, <span class="built_in">UIViewControllerAnimatedTransitioning</span> {
    <span class="keyword">enum</span> SwipeTo {
        <span class="keyword">case</span> Main
        <span class="keyword">case</span> Modal
    };

    var transitonTo:SwipeTo = <span class="variable">.Main</span>

    <span class="comment">// 0. 返回动画时间</span>
    func transitionDuration(transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>) -&gt; <span class="built_in">NSTimeInterval</span> {
        <span class="keyword">return</span> <span class="number">1.0</span>
    }

    func animateTransition(transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>) {
        <span class="comment">// 1. 获取相关资源</span>
        let fromVC = transitionContext<span class="variable">.viewControllerForKey</span>(<span class="built_in">UITransitionContextFromViewControllerKey</span>)!

        let toView = transitionContext<span class="variable">.viewForKey</span>(<span class="built_in">UITransitionContextToViewKey</span>)

        <span class="comment">// 2. 弹出模态</span>
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.transitonTo</span> == <span class="variable">.Modal</span>) {
            <span class="keyword">if</span> toView != <span class="literal">nil</span> {
                transitionContext<span class="variable">.containerView</span>()<span class="variable">.addSubview</span>(toView!)

                toView!<span class="variable">.alpha</span> = <span class="number">0.0</span>

                <span class="comment">// 2.1 以左上角为锚点旋转</span>
                fromVC<span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.anchorPoint</span> = <span class="built_in">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)
                fromVC<span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.position</span> = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>)

                <span class="built_in">UIView</span><span class="variable">.animateWithDuration</span>(<span class="number">1.0</span>, animations: { () -&gt; Void <span class="keyword">in</span>
                    fromVC<span class="variable">.view</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="built_in">CGFloat</span>(-M_PI/<span class="number">2</span>))
                    toView!<span class="variable">.alpha</span> = <span class="number">1.0</span>
                }, completion: { (completion:Bool) -&gt; Void <span class="keyword">in</span>
                    <span class="comment">// 2.2 报告转场动画完成</span>
                    transitionContext<span class="variable">.completeTransition</span>(!transitionContext<span class="variable">.transitionWasCancelled</span>())
                })
            }
        } <span class="keyword">else</span> {
            <span class="comment">// 3. 关闭模态</span>
            <span class="keyword">if</span> fromView != <span class="literal">nil</span> {
                fromView!<span class="variable">.alpha</span> = <span class="number">1.0</span>
                <span class="built_in">UIView</span><span class="variable">.animateWithDuration</span>(<span class="number">1.0</span>, animations: { () -&gt; Void <span class="keyword">in</span>
                    toVC<span class="variable">.view</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0</span>)
                    fromView!<span class="variable">.alpha</span> = <span class="number">0.0</span>
                }, completion: { (completion:Bool) -&gt; Void <span class="keyword">in</span>
                    transitionContext<span class="variable">.completeTransition</span>(!transitionContext<span class="variable">.transitionWasCancelled</span>())
                })
            }
        }
    }
}
</code></pre><p>实现非常简单，我们来一步步看下。</p>
<ul>
<li><ol>
<li>根据UIViewControllerAnimatedTransition协议返回动画时间</li>
</ol>
</li>
<li><ol>
<li>根据UIViewControllerContextTransition获取我们需要操作的即将切出的ViewController(fromVC)以及即将切入的页面(toView)，<strong>为什么要用这种获取方式，稍微在重点分析会指出</strong></li>
</ol>
</li>
<li><ol>
<li>当遇到是弹出模态窗口转场的时候，我们首先将toView加入到转场过程提供的一个containView中，然后改变fromVC的锚点，进行旋转，同时我们对toView进行了一个淡入淡出。当转场动画完成以后，<strong>在回调的closure中报告转场动画已经完成</strong>。</li>
</ol>
</li>
<li><ol>
<li>当关闭模态转场的时候，这个时候转场的出和入就正好和弹出的时候截然相反。原先的fromVC成了现在的toVC，因此我们在这里将toVC旋转回原来的位置。当然别忘了我们的淡入淡出啦，原理是一样的，只要改变fromView的alpha即可。动画完成后，依然要报告我们的转场完成了。</li>
</ol>
</li>
</ul>
<p>第三部分，UIViewControllerTransitionDelegate的实现依然非常简单，我们仅仅需要告知转场发生时，我们具体要采用哪种转场效果就好了。</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">animationControllerForPresentedController</span><span class="params">(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? {
    <span class="keyword">self</span>.animator.transitonTo = .<span class="type">Modal</span>
    <span class="keyword">return</span> <span class="keyword">self</span>.animator
}

<span class="func"><span class="keyword">func</span> <span class="title">animationControllerForDismissedController</span><span class="params">(dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? {
    <span class="keyword">self</span>.animator.transitonTo = .<span class="type">Main</span>
    <span class="keyword">return</span> <span class="keyword">self</span>.animator
}
</code></pre><p>在这里，我们复用了同一个转场效果，通过不同的transitionTo参数进行控制。你当然也可以给两个转场分别生成对应不同的转场效果。</p>
<h3 id="iOS8的坑">iOS8的坑</h3><p>嘿嘿，重头戏来了，千万别错过。</p>
<p>一开始实现这个转场效果的时候，压根没想到这么复杂，但是，突然发现了一个很大的问题：</p>
<p><strong>当弹出模态窗口的时候，转场效果正常，最后成功显示模态界面。但是当关闭模态窗口的时候，转场效果依然正确，但是转场结束后，整个屏幕都黑了。</strong></p>
<p><em>What the F*ck!!!</em></p>
<p>我以为是我自己实现有问题，但是我去Github上找了几个著名的转场效果跑了下，都存在这个问题，那我就百思不得其解了呀！！！</p>
<h4 id="误打误撞">误打误撞</h4><p>从网上搜寻了很久之后，我还是没有头绪，于是我首先尝试将如下代码中</p>
<pre><code><span class="tag">var</span> modalVC = <span class="function"><span class="title">UIStoryboard</span><span class="params">(name: <span class="string">"Main"</span>, bundle: nil)</span></span>.<span class="function"><span class="title">instantiateViewControllerWithIdentifier</span><span class="params">(<span class="string">"ModalViewController"</span>)</span></span> as! UIViewController
modalVC<span class="class">.transitioningDelegate</span> = self
modalVC<span class="class">.modalPresentationStyle</span> = <span class="class">.Custom</span>
<span class="function"><span class="title">presentViewController</span><span class="params">(modalVC, animated: true, completion: nil)</span></span>
</code></pre><p><strong>modalVC.modalPresentationStyle = .Custom</strong>中的.Custom改成了.FullScreen。<br>这一下子就给我整好了！</p>
<p>所以，给大家提个醒，如果遇到相似的问题，解决方法很简单，就是.FullScreen即可。</p>
<h4 id="深层原因">深层原因</h4><p>作为一个站在红旗下的三好学生，弄懂问题的深层原因才是最主要的，通过不过的debug，我终于弄懂了。</p>
<p><strong>首先，我们要强调一个基本知识。一个UIView的superview最多只能由一个。当一个本身处于别的UIView下的subView被添加到另一个UIView上的时候，它就自动被从前一个UIView的Hierarchy中移除了。</strong></p>
<p>还记得我们之前一个很奇怪的写法吗？<br>根据UIViewControllerContextTransition获取我们需要操作的即将切出的ViewController(fromVC)以及即将切入的页面(toView)</p>
<p>我们这么写的原因就是因为我们刚刚强调的基本知识，别急，让我们一步步来解析。</p>
<p>在iOS8中，苹果提供了一个新的API：</p>
<pre><code><span class="constant">@availability</span>(iOS, introduced=<span class="number">8.0</span>)
<span class="function"><span class="keyword">func</span> <span class="title">viewForKey</span><span class="params">(key: String)</span> -&gt; <span class="title">UIView</span>?</span>
</code></pre><p>并且在文档中明确强调了一点：</p>
<pre><code><span class="comment">// Currently only two keys are defined by the</span>
<span class="comment">// system - UITransitionContextToViewControllerKey, and</span>
<span class="comment">// UITransitionContextFromViewControllerKey. </span>
<span class="comment">// Animators should not directly manipulate a view controller's views and should</span>
<span class="comment">// use viewForKey: to get views instead.</span>
<span class="func"><span class="keyword">func</span> <span class="title">viewControllerForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIViewController</span>?
</code></pre><p>什么意思呢？<br>之前在iOS7中，开发者需要通过<strong>viewControllerForKey</strong>这个方法获取切入切出的ViewController，并直接操作ViewController对应的View来编写转场动画。而在iOS8以后，苹果规定必须使用<strong>viewForKey</strong>来获取fromView和toView来进行转场动画的操作。</p>
<p>那这个API的更改和黑屏有什么关联呢？</p>
<ul>
<li>在整个转场过程中，我们都依赖于转场上下文transitonContext提供的containerView容器进行view动画的操作。这是因为在转场完成前，即将<strong>切入</strong>的viewcontroller都不存在于当前的可视界面的视图层级内(View Hierarchy)。因此，苹果提供了一个过渡的容器给我们使用（如果大家debug下的话，就会发现在转场过程之中，UIWindow上多了一个UITransitionView，就是切换上下文的containerView）。</li>
<li>在iOS7的实现中，我们需要将fromVC.view和toVC.view都通过addSubView的方式添加到容器View上进行动画展示。<strong>由于是直接操作了ViewController的view，因此，fromVC的view会被从当前的视图层级中移除</strong></li>
<li><strong>但是，iOS7中，会在转场动画完成后，自动将fromVC的view添加回原先fromVC从属的父视图中</strong></li>
<li>iOS8中不会</li>
<li>在本文的初版实现中，在转场过程中当判断transitionTo == .Main的时候，将此时toViewController.view (也就是原先的主窗口) 添加到了containerView上。因此，当转场结束的时候，containerView从window可见视图层级中移除了，因此就变得不可见，从而变成黑屏了。</li>
</ul>
<p>那么为什么模态窗口在转场过程后可见呢？</p>
<ul>
<li>因为这个特性依然正确。</li>
</ul>
<p>containerView到底是啥?</p>
<ul>
<li>就是一个过渡的UITransitionView，一个转场效果对应生成一个（会复用）。</li>
<li>在转场结束后自动从视图层级中移除，因此不需要大家手动进行removeFromSuperView。</li>
</ul>
<p>那么viewForKey和viewControlelrForKey直接操纵view的区别呢？</p>
<ul>
<li>viewForKey很可能返回的是一个完全克隆VC的view的对象。</li>
</ul>
<p>到这，相信大家都弄懂了吧，我真是太佩服我自己了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前因为面试的缘故发现了自己在自定义转场这块有点欠缺，今天拿Swift练下手，实现一个自定义转场的效果。<em>没耐心的话请直接翻到最后吧，我前面都是铺垫呢。</em></p>
<p>首先让我们先来看看最后实现的效果：<br><img src="http://7lrzqz.]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅入浅出VIPER设计架构(1)]]></title>
    <link href="http://satanwoo.github.io/2015/11/05/Understand-Viper/"/>
    <id>http://satanwoo.github.io/2015/11/05/Understand-Viper/</id>
    <published>2015-11-04T17:01:51.000Z</published>
    <updated>2015-11-04T18:46:48.000Z</updated>
    <content type="html"><![CDATA[<p>之前和豌豆荚的同学聊天，发现他们的App从MVVM切换到VIPER设计架构，于是这两天花了点时间研读了一下 相关资料，浅谈一下。</p>
<h3 id="VIPER是什么">VIPER是什么</h3><p>VIPER是<b>View, Interactor, Presenter, Entity, Routing</b>5个词语的缩写，这5个词语也是VIPER架构的核心。</p>
<p>View - 视图，接收传递的内容，然后进行内容展示。</p>
<p>Presenter - 视图逻辑控制器，这个模块只用来执行和UI相关的逻辑。什么叫和UI相关的逻辑呢？比如：接收用户交互、将展示的内容分发给不同的UI界面进行展示。</p>
<p>Interactor - <b>纯业务逻辑控制器</b>，这个模块完全脱离于UI，只用来做业务相关的逻辑控制。举例来说，比如下载逻辑、计算逻辑等等可以划分为单一Use Case的逻辑。</p>
<p>Entity - 基础的数据模型，比方说大家经常定义的XXXModel之类的，但是，这里的XXXModel可以认为基本就是<b>纯数据结构了</b>，不包含轻量级业务处理逻辑</p>
<p>Routing - 路由器，视图切换的逻辑。比如包含如何从一个界面切换到另一个界面，切换的顺序是如何等等。</p>
<p>除了五大核心之外，我们还经常使用了<strong>Data Store</strong>这个模块。因为我们之前提过，我们的Entity基本就是纯数据结构，不包含轻量级的业务逻辑，因此，Entity进行持久化这个职责是要单独划分出来，而这个职能就落到了Data Store身上。</p>
<p>下面是网上一张比较经典的架构设计图：</p>
<p><img src="https://www.objc.io/images/issue-13/2014-06-07-viper-wireframe-76305b6d.png"></p>
<h3 id="为什么要用VIPER">为什么要用VIPER</h3><p><strong>在软件工程领域，有一个很重要的观点，就是测试、测试、测试。（重要的话说三遍！）</strong></p>
<p>之前在BMW Group实习的时候从事Java开发，每一个函数都要经过JUnit的测试，也就是我们所谓的Test-Driven Development。但是iOS开发由于其逻辑和视图的强耦合关系，常常导致业务逻辑不能完全独立于界面，进行单元测试十分困难。比如，臭名昭著的”Massive View Controller” 就是因为将大量的业务逻辑和视图逻辑耦合进了Controller，导致Controller非常臃肿，也不容易剥离进行测试。</p>
<p>而VIPER架构引入了Interactor和Presentator两个概念，将业务逻辑和视图逻辑独立开来，从而可以单独测试业务逻辑的代码。</p>
<h3 id="例子分析">例子分析</h3><p>说了好多虚的概念，有些人一定已经被弄晕了，还是赶紧看两个典型的例子看深入了解下吧.</p>
<h4 id="1-_Counter">1. Counter</h4><p>第一个例子来源于<a href="https://github.com/mutualmobile/Counter" target="_blank" rel="external">Counter</a>，是一个非常简单了计数应用。麻雀虽小，却五脏俱全。</p>
<p>打开项目，我们可以快速的过一下项目结构：</p>
<pre><code>-<span class="ruby">- <span class="constant">CNTAppDelegate</span>.h/.m
</span>-<span class="ruby">- <span class="constant">CNTCountInteractorIO</span>.h
</span>-<span class="ruby">- <span class="constant">CNTCountInteractor</span>.h/.m
</span>-<span class="ruby">- <span class="constant">CNTCountPresenter</span>.h/.m
</span>-<span class="ruby">- <span class="constant">CNTCountView</span>.h
</span>-<span class="ruby">- <span class="constant">CNTCountViewController</span>.h/.m/.xib</span>
</code></pre><p>首先我们来看一下最简单的模块：CNTCountView</p>
<pre><code><span class="comment">// CNTCountView.h</span>
<span class="class"><span class="keyword">@protocol</span> <span class="title">CNTCountView</span> &lt;<span class="title">NSObject</span>&gt;</span>
- (<span class="keyword">void</span>)setCountText:(<span class="built_in">NSString</span>*)countText;
- (<span class="keyword">void</span>)setDecrementEnabled:(<span class="built_in">BOOL</span>)enabled;
<span class="keyword">@end</span>
</code></pre><p>咦？为什么这个View只包含一个Protocol呢？说好的View用来接收传递的内容然后进行内容展示呢？</p>
<p>原因是这样：在iOS应用中，一个无法避免的模块就是ViewController（<strong>无论如何每个应用都必须存在一个RootViewController</strong>）。每个ViewController包含一个根View用来进行视图展示。因此，在将VIPER架构应用到iOS领域的过程中，实际上起到View作用的是ViewController！(<b>当然，ViewController不仅仅起到了视图展示的作用</b>)</p>
<p><em>题外话：我个人认为这个例子的取名不太好，让人迷惑，如果换个名字，如CNTCountViewOperation就没有这个问题了</em></p>
<p>既然如此，让我们赶快去看看相关的ViewController：CNTCountViewController中的实现。</p>
<pre><code><span class="comment">// CNTCountViewController.h</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">CNTCountViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">CNTCountView</span>&gt;</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span>    <span class="built_in">UILabel</span>*    countLabel;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span>    <span class="built_in">UIButton</span>*   decrementButton;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span>    <span class="built_in">UIButton</span>*   incrementButton;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)   CNTCountPresenter*  presenter;
<span class="keyword">@end</span>
</code></pre><p>在上述CNTCountViewController的头文件中，我们可以看到该类遵从了CNTCountView协议。其次，他包含了真正的View：两个UIButton和一个UILabel。说明这和我们之前说的ViewController起到了真正的视图展示作用是吻合的。</p>
<p>同时，我们还看到了一个非常显眼的类：<strong>CNTCountPresenter</strong>。如果这个类的命名没错，那这个类就是所谓的Presenter了，用来进行界面逻辑控制的类。那么是不是这样呢？我们<em>Command + 左击</em>这个类一探究竟！</p>
<pre><code><span class="comment">// CNTCountPresenter.h</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">CNTCountPresenter</span> : <span class="title">NSObject</span> &lt;<span class="title">CNTCountInteractorOutput</span>&gt;</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)     <span class="keyword">id</span>&lt;CNTCountView&gt;            view;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)   <span class="keyword">id</span>&lt;CNTCountInteractorInput&gt; interactor;

- (<span class="keyword">void</span>)updateView;
- (<span class="keyword">void</span>)increment;
- (<span class="keyword">void</span>)decrement;
<span class="keyword">@end</span>
</code></pre><p>从CNTCountPresenter的头文件中，我们能看出很多逻辑关系。Presenter包含了一个View和一个Interactor。这和文首我们对于VIPER的介绍相吻合：Presenter从Interactor获取数据，经过界面逻辑处理后，将数据发送给View进行展示。</p>
<p>从Interactor请求获取数据的部分代码如下：</p>
<pre><code><span class="comment">// CNTCountPresenter.m</span>
<span class="tag">-</span> (void)<span class="tag">updateView</span>
{
    <span class="attr_selector">[self.interactor requestCount]</span>;
}

<span class="tag">-</span> (void)<span class="tag">increment</span>
{
    <span class="attr_selector">[self.interactor increment]</span>;
}

<span class="tag">-</span> (void)<span class="tag">decrement</span>
{
    <span class="attr_selector">[self.interactor decrement]</span>;
}
</code></pre><p>由于Presenter从Interactor获取数据，那么势必Presenter是Interactor的一个输出，而Interactor是Presenter的一个输入。</p>
<pre><code><span class="comment">// CNTCountInteractorIO.h</span>
<span class="class"><span class="keyword">@protocol</span> <span class="title">CNTCountInteractorInput</span> &lt;<span class="title">NSObject</span>&gt;</span>
- (<span class="keyword">void</span>)requestCount;
- (<span class="keyword">void</span>)increment;
- (<span class="keyword">void</span>)decrement;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@protocol</span> <span class="title">CNTCountInteractorOutput</span> &lt;<span class="title">NSObject</span>&gt;</span>
- (<span class="keyword">void</span>)updateCount:(<span class="built_in">NSUInteger</span>)count;
<span class="keyword">@end</span>
</code></pre><p><em><b>这里各位可以先不关注Protocol协议的设计本身，只要理解逻辑关系即可。</b></em></p>
<p>通过这样的职责划分，落入到Interactor类中的职责就是最基本的业务逻辑：计数的增加和减少。</p>
<pre><code><span class="comment">// CNTCountInteractor.h</span>
- (<span class="keyword">void</span>)requestCount
{
    [<span class="keyword">self</span> sendCount];
}

- (<span class="keyword">void</span>)increment
{
    ++<span class="keyword">self</span><span class="variable">.count</span>;
    [<span class="keyword">self</span> sendCount];
}

- (<span class="keyword">void</span>)decrement
{
    <span class="keyword">if</span> ([<span class="keyword">self</span> canDecrement])
    {
        --<span class="keyword">self</span><span class="variable">.count</span>;
        [<span class="keyword">self</span> sendCount];
    }
}
</code></pre><p>至此，我们可以将Counter的项目架构进行如下表示：</p>
<p>Interactor &lt;——–&gt; Presenter</p>
<ul>
<li><strong>Interactor</strong> 是 <strong>Presenter</strong>  的 <b>输入</b></li>
<li><strong>Presenter</strong>  是 <strong>Interactor</strong> 的 <b>输出</b></li>
<li><strong>Presenter</strong> 通过某些事件触发，去向其输入<strong>Interactor</strong>请求数据</li>
</ul>
<p>Presenter &lt;——–&gt; View(ViewController)</p>
<ul>
<li><strong>View</strong>       是 <strong>Presenter</strong>  的 <b>输出</b></li>
<li><strong>ViewController</strong> 触发了 <strong>Presenter</strong> 去<strong>Interactor</strong>中请求新的业务结果，从而更新<strong>View</strong></li>
</ul>
<p>Presenter更新View的代码如下：</p>
<pre><code><span class="comment">// CNTCountPresenter.m</span>
<span class="tag">-</span> (void)<span class="tag">updateCount</span>:(NSUInteger)<span class="tag">count</span>
{
    <span class="attr_selector">[self.view setCountText:[self formattedCount:count]</span>];
    <span class="attr_selector">[self.view setDecrementEnabled:[self canDecrementCount:count]</span>];
}
</code></pre><p>到这里，Counter这个例子的解读基本就完成了。细心的读者一定会发现，<strong>Entity</strong>和<strong>Route</strong>到哪里去了？</p>
<p>是的，这个例子由于过于简单，压根不需要Entity。并且由于它是单视图应用，压根不涉及到页面切换，因此也无须Route功能。不过我们在后续的浅入浅出VIPER架构（2）中解读一个更细致更负责的例子，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前和豌豆荚的同学聊天，发现他们的App从MVVM切换到VIPER设计架构，于是这两天花了点时间研读了一下 相关资料，浅谈一下。</p>
<h3 id="VIPER是什么">VIPER是什么</h3><p>VIPER是<b>View, Interactor, Present]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object-Path 源码解读]]></title>
    <link href="http://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/"/>
    <id>http://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/</id>
    <published>2015-11-04T16:18:02.000Z</published>
    <updated>2015-11-09T17:57:55.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Object-Path">Object-Path</h3><p>今天看到了一个非常有意思的JavaScript库，乍一看有点iOS keypath chain的意思，名字叫Object-Path，<a href="https://github.com/mariocasciaro/object-path" target="_blank" rel="external">地址点我</a>，主要的功能包含了：</p>
<ul>
<li>Set</li>
<li>Get</li>
<li>Del</li>
<li>Empty </li>
<li>Insert </li>
<li>EnsureExist</li>
<li>Push</li>
</ul>
<p>从它的Example中我们可以先一览它的功能：</p>
<pre><code><span class="keyword">var</span> obj = {
  a: {
    b: <span class="string">"d"</span>,
    c: [<span class="string">"e"</span>, <span class="string">"f"</span>],
    <span class="string">'\u1200'</span>: <span class="string">'unicode key'</span>,
    <span class="string">'dot.dot'</span>: <span class="string">'key'</span>
  }
};

<span class="keyword">var</span> objectPath = require(<span class="string">"object-path"</span>);

<span class="comment">//get deep property</span>
objectPath.<span class="keyword">get</span>(obj, <span class="string">"a.b"</span>);  <span class="comment">//returns "d"</span>
objectPath.<span class="keyword">get</span>(obj, [<span class="string">"a"</span>, <span class="string">"dot.dot"</span>]);  <span class="comment">//returns "key"</span>
objectPath.<span class="keyword">get</span>(obj, <span class="string">'a.\u1200'</span>);  <span class="comment">//returns "unicode key"</span>
</code></pre><p>从这个例子中，我们可以发现对于一个Object <strong>obc</strong>，除了默认的直接通过点 <strong>.</strong>方式访问一个属性外， 如obj.a。我们还可以通过点 <strong>.</strong> 来进行<strong>“链式”</strong>访问其属性的属性（如果存在的话），如obj.a.b。这看起来真的和iOS中的keypath coding非常相似，所以，今天就让我们来分析下其实现吧！</p>
<h3 id="源码解析">源码解析</h3><h4 id="Set方法">Set方法</h4><pre><code>例子：objectPath.<span class="keyword">set</span>(obj, <span class="string">"a.h"</span>, <span class="string">"m"</span>); 
</code></pre><p>Set方法是用来给obj的某个<strong>“链式”</strong>属性进行赋值的，源码如下：</p>
<pre><code><span class="function">function <span class="title">set</span><span class="params">(obj, path, value, doNotReplace)</span></span>{
     <span class="comment">// 1. </span>
    <span class="keyword">if</span> (isNumber(path)) {
      path = [path];
    }

    <span class="comment">// 2.</span>
    <span class="keyword">if</span> (isEmpty(path)) {
      <span class="keyword">return</span> obj;
    }

    <span class="comment">// 3.</span>
    <span class="keyword">if</span> (isString(path)) {
      <span class="keyword">return</span> <span class="built_in">set</span>(obj, path.split(<span class="string">'.'</span>).<span class="built_in">map</span>(getKey), value, doNotReplace);
    }

    <span class="comment">// 4.</span>
    var currentPath = path[<span class="number">0</span>];

    <span class="keyword">if</span> (path.length === <span class="number">1</span>) {
      var oldVal = obj[currentPath];
      <span class="keyword">if</span> (oldVal === <span class="keyword">void</span> <span class="number">0</span> || !doNotReplace) {
        obj[currentPath] = value;
      }
      <span class="keyword">return</span> oldVal;
    }

     <span class="comment">// 5.</span>
    <span class="keyword">if</span> (obj[currentPath] === <span class="keyword">void</span> <span class="number">0</span>) {
      <span class="comment">//check if we assume an array</span>
      <span class="keyword">if</span>(isNumber(path[<span class="number">1</span>])) {
        obj[currentPath] = [];
      } <span class="keyword">else</span> {
        obj[currentPath] = {};
      }
    }

    <span class="keyword">return</span> <span class="built_in">set</span>(obj[currentPath], path.slice(<span class="number">1</span>), value, doNotReplace);
  }
</code></pre><ul>
<li><ol>
<li>判断传入的path是否是Number类型，如果不是的话，构建一个包含这个pathde数组，这里为什么要这样处理，在下文解释。<strong>注：JavaScript中不存在浮点数、整数等等不同数值类型，统一为Number</strong></li>
</ol>
</li>
<li><ol>
<li>判断传入的path是不是“空”，空的情况包含：undefined，空数组，没有任何自身属性的对象。下文我们会详细查看<strong>isEmpty</strong>的实现。</li>
</ol>
</li>
<li><ol>
<li>判断是否是字符串，如果是字符串，就通过<strong>“.”</strong>进行分割，分割完成构建数组，然后进行set方法的重新调用。</li>
</ol>
</li>
<li><ol>
<li>判断是否当前path深度只为一层，<em>var currentPath = path[0]</em>，如果是一层的话，根据是否要doNotReplace进行值的替换。</li>
</ol>
</li>
</ul>
<p>这里有个很有意思的实现 <strong>oldVal === void 0</strong>，void 0是什么鬼，我们经常会看见<strong>JavaScript::void(0)代表网页的死链接</strong>，那么oldVal == void 0又是什么意思呢？</p>
<p><strong>其实，void 0就是undefined！</strong>在现代的浏览器中，它们两已经完全的等同了。而写成void 0的形式，是为了兼容。在过去的浏览器中，undefined不是一个关键字，它是个全局变量。因此，你完全可以徒手改变它的含义，</p>
<pre><code><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;
<span class="built_in">console</span>.log(<span class="literal">undefined</span>);
</code></pre><p>这样的改变，就会undefined原本的含义错乱。而<strong>由于void是一个操作符，你无法改写它的含义，因此void 0是一种更安全的写法！</strong></p>
<p>在这里的含义就是，判断<strong>oldVal === void 0</strong>是不是未定义罢了。</p>
<ul>
<li><ol>
<li>如果不是一层深度的path，并且当前的obj[currentPath]是未定义的。那么就需要判断path[1]，也就是path数组中的第二个属性是什么了。<strong>如果是数字，就将obj[currentPath]构建为数组［］，否则构建一个对象｛｝。</strong></li>
</ol>
</li>
</ul>
<p>为什么要分开处理呢？这里就需要提及JavaScript访问属性的一个特别的地方。对于如下这样一个对象，</p>
<pre><code><span class="keyword">var</span> obj = <span class="comment">{a:5}</span>
</code></pre><p>来说，我们实现<strong>obj.a 或者 obj[“a”]</strong>都可以获得正确的结果5，但是对于另一个对象，</p>
<pre><code>var obj = {<span class="number">1</span>: <span class="number">5</span>}
</code></pre><p>我们只能使用obj[“1”]的方式来访问结果5，而不能使用obj.1。如果使用obj.1，就能报错误：<div style="color:red">Uncaught SyntaxError: Unexpected number(…)</div></p>
<p>究其原因，就在于JavaScript在处理对象的key的时候，都是将key当成字符串处理的。</p>
<p>所以，在这里构建完相对应的下一层级obj[currrentPath]，递归调用set方法即可。</p>
<h4 id="Del方法">Del方法</h4><pre><code><span class="function">function <span class="title">del</span><span class="params">(obj, path)</span> </span>{
    <span class="keyword">if</span> (isNumber(path)) {
     path = [path];
    }

    <span class="keyword">if</span> (isEmpty(obj)) {
     <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;
    }

    <span class="keyword">if</span> (isEmpty(path)) {
     <span class="keyword">return</span> obj;
    }

    <span class="keyword">if</span>(isString(path)) {
     <span class="keyword">return</span> del(obj, path.split(<span class="string">'.'</span>));
    }

    <span class="comment">// 重点</span>
    var currentPath = getKey(path[<span class="number">0</span>]);
    var oldVal = obj[currentPath];

    <span class="keyword">if</span>(path.length === <span class="number">1</span>) {
     <span class="keyword">if</span> (oldVal !== <span class="keyword">void</span> <span class="number">0</span>) {
       <span class="keyword">if</span> (isArray(obj)) {
         obj.splice(currentPath, <span class="number">1</span>);
       } <span class="keyword">else</span> {
         <span class="keyword">delete</span> obj[currentPath];
       }
     }
    } <span class="keyword">else</span> {
     <span class="keyword">if</span> (obj[currentPath] !== <span class="keyword">void</span> <span class="number">0</span>) {
       <span class="keyword">return</span> del(obj[currentPath], path.slice(<span class="number">1</span>));
     }
    }

    <span class="keyword">return</span> obj;
}
</code></pre><p>让我们再来看看Del方法，这个方法用于“链式”删除一些属性对应的值。由于之前的逻辑和Set类似，我们直接从重点开始看起。</p>
<ul>
<li>首先先从path[0]中获取key，然后取出对应的oldVal。</li>
<li><p>如果path深度为1，并且oldVal不是未定义的话，究进行删除，删除分为两种：</p>
<p>（1）如果是数组的话,通过splice删除数组中currentPath位置上的属性值<br>（2）如果是object，直接进行删除即可</p>
</li>
<li><p>如果深度不为1，并且oldValue不是未定义，递归调用del函数即可。</p>
</li>
</ul>
<p>这里有一点需要注意，我们看到在获取currentPath的过程中，调用了getKey这个函数，让我们赶紧去看看这个getKey的实现。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">key</span>)</span>{
    <span class="keyword">var</span> intKey = <span class="built_in">parseInt</span>(key);
    <span class="keyword">if</span> (intKey.toString() === key) {
      <span class="keyword">return</span> intKey;
    }
    <span class="keyword">return</span> key;
} 
</code></pre><p>这里的逻辑不难理解，通过parseInt将key转成整型，如果转换后的结果通过toString函数和原有的key一致，就直接返回整形，否则返回原有的key。<strong>通过===(强等于号)不难理解，这里if的满足条件当且仅当key本身是string类型，同时其值是个整数才可以满足，如”5”等，像类似”a.2”, “5.5”就不会满足。</strong></p>
<p>剩下的诸如Get, Has方法，实现都大同小异，我们就不再一一解读了，大家有兴趣可以自行阅读。</p>
<h3 id="补充知识：JavaScript类型判断">补充知识：JavaScript类型判断</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span><span class="params">(value)</span></span>{
  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> || toString(value) === <span class="string">"[object Number]"</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isString</span><span class="params">(obj)</span></span>{
  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'string'</span> || toString(obj) === <span class="string">"[object String]"</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isObject</span><span class="params">(obj)</span></span>{
  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; toString(obj) === <span class="string">"[object Object]"</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(obj)</span></span>{
  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj.length === <span class="string">'number'</span> &amp;&amp; toString(obj) === <span class="string">'[object Array]'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isBoolean</span><span class="params">(obj)</span></span>{
  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'boolean'</span> || toString(obj) === <span class="string">'[object Boolean]'</span>;
}
</code></pre><p>在Object-Path的实现中，大量的类型判断工作都是通过如上一些函数来搞定的。有人会问了，判断一个类型为啥要这么麻烦，直接用instanceOf或者typeof不可以吗？</p>
<ul>
<li>用instanceOf是肯定错误的，如果被判断的对象不处于同一个页面，那么instanceOf就肯定失效了。</li>
</ul>
<blockquote><br>比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量是否是array类型，就是失败<br></blockquote>

<ul>
<li>用typeof的缺陷在于，JavaScript中存在基本类型和包装类型，对于数值5来说，它是基本类型Number，通过typeof可以准备的判断出。但是如果是包装对象<b>var k = new Number(5)</b>，在意义上其仍然应该是属于数值类型，但是通过typeof获得的结果是object，因此就不正确。</li>
</ul>
<p><strong>所以，在这里的实现，我们采用了Object.prototype.toString.call(obj)的方式来获取正确的类型。</strong></p>
<p>嘿嘿，今天就到这里啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Object-Path">Object-Path</h3><p>今天看到了一个非常有意思的JavaScript库，乍一看有点iOS keypath chain的意思，名字叫Object-Path，<a href="https://github.com/marioc]]>
    </summary>
    
      <category term="JavaScript" scheme="http://satanwoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大菜比学安卓]]></title>
    <link href="http://satanwoo.github.io/2015/10/29/Learn-Android-Day-by-Day/"/>
    <id>http://satanwoo.github.io/2015/10/29/Learn-Android-Day-by-Day/</id>
    <published>2015-10-29T11:52:44.000Z</published>
    <updated>2015-11-05T17:07:20.000Z</updated>
    <content type="html"><![CDATA[<p>本人新手，学习安卓，这里用来记录一下阅读《第一行代码》的笔试和体会。</p>
<ol>
<li>在XML引入一个id，就使用@id/id_name，如果要添加一个id，就使用@+id/id_name</li>
<li>给主活动指定的Label不仅会成为标题栏中的内容，还会成为Launcher中应用程序显示的名称。</li>
<li>Intent 调用StartActivityForResult用来给上一层Activity返回数据</li>
<li>活动的生存期</li>
</ol>
<ul>
<li>运行状态，当一个活动处于返回栈的栈顶时，就处于运行状态，系统最不愿意回收的就是处于运行状态的活动。</li>
<li>暂停状态，当一个活动不处于栈顶位置，但是仍然可见的时候，就进入了暂停状态（因为有些活动，如对话框等，就不会占据整个屏幕，因此其他活动仍然可见）</li>
<li>停止状态，当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。</li>
<li>销毁状态，当一个活动从返回栈中被移除后，就进入了销毁状态。</li>
</ul>
<ol>
<li>活动生命周期回调函数</li>
</ol>
<ul>
<li>onCreate在活动第一次创建的时候调用</li>
<li>onStart在活动由不可见变成可见的时候调用</li>
<li>onResume在活动准备好和用户进行交互的时候调用，此时的活动一定位于栈的栈顶，且处于运行状态。</li>
<li>onPause在系统准备去启动或者恢复另一个活动的时候调用。</li>
<li>onStop在活动完全不可见的时候调用。</li>
<li>onDestory在活动被销毁之前调用，之后的活动变为销毁状态。</li>
<li>onRestart在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本人新手，学习安卓，这里用来记录一下阅读《第一行代码》的笔试和体会。</p>
<ol>
<li>在XML引入一个id，就使用@id/id_name，如果要添加一个id，就使用@+id/id_name</li>
<li>给主活动指定的Label不仅会成为标题栏中的内容，还会成]]>
    </summary>
    
      <category term="Android" scheme="http://satanwoo.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift每日一练：重写UICountingLabel]]></title>
    <link href="http://satanwoo.github.io/2015/10/29/Swift-Count-Down-Label/"/>
    <id>http://satanwoo.github.io/2015/10/29/Swift-Count-Down-Label/</id>
    <published>2015-10-28T18:54:23.000Z</published>
    <updated>2015-10-29T11:13:50.000Z</updated>
    <content type="html"><![CDATA[<p>今天Swift练习的是准备尝试把<a href="https://github.com/dataxpress/UICountingLabel/blob/master/UICountingLabel.m" target="_blank" rel="external">UICountingLabel</a>这个Github Star数超过500的库用Swift重写一遍。</p>
<h3 id="UICountingLabel源码解析">UICountingLabel源码解析</h3><p>整个uICountingLabel的本质就是基于一个NSTimer来计算当前时间内应该显示什么值，</p>
<pre><code>- (<span class="built_in">CGFloat</span>)currentValue {

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progress</span> &gt;= <span class="keyword">self</span><span class="variable">.totalTime</span>) {
        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.destinationValue</span>;
    }

    <span class="built_in">CGFloat</span> percent = <span class="keyword">self</span><span class="variable">.progress</span> / <span class="keyword">self</span><span class="variable">.totalTime</span>;
    <span class="built_in">CGFloat</span> updateVal = [<span class="keyword">self</span><span class="variable">.counter</span> update:percent];
    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.startingValue</span> + (updateVal * (<span class="keyword">self</span><span class="variable">.destinationValue</span> - <span class="keyword">self</span><span class="variable">.startingValue</span>));
}
</code></pre><p>这个值通过不同的插值方式得到，这个插值方式的具体实现时通过<strong>self.counter</strong>的不同子类进行实现。</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">UILabelCounterLinear</span></span>

-(<span class="built_in">CGFloat</span>)update:(<span class="built_in">CGFloat</span>)t
{
    <span class="keyword">return</span> t;
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">UILabelCounterEaseIn</span></span>

-(<span class="built_in">CGFloat</span>)update:(<span class="built_in">CGFloat</span>)t
{
    <span class="keyword">return</span> powf(t, k<span class="built_in">UILabelCounterRate</span>);
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">UILabelCounterEaseOut</span></span>

-(<span class="built_in">CGFloat</span>)update:(<span class="built_in">CGFloat</span>)t{
    <span class="keyword">return</span> <span class="number">1.0</span>-powf((<span class="number">1.0</span>-t), k<span class="built_in">UILabelCounterRate</span>);
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">UILabelCounterEaseInOut</span></span>

-(<span class="built_in">CGFloat</span>) update: (<span class="built_in">CGFloat</span>) t
{
    <span class="keyword">int</span> sign =<span class="number">1</span>;
    <span class="keyword">int</span> r = (<span class="keyword">int</span>) k<span class="built_in">UILabelCounterRate</span>;
    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">0</span>)
        sign = -<span class="number">1</span>;
    t *= <span class="number">2</span>;
    <span class="keyword">if</span> (t &lt; <span class="number">1</span>)
        <span class="keyword">return</span> <span class="number">0.5</span>f * powf(t, k<span class="built_in">UILabelCounterRate</span>);
    <span class="keyword">else</span>
        <span class="keyword">return</span> sign * <span class="number">0.5</span>f * (powf(t-<span class="number">2</span>, k<span class="built_in">UILabelCounterRate</span>) + sign * <span class="number">2</span>);
}
</code></pre><p>这里用子类化这么说是不严谨的，因为这其实就类似于Java或者C#是面向了接口编程了而已，因为这里的每个类都只是实现了update这个函数接口而已。</p>
<p>然后实现里相对比较直观，</p>
<pre><code>-(<span class="keyword">void</span>)countFrom:(<span class="built_in">CGFloat</span>)startValue to:(<span class="built_in">CGFloat</span>)endValue withDuration:(<span class="built_in">NSTimeInterval</span>)duration {
    <span class="keyword">if</span> (duration == <span class="number">0.0</span>) {
        <span class="comment">// No animation</span>
        [<span class="keyword">self</span> setTextValue:endValue];
        [<span class="keyword">self</span> runCompletionBlock];
        <span class="keyword">return</span>;
    }

    <span class="keyword">self</span><span class="variable">.lastUpdate</span> = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];

    <span class="keyword">switch</span>(<span class="keyword">self</span><span class="variable">.method</span>)
    {
        <span class="keyword">case</span> <span class="built_in">UILabelCountingMethodLinear</span>:
            <span class="keyword">self</span><span class="variable">.counter</span> = [[<span class="built_in">UILabelCounterLinear</span> alloc] init];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="built_in">UILabelCountingMethodEaseIn</span>:
            <span class="keyword">self</span><span class="variable">.counter</span> = [[<span class="built_in">UILabelCounterEaseIn</span> alloc] init];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="built_in">UILabelCountingMethodEaseOut</span>:
            <span class="keyword">self</span><span class="variable">.counter</span> = [[<span class="built_in">UILabelCounterEaseOut</span> alloc] init];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="built_in">UILabelCountingMethodEaseInOut</span>:
            <span class="keyword">self</span><span class="variable">.counter</span> = [[<span class="built_in">UILabelCounterEaseInOut</span> alloc] init];
            <span class="keyword">break</span>;
    }

    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="number">1.0</span>f/<span class="number">30.0</span>f) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateValue:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];
    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];
    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];
    <span class="keyword">self</span><span class="variable">.timer</span> = timer;
}
</code></pre><p>首先如果动画的时间是0，就默认直接回调。但是，我想说<b>duration == 0.0，浮点数这么判断，真的没问题吗？</b></p>
<p>由于NSTimer无法得知确切得知道执行了多少，所以这里要记录上一步回调的lastUpdate。<br>根据不同的方法选择不同的Counter进行插值，然后创建NSTimer，这里我们要特别注意两句话：</p>
<pre><code><span class="attr_selector">[[NSRunLoop mainRunLoop]</span> <span class="rule"><span class="attribute">addTimer</span>:<span class="value">timer forMode:NSRunLoopCommonModes]</span></span>;
<span class="attr_selector">[[NSRunLoop mainRunLoop]</span> <span class="rule"><span class="attribute">addTimer</span>:<span class="value">timer forMode:UITrackingRunLoopMode]</span></span>;
</code></pre><p>这表示NSTimer默认加入的是RunLoop的Default Mode，但是Default Mode在进入Tracking Mode的时候（也就是当用户滑动的时候）会被阻塞，影响动画的执行。因此要特别加入TrackingMode。</p>
<p>但是我又想说了，<b>NSRunLoopCommonModes难道不是包含UITrackingRunLoopMode吗？天呐，还是我理解的不对，重复添加的意义呢！！！！</b></p>
<p>然后在NSTimer的回调函数中,</p>
<pre><code><span class="built_in">NSTimeInterval</span> now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];
<span class="keyword">self</span><span class="variable">.progress</span> += now - <span class="keyword">self</span><span class="variable">.lastUpdate</span>;
<span class="keyword">self</span><span class="variable">.lastUpdate</span> = now;

<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progress</span> &gt;= <span class="keyword">self</span><span class="variable">.totalTime</span>) {
    [<span class="keyword">self</span><span class="variable">.timer</span> invalidate];
    <span class="keyword">self</span><span class="variable">.timer</span> = <span class="literal">nil</span>;
    <span class="keyword">self</span><span class="variable">.progress</span> = <span class="keyword">self</span><span class="variable">.totalTime</span>;
}

[<span class="keyword">self</span> setTextValue:[<span class="keyword">self</span> currentValue]];

<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progress</span> == <span class="keyword">self</span><span class="variable">.totalTime</span>) {
    [<span class="keyword">self</span> runCompletionBlock];
}
</code></pre><p>就是计算当前的progress进度，更新相应的值而已，没有难度。</p>
<h3 id="Swift_重写">Swift 重写</h3><p>先来效果:</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/CountDownLabel.gif"></p>
<h4 id="CADisplayLink_vs_NSTimer">CADisplayLink vs NSTimer</h4><p>首先我们来回忆下Objective-C版本中的一些逻辑，使用NSTimer动态根据进度更新时间。但是我们知道，NSTimer有一个很大的问题就是他的“刷新率”不够准确。如果NSTimer设置了每两秒更新一次，那么如果RunLoop中有个耗时的任务，就会讲这个更新任务推迟，用时间轴来理解：</p>
<pre><code><span class="number">0</span><span class="function"> -&gt;</span> <span class="number">2s</span> <span class="function"><span class="params">(NSTimer回调)</span> -&gt;</span> <span class="number">3s</span> （耗时的任务）<span class="function"> -&gt;</span> <span class="number">2s</span> (NSTimer回调)。
</code></pre><p>那么这个会导致什么问题呢？NSTimer的回调和屏幕刷新不是同步的。因此，在Swift版本的重写中，我采用了CADisplayLink来改写，它的好处我们同样用时间轴来理解：</p>
<pre><code><span class="number">0</span> -&gt; <span class="number">2</span>s（CADisplayLink回调） -&gt; <span class="number">3</span>s（耗时的任务） -&gt; <span class="number">1</span>s（空闲） -&gt; <span class="number">2</span>s（CADisplayLink回调）
</code></pre><p>可以看出，CADisplayLink始终是保持和屏幕刷新率一样。</p>
<p><b>这里强调一下，不论是NSTimer抑或是CADisplayLink，既然他们都是基于RunLoop的，就无法脱离被所处同一个RunLoop里的其他任务所影响的宿命，所以网上那些说CADisplayLink不会被阻塞的说法都是错误的。</b></p>
<h4 id="Swift_面向接口编程">Swift 面向接口编程</h4><p>之前我们提过“子类化“这个说法是不准确的，因此，我们在Swift中，可以基于protocol-oriented进行编程。</p>
<pre><code><span class="keyword">let</span> <span class="type">WZCountRate</span>:<span class="type">Float</span> = <span class="number">3.0</span>

<span class="class"><span class="keyword">protocol</span> <span class="title">Interpolation</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(val:Float)</span></span> -&gt; <span class="type">Float</span>;
}

<span class="class"><span class="keyword">struct</span> <span class="title">Linear</span>:<span class="title">Interpolation</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(val: Float)</span></span> -&gt; <span class="type">Float</span> {
        <span class="keyword">return</span> val
    }
}

<span class="class"><span class="keyword">struct</span> <span class="title">EaseIn</span>:<span class="title">Interpolation</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(val: Float)</span></span> -&gt; <span class="type">Float</span> {
        <span class="keyword">return</span> powf(val, <span class="type">WZCountRate</span>)
    }
}

<span class="class"><span class="keyword">struct</span> <span class="title">EaseOut</span>:<span class="title">Interpolation</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(val: Float)</span></span> -&gt; <span class="type">Float</span> {
        <span class="keyword">return</span> <span class="number">1</span> - powf((<span class="number">1</span> - val), <span class="type">WZCountRate</span>)
    }
}

<span class="class"><span class="keyword">struct</span> <span class="title">EaseInOut</span>:<span class="title">Interpolation</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(val: Float)</span></span> -&gt; <span class="type">Float</span> {
        <span class="keyword">var</span> sign:<span class="type">Float</span> = <span class="number">1</span>
        <span class="keyword">let</span> r = <span class="type">Int</span>(<span class="type">WZCountRate</span>)

        <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">0</span>) {
           sign = -<span class="number">1</span>
        }

        <span class="keyword">var</span> t = val * <span class="number">2</span>
        <span class="keyword">if</span> (t &lt; <span class="number">1</span>) {
            <span class="keyword">return</span> <span class="number">0.5</span> * powf(t, <span class="type">WZCountRate</span>)
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="number">0.5</span> * (powf(t - <span class="number">2.0</span>, <span class="type">WZCountRate</span>) + sign * <span class="number">2</span>) * sign
        }
    }
}
</code></pre><p>可以看到，我们用四个<b>Struct</b>结构体遵从了<b>Interpolation</b>这个接口，实现了四种不同的插值方法。</p>
<p>别的方面没什么特别难的，</p>
<h4 id="Access_Control_对Selector_Callback的影响">Access Control 对Selector Callback的影响</h4><p>我们都知道，Swift对类引入了Access Control这一机制，默认情况下是internal的权限。由于CADisplayLink还是基于Selector设置回调的，如下：</p>
<pre><code><span class="keyword">let</span> displayLink = CADisplayLink(
   target: <span class="built_in">self</span>,
   <span class="keyword">select</span><span class="subst">or</span>: <span class="keyword">Select</span><span class="subst">or</span>(<span class="string">"displayTick:"</span>)
)
</code></pre><p>当这个displayTick函数处于<b>public或者internal</b>权限的时候，没有任何问题。而当你想声明如</p>
<p><em>private func displayTick()</em></p>
<p>的时候，就会产生doesn’t recognize selector的runtime error。</p>
<p>原因如下：<br><b>基于Selector的回调方式还是采用了Objective-C传统的runtime 查函数表的方式，但是在Swift中声明为private的函数，对于Objective-C Runtime是不可见的。因此，如果你需要让私有函数可以被查询到，你需要添加@objc关键词。</b></p>
<p>@objc private func displayTick()</p>
<p>当然啦， 对于IBOutlets, IBActions 以及 Core Data 相关属性来说，默认是可以被Objective-C Runtime查询到的。</p>
<p></p>
<p>最后，附上<a href="https://github.com/SatanWoo/WZCountDownLabel" target="_blank" rel="external">项目地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天Swift练习的是准备尝试把<a href="https://github.com/dataxpress/UICountingLabel/blob/master/UICountingLabel.m" target="_blank" rel="external">UICo]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift每日一练：圆形滑动条]]></title>
    <link href="http://satanwoo.github.io/2015/10/27/Swift-Circle-Slider/"/>
    <id>http://satanwoo.github.io/2015/10/27/Swift-Circle-Slider/</id>
    <published>2015-10-27T07:24:11.000Z</published>
    <updated>2015-10-27T08:22:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近遇到了好多人问我会不会Swift，虽然我很早就进行了Swift的学习，但是苹果对于Swift的更新真是日新月异，和我当时beta版本学习的时候大大不同了，所以，从今天起准备督促自己进行每日一练。</p>
<p>今天想要做的是一个360度的圆型滑动条。</p>
<h3 id="预览效果">预览效果</h3><p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/RotationSlider.gif"></p>
<p>细节方面还有欠缺，比如，没有进行旋转圈数的控制，同时也没有进行拖拽范围的控制。</p>
<h3 id="效果实现">效果实现</h3><p>我们首先来大致看看怎么做分解：</p>
<pre><code>-<span class="ruby"> 一个圆环
</span>-<span class="ruby"> 一个渐变色
</span>-<span class="ruby"> 一个控制球
</span>-<span class="ruby"> 一个显示文字</span>
</code></pre><p>首先看看圆环怎么实现的，很简单，我们利用Core Graphic使用如下代码即可以画出一个圆圈，只要加上描边宽度，就可以形成圆环效果。</p>
<pre><code>CGContextAddArc(
    ctx,
    self.frame.size.width/<span class="number">2</span>,
    self.frame.size.height/<span class="number">2</span>,
    self.radius,
    <span class="number">0</span>,
    <span class="number">2.0</span> * M_PI,
    <span class="number">0</span>
)
UIColor(red: <span class="number">0</span>, green: <span class="number">0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1.0</span>).<span class="built_in">set</span>()
CGContextSetLineWidth(ctx, <span class="number">72</span>)
CGContextSetLineCap(ctx, kCGLineCapButt)
CGContextDrawPath(ctx, kCGPathStroke)
</code></pre><p>然后我们的圆环背景色是渐变的，这可怎么办？我们直接使用CAGradientLayer吗？当然那是其中之一的方法，不过这次我们试试用Mask ＋ 背景色的方式实现。什么是Mask呢？简单来理解就是，如果你想做出非常复杂的形状，你可以将构造一个包含这种形状的图片，需要显示形状的地方用<strong>非白色</strong>的颜色来填充，不显示的地方用<strong>白色</strong>填充。因此，我们构建一个从上到下的渐变色背景，然后配合黑色的圆环进行Mask，就可以得到带有渐变色背景的。</p>
<pre><code><span class="built_in">CGContextSaveGState</span>(ctx)     
<span class="built_in">CGContextClipToMask</span>(ctx, <span class="keyword">self</span><span class="variable">.bounds</span>, mask)

let startColorComponents = <span class="built_in">CGColorGetComponents</span>(startColor<span class="variable">.CGColor</span>)
let endColorComponents = <span class="built_in">CGColorGetComponents</span>(endColor<span class="variable">.CGColor</span>)
let components = [
  startColorComponents[<span class="number">0</span>], startColorComponents[<span class="number">1</span>], startColorComponents[<span class="number">2</span>], <span class="number">1.0</span>,
  endColorComponents[<span class="number">0</span>], endColorComponents[<span class="number">1</span>], endColorComponents[<span class="number">2</span>], <span class="number">1.0</span>
]
let gradient = <span class="built_in">CGGradientCreateWithColorComponents</span>(<span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), components, <span class="literal">nil</span>, <span class="number">2</span>)

<span class="built_in">CGContextDrawLinearGradient</span>(
    ctx,
    gradient,
    <span class="built_in">CGPointMake</span>(<span class="built_in">CGRectGetMidX</span>(rect), <span class="built_in">CGRectGetMinY</span>(rect)),
    <span class="built_in">CGPointMake</span>(<span class="built_in">CGRectGetMidX</span>(rect), <span class="built_in">CGRectGetMaxY</span>(rect)),
    <span class="number">0</span>
);

<span class="built_in">CGContextRestoreGState</span>(ctx);
</code></pre><p>到此，绘画的工作基本就结束了，画白色小球的原理很简单，也不赘述了。我们下面来说一下根据手势来控制白色小球旋转位置，主要的思路还是控制位置来计算弧度。</p>
<pre><code>override func touchesMoved(touches: <span class="type">Set</span>&lt;<span class="type">NSObject</span>&gt;, withEvent event: <span class="type">UIEvent</span>)     {    
    //println(<span class="string">"Touches Moved"</span>)

    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first <span class="keyword">as</span>? <span class="type">UITouch</span> {
        <span class="keyword">var</span> location = touch.locationInView(self)
        moveHandle(location)
    }
}

func computeAngle(p1:<span class="type">CGPoint</span> , p2:<span class="type">CGPoint</span>) -&gt; <span class="type">Double</span> {
    <span class="keyword">var</span> delta = <span class="type">CGPoint</span>(x: p2.x - p1.x, y: p1.y - p2.y)

    <span class="keyword">let</span> radians = <span class="type">Double</span>(atan2(delta.y, delta.x))
    <span class="keyword">let</span> <span class="literal">result</span> = toDegree(radians)
    <span class="keyword">return</span> <span class="literal">result</span> &gt;= <span class="number">0</span> ? <span class="literal">result</span> : <span class="literal">result</span> + <span class="number">360</span>
}
</code></pre><p>其中，有一点我们要特别注意<br><b>var delta = CGPoint(x: p2.x - p1.x, y: p1.y - p2.y)</b>，在Y轴的计算上，我们需要进行上下翻转的计算，原因就在于我们通过UITouch拿到的location的Y坐标，是UIKit系的坐标体系，Y轴原点在上方，而我们通过绘图的时候需要进行进行Y轴的上下颠倒。</p>
<p>此外，根据计算的弧度，来更新小球的位置，由于我们是逆时针的slider，所以我们需要用 360 减去我们实际计算得到的弧度。</p>
<h3 id="一些感受">一些感受</h3><p>真的，Swift中的类型安全太恶心了，不能忍，于是只好玩起了操作符重载</p>
<pre><code><span class="func"><span class="keyword">func</span> -<span class="params">(lhs:CGFloat, rhs:Double)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> lhs - <span class="type">CGFloat</span>(rhs)
}

<span class="func"><span class="keyword">func</span> +<span class="params">(lhs:Double, rhs:CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> <span class="type">CGFloat</span>(lhs) + rhs
}

<span class="func"><span class="keyword">func</span> +<span class="params">(lhs:CGFloat, rhs:Double)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> lhs + <span class="type">CGFloat</span>(rhs)
}

<span class="func"><span class="keyword">func</span> *<span class="params">(lhs:Double, rhs:CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> <span class="type">CGFloat</span>(lhs) * rhs
}

<span class="func"><span class="keyword">func</span> *<span class="params">(lhs:CGFloat, rhs:Double)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> lhs * <span class="type">CGFloat</span>(rhs)
}

<span class="func"><span class="keyword">func</span> /<span class="params">(lhs:Double, rhs:CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> <span class="type">CGFloat</span>(lhs) / rhs
}

<span class="func"><span class="keyword">func</span> /<span class="params">(lhs:CGFloat, rhs:Double)</span></span> -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> lhs / <span class="type">CGFloat</span>(rhs)
}
</code></pre><p>最后附上<a href="https://github.com/SatanWoo/SwiftRotateSlider" target="_blank" rel="external">项目地址</a></p>
<p>好了，不多说了，我要升级El Captain了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近遇到了好多人问我会不会Swift，虽然我很早就进行了Swift的学习，但是苹果对于Swift的更新真是日新月异，和我当时beta版本学习的时候大大不同了，所以，从今天起准备督促自己进行每日一练。</p>
<p>今天想要做的是一个360度的圆型滑动条。</p>
<h3 i]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GLCaledarView 源码解读 & Glow面经]]></title>
    <link href="http://satanwoo.github.io/2015/10/14/GLCalendarView/"/>
    <id>http://satanwoo.github.io/2015/10/14/GLCalendarView/</id>
    <published>2015-10-14T01:15:52.000Z</published>
    <updated>2015-10-16T07:50:46.000Z</updated>
    <content type="html"><![CDATA[<p>今天选择了GLCalendarView来进行源码解读，一方面是因为它的实现效果简单清晰，第二方面，是我同学让我把Glow的面经给写了。</p>
<h2 id="Glow面经">Glow面经</h2><p>可能对于大多数来说，Glow相对来说还算一个比较神秘的公司，它主要致力于基于大数据分析女性健康的app的研发。</p>
<p><em>好吧，其实我也不是很懂，但是我觉得懂一点也挺好，毕竟我是有女朋友的人。</em></p>
<p>先说说我为什么会投Glow，两点原因：</p>
<ul>
<li>主要原因我是想去参加他们的开放日吃东西，然后他们的登记页面有个投简历的选项，我就投了，但是后来开放日那天我被导师拉出去开项目会议了结果就没去成。</li>
<li>他们的团队很厉害，学历上都是清华、复旦、交大、同济（其中交大和复旦排名不分先后，你们别喷我）。 初创团队都是Google出身，董事还是Paypal的创始人之一。</li>
</ul>
<p>后来9月中下旬，Glow给我安排了一次电面，商量了一个时间，电话如约而至。</p>
<h4 id="电面">电面</h4><p>电面的内容我不记得了，有一个问题是围绕Core Data展开的，问我多线程之间的Core Data搞过没，我说我搞过。后来说到在多个Context之间传输object的问题，一般情况下都是直接<b>mergeChangeFromNotification就可以了，然后你就可以在private context进行数据获取</b>，当时面试官问的一个问题是你是直接merge完了就使用了，还是[context save]提交到persistentStoreCoordinator以后通过objectID去取呢。当时我说了一个我的做法，后来我再打开我自己代码的时候，发现是因为我的app支持删后保存数据，造成了objectID不一致，所以我当时提出了刚启动的时候一定要拉去objectID，现在想想好像应该是答错了。</p>
<h4 id="现场面试">现场面试</h4><p>地狱般的6小时连续面试，累晕了。</p>
<h5 id="第一轮_iOS面试">第一轮 iOS面试</h5><p>第一轮是iOS面试，同时来了两位iOS面试官, 先上来让自我介绍下。我每次自我介绍都比较喜欢节约时间，把自己做过的所有app都装在手机上带到现场演示。于是第一轮的很多问题都是穿插着我的项目提问，具体问题我就不说了，因人而异的，所以我就说下我没答上来的知识面：</p>
<ol>
<li>UITransition</li>
<li>UIView的仿射变换对于界面层级显示的一个效果</li>
<li>他们自家app中一个动画效果制作方式，我应该是答错了</li>
</ol>
<p>这一轮给自己打个70分吧。</p>
<h5 id="第二轮_数学">第二轮 数学</h5><p>第二轮一上来我以为是产品面，结果是服务器端的一位面试官，先聊了聊自己对于做app有没有什么促进app增长的方式。然后，就开始做一道很奇怪的算法题，为什么说奇怪，是因为这题没有正确答案。然后说完思路以后就在白纸上写下来，我用C++写了。面试官问我为啥不用Objective-C写，我说Objective-C手写代码太长了，顺便我还想证明下我还会别的技术。</p>
<p>这一轮给自己打个80分。</p>
<h5 id="第三轮_英语面试">第三轮 英语面试</h5><p>第三轮是他们的产品的创始人来面我，他一上来问说他中文不好，我选择英语面试还是中文面试，我说的英语没问题，于是我们就开始了至少50分钟了全英语面试。</p>
<p>这一轮可以打个95分。</p>
<h5 id="第四轮_CTO面">第四轮 CTO面</h5><p>面试的时候我不知道他就是CTO，他还带我去外出吃了顿中饭，吃完回来就开始了面试。<br>这轮一开始先问了我怎么修一些关于多线程的Bug。然后问了我道算法题，就是求矩形相交。当时太诚实了，直接说了我做过这题，然后给出了我自己非投影的解法，于是，悲剧就从这里开始了。</p>
<p>然后CTO就给我出了一道在我看来比较奇特的题目，具体题目保密我不说了，反正就是一开始他出难的，我没答上来，他说你先简化下，做简单版本的。我做出来了，然后又切换成了复杂的，在他的提示下我还是没做出来。</p>
<p>这轮只能打30分。</p>
<h5 id="第五轮_CEO面">第五轮 CEO面</h5><p>CEO进来的时候我还在想上一轮的题目，于是悲剧又来了。我在一边想题目一边和CEO进行了握手，然后就被xx了。然后CEO提了一个让我至今非常难忘的面试题：前面面你的所有面试官他们叫什么？这下是真傻眼了。<br>可能最后比较好的是我用纯英文跟CEO聊了一段时间，估计挽回了一点分数。</p>
<p>这轮打个50分。</p>
<p>反正面试感觉有点晕，尤其是下午，战线拖的太长了，自己表现的不是很理想。具体技术题目不说了，说出来我认为是对以后面试者的一种不尊重，所以就略过了。总体面试的体验是硅谷风格，英语 ＋ 技术 ＋ 智力。</p>
<h2 id="GLCalendarView_源码解析">GLCalendarView 源码解析</h2><p>先来张效果图</p>
<!--img src="https://raw.githubusercontent.com/Glow-Inc/GLCalendarView/master/demo.gif" alt="GLCalendarView" style="max-width:100%;"-->
<p>效果还挺酷炫的，这里是它的<a href="https://github.com/Glow-Inc/GLCalendarView" target="_blank" rel="external">Github地址</a></p>
<p>从Github上的介绍来说，这款Calendar和别的同类库之间有个比较大的区别就是可以选择Date Range。从上面的效果我们也可以看出，用户可以通过手势选择一段连续日期。</p>
<h2 id="源码解析">源码解析</h2><h3 id="图层分解">图层分解</h3><p>既然是个UI的开源库，抛开内部逻辑实现来看，我们首先需要剖析它的图层结构，这样才有助于我们理解整个设计思路。</p>
<p>在看真正的源代码之前，我们首先来猜测下这玩意怎么实现的。从我个人角度出发，我一开始是这么猜测的：</p>
<ul>
<li>整体的结构应该是个UICollectionView，每个日期都是一个UICollectionViewCell。</li>
<li>每个Cell包含一个圆的背景色（如果是今天），包含一个方形的背景色(连续)，左右尽头是两个半圆的，基于这个，猜测在每个日期Cell里面包含一个背景View，填充颜色，设置圆角。</li>
<li>最上面有个悬浮的sunday - saturday的表示星期几的UIView，应该是个独立图层，添加了阴影。<b>国外人为什么喜欢把星期日当成一周的开始呢，真蛋疼。</b></li>
<li>滚动整个过程中，会出现一个显示对应月份的View，可能是个独立的UIView。</li>
<li><b>拖动过程中出现的放大镜效果，没猜出来。这个放大镜怎么做的？</b></li>
</ul>
<p>带着这些疑问我们下面进入图层分解，来一个个验证我们的猜测正确不正确。</p>
<p>当然，首先我们先大致浏览下结构，整个项目的文件结构大致如下：</p>
<pre><code>-<span class="ruby">- <span class="constant">GLCalendarDateRange</span>.h/.m
</span>-<span class="ruby">- <span class="constant">GLCalendarDayCell</span>
</span>   -<span class="ruby">- <span class="constant">GLCalendarDayCell</span>.h/.m/.xib
</span>   -<span class="ruby">- <span class="constant">GLCalendarDayCellBackgroundCover</span>.h/.m
</span>-<span class="ruby">- <span class="constant">GLCalendarMonthCoverView</span>.h/.m
</span>-<span class="ruby">- <span class="constant">GLCalendarView</span>.h/.m/.xib
</span>-<span class="ruby">- <span class="constant">GLDateUtils</span>.h/.m</span>
</code></pre><h4 id="GLCalendarDayCell">GLCalendarDayCell</h4><p>全局搜索下CollectionViewCell关键字，我们发现，果然在GLCalendarDayCell这个类里面，包含了一个UICollectionView成员。</p>
<p><b> GLCalendarDayCell采用xib式的图形化开发，只要找到对应的xib文件，对于一个界面的布局很轻松得就了然于胸了.</b></p>
<p>然后我们打开这个对应的xib文件，发现这个cell的布局包括了：</p>
<ul>
<li>底层的Cell</li>
<li>backgroundCover 的UIView</li>
<li>显示日期的UILabel</li>
<li>显示月份的UILabel</li>
</ul>
<p>这个类很简单，具体就是做了一大堆细节配置的东西，我们来说一个有意思的地方，在GLCalendarDayCell.h里面，有这个一段定义：</p>
<pre><code><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *evenMonthBackgroundColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *oddMonthBackgroundColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *dayLabelAttributes <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *futureDayLabelAttributes <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *todayLabelAttributes <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *monthLabelAttributes <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *todayBackgroundColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;
</code></pre><p>其中<b>UIAPPEARANCESELECTOR</b>可能对于很多人不熟悉，我们来看看的定义，</p>
<pre><code><span class="hexcolor">#def</span>ine UI_APPEARANCE_SELECTOR __attribute__((<span class="function"><span class="title">annotate</span><span class="params">(<span class="string">"ui_appearance_selector"</span>)</span></span>))
</code></pre><p>这个其实是一个宏，那么这个东西的作用是什么呢？<b>是为了全局配置样式！</b></p>
<p>不知道大家是否还记得我们经常会写[UINavigationBar appearance].tintColor来修改导航栏的颜色，那么这个宏的作用简单来理解就是让你的类拥有可以全局修改样式的能力，如：</p>
<pre><code><span class="string">[GLCalendarDayCell appearance]</span>.todayBackgroundColor = <span class="string">[UIColol redColor]</span>;
</code></pre><p>这个类代码虽然简单，却在实现上有个很好的地方，他把这个Cell的样式（简单来说的就是颜色，边界）交由了下面我们要提到的GLCalendarDayCellBackgroundCover类去做，也就是说，这个Cell仅仅维护状态变更的逻辑，样式有单独的样式类完成绘制。</p>
<h4 id="GLCalendarDayCellBackgroundCover">GLCalendarDayCellBackgroundCover</h4><p>这个类的作用，无它，就是画。看下他的头文件定义，大家就能瞬间明白：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">GLCalendarDayCellBackgroundCover</span> : <span class="title">UIView</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) RANGE_POSITION rangePosition;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> paddingLeft;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> paddingRight;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> paddingTop;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *fillColor;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *strokeColor;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *backgroundImage;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> borderWidth;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> inEdit;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> isToday;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> continuousRangeDisplay;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> pointSize;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> pointScale;
- (<span class="keyword">void</span>)enlargeBeginPoint:(<span class="built_in">BOOL</span>)enlarge;
- (<span class="keyword">void</span>)enlargeEndPoint:(<span class="built_in">BOOL</span>)enlarge;
<span class="keyword">@end</span>
</code></pre><p>当然，这里要提一点，画圆的几种方法：</p>
<ul>
<li>cornerRadius -&gt; GPU offscreen rendering 低性能</li>
<li>CAShaperLayer 当成mask -&gt; GPU offscreen rendering 低性能</li>
<li>drawRect + UIBeizerPath -&gt; CPU offerscreen rendering，快，但是内存开销大</li>
</ul>
<p>这里在实现圆角的时候，就用了第三种：</p>
<pre><code><span class="setting">path = <span class="value">[UIBezierPath bezierPathWithOvalInRect:rect];</span></span>
<span class="title">[path closePath]</span><span class="comment">;</span>
<span class="title">[self.fillColor setFill]</span><span class="comment">;</span>
<span class="title">[path fill]</span><span class="comment">;</span>
</code></pre><p>别的也没什么，都是具体的数学求画的位置。以如下代码为例子说明下</p>
<pre><code><span class="tag">if</span> (self.rangePosition == RANGE_POSITION_BEGIN) {
    <span class="attr_selector">[path moveToPoint:CGPointMake(radius + borderWidth + paddingLeft, paddingTop + borderWidth)]</span>;
    <span class="attr_selector">[path addArcWithCenter:CGPointMake(radius + borderWidth + paddingLeft, midY) radius:radius startAngle: - M_PI / 2 endAngle: M_PI / 2 clockwise:NO]</span>;

    <span class="attr_selector">[path addLineToPoint:CGPointMake(width, height - borderWidth - paddingTop)]</span>;
    <span class="attr_selector">[path addLineToPoint:CGPointMake(width, borderWidth + paddingTop)]</span>;

    <span class="attr_selector">[path closePath]</span>;
}
</code></pre><p><b>RANGEPOSITIONBEGIN</b>表示为左侧开头的cell，所以有个左弧度。画法过程如下：</p>
<ul>
<li>左弧度的上部顶点作为贝塞尔曲线的初始点</li>
<li>画左弧度</li>
<li>画左弧度下方的一条水平横线</li>
<li>画水平横线右端顶点向上的竖直线</li>
<li>封闭，自动会在竖直线和上部初始顶点间添加一条水平横线。</li>
</ul>
<h4 id="GLCalendarView">GLCalendarView</h4><p>最后来说下对外暴露的类，GLCalendarView。<br>这个类的实现就是一对控制逻辑，主要说下我特别感兴趣的拖动range的过程中放大镜的实现。</p>
<ul>
<li>首先这个放大镜，是个中心区域透明的图片。我一开始是纯代码编程的，真蛋疼。</li>
<li>这个放大镜底下偷偷埋了个UIImageView，每次拖动的更新的时候，都自动去截图，把截图放到这个UIImageView里面，就完成了放大镜的效果。</li>
</ul>
<p>具体的实现如下：</p>
<pre><code>- (<span class="keyword">void</span>)showMagnifierAboveDate:(<span class="built_in">NSDate</span> *)date
{
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.showMagnifier</span>) {
        <span class="keyword">return</span>;
    }
    GLCalendarDayCell *cell = (GLCalendarDayCell *)[<span class="keyword">self</span> collectionView:<span class="keyword">self</span><span class="variable">.collectionView</span> cellForItemAtIndexPath:[<span class="keyword">self</span> indexPathForDate:date]];
    <span class="built_in">CGFloat</span> delta = <span class="keyword">self</span><span class="variable">.cellWidth</span> / <span class="number">2</span>;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.draggingBeginDate</span>) {
        delta = delta;
    } <span class="keyword">else</span> {
        delta = -delta;
    }
    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.maginifierContentView</span><span class="variable">.frame</span><span class="variable">.size</span>, <span class="literal">YES</span>, <span class="number">0.0</span>);
    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();
    <span class="built_in">CGContextFillRect</span>(context, <span class="keyword">self</span><span class="variable">.maginifierContentView</span><span class="variable">.bounds</span>);
    <span class="built_in">CGContextTranslateCTM</span>(context, -cell<span class="variable">.center</span><span class="variable">.x</span> + delta, -cell<span class="variable">.center</span><span class="variable">.y</span>);
    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="keyword">self</span><span class="variable">.maginifierContentView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span> / <span class="number">2</span>, <span class="keyword">self</span><span class="variable">.maginifierContentView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span> / <span class="number">2</span>);
    [<span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.layer</span> renderInContext:context];
    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
    <span class="built_in">UIGraphicsEndImageContext</span>();

    <span class="keyword">self</span><span class="variable">.maginifierContentView</span><span class="variable">.image</span> = image;
    <span class="keyword">self</span><span class="variable">.magnifierContainer</span><span class="variable">.center</span> = [<span class="keyword">self</span> convertPoint:<span class="built_in">CGPointMake</span>(cell<span class="variable">.center</span><span class="variable">.x</span> - delta - <span class="number">58</span>, cell<span class="variable">.center</span><span class="variable">.y</span> - <span class="number">90</span>) fromView:<span class="keyword">self</span><span class="variable">.collectionView</span>];
    <span class="keyword">self</span><span class="variable">.magnifierContainer</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;
}
</code></pre><p>主要说下CGContext那块，因为发现好多人还不是特别能理解。</p>
<p><b>首先，坐标系和UIKit是反过来的！</b><br>然后这段代码做了啥呢？</p>
<ul>
<li><p>获取当前拖拽日期的对应的Cell。</p>
</li>
<li><p>创建一个画布，画布大小就是放大镜的大小。</p>
<pre><code><span class="tag">UIGraphicsBeginImageContextWithOptions</span>(<span class="tag">self</span><span class="class">.maginifierContentView</span><span class="class">.frame</span><span class="class">.size</span>, <span class="tag">YES</span>, 0<span class="class">.0</span>);
</code></pre></li>
<li><p>位移到cell的位置处进行截图，因为是CGContext画图，所以向上是正的，向下负的。</p>
<pre><code><span class="tag">CGContextTranslateCTM</span>(<span class="tag">context</span>, <span class="tag">-cell</span><span class="class">.center</span><span class="class">.x</span> + <span class="tag">delta</span>, <span class="tag">-cell</span><span class="class">.center</span><span class="class">.y</span>);
</code></pre></li>
<li><p>向上移到放大镜的中心截图，否则因为放大镜的大小是cell的高度，会包含上cell的下半部分，和下cell的上半部分。</p>
<pre><code>CGContextTranslateCTM(context, self.maginifierContentView.frame.<span class="built_in">size</span>.<span class="variable">width</span> / <span class="number">2</span>, self.maginifierContentView.frame.<span class="built_in">size</span>.<span class="variable">height</span> / <span class="number">2</span>);
</code></pre></li>
</ul>
<h4 id="Thread_Local_变量">Thread Local 变量</h4><p>在GLCalendarView里面，有一个比较有亮点的实现：</p>
<pre><code>+ (<span class="built_in">NSCalendar</span> *)calendar {
    <span class="built_in">NSMutableDictionary</span> *threadDictionary = [[<span class="built_in">NSThread</span> currentThread] threadDictionary];

    <span class="built_in">NSCalendar</span> *cal = [threadDictionary objectForKey:<span class="string">@"GLCalendar"</span>];
    <span class="keyword">if</span> (!cal) {
        cal = [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSCalendarIdentifierGregorian</span>];
        cal<span class="variable">.locale</span> = [<span class="built_in">NSLocale</span> currentLocale];
        [threadDictionary setObject:cal forKey:<span class="string">@"GLCalendar"</span>];
    }
    <span class="keyword">return</span> cal;
}
</code></pre><p>我们都知道，NSCalendar的初始化是比较耗时的，所以经验上来说一般会构建一个单例子使用。但是在这里可以看到，这里用了threadDictionary去获取thread local variable。相当于在每个使用到这个函数的线程里都构建一个thread local的单例子，那么thread local的好处有啥呢？</p>
<ul>
<li>线程安全</li>
<li>thread local cache，访问快，避免flush cache line。</li>
</ul>
<p>但是其实我个人不是很理解这么做的优势究竟有多大，请大家指点一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天选择了GLCalendarView来进行源码解读，一方面是因为它的实现效果简单清晰，第二方面，是我同学让我把Glow的面经给写了。</p>
<h2 id="Glow面经">Glow面经</h2><p>可能对于大多数来说，Glow相对来说还算一个比较神秘的公司，它主要致力]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现iOS中的函数节流和函数防抖]]></title>
    <link href="http://satanwoo.github.io/2015/09/30/Debounce-and-Throttle-in-iOS/"/>
    <id>http://satanwoo.github.io/2015/09/30/Debounce-and-Throttle-in-iOS/</id>
    <published>2015-09-30T10:44:45.000Z</published>
    <updated>2015-09-30T15:45:40.000Z</updated>
    <content type="html"><![CDATA[<h3 id="函数防抖与节流">函数防抖与节流</h3><p>今天来和大家谈论一个非常有意思的话题，就是函数节流和函数防抖。<br>可能大家还不是非常了解这两个术语的意思，让我们先来看下他们的含义吧。</p>
<blockquote><br>Throttling enforces a maximum number of times a function can be called over time. As in “execute this function at most once every 100 milliseconds.”<br></blockquote>

<p>首先是函数节流（Throttling），意思就是说一个函数在一定时间内，只能执行有限次数。比如，一个函数在100毫秒呢，最多只能执行一次。<b>当然，也可以不执行！</b></p>
<p>看完了节流，我们再来看看函数防抖（Debouncing）。</p>
<blockquote><br>Debouncing enforces that a function not be called again until a certain amount of time has passed without it being called. As in “execute this function only if 100 milliseconds have passed without it being called.”<br></blockquote>

<p>函数防抖的意思就是，一个函数被执行过一次以后，在一段时间内不能再次执行。比如，一个函数执行完了之后，100毫秒之内不能第二次执行。</p>
<p>咦？有人看到这，肯定就有疑惑了，这两玩意有啥区别啊？这么解释吧，函数防抖可能会被无限延迟。用现实乘坐公交车中的例子来说，Throttle就是准点就发车（比如15分钟一班公交车）；Debounce就是黑车，上了一个人以后，司机说，再等一个人，等不到，咱么10分钟后出发。但是呢，如果在10分钟内又有一个人上车，这个10分钟自动延后直到等待的10分钟内没人上车了。换句话说，Debounce可以理解成merge一段时间的一系列相同函数调用。</p>
<p>如果还不能理解，这里有个很好玩的<a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="external">在线演示</a> (PS:你必须用电脑上)</p>
<h3 id="JavaScript中的函数节流和防抖">JavaScript中的函数节流和防抖</h3><p>说到防抖和节流，我们就不得不先来提一提JavaScript中坑爹的DOM操作。我们直接看underscore.js中的源码：<br>首先是Throttle：</p>
<pre><code>_.throttle = function(func, wait) {
  <span class="keyword">var</span> context, args, <span class="literal">result</span>;
  <span class="keyword">var</span> timeout = null;

  <span class="keyword">var</span> previous = <span class="number">0</span>;
  <span class="keyword">var</span> later = function() {
    // 若设定了开始边界不执行选项，上次执行时间始终为<span class="number">0</span>
    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();
    timeout = null;
    <span class="literal">result</span> = func.apply(context, args);
    <span class="keyword">if</span> (!timeout) context = args = null;
  };
  <span class="keyword">return</span> function() {
    <span class="keyword">var</span> now = _.now();
    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。
    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;
    // 延迟执行时间间隔
    <span class="keyword">var</span> remaining = wait - (now - previous);
    context = this;
    args = arguments;
    // 延迟时间间隔remaining小于等于<span class="number">0</span>，表示上次执行至此所间隔时间已经超过一个时间窗口
    // remaining大于时间窗口wait，表示客户端系统时间被调整过
    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      <span class="literal">result</span> = func.apply(context, args);
      <span class="keyword">if</span> (!timeout) context = args = null;
    //如果延迟执行不存在，且没有设定结尾边界不执行选项
    } <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) {
      timeout = setTimeout(later, remaining);
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
  };
};
</code></pre><p>代码逻辑非常好理解，</p>
<pre><code><span class="variable"><span class="keyword">var</span> remaining</span> = wait - (now - previous);
</code></pre><p>就是计算下上一次调用的时间和现在所处的时间间隔是不是超过了wait的时间<b>（这个时间只有可能会大于等于wait，因为runloop是很繁忙的，前面一个任务很耗时，那你就多等一会呗）</b>。<br>可能会有人不理解option是啥意思，我们看下代码中涉及了以下两个参数：</p>
<pre><code><span class="tag">options</span><span class="class">.leading</span>和<span class="tag">options</span><span class="class">.trailing</span>
</code></pre><p>这两个参数的意思就是禁止第一次调用和最后一次调用，简单吧。</p>
<p>理解了函数节流，我们再来看看防抖是怎么做的。<br>    _.debounce = function(func, wait, immediate) {<br>      var timeout, args, context, timestamp, result;</p>
<pre><code>  <span class="keyword">var</span> later = function() {
    // 据上一次触发时间间隔
    <span class="keyword">var</span> last = _.now() - timestamp;

    // 上次被包装函数被调用时间间隔last小于设定时间间隔wait
    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="number">0</span>) {
      timeout = setTimeout(later, wait - last);
    } <span class="keyword">else</span> {
      timeout = null;
      // 如果设定为immediate===<span class="literal">true</span>，因为开始边界已经调用过了此处无需调用
      <span class="keyword">if</span> (!immediate) {
        <span class="literal">result</span> = func.apply(context, args);
        <span class="keyword">if</span> (!timeout) context = args = null;
      }
    }
  };

  <span class="keyword">return</span> function() {
    context = this;
    args = arguments;
    timestamp = _.now();
    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;
    // 如果延时不存在，重新设定延时
    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);
    <span class="keyword">if</span> (callNow) {
      <span class="literal">result</span> = func.apply(context, args);
      context = args = null;
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
  };
};
</code></pre><p>可以看到，在防抖的函数中包含了一个<b>timestamp</b>，这个参数用来记录了当前这个函数最后一次被调用是什么时候，每次调用的时候，就更新了timestamp。有人可能会问，这个timestamp在多次调用的过程中还能保留吗？<b>答案是肯定的，debounce函数返回的实际是一个匿名函数，这个匿名函数就是一个闭包环境，可以捕捉timestap进行持久话访问，所以多次调用这个匿名函数实际上访问的都是同一个timestamp。</b></p>
<h3 id="实现iOS中的函数节流">实现iOS中的函数节流</h3><p>重头戏来啦！！！！。<br>在iOS中，我们经常会遇到这样的需求，比如说你要根据UIScrollView的contentOffset进行某些计算。这些计算有的很简单不耗时，比如根据offset动态的更改UINavigationBar的alpha值。但是有些就很复杂，比如你要根据某些offset启动某些动画，或者进行大规模的运算，还有很多时候时候会发送很多异步的API请求，由于很多用户会不停的用指尖在完美的iPhone屏幕上来回滑动，你一定不想你的App甚至是服务器这些操作给玩崩了，所以，函数节流是必不可少的。</p>
<h4 id="初级版本">初级版本</h4><p>第一个版本的函数节流如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">"PerformSelectorWithDebounce.h"</span></span>
<span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span>
<span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Throttle</span>)</span>

<span class="keyword">const</span> <span class="keyword">char</span> * WZThrottledSelectorKey;

- (<span class="keyword">void</span>) wz_performSelector:(SEL)aSelector withThrottle:(<span class="built_in">NSTimeInterval</span>)duration
{
    <span class="built_in">NSMutableDictionary</span> *blockedSelectors = objc_getAssociatedObject(<span class="keyword">self</span>, WZThrottledSelectorKey);

    <span class="keyword">if</span>(!blockedSelectors)
    {
        blockedSelectors = [<span class="built_in">NSMutableDictionary</span> dictionary];
        objc_setAssociatedObject(<span class="keyword">self</span>, kDictionaryOfSelectorsToBlock, blockedSelectors, OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);
    }

    <span class="built_in">NSString</span> * selectorName = <span class="built_in">NSStringFromSelector</span>(aSelector);
    <span class="keyword">if</span>(![blockedSelectors objectForKey:aSelectorAsStr])
    {
        [blockedSelectors setObject:selectorName selectorName];

        objc_msgSend(<span class="keyword">self</span>, aSelector);
        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(unlockSelector:) withObject:aSelectorAsStr afterDelay:duration];

    }
}

-(<span class="keyword">void</span>)unlockSelector:(<span class="built_in">NSString</span>*)selectorAsString
{
    <span class="built_in">NSMutableDictionary</span> *blockedSelectors = objc_getAssociatedObject(<span class="keyword">self</span>, WZThrottledSelectorKey);
    [blockedSelectors removeObjectForKey:selectorAsString];
}
</code></pre><p>初看这个代码逻辑，这个代码基本实现了在一定时间内只调用有限次数的函数。但是，这哪是函数节流啊，这是函数断流！不信你们在<b>[UIScrollView scrollViewDidScroll]</b>试试看，你们就知道啥叫断流了。<b>原因也很简单，我们的unlockSelector是基于performSelector解锁的，而performSelector是基于runloop的，我们在不停的滚动的时候就会导致整个主runloop被我们占用，因此，unlock的函数一直没有得到调用，结果就导致了断流。</b></p>
<h4 id="高级版本">高级版本</h4><p>因此，我又实现了一个高级版本，代码如下，需要测试用例和源码的可以上我的github自取，<a href="https://github.com/SatanWoo/iOSThrottle" target="_blank" rel="external">地址戳我</a>。代码逻辑很简单同时也解决了上述版本所提及的问题。</p>
<pre><code><span class="preprocessor">#import <span class="title">"NSObject+Throttle.h"</span></span>
<span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span>
<span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span>

<span class="keyword">static</span> <span class="keyword">char</span> WZThrottledSelectorKey;
<span class="keyword">static</span> <span class="keyword">char</span> WZThrottledSerialQueue;

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Throttle</span>)</span>

- (<span class="keyword">void</span>)wz_performSelector:(SEL)aSelector withThrottle:(<span class="built_in">NSTimeInterval</span>)inteval
{
    <span class="built_in">dispatch_async</span>([<span class="keyword">self</span> getSerialQueue], ^{
        <span class="built_in">NSMutableDictionary</span> *blockedSelectors = [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSelectorKey) mutableCopy];

        <span class="keyword">if</span> (!blockedSelectors) {
            blockedSelectors = [<span class="built_in">NSMutableDictionary</span> dictionary];
            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSelectorKey, blockedSelectors, OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span>);
        }

        <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(aSelector);
        <span class="keyword">if</span> (![blockedSelectors objectForKey:selectorName]) {
            [blockedSelectors setObject:selectorName forKey:selectorName];
            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSelectorKey, blockedSelectors, OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span>);

            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
                objc_msgSend(<span class="keyword">self</span>, aSelector);

                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(inteval * <span class="built_in">NSEC_PER_SEC</span>)), [<span class="keyword">self</span> getSerialQueue], ^{
                    [<span class="keyword">self</span> unlockSelector:selectorName];
                });
            });
        }
    });
}

<span class="preprocessor">#pragma mark - Private</span>
- (<span class="keyword">void</span>)unlockSelector:(<span class="built_in">NSString</span> *)selectorName
{
    <span class="built_in">dispatch_async</span>([<span class="keyword">self</span> getSerialQueue], ^{
        <span class="built_in">NSMutableDictionary</span> *blockedSelectors = [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSelectorKey) mutableCopy];

        <span class="keyword">if</span> ([blockedSelectors objectForKey:selectorName]) {
            [blockedSelectors removeObjectForKey:selectorName];
        }

        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSelectorKey, blockedSelectors, OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span>);
    });
}

- (<span class="built_in">dispatch_queue_t</span>)getSerialQueue
{
    <span class="built_in">dispatch_queue_t</span> serialQueur = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSerialQueue);
    <span class="keyword">if</span> (!serialQueur) {
        serialQueur = dispatch_queue_create(<span class="string">"com.satanwoo.throttle"</span>, <span class="literal">NULL</span>);
        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;WZThrottledSerialQueue, serialQueur, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);
    }
    <span class="keyword">return</span> serialQueur;
}

<span class="keyword">@end</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="函数防抖与节流">函数防抖与节流</h3><p>今天来和大家谈论一个非常有意思的话题，就是函数节流和函数防抖。<br>可能大家还不是非常了解这两个术语的意思，让我们先来看下他们的含义吧。</p>
<blockquote><br>Throttling enforce]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flux源码解析（一）]]></title>
    <link href="http://satanwoo.github.io/2015/09/23/flux-js-part-one/"/>
    <id>http://satanwoo.github.io/2015/09/23/flux-js-part-one/</id>
    <published>2015-09-23T10:37:36.000Z</published>
    <updated>2015-09-23T16:20:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Flux源码解析_第一章">Flux源码解析 第一章</h3><p>Flux是Facebook推出的一个新的Web架构，用来构建新一代的客户端的Web程序，今天我们来解析下其中的源码：Dispatcher.js和Invariant.js</p>
<h4 id="准备工作">准备工作</h4><p>建议大家先了解一下什么是Flux架构，Facebook的官网上有非常详细的解释:<a href="http://facebook.github.io/flux/docs/overview.html#content" target="_blank" rel="external">链接点我</a></p>
<h4 id="Invariant-js">Invariant.js</h4><p>首先让我们来看下Invariant.js的代码内容，非常短：</p>
<pre><code><span class="pi">"use strict"</span>;

<span class="keyword">var</span> invariant = <span class="function"><span class="keyword">function</span>(<span class="params">condition, format, a, b, c, d, e, f</span>) </span>{
  <span class="number">1.</span> 
  <span class="keyword">if</span> (__DEV__) {
    <span class="keyword">if</span> (format === <span class="literal">undefined</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'invariant requires an error message argument'</span>);
    }
  }

  <span class="number">2.</span> 
  <span class="keyword">if</span> (!condition) {
    <span class="keyword">var</span> error;
    <span class="keyword">if</span> (format === <span class="literal">undefined</span>) {
      error = <span class="keyword">new</span> <span class="built_in">Error</span>(
        <span class="string">'Minified exception occurred; use the non-minified dev environment '</span> +
        <span class="string">'for the full error message and additional helpful warnings.'</span>
      );
    } <span class="keyword">else</span> {
      <span class="keyword">var</span> args = [a, b, c, d, e, f];
      <span class="keyword">var</span> argIndex = <span class="number">0</span>;
      error = <span class="keyword">new</span> <span class="built_in">Error</span>(
        <span class="string">'Invariant Violation: '</span> +
        format.replace(<span class="regexp">/%s/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> args[argIndex++]; })
      );
    }

    error.framesToPop = <span class="number">1</span>; <span class="comment">// we don't care about invariant's own frame</span>
    <span class="keyword">throw</span> error;
  }
};

<span class="built_in">module</span>.exports = invariant;
</code></pre><p>‘use strict’ 不必多说，就是构建了一个严格的JS的执行环境。<br>整个Invariant.js其实就是定义了一个函数, 名字叫Invariant， 他的参数包含一个condition（判断条件），一个自定义的报错格式，以及一系列的自定义参数。</p>
<p><b>第一次读Flux.js源码的时候，这里采用的还是arguments可变参数的定义方式，今天写这篇文章的时候竟然就改写了，晕！</b></p>
<p>然后我们来分两个段落查看下其中的代码含义。</p>
<p>第一部分，定义了一个<strong>dev</strong>变量，这个变量就是一种类似于配置的环境变量。玩过JavaScript或者ruby的人可能都有所了解，比如非常著名的’development’, ‘product’, ‘test’就是与之类似的。<br>如果没有format是个未定义的变量（在这里就是没有传入第二个参数），那么就保个错。</p>
<p>第二部分也很简单，如果condition为假值，说明这个条件没被满足，那么执行报错的功能，报错的时候使用的提示格式就是传入的format, 参数则为自定义的a-f。</p>
<p>总之，这个Invariant.js的作用就是构建了一个类似<b>iOS中NSAssert</b>的东西。</p>
<p>哦，这里要指出一下 <b>/%s/g</b>这个正则表达式，这玩意啥意思呢。其实就类似于我们常常用的printf函数，可以简单理解为，把format中所有的%s, 替换成自定义的参数，g表示为global。</p>
<h4 id="重点:Dispatcher-js">重点:Dispatcher.js</h4><p>再让我们来看一看Dispatcher.js，闲话不多话，上代码。</p>
<pre><code><span class="pi">'use strict'</span>;

<span class="keyword">var</span> invariant = <span class="built_in">require</span>(<span class="string">'./invariant'</span>);

<span class="keyword">export</span> <span class="keyword">type</span> DispatchToken = <span class="built_in">string</span>;

<span class="keyword">var</span> _prefix = <span class="string">'ID_'</span>;

<span class="keyword">class</span> Dispatcher&lt;TPayload&gt; {
  _callbacks: {[key: DispatchToken]: (payload: TPayload) =&gt; <span class="built_in">void</span>};
  _isDispatching: <span class="built_in">boolean</span>;
  _isHandled: {[key: DispatchToken]: <span class="built_in">boolean</span>};
  _isPending: {[key: DispatchToken]: <span class="built_in">boolean</span>};
  _lastID: <span class="built_in">number</span>;
  _pendingPayload: TPayload;

  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="keyword">this</span>._callbacks = {};
    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;
    <span class="keyword">this</span>._isHandled = {};
    <span class="keyword">this</span>._isPending = {};
    <span class="keyword">this</span>._lastID = <span class="number">1</span>;
  }


  unregister(id: DispatchToken): <span class="built_in">void</span> {
    invariant(
      <span class="keyword">this</span>._callbacks[id],
      <span class="string">'Dispatcher.unregister(...): `%s` does not map to a registered callback.'</span>,
      id
    );
    <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks[id];
  }

  waitFor(ids: <span class="built_in">Array</span>&lt;DispatchToken&gt;): <span class="built_in">void</span> {
    invariant(
      <span class="keyword">this</span>._isDispatching,
      <span class="string">'Dispatcher.waitFor(...): Must be invoked while dispatching.'</span>
    );
    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; ids.length; ii++) {
      <span class="keyword">var</span> id = ids[ii];
      <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) {
        invariant(
          <span class="keyword">this</span>._isHandled[id],
          <span class="string">'Dispatcher.waitFor(...): Circular dependency detected while '</span> +
          <span class="string">'waiting for `%s`.'</span>,
          id
        );
        <span class="keyword">continue</span>;
      }
      invariant(
        <span class="keyword">this</span>._callbacks[id],
        <span class="string">'Dispatcher.waitFor(...): `%s` does not map to a registered callback.'</span>,
        id
      );
      <span class="keyword">this</span>._invokeCallback(id);
    }
  }

  dispatch(payload: TPayload): <span class="built_in">void</span> {
    invariant(
      !<span class="keyword">this</span>._isDispatching,
      <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>
    );
    <span class="keyword">this</span>._startDispatching(payload);
    <span class="keyword">try</span> {
      <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) {
        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) {
          <span class="keyword">continue</span>;
        }
        <span class="keyword">this</span>._invokeCallback(id);
      }
    } <span class="keyword">finally</span> {
      <span class="keyword">this</span>._stopDispatching();
    }
  }

  isDispatching(): <span class="built_in">boolean</span> {
    <span class="keyword">return</span> <span class="keyword">this</span>._isDispatching;
  }

  _invokeCallback(id: DispatchToken): <span class="built_in">void</span> {
    <span class="keyword">this</span>._isPending[id] = <span class="literal">true</span>;
    <span class="keyword">this</span>._callbacks[id](<span class="keyword">this</span>._pendingPayload);
    <span class="keyword">this</span>._isHandled[id] = <span class="literal">true</span>;
  }

  _startDispatching(payload: TPayload): <span class="built_in">void</span> {
    <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) {
      <span class="keyword">this</span>._isPending[id] = <span class="literal">false</span>;
      <span class="keyword">this</span>._isHandled[id] = <span class="literal">false</span>;
    }
    <span class="keyword">this</span>._pendingPayload = payload;
    <span class="keyword">this</span>._isDispatching = <span class="literal">true</span>;
  }

  _stopDispatching(): <span class="built_in">void</span> {
    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;
    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;
  }
}

<span class="module"><span class="keyword">module</span>.exports = Dispatcher;</span>
</code></pre><p>首先我们来看一下这句话：</p>
<pre><code><span class="keyword">export</span> <span class="keyword">type</span> DispatchToken = <span class="built_in">string</span>;
</code></pre><p>这其实就是一个typedef，那么DispatchToken是什么意思呢？如果你本文最上方的Flux解答的话，你就可以了解到，其实一个Flux的回调代码块有唯一的一个token，这个token就是用来让别人Invokoe你代码的。</p>
<p>那么这个DispatchToken怎么确保唯一呢？看下面这句话：</p>
<pre><code><span class="keyword">var</span> id = _prefix + <span class="keyword">this</span>._lastID++;
</code></pre><p>第一感觉是不是想，我了个擦，怎么那么简单。后来想想，JavaScript在浏览器中执行就是单线程，这种自增ID的做法又快又安全呐。</p>
<p>下面我们来解释一下Dispatcher这个类，这个类的目的很简单，六个字归纳一下：唯一，中控，分配。<br>可以把他看成一个单例对象，所有的任务分发都必须由这个类统一控制。</p>
<p>那么，这个类中包含了哪些玩意呢？让我们赶快来一探究竟！</p>
<pre><code><span class="rule"><span class="attribute">_callbacks</span>:<span class="value"> {[key: DispatchToken]: (payload: TPayload) =&gt; void}</span></span>;
<span class="rule"><span class="attribute">_isDispatching</span>:<span class="value"> boolean</span></span>;
<span class="rule"><span class="attribute">_isHandled</span>:<span class="value"> {[key: DispatchToken]: boolean}</span></span>;
<span class="rule"><span class="attribute">_isPending</span>:<span class="value"> {[key: DispatchToken]: boolean}</span></span>;
<span class="rule"><span class="attribute">_lastID</span>:<span class="value"> number</span></span>;
<span class="rule"><span class="attribute">_pendingPayload</span>:<span class="value"> TPayload</span></span>;
</code></pre><ul>
<li>callbacks，就是DispatchToken和函数回调的一个Dictionary。</li>
<li>isDispatching，体现当前Dispatcher是否处于dispatch状态。</li>
<li>isHandled，通过token去检测一个函数是否被处理过了。</li>
<li>isPending，通过token去检测一个函数是否被提交Dispatcher了。</li>
<li>lastID，最近一次被加入Dispatcher的函数体的UniqueID，即DispatchToken。</li>
<li>pendingPayload，需要传递给调用函数的参数，iOS开发者可以理解为<b>userInfo</b>。</li>
</ul>
<p>下面我们一个个函数来看看。</p>
<pre><code><span class="keyword">register</span>(callback: (payload: TPayload) =&gt; <span class="keyword">void</span>): DispatchToken {
    var <span class="keyword">id</span> = _prefix + <span class="keyword">this</span><span class="variable">._lastID</span>++;
    <span class="keyword">this</span><span class="variable">._callbacks</span>[<span class="keyword">id</span>] = callback;
    <span class="keyword">return</span> <span class="keyword">id</span>;
}
</code></pre><p>这函数就是注册一个callback进入dispatcher，同时为这个callback生成DispatchToken，加入字典。</p>
<pre><code>unregister(<span class="property">id</span>: DispatchToken): void {
    invariant(
      this._callbacks[<span class="property">id</span>],
      'Dispatcher.unregister(...): `%s` <span class="keyword">does</span> <span class="keyword">not</span> map <span class="keyword">to</span> a registered callback.',
      <span class="property">id</span>
    );
    delete this._callbacks[<span class="property">id</span>];
}
</code></pre><p>有注册就有取消注册，unregister就是通过DispatchToken将注册的callback从字典中删除。当然了，这里使用了我们在上文中提过的Invariant来进行一个判断：即字典中必须包含对应这个DispatchToken的函数。</p>
<p>dispatch函数是Dispatcher用来分发payload的函数。</p>
<pre><code>dispatch(payload: TPayload): <span class="keyword">void</span> {
    invariant(
      !<span class="keyword">this</span>._isDispatching,
      <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>
    );
    <span class="keyword">this</span>._startDispatching(payload);
    <span class="keyword">try</span> {
      <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) {
        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) {
          <span class="keyword">continue</span>;
        }
        <span class="keyword">this</span>._invokeCallback(id);
      }
    } <span class="keyword">finally</span> {
      <span class="keyword">this</span>._stopDispatching();
    }
  }
</code></pre><p>整个函数的含义就是，首先是判断当前Dispatcher是否已经处于Dispatching状态中了，如果是，不能打断。然后通过_startDispatching更新状态。更新状态结束以后，将非pending状态的callback进通过_invokeCallback执行<b>（pending在这里的含义可以简单理解为，还没准备好或者被卡住了）</b>。所有执行完了以后，通过_stopDispatching恢复状态。</p>
<p>接下来便让我一一来看看其中涉及的几个函数，首先是_startDispatching函数。</p>
<pre><code>_startDispatching(payload: TPayload): <span class="keyword">void</span> {
    <span class="keyword">for</span> (var <span class="keyword">id</span> <span class="keyword">in</span> <span class="keyword">this</span><span class="variable">._callbacks</span>) {
      <span class="keyword">this</span><span class="variable">._isPending</span>[<span class="keyword">id</span>] = <span class="literal">false</span>;
      <span class="keyword">this</span><span class="variable">._isHandled</span>[<span class="keyword">id</span>] = <span class="literal">false</span>;
    }
    <span class="keyword">this</span><span class="variable">._pendingPayload</span> = payload;
    <span class="keyword">this</span><span class="variable">._isDispatching</span> = <span class="literal">true</span>;
  }
</code></pre><p>首先该函数将所有注册的callback的状态都清空，并标记Dispatcher的状态进入dispatching。</p>
<p>同样，与之对应的有的_stopDispatching，函数很简单，不具体解释了。</p>
<pre><code>_stopDispatching(): <span class="keyword">void</span> {
    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;
    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;
}
</code></pre><p>而_invokeCallback函数也很简单，当真正调用callback之前将其状态设置为pending，执行完成之后设置为handled。<br>    _invokeCallback(id: DispatchToken): void {<br>        this._isPending[id] = true;<br>        this._callbacks<a href="this._pendingPayload">id</a>;<br>        this._isHandled[id] = true;<br>      }</p>
<p>读到这里，有些人可能有些疑问，这个pending到底是用来做什么的呢？别着急，看了下面这个最重要的函数waitFor，你就会了解。</p>
<pre><code>waitFor(ids: Array&lt;DispatchToken&gt;): void {
     <span class="number">1.</span> 
    invariant(
      this._isDispatching,
      'Dispatcher.waitFor(...): Must be invoked <span class="keyword">while</span> dispatching.'
    );

     <span class="number">2.</span>
    <span class="keyword">for</span> (var ii = <span class="number">0</span>; ii &lt; ids.<span class="property">length</span>; ii++) {
      var <span class="property">id</span> = ids[ii];
      <span class="keyword">if</span> (this._isPending[<span class="property">id</span>]) {
        <span class="number">3.</span> 
        invariant(
          this._isHandled[<span class="property">id</span>],
          'Dispatcher.waitFor(...): Circular dependency detected <span class="keyword">while</span> ' +
          'waiting <span class="keyword">for</span> `%s`.',
          <span class="property">id</span>
        );
        <span class="keyword">continue</span>;
      }
       <span class="number">4.</span>
      invariant(
        this._callbacks[<span class="property">id</span>],
        'Dispatcher.waitFor(...): `%s` <span class="keyword">does</span> <span class="keyword">not</span> map <span class="keyword">to</span> a registered callback.',
        <span class="property">id</span>
      );

      <span class="number">5.</span>
      this._invokeCallback(<span class="property">id</span>);
    }
  }
</code></pre><p>这个waitFor啥意思呢？我们首先看下他的参数，一个数组，里面全是DispatchToken。再看下实现。</p>
<ul>
<li>首先是一个Invariant判断当前必须处于Dispatching状态。一开始比较难理解，简单来说就是，如果不处于Dispatching状态中，那么说明压根没有函数在执行，那你等谁呢？</li>
<li>然后该函数从DispatchToken的数组中进行遍历，如果遍历到的DispatchToken处于pending状态，就暂时跳过他。</li>
<li>但是，在这有个必要的循环以来的检查，试想如下情况，如果A函数以来B的Token, B函数依赖A的Token，就会造成“死锁”。<b>所以，当一个函数依赖的对象处于pending，说明这个函数已经被开始执行了，但是如果同时该函数没有进入handled状态，说明该函数也被卡死了。</b></li>
<li>检查token对应的callback是否存在</li>
<li>调用这个token对应的函数。</li>
</ul>
<p>从上诉步骤中，我们可以看到，waitFor就是一个等待函数，当B执行，执行到某些条件不满足的时候（我们称之为依赖没解决），就是等待依赖去完成，简单来说，就是如下函数代表的意思：</p>
<pre><code><span class="keyword">while</span> (!satisfied) ; <span class="keyword">do</span>Something
</code></pre><p>到这里，差不多Dispatcher.js就解释完了，下次继续。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Flux源码解析_第一章">Flux源码解析 第一章</h3><p>Flux是Facebook推出的一个新的Web架构，用来构建新一代的客户端的Web程序，今天我们来解析下其中的源码：Dispatcher.js和Invariant.js</p>
<h4 id="准]]>
    </summary>
    
      <category term="JavaScript" scheme="http://satanwoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSONModel源码解析]]></title>
    <link href="http://satanwoo.github.io/2015/09/17/code-of-JSONModel/"/>
    <id>http://satanwoo.github.io/2015/09/17/code-of-JSONModel/</id>
    <published>2015-09-17T12:52:12.000Z</published>
    <updated>2015-09-17T13:15:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="背景介绍">背景介绍</h3><p>现在的移动App基本上免不了和网络传输打交道，我们经常需要和服务器进行数据的传输，常用的数据格式无外乎XML或者JSON。这也就引出了一个新的话题，如何将获得的数据实际应用到我们的App中？答案很简单，建立Model。我们拿到的网络传输数据，无非就是一种以JSON格式标准划分的字符串罢了，我们需要将字符串解析到相应的字段中来，否则如果每次我们都需要直接和网络字符串打交道，那也太复杂了。在刚学习iOS开发的时候，那个时候看了Stanford老爷爷讲的开发教程，里面在涉及<b>Core Data</b>的章节曾经写过这样的一段代码：</p>
<pre><code>+ (XXXModel *)insertModelWithDictionary:(<span class="built_in">NSDictionary</span> *)dict inContext:(<span class="built_in">NSManagedObjectContext</span> *)context
{
    <span class="keyword">if</span> (dict == <span class="literal">nil</span> || ![dict isKindOf[<span class="built_in">NSDictionary</span> class]]) <span class="keyword">return</span> <span class="literal">nil</span>;

    XXXModel *model = [XXXModel getByIdentifier:[dict objectForKey:<span class="string">@"id"</span>] inContext:context];
    <span class="keyword">if</span> (!model) {
        model = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"XXXModel"</span> 
                                              inManagedObjectContext:context];
    }

    model<span class="variable">.identifier</span> = [dict objectForKey:<span class="string">@"id"</span>];
    model<span class="variable">.name</span>       = [dict objectForKey:<span class="string">@"name"</span>];
    model<span class="variable">.age</span>        = [dict objectForKey:<span class="string">@"age"</span>];

    <span class="comment">// 许多许多属性 </span>
    ......
    ......
    ......

    <span class="keyword">return</span> model;
}

+ (XXXModel *)getByIdentifier:(<span class="built_in">NSString</span> *)identifier inContext:(<span class="built_in">NSManagedObjectContext</span> *)context
{
    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"XXXModel"</span>];
    [request setPredicate:[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"identifier == %@"</span>, identifier]];

    XXXModel *model = [[context executeFetchRequest:request error:<span class="literal">nil</span>] lastObject];
    <span class="keyword">return</span> model;
}
</code></pre><p>当时一直以为这个是<b>圣经式的写法</b>，一直坚持着，直到后来我接触到了<b>Mantle</b>。当然，今天这篇文章说的不是Mantle，而是另外一个类似的开源库：<b>JSONModel</b></p>
<h3 id="JSONModel">JSONModel</h3><p>既然要解析它，首先先放上他的代码地址以示尊重：<a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="external">点我点我!</a></p>
<p>从Github上的介绍来看，利用JSONModel，我们可以节省大量的时间，它会利用类似于反射(Introspect)的机制，帮助我们自动将JSON的数据解析成Model的字段。</p>
<p>它的用法也很简单，比如有如下这样的JSON数据：</p>
<pre><code>{"<span class="attribute">id</span>":<span class="value"><span class="string">"10"</span></span>, "<span class="attribute">country</span>":<span class="value"><span class="string">"Germany"</span></span>, "<span class="attribute">dialCode</span>": <span class="value"><span class="number">49</span></span>, "<span class="attribute">isInEurope</span>":<span class="value"><span class="literal">true</span></span>}
</code></pre><p>你只需要建立如下这样的Model：</p>
<pre><code><span class="preprocessor">#import <span class="title">"JSONModel.h"</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">CountryModel</span> : <span class="title">JSONModel</span></span>

<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> <span class="keyword">id</span>;
<span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span>* country;
<span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span>* dialCode;
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> isInEurope;

<span class="keyword">@end</span>
</code></pre><p>然后像这样：</p>
<pre><code>NSString<span class="keyword">*</span> json = (fetch here JSON from Internet) ... 
NSError<span class="keyword">*</span> err = nil;
CountryModel<span class="keyword">*</span> country = [[CountryModel alloc] initWithString:json error:&amp;err];
</code></pre><p>嘿嘿，JSON的数据就成功得被解析到country这个变量的对应字段上了！</p>
<p>是不是很神奇？让我们赶快来一探背后的原理吧！！！</p>
<h3 id="源码分析">源码分析</h3><p>下载源代码，我们可以看到如下格式的包内容：</p>
<pre>
-- JSONModel
   -- JSONModel.h/.m
   -- JSONModelArray.h/.m
   -- JSONModelClassProperty.h/.m
   -- JSONModelError.h/.m
-- JSONModelCategories
   -- NSArray+JSONModel.h/.m
-- JSONModelNetworking
   -- 略
-- JSONModelTransformations
   -- JSONKeyMapper.h/.m
   -- JSONValueTransformer.h/.m
</pre>

<p>我们把JSONModelNetworking中的内容略过，因为基本就是网络传输的东西，不是我们了解的重点。</p>
<h4 id="JSONModel文件">JSONModel文件</h4><p>JSONModel是我们要讲解的重点，我们首先从它的初始化方法谈起。</p>
<pre><code><span class="pp">-<span class="params">(instancetype)</span>initWithString:<span class="params">(<span class="variable">NSString</span>*)</span>string error:<span class="params">(<span class="variable">JSONModelError</span>**)</span>err;
-<span class="params">(instancetype)</span>initWithString:<span class="params">(<span class="variable">NSString</span> *)</span>string usingEncoding:<span class="params">(<span class="variable">NSStringEncoding</span>)</span>encoding error:<span class="params">(<span class="variable">JSONModelError</span>**)</span>err;
-<span class="params">(instancetype)</span>initWithDictionary:<span class="params">(<span class="variable">NSDictionary</span>*)</span>dict error:<span class="params">(<span class="variable">NSError</span> **)</span>err;
-<span class="params">(instancetype)</span>initWithData:<span class="params">(<span class="variable">NSData</span> *)</span>data error:<span class="params">(<span class="variable">NSError</span> **)</span>error;</span>
</code></pre><p>粗略一看，四个初始化方法，太可怕了。但是我们知道在iOS的设计理念里，有一种designated initializer的说法，因此，我们挑一个<b>initWithDictionary</b>看起。</p>
<h5 id="initWithDictionary">initWithDictionary</h5><pre><code>-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err
{
    <span class="number">1.</span> <span class="comment">//check for nil input</span>
    <span class="keyword">if</span> (!dict) {
        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="number">2.</span> <span class="comment">//invalid input, just create empty instance</span>
    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) {
        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="number">3.</span> <span class="comment">//create a class instance</span>
    <span class="keyword">self</span> = [<span class="keyword">self</span> init];
    <span class="keyword">if</span> (!<span class="keyword">self</span>) {

        <span class="comment">//super init didn't succeed</span>
        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }
    <span class="comment">// Class infoClass = NSClassFromString([NSString stringWithFormat:@"%@Info", NSStringFromClass(class)]);</span>
    <span class="number">4.</span> <span class="comment">//check incoming data structure</span>
    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span><span class="variable">.__keyMapper</span> error:err]) {
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="number">5.</span> <span class="comment">//import the data from a dictionary</span>
    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span><span class="variable">.__keyMapper</span> validation:<span class="literal">YES</span> error:err]) {
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="number">6.</span> <span class="comment">//run any custom model validation</span>
    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) {
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="number">7.</span> <span class="comment">//model is valid! yay!</span>
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>我们分七步来解析这个函数：</p>
<ul>
<li>检查参数dict是不是空，是空直接解析失败</li>
<li>检查参数dict是不是NSDictionary或其子类的实例，是空直接解析失败</li>
<li><b>关键步骤</b>：创建JSONModel，创建失败直接滚粗，千万别小看这一步哦，具体我们下文说</li>
<li><b>关键步骤</b>：这是一个通过检查是不是有没被映射到的property的过程，如果有存在疏漏的property，那么会导致解析失败，触发Crash</li>
<li><b>关键步骤</b>：这是真正将解析的值对应的赋予Model的property的阶段</li>
<li>进行自定义的检查工作，比如避免直接触发Crash之类的</li>
<li>得到了正确的model，返回给程序使用。</li>
</ul>
<p>下面我们来着重分析最重要的三个步骤</p>
<h5 id="重点1:_第三步_[self_init]">重点1: 第三步 [self init]</h5><p>[self init]的代码调用了init初始化函数，实现如下，我们主要关注的是其中<em>[self <strong>setup</strong>]</em></p>
<pre><code>- (id)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        <span class="regexp">//do</span> initial <span class="class"><span class="keyword">class</span> <span class="title">setup</span></span>
        [<span class="keyword">self</span> __setup__];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>来看看setup的实现，</p>
<pre><code>- (<span class="keyword">void</span>)__setup__
{
    <span class="comment">//if first instance of this model, generate the property list</span>
    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span><span class="variable">.class</span>, &amp;kClassPropertiesKey)) {
        [<span class="keyword">self</span> __inspectProperties];
    }

    <span class="comment">//if there's a custom key mapper, store it in the associated object</span>
    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> class] keyMapper];
    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span><span class="variable">.class</span>, &amp;kMapperObjectKey) ) {
        objc_setAssociatedObject(
                                 <span class="keyword">self</span><span class="variable">.class</span>,
                                 &amp;kMapperObjectKey,
                                 mapper,
                                 OBJC_ASSO<span class="built_in">CIATION_RETAIN</span> <span class="comment">// This is atomic</span>
                                 );
    }
}
</code></pre><p>WoW! What are 这个函数弄啥类？看起来很吓人？别怕，让我来一个个解释。</p>
<p><b>objc_getAssociatedObject想必大家都不会陌生，这就是一个Associate Object，我们经常用这种方法在Category给一个类添加property。</b></p>
<p>所以，第一个if的意思就是，我根据kClassPropertiesKey这个key，去当前类的Associate Object找property list，如果没找到，就说明是第一次执行解析，所以我要自己建立一个。所以我们赶紧进入<br>__inspectProperties一探究竟！</p>
<pre><code>- (<span class="keyword">void</span>)__inspectProperties
{
    <span class="comment">//JMLog(@"Inspect class: %@", [self class]);</span>

    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];

    <span class="comment">//temp variables for the loops</span>
    Class class = [<span class="keyword">self</span> class];
    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;
    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;

    <span class="comment">// inspect inherited properties up to the JSONModel class</span>
    <span class="keyword">while</span> (class != [JSONModel class]) {
        <span class="comment">//JMLog(@"inspecting: %@", NSStringFromClass(class));</span>

        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;
        objc_property_t *properties = class_copyPropertyList(class, &amp;propertyCount);

        <span class="comment">//loop over the class properties</span>
        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) {

            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];
            <span class="comment">//get property name</span>
            objc_property_t property = properties[i];
            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);
            p<span class="variable">.name</span> = @(propertyName);

            <span class="comment">//JMLog(@"property: %@", p.name);</span>

            <span class="comment">//get property attributes</span>
            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);
            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);
            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];

            <span class="comment">//ignore read-only properties</span>
            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) {
                <span class="keyword">continue</span>; <span class="comment">//to next property</span>
            }

            <span class="comment">//check for 64b BOOLs</span>
            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) {
                <span class="comment">//mask BOOLs as structs so they can have custom convertors</span>
                p<span class="variable">.structName</span> = <span class="string">@"BOOL"</span>;
            }

            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];

            <span class="comment">//JMLog(@"attr: %@", [NSString stringWithCString:attrs encoding:NSUTF8StringEncoding]);</span>
            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];
            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];

            <span class="comment">//check if the property is an instance of a class</span>
            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) {

                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]
                                        intoString:&amp;propertyType];

                <span class="comment">//JMLog(@"type: %@", propertyClassName);</span>
                p<span class="variable">.type</span> = <span class="built_in">NSClassFromString</span>(propertyType);
                p<span class="variable">.isMutable</span> = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>);
                p<span class="variable">.isStandardJSONType</span> = [allowedJSONTypes containsObject:p<span class="variable">.type</span>];

                <span class="comment">//read through the property protocols</span>
                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) {

                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;

                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];

                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) {
                        p<span class="variable">.isOptional</span> = <span class="literal">YES</span>;
                    } <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) {
                        p<span class="variable">.isIndex</span> = <span class="literal">YES</span>;
                        objc_setAssociatedObject(
                                                 <span class="keyword">self</span><span class="variable">.class</span>,
                                                 &amp;kIndexPropertyNameKey,
                                                 p<span class="variable">.name</span>,
                                                 OBJC_ASSO<span class="built_in">CIATION_RETAIN</span> <span class="comment">// This is atomic</span>
                                                 );
                    } <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"ConvertOnDemand"</span>]) {
                        p<span class="variable">.convertsOnDemand</span> = <span class="literal">YES</span>;
                    } <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) {
                        p = <span class="literal">nil</span>;
                    } <span class="keyword">else</span> {
                        p<span class="variable">.protocol</span> = protocolName;
                    }

                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];
                }

            }
            <span class="comment">//check if the property is a structure</span>
            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"{"</span> intoString: &amp;propertyType]) {
                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]
                                    intoString:&amp;propertyType];

                p<span class="variable">.isStandardJSONType</span> = <span class="literal">NO</span>;
                p<span class="variable">.structName</span> = propertyType;

            }
            <span class="comment">//the property must be a primitive</span>
            <span class="keyword">else</span> {

                <span class="comment">//the property contains a primitive data type</span>
                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]
                                        intoString:&amp;propertyType];

                <span class="comment">//get the full name of the primitive type</span>
                propertyType = valueTransformer<span class="variable">.primitivesNames</span>[propertyType];

                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) {

                    <span class="comment">//type not allowed - programmer mistaked -&gt; exception</span>
                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span>
                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span><span class="variable">.class</span>, p<span class="variable">.name</span>]
                                                 userInfo:<span class="literal">nil</span>];
                }

            }

            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);
            <span class="keyword">if</span>([[<span class="keyword">self</span> class] propertyIsOptional:nsPropertyName]){
                p<span class="variable">.isOptional</span> = <span class="literal">YES</span>;
            }

            <span class="keyword">if</span>([[<span class="keyword">self</span> class] propertyIsIgnored:nsPropertyName]){
                p = <span class="literal">nil</span>;
            }

            <span class="comment">//few cases where JSONModel will ignore properties automatically</span>
            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) {
                p = <span class="literal">nil</span>;
            }

            <span class="comment">//add the property object to the temp index</span>
            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p<span class="variable">.name</span>]) {
                [propertyIndex setValue:p forKey:p<span class="variable">.name</span>];
            }
        }

        free(properties);

        <span class="comment">//ascend to the super of the class</span>
        <span class="comment">//(will do that until it reaches the root class - JSONModel)</span>
        class = [class superclass];
    }

    <span class="comment">//finally store the property index in the static property index</span>
    objc_setAssociatedObject(
                             <span class="keyword">self</span><span class="variable">.class</span>,
                             &amp;kClassPropertiesKey,
                             [propertyIndex <span class="keyword">copy</span>],
                             OBJC_ASSO<span class="built_in">CIATION_RETAIN</span> <span class="comment">// This is atomic</span>
                             );
}
</code></pre><p>这么多代码，其实总结起来就几个步骤：</p>
<ul>
<li>获取当前类的的property list，通过class_copyPropertyList runtime的方法</li>
<li><p>遍历每一个propery，解析他们的属性，这里的属性包括是否只读、类型、是否是weak类型，是否是原子性的等等，如果不了解，可以看如下的表格：</p>
<p>  | Code        | Meaning          |<br>  | :————-: |:————-<br>  | R      | The property is read-only (readonly).<br>  | C      | The property is a copy of the value last assigned (copy).<br>  | &amp; | The property is a reference to the value last assigned (retain).<br>  | N | The property is non-atomic (nonatomic).<br>  | G<name> | The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).<br>  | S<name> | The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).<br>  | D | The property is dynamic (@dynamic).<br>  | W | The property is a weak reference (__weak).<br>  | P | The property is eligible for garbage collection.<br>  | t<encoding> | Specifies the type using old-style encoding.</encoding></name></name></p>
</li>
<li><p>根据解析结果，检测是不是合法，如果合法创建对应的JSONModelClassProperty并赋值相应的属性值。</p>
</li>
<li><p>然后重复执行，查看完当前的类就去查询其父类，直到没有为止。</p>
</li>
<li><p>最后将解析出来的property list通过Associate Object给赋值，这和我们刚刚在<strong>setup</strong>中看到的相呼应。</p>
</li>
</ul>
<p>同样，附上关于property属性的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="external">苹果的官方文档链接</a></p>
<p>这一步基本就解释完了，我们来看看下一步。</p>
<h5 id="重点2:_第四步___doesDictionary:(NSDictionary)dict_matchModelWithKeyMapper:(JSONKeyMapper)keyMapper_error:(NSError**)err">重点2: 第四步 __doesDictionary:(NSDictionary<em>)dict matchModelWithKeyMapper:(JSONKeyMapper</em>)keyMapper error:(NSError**)err</h5><p>老样子，我们先来看看他的实现：</p>
<pre><code>-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err
{
    <span class="comment">//check if all required properties are present</span>
    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];
    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames]<span class="variable">.mutableCopy</span>;
    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];

    <span class="comment">//transform the key names, if neccessary</span>
    <span class="keyword">if</span> (keyMapper || globalKeyMapper) {

        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties<span class="variable">.count</span>];
        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;

        <span class="comment">//loop over the required properties list</span>
        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) {

            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property<span class="variable">.name</span> withKeyMapper:keyMapper importing:<span class="literal">YES</span>] : property<span class="variable">.name</span>;

            <span class="comment">//chek if exists and if so, add to incoming keys</span>
            <span class="keyword">id</span> value;
            <span class="keyword">@try</span> {
                value = [dict valueForKeyPath:transformedName];
            }
            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) {
                value = dict[transformedName];
            }

            <span class="keyword">if</span> (value) {
                [transformedIncomingKeys addObject: property<span class="variable">.name</span>];
            }
        }

        <span class="comment">//overwrite the raw incoming list with the mapped key names</span>
        incomingKeys = transformedIncomingKeys;
    }

    <span class="comment">//check for missing input keys</span>
    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) {

        <span class="comment">//get a list of the missing properties</span>
        [requiredProperties minusSet:incomingKeys];

        <span class="comment">//not all required properties are in - invalid input</span>
        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span><span class="variable">.class</span>, requiredProperties);

        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">//not needed anymore</span>
    incomingKeys= <span class="literal">nil</span>;
    requiredProperties= <span class="literal">nil</span>;

    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>抛开我们暂时还不熟悉的keyMapper(<b>用过Mantle的人估计有一定了解。</b>)，整个函数非常容易理解。我们首先获取我们传入的代表JSON数据的Dictionary，然后和我们解析出来的property list进行对比（基于NSSet），<b>如果得到property list室Dictionary的超集，意味着JSON中的数据不能完全覆盖我们生命的属性，说明我们有属性得不到赋值，因此会判断出错。</b>在默认的实现中，如果出现没匹配的实现，就是导致Crash</p>
<h5 id="重点2:_第五步___importDictionary:(NSDictionary)dict_withKeyMapper:(JSONKeyMapper)keyMapper_validation:(BOOL)validation_error:(NSError**)err">重点2: 第五步 __importDictionary:(NSDictionary<em>)dict withKeyMapper:(JSONKeyMapper</em>)keyMapper validation:(BOOL)validation error:(NSError**)err</h5><p>继续看实现：</p>
<pre><code>-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err
{
    <span class="comment">//loop over the incoming keys and set self's properties</span>
    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) {

        <span class="comment">//convert key name ot model keys, if a mapper is provided</span>
        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property<span class="variable">.name</span> withKeyMapper:keyMapper importing:<span class="literal">YES</span>] : property<span class="variable">.name</span>;
        <span class="comment">//JMLog(@"keyPath: %@", jsonKeyPath);</span>

        <span class="comment">//general check for data type compliance</span>
        <span class="keyword">id</span> jsonValue;
        <span class="keyword">@try</span> {
            jsonValue = [dict valueForKeyPath: jsonKeyPath];
        }
        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) {
            jsonValue = dict[jsonKeyPath];
        }

        <span class="comment">//check for Optional properties</span>
        <span class="keyword">if</span> (isNull(jsonValue)) {
            <span class="comment">//skip this property, continue with next property</span>
            <span class="keyword">if</span> (property<span class="variable">.isOptional</span> || !validation) <span class="keyword">continue</span>;

            <span class="keyword">if</span> ([property<span class="variable">.type</span> isSubclassOfClass:[JSONModel class]]) {
                <span class="built_in">NSMutableDictionary</span> *infoKey = [<span class="built_in">NSMutableDictionary</span> new];
                <span class="keyword">for</span> (<span class="built_in">NSString</span> *name <span class="keyword">in</span> dict<span class="variable">.allKeys</span>) {
                    <span class="keyword">id</span> value = [dict objectForKey:name];
                    <span class="built_in">NSMutableString</span> *ignoredCaseName = [<span class="built_in">NSMutableString</span> stringWithString:[name lowercaseString]];
                    <span class="built_in">NSString</span> *ignoredCaseKey  = [property<span class="variable">.name</span> lowercaseString];

                    <span class="built_in">NSRange</span> range = [ignoredCaseName rangeOfString:ignoredCaseKey];
                    <span class="keyword">if</span> (range<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) {
                        [ignoredCaseName deleteCharactersInRange:range];
                        <span class="built_in">NSString</span> *newPropertyName = [ignoredCaseName <span class="keyword">copy</span>];
                        <span class="keyword">if</span> (!isNull(value)) {
                            [infoKey setObject:value forKey:newPropertyName];
                        }
                    }
                }

                jsonValue = [infoKey <span class="keyword">copy</span>];
            }

            <span class="keyword">if</span> (err &amp;&amp; isNull(jsonValue)) {
                <span class="comment">//null value for required property</span>
                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property<span class="variable">.name</span>];
                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];
                *err = [dataErr errorByPrependingKeyPathComponent:property<span class="variable">.name</span>];

                <span class="keyword">return</span> <span class="literal">NO</span>;
            }
        }

        Class jsonValueClass = [jsonValue class];
        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;

        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) {
            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) {
                isValueOfAllowedType = <span class="literal">YES</span>;
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) {
            <span class="comment">//type not allowed</span>
            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));

            <span class="keyword">if</span> (err) {
                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];
                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];
                *err = [dataErr errorByPrependingKeyPathComponent:property<span class="variable">.name</span>];
            }
            <span class="keyword">return</span> <span class="literal">NO</span>;
        }

        <span class="comment">//check if there's matching property in the model</span>
        <span class="keyword">if</span> (property) {

            <span class="comment">// check for custom setter, than the model doesn't need to do any guessing</span>
            <span class="comment">// how to read the property's value from JSON</span>
            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) {
                <span class="comment">//skip to next JSON key</span>
                <span class="keyword">continue</span>;
            };

            <span class="comment">// 0) handle primitives</span>
            <span class="keyword">if</span> (property<span class="variable">.type</span> == <span class="literal">nil</span> &amp;&amp; property<span class="variable">.structName</span>==<span class="literal">nil</span>) {

                <span class="comment">//generic setter</span>
                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>]) {
                    [<span class="keyword">self</span> setValue:jsonValue forKey: property<span class="variable">.name</span>];
                }

                <span class="comment">//skip directly to the next key</span>
                <span class="keyword">continue</span>;
            }

            <span class="comment">// 0.5) handle nils</span>
            <span class="keyword">if</span> (isNull(jsonValue)) {
                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>] != <span class="literal">nil</span>) {
                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property<span class="variable">.name</span>];
                }
                <span class="keyword">continue</span>;
            }


            <span class="comment">// 1) check if property is itself a JSONModel</span>
            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property<span class="variable">.type</span>]) {

                <span class="comment">//initialize the property's model, store it</span>
                JSONModelError* initErr = <span class="literal">nil</span>;
                <span class="keyword">id</span> value = [[property<span class="variable">.type</span> alloc] initWithDictionary: jsonValue error:&amp;initErr];

                <span class="keyword">if</span> (!value) {
                    <span class="comment">//skip this property, continue with next property</span>
                    <span class="keyword">if</span> (property<span class="variable">.isOptional</span> || !validation) <span class="keyword">continue</span>;

                    <span class="comment">// Propagate the error, including the property name as the key-path component</span>
                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))
                    {
                        *err = [initErr errorByPrependingKeyPathComponent:property<span class="variable">.name</span>];
                    }
                    <span class="keyword">return</span> <span class="literal">NO</span>;
                }
                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>]]) {
                    [<span class="keyword">self</span> setValue:value forKey: property<span class="variable">.name</span>];
                }

                <span class="comment">//for clarity, does the same without continue</span>
                <span class="keyword">continue</span>;

            } <span class="keyword">else</span> {

                <span class="comment">// 2) check if there's a protocol to the property</span>
                <span class="comment">//  ) might or not be the case there's a built in transofrm for it</span>
                <span class="keyword">if</span> (property<span class="variable">.protocol</span>) {

                    <span class="comment">//JMLog(@"proto: %@", p.protocol);</span>
                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];
                    <span class="keyword">if</span> (!jsonValue) {
                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) {
                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];
                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];
                            *err = [dataErr errorByPrependingKeyPathComponent:property<span class="variable">.name</span>];
                        }
                        <span class="keyword">return</span> <span class="literal">NO</span>;
                    }
                }

                <span class="comment">// 3.1) handle matching standard JSON types</span>
                <span class="keyword">if</span> (property<span class="variable">.isStandardJSONType</span> &amp;&amp; [jsonValue isKindOfClass: property<span class="variable">.type</span>]) {

                    <span class="comment">//mutable properties</span>
                    <span class="keyword">if</span> (property<span class="variable">.isMutable</span>) {
                        jsonValue = [jsonValue mutableCopy];
                    }

                    <span class="comment">//set the property value</span>
                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>]]) {
                        [<span class="keyword">self</span> setValue:jsonValue forKey: property<span class="variable">.name</span>];
                    }
                    <span class="keyword">continue</span>;
                }

                <span class="comment">// 3.3) handle values to transform</span>
                <span class="keyword">if</span> (
                    (![jsonValue isKindOfClass:property<span class="variable">.type</span>] &amp;&amp; !isNull(jsonValue))
                    ||
                    <span class="comment">//the property is mutable</span>
                    property<span class="variable">.isMutable</span>
                    ||
                    <span class="comment">//custom struct property</span>
                    property<span class="variable">.structName</span>
                    ) {

                    <span class="comment">// searched around the web how to do this better</span>
                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span>
                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue class]];

                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span>

                    <span class="comment">//build a method selector for the property and json object classes</span>
                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,
                                              (property<span class="variable">.structName</span>? property<span class="variable">.structName</span> : property<span class="variable">.type</span>), <span class="comment">//target name</span>
                                              sourceClass]; <span class="comment">//source name</span>
                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);

                    <span class="comment">//check for custom transformer</span>
                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;
                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) {
                        foundCustomTransformer = <span class="literal">YES</span>;
                    } <span class="keyword">else</span> {
                        <span class="comment">//try for hidden custom transformer</span>
                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];
                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);
                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) {
                            foundCustomTransformer = <span class="literal">YES</span>;
                        }
                    }

                    <span class="comment">//check if there's a transformer with that name</span>
                    <span class="keyword">if</span> (foundCustomTransformer) {

                        <span class="comment">//it's OK, believe me...</span>
<span class="preprocessor">#pragma clang diagnostic push</span>
<span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span>
                        <span class="comment">//transform the value</span>
                        jsonValue = [valueTransformer performSelector:selector withObject:jsonValue];
<span class="preprocessor">#pragma clang diagnostic pop</span>

                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>]]) {
                            [<span class="keyword">self</span> setValue:jsonValue forKey: property<span class="variable">.name</span>];
                        }

                    } <span class="keyword">else</span> {

                        <span class="comment">// it's not a JSON data type, and there's no transformer for it</span>
                        <span class="comment">// if property type is not supported - that's a programmer mistaked -&gt; exception</span>
                        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"Type not allowed"</span>
                                                       reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property<span class="variable">.type</span>, [<span class="keyword">self</span> class], property<span class="variable">.name</span>]
                                                     userInfo:<span class="literal">nil</span>];
                        <span class="keyword">return</span> <span class="literal">NO</span>;
                    }

                } <span class="keyword">else</span> {
                    <span class="comment">// 3.4) handle "all other" cases (if any)</span>
                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property<span class="variable">.name</span>]]) {
                        [<span class="keyword">self</span> setValue:jsonValue forKey: property<span class="variable">.name</span>];
                    }
                }
            }
        }
    }

    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>这一个函数看着吓人，其实非常容易理解。根据我们刚刚得到的property list，我们一个个取出来，用property name作为key，来查询在对应的JSON字典中的value。然后分为如下几个情况：</p>
<ul>
<li>检查是不是空值。如果该属性是optional，那么无所谓。如果不能为空，那么抛出错误。</li>
<li>检查这个值是不是合法的JSON类型，如果不是，抛出错误。</li>
<li>如果property是非自定义JSONModel子类的字段，基于Key-Value赋值，当然，你可以自己override setter。</li>
<li>如果是自定义的JSONModel子类是，创建一个对应的新类，解析对应的value。</li>
<li>如果再不行，进行一系列的判断和利用JSONValueTransformer进行类型转换进行解析。</li>
</ul>
<p>为什么要进行JSONValueTransformer的转换呢，是因为在iOS的视线中，由于抽象工厂的存在，构建了大量的簇类，比如NSArray, NSNumber, NSDictionary等等，他们只是对外暴露的一层皮，实质上底层对于真正的类。比如NSArrayI &lt;=&gt; NSArray等等。因此，我们需要通过JSONValueTransformer得到真正的Class Type，同时通过class Type找到最合适的转换方法，在JSONValueTransformer.m的文件中，我们能找到一大堆<b>xxxFromYYY</b>的函数。</p>
<p>好了，到此为止，JSONModel的源码解读就差不多了，下周带来SDWebImageCache的解读。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景介绍">背景介绍</h3><p>现在的移动App基本上免不了和网络传输打交道，我们经常需要和服务器进行数据的传输，常用的数据格式无外乎XML或者JSON。这也就引出了一个新的话题，如何将获得的数据实际应用到我们的App中？答案很简单，建立Model。我们拿到的]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS下载模块的实现]]></title>
    <link href="http://satanwoo.github.io/2015/09/11/A-New-Start/"/>
    <id>http://satanwoo.github.io/2015/09/11/A-New-Start/</id>
    <published>2015-09-11T04:15:55.000Z</published>
    <updated>2015-09-17T12:55:17.000Z</updated>
    <content type="html"><![CDATA[<p>这是我在实习的时候对于一个下载模块的实现，在这里记录一下心得体会。这个模块完全独立实现，且不依赖于公司任何的代码，不会涉及任何隐私。</p>
<h3 id="下载模块的需求">下载模块的需求</h3><p>在实现一个新模块之前，我们需要理清楚这个模块需要支持最小的功能集，并逐步扩展。并且由于下载模块是存在潜在的可能性被多个模块调用，因此，我们特别要注意模块的封装。</p>
<h4 id="功能需求">功能需求</h4><h5 id="支持下载">支持下载</h5><p>   下载模块最基本的自然就是可以正确的将需要下载的东西下载到指定路径，这里下载的东西包括但是不局限于图片、文本文档、压缩文件等等。因此，这些下载东西的大小是不等的，在设计功能的时候，需要讲这点考虑进去。</p>
<h5 id="支持取消下载">支持取消下载</h5><p>   处于控制角度的考虑，甚至是出于当流量和资源节省的角度考虑，我们都已经对下载任务有控制权。可以随时根据我们业务处于的状态，对下载任务进行暂停或者完整的停止取消。</p>
<h5 id="支持并发下载">支持并发下载</h5><p>   下载任务的个数肯定不会只有一个，而是可能同时存在多个。因此，我们就需要考虑如何去支持多个下载任务同时并发的下载。其外，我们还要考虑到潜在的任务之间的关联性和依赖性（比如B下载任务需要依赖于A下载任务的完成）</p>
<p>初步的任务我们可以认为就是如上三个就可以（<b>初期设计模块真的不要考虑过多功能，先开始做起来，一点点看着自己造的轮子可以运转起来，成就感会促使你会不停的去完善。当然，你的代码一定要写的整洁易读！</b>）</p>
<a id="more"></a>
<h3 id="实现下载">实现下载</h3><p>谈到实现下载，很多人会联想到向服务器请求数据，比如我们会使用<b>AFNetworkong</b>或者<b>ASIHttpRequest</b>这两个大名鼎鼎的开源库。两者对HTTP应用层协议进行了良好的封装，支持多种HTTP操作。我们平时也经常使用这两个库经常服务器数据请求和传输，看起来好像我们只要用这两个库，这个任务就自然而然的解决了。但是我们要考虑到，我们的下载模块是一个可能经常被别的模块甚至是应用拿来应用的功能模块，我们如果还耦合于第三库，无疑降低了这个模块的使用价值。因此，我们采用苹果原生的函数来实现，并且考虑到兼容性，我们还是采用了NSURLConnection而不是NSURLSession。</p>
<h4 id="下载任务建模">下载任务建模</h4><p>首先我们需要思考，将下载任务对应成一个实际存在的类，这些类应该包括下载文件所在URL，下载任务目前的状态，比如未开始，进行中还是已结束。当然，我们也可以包含一个自定义参数等等进行下载任务的配置，当然，这是可选的。那是不是我们直接建立一个基于<b>NSObject</b>的子类就是最理想的建模呢？构建一个基于NSOperation的子类化operation更适合我们的场景（具体下文会说）。因此，初步的<b>XXXDownloadOperation</b>结果如下：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">XXXDownloadOperation</span> : <span class="title">NSOperation</span></span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) XXXDownloadStatus status;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *fileURL;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)           <span class="keyword">id</span> userInfo;

- (instancetype)initWithURL:(<span class="built_in">NSURL</span> *)fileURL
- (<span class="keyword">void</span>)cancelDownload;
<span class="keyword">@end</span>
</code></pre><h5 id="下载任务的状态">下载任务的状态</h5><p>在XXXDownloadOperation中，我们可以看到包含了一个只读字段的<em>XXXDownloadStatus</em>的字段，这个字段就是为了反应当前下载任务的状态，它包含如下几种：</p>
<pre><code><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSUInteger, XXXDownloadStatus)</span> </span>{
    XXXDownloadStatusReady = <span class="number">0</span>,
    XXXDownloadStatusFailed = <span class="number">1</span>,
    XXXDownloadStatusDownloading = <span class="number">2</span>,
    XXXDownloadStatusCancelled = <span class="number">3</span>,
    XXXDownloadStatusDone = <span class="number">4</span>,
    XXXDownloadStatusPause = <span class="number">5</span>
};
</code></pre><ul>
<li>XXXDownloadStatusReady       代表了当前任务可以开始进行下载</li>
<li>XXXDownloadStatusFailed      代表当前任务下载失败，比如网络断了</li>
<li>XXXDownloadStatusDownloading 代表当前下载任务正在进行中</li>
<li>XXXDownloadStatusCancelled   代表当前任务已经被取消了</li>
<li>XXXDonwloadStatusDone        代表当前任务下载完毕</li>
<li>XXXDownloadStatusPause       代表当前任务暂停</li>
</ul>
<p><b>设置为只读就是为了避免人为的修改状态</b></p>
<h5 id="实现NSURLConnection">实现NSURLConnection</h5><p>实现NSURLConnection非常简单，它只有几个简单的Delegate需要我们去实现。</p>
<pre><code><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didFailWithError:(NSError *)error</span></span>;
<span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span></span>;
<span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection*)connection didReceiveData:(NSData *)data</span></span>;
<span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connectionDidFinishLoading</span>:<span class="value">(NSURLConnection*)connection</span></span>;
</code></pre><p>但是由于我们是基于NSOperation，在非主线程进行NSURLConnection进行操作，所以，我们要特别注意一点，就是非主线程是没有<b>RunLoop</b>的，而NSURLConnection的回调都是基于NSRunLoop，因此我们需要创建一个RunLoop, 如下所示：</p>
<pre><code><span class="built_in">NSRunLoop</span>* runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];
[runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];
[<span class="keyword">self</span><span class="variable">.connection</span> scheduleInRunLoop:runLoop
                           forMode:<span class="built_in">NSDefaultRunLoopMode</span>];   
[<span class="keyword">self</span><span class="variable">.connection</span> start];
[runLoop run];
</code></pre><p> 上述这段代码非常容易理解，我们创建了一个NSRunLoop，并且运行它，这样我们的NSURLConnection就可以基于它进行delegate回调了。</p>
<p> 且慢，</p>
<pre><code><span class="attr_selector">[runLoop addPort:[NSMachPort port]</span> <span class="rule"><span class="attribute">forMode</span>:<span class="value">NSDefaultRunLoopMode]</span></span>;
</code></pre><p> 这段话是什么意思？我们为什么要让RunLoop监听一个port。<br> 原因就在于<b>默认情况下，当RunLoop无所事事的时候，它就自动退出了，有可能导致NSURLConnection的事件还没回调的时候NSRunLoop已经不存在了。因此我们要让它监听一个没啥用的端口，嘿嘿，大名鼎鼎的AFNetworking也是这么做的</b></p>
<h5 id="实现并发下载">实现并发下载</h5><p>嘿嘿，知道我们为什么采用子类化NSOperation了吧，我们就是为了利用NSOperationQueue的并发特性。</p>
<pre><code><span class="keyword">self</span><span class="variable">.taskQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];
<span class="keyword">self</span><span class="variable">.taskQueue</span><span class="variable">.maxConcurrentOperationCount</span> = capacity;
<span class="keyword">self</span><span class="variable">.taskQueue</span><span class="variable">.name</span> = <span class="string">@"com.satanwoo.taskQueue"</span>;
</code></pre><p>我们可以随意设置的NSOperationQueue的最大并发数来构建并发下载。当然这里要提醒一句，<b>多线程环境中，并不是线程数越多并发性越好，因为多线程最大并发数其实和系统硬件资源相关联。而过多的线程数会导致过多的线程上下文切换。</b></p>
<h5 id="NSOperation与KVO">NSOperation与KVO</h5><p>首先建议大家读一下这篇文章 <a href="http://www.dribin.org/dave/blog/archives/2009/05/05/concurrent_operations/" target="_blank" rel="external">Concurrent Operations Demystified</a></p>
<pre><code>- (<span class="built_in">BOOL</span>)isExecuting
{
    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.status</span> == XXXDownloadStatusDownloading;
}

- (<span class="built_in">BOOL</span>)isCancelled
{
    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.status</span> == XXXDownloadStatusCancelled;
}

- (<span class="built_in">BOOL</span>)isFinished
{
    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.status</span> == XXXDownloadStatusCancelled ||
           <span class="keyword">self</span><span class="variable">.status</span> == XXXDownloadStatusDone ||
           <span class="keyword">self</span><span class="variable">.status</span> == XXXDownloadStatusFailed;
}
</code></pre><p>从上面链接文章我们可以得知，NSOperation的执行以来于这些状态。因此，我们根据自己下载任务的状态override了这些变量状态。<br>然后，我们只要利用KVO，去更改如上这些override的状态就好。</p>
<pre><code>- (<span class="keyword">void</span>)updateState:(XXXDownloadStatus)status
{
      <span class="comment">// 防止我们直接调用了canel</span>
    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];

    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];
    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];
    <span class="keyword">self</span><span class="variable">.status</span> = status;
    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];
    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];
}

- (<span class="keyword">void</span>)cancel
{
    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isCancelled"</span>];
    [<span class="keyword">self</span> updateState];
    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isCancelled"</span>];
}
</code></pre><p>至此，一个具备并发、取消的下载功能就完成了。我们可以根据业务需要，上层封装一系列简单的函数，进行便捷的管理。</p>
<p>接下来我们要实现的，就是基于HTTP Header的range字段来支持断点续传功能了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我在实习的时候对于一个下载模块的实现，在这里记录一下心得体会。这个模块完全独立实现，且不依赖于公司任何的代码，不会涉及任何隐私。</p>
<h3 id="下载模块的需求">下载模块的需求</h3><p>在实现一个新模块之前，我们需要理清楚这个模块需要支持最小的功能集，并逐步扩展。并且由于下载模块是存在潜在的可能性被多个模块调用，因此，我们特别要注意模块的封装。</p>
<h4 id="功能需求">功能需求</h4><h5 id="支持下载">支持下载</h5><p>   下载模块最基本的自然就是可以正确的将需要下载的东西下载到指定路径，这里下载的东西包括但是不局限于图片、文本文档、压缩文件等等。因此，这些下载东西的大小是不等的，在设计功能的时候，需要讲这点考虑进去。</p>
<h5 id="支持取消下载">支持取消下载</h5><p>   处于控制角度的考虑，甚至是出于当流量和资源节省的角度考虑，我们都已经对下载任务有控制权。可以随时根据我们业务处于的状态，对下载任务进行暂停或者完整的停止取消。</p>
<h5 id="支持并发下载">支持并发下载</h5><p>   下载任务的个数肯定不会只有一个，而是可能同时存在多个。因此，我们就需要考虑如何去支持多个下载任务同时并发的下载。其外，我们还要考虑到潜在的任务之间的关联性和依赖性（比如B下载任务需要依赖于A下载任务的完成）</p>
<p>初步的任务我们可以认为就是如上三个就可以（<b>初期设计模块真的不要考虑过多功能，先开始做起来，一点点看着自己造的轮子可以运转起来，成就感会促使你会不停的去完善。当然，你的代码一定要写的整洁易读！</b>）</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
