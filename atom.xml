<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://satanwoo.github.io/"/>
  <updated>2017-04-22T19:18:04.000Z</updated>
  <id>http://satanwoo.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ARM64下Indirect Result Location摸索]]></title>
    <link href="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/"/>
    <id>http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/</id>
    <published>2017-04-22T19:00:36.000Z</published>
    <updated>2017-04-22T19:18:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ARM64下Indirect_Result_Location摸索">ARM64下Indirect Result Location摸索</h3><p>之前学习汇编的时候，大概了解了一些ARM64下寄存器的用途，比如<code>x0 - x7</code>作为函数传递使用。同时，<code>x0</code>也可以作为函数返回值时候的寄存器。</p>
<p>但是，今天在研究一些跟返回结构体相关的时候，发现返回值并不是放在<code>X0</code>寄存器中。上网搜索了一下资料，发现在<strong>ARM64下，当一个<code>Callee</code>函数返回的内容大于16bytes的时候，该内容会被存到一个内存地址当中，然后这个内存地址的值会存入寄存器<code>x8</code>。后续<code>Caller</code>函数在使用该返回值的时候，会从<code>X8</code>寄存器中取出内存地址，并从内存地址取出内容的值</strong></p>
<p>是不是有点绕，还是让我们来看个例子吧。</p>
<h3 id="原理">原理</h3><p>首先我根据<strong>大于16 bytes</strong>的要求定义了如下结构体：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">int64_t</span> i;
    <span class="keyword">int64_t</span> j;
    <span class="keyword">int64_t</span> k;
} MYStruct;
</code></pre><p>在ARM64下，该结构体默认按<code>4 bytes</code>对齐，每个<code>int64</code>占用<code>8 bytes</code>，因此结构体大小<code>24 bytes</code></p>
<p>我们定义如下函数，用于返回一个该结构体：</p>
<pre><code>- (MYStruct)testIndirectResultLocation:(int64_t)i1 second:(int64_t)i2 th:(int64_t)i3
{
    MYStruct s<span class="comment">;</span>
    s.i = i1<span class="comment">;</span>
    s.j = i2<span class="comment">;</span>
    s.k = i3<span class="comment">;</span>
    return s<span class="comment">;</span>
}
</code></pre><p>这个函数很简单，传入三个值。然后构造个局部变量<code>MYStruct s</code>，将其对应的成员变量按照刚刚的传入参数赋值，最后返回该结构体。</p>
<p>该函数调用<strong>在未优化的前提下</strong>的汇编结果如下：</p>
<pre><code>IndirectResultLocation`-[ViewController testIndirectResultLocation:second:th:]:
    <span class="comment">// 预留空间</span>
    &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>

    <span class="comment">// 存参</span>
    &lt;+<span class="number">4</span>&gt;:  str    x0, [sp, <span class="preprocessor">#<span class="number">0x38</span>]</span>
    &lt;+<span class="number">8</span>&gt;:  str    x1, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    &lt;+<span class="number">12</span>&gt;: str    x2, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">16</span>&gt;: str    x3, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">20</span>&gt;: str    x4, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>

    <span class="comment">// 赋值</span>
-&gt;  &lt;+<span class="number">24</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">28</span>&gt;: str    x0, [sp]
    &lt;+<span class="number">32</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">36</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">40</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>
    &lt;+<span class="number">44</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 将结构体存到x8寄存器的值代表的地址去</span>
    &lt;+<span class="number">48</span>&gt;: ldr    x0, [sp]
    &lt;+<span class="number">52</span>&gt;: str    x0, [x8]
    &lt;+<span class="number">56</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">60</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">64</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    &lt;+<span class="number">68</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 释放空间</span>
    &lt;+<span class="number">72</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>
    &lt;+<span class="number">76</span>&gt;: ret    
</code></pre><p>第一行：SP即<code>Stack Pointer</code>，向下减<code>0x40（64 bytes）</code>的大小，预先分配出函数需要用的栈空间。为什么要预留这么多的大小呢？首先按照<strong>Objective-C的函数调用规定，前两个参数必须是<code>self</code>和<code>selector</code>，也即会使用到寄存器<code>X0</code>和<code>X1</code>。然后该函数有三个形参，使用了<code>X2-X4</code>的寄存器</strong>。<br>上述这五个，大小占用了<strong>self(8 bytes) + selector(8 bytes) + 三个参数(24 bytes) = 40 bytes</strong>。那么还有<code>24 bytes</code>去干嘛了呢？</p>
<p>别忘了，我们在函数中可以声明了一个局部变量<code>MYStruct s</code>，该结构体大小是24 bytes。而在函数调用中使用到的变量，基本上都在栈区中开辟对应的空间进行暂存。</p>
<p>后续第二行到第六行非常简单易懂，就是把上述5个参数存到实际的栈区中去使用。按照这个存法以后，内存布局如下（注意高地址在上，低地址在下，ARM下的栈是向下增长）：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.48.35.png?raw=true" alt=""></p>
<p>将参数都存入到栈以后，我们就要对结构体进行赋值了，这些操作在第七行到第十二行之间。<br>将<strong>1赋值给[SP]，2赋值给[SP + #0x8]，3赋值给[SP + #0x10]</strong>。如果不理解啥意思的话，可以看下我自己转化的伪代码：</p>
<pre><code><span class="keyword">void</span> *address = &amp;s;
*(<span class="keyword">int64_t</span> *)(address) = <span class="number">1</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">8</span>) = <span class="number">2</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">16</span>) = <span class="number">3</span>;
</code></pre><p>赋值完以后，我们可以通过内存分布看下数据是否正确：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.30.06.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.29.53.png?raw=true" alt=""></p>
<p>当赋值完成后，就要进行结构体的返回了。这里不是简单的<code>mov x0, sp</code>之类的操作，而是一串和<code>X8</code>寄存器相关操作。</p>
<p>其实原理差不多，转化成伪代码的话，基本上是这样：</p>
<pre><code>void <span class="keyword">*</span>toSaveAddress = [x8];
void <span class="keyword">*</span>valueNowAddress = [sp];

<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress) = <span class="keyword">*</span>valueNowAddress;
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 8) = <span class="keyword">*</span>(valueNowAddress + 8);
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 16) = <span class="keyword">*</span>(valueNowAddress + 16);
</code></pre><p>操作完成后，释放空间即可。</p>
<h3 id="补充">补充</h3><p>其实ARM64在汇编层面实现的这么复杂， 我们在编程层面只要按照如下方式理解即可：</p>
<pre><code><span class="function">some_struct <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s = foo(<span class="number">1</span>, <span class="number">2</span>);
</code></pre><p>会被编译成：</p>
<pre><code><span class="function">some_struct* <span class="title">foo</span><span class="params">(some_struct* ret_val, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s; 
foo(&amp;s, <span class="number">1</span>, <span class="number">2</span>);
</code></pre><h3 id="后续">后续</h3><p>从本文中我们不难看出，ARM64针对不同大小的返回值都有着对应的<strong>Calling Convention</strong>。下次我准备来摸索下，处于<code>8 bytes - 16 bytes</code>之间的返回值究竟是怎么处理的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ARM64下Indirect_Result_Location摸索">ARM64下Indirect Result Location摸索</h3><p>之前学习汇编的时候，大概了解了一些ARM64下寄存器的用途，比如<code>x0 - x7</code>作为函数传递]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速计算两组数据源的变化的方法 - Doppelganger 源码剖析]]></title>
    <link href="http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/"/>
    <id>http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/</id>
    <published>2017-04-17T17:15:40.000Z</published>
    <updated>2017-04-17T17:24:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Doppelganger_源码剖析">Doppelganger 源码剖析</h3><p>性能优化系列一：如何快速的计算UITableView的数据量变换。</p>
<p>今天要介绍的是一个比较精简但是很实用的库：Doppelganger。平时我们经常会和<code>UITableView</code>或者<code>UICollectionView</code>打交道，所以数据源（dataSource）及其变化就非常重要。</p>
<p>如何高效的求解两次数据源之间的删除、增加以及移动（交换位置）就成为了一个可以显著加速的地方。</p>
<blockquote>
<p>备注：这里指的是将一定量的数据计算放在客户端来进行，而不是通过多次发送网络请求获取数据然后整体重新刷新。有人会问，什么情况下会有这样的需求呢？比如，你有个用户选项，可以支持按照倒序或者正序的方式进行布局，那这个时候，你直接在本地进行计算并展示差量布局计算，就要比从网络请求多次拉取整体重新刷新的效果赞很多。</p>
</blockquote>
<p>本文提到的<code>Doppelganger</code>其实就是一种对于上述需求的封装，提供了及其简化的数据源更新机制。抛开其性能不谈，我们先来看看其实现。</p>
<h4 id="数据结构">数据结构</h4><p>从需求不难看出，我们的数据结构需要支持如下潜在数据记录：</p>
<ul>
<li>改动类型：增加、删除、移动</li>
<li>改动索引：增加的话，是插入到哪行、删除的话是删除哪行、移动的话是从哪行移动到哪行。</li>
</ul>
<p>基于此，数据结构的定义就很显而易见了：</p>
<pre><code><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WMLArrayDiffType) {
    WMLArrayDiffTypeMove,
    WMLArrayDiffTypeInsert,
    WMLArrayDiffTypeDelete
};

<span class="class"><span class="keyword">@interface</span> <span class="title">WMLArrayDiff</span> : <span class="title">NSObject</span></span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) WMLArrayDiffType type;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> previousIndex;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> currentIndex;

<span class="keyword">@end</span>
</code></pre><p>其中，有些字段在某些类型下可以为空。</p>
<h4 id="计算变动">计算变动</h4><p>我们先简化下我们的模型，我们就是两个数组A和B，里面各自一堆不重复的数字，分别代表之前的数据源和现在的数据源。现在我们需要求得这两个数组之前提到的三种变化。</p>
<p><strong>首先是删除的计算，非常简单，只要计算在A中不在B中就可以：</strong></p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>然后是增加的计算，同样简单，只要计算在B中不在A中的：</strong></p>
<pre><code>NSSet *insertedObjects = ({
    NSMutableSet *<span class="keyword">set</span> = [currentSet mutableCopy];
    [<span class="keyword">set</span> minusSet:previousSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>最后就是计算那些即在A中又在B中的改变，对于这种计算，我们要得到在A中的原索引和现在的新索引。</strong></p>
<pre><code>- (<span class="type">NSArray</span> *)_moveDiffsWithDeletedObjects:(<span class="type">NSSet</span> *)deletedObjects insertedObjects:(<span class="type">NSSet</span> *)insertedObjects {    
    // <span class="type">TODO</span>: <span class="type">Improve</span> on O(n^<span class="number">2</span>)
    __block <span class="type">NSInteger</span> delta = <span class="number">0</span>;
    <span class="type">NSMutableArray</span> *<span class="literal">result</span> = [<span class="type">NSMutableArray</span> <span class="type">array</span>];
    [self.previousArray enumerateObjectsUsingBlock:^(id leftObj, <span class="type">NSUInteger</span> leftIdx, <span class="type">BOOL</span> *stop) {
        <span class="keyword">if</span> ([deletedObjects containsObject:leftObj]) {
            delta++;
            <span class="keyword">return</span>; 
        }
        <span class="type">NSUInteger</span> localDelta = delta;
        <span class="keyword">for</span> (<span class="type">NSUInteger</span> rightIdx = <span class="number">0</span>; rightIdx &lt; self.currentArray.count; ++rightIdx) {
            id rightObj = self.currentArray[rightIdx];
            <span class="keyword">if</span> ([insertedObjects containsObject:rightObj]) {
                localDelta--;
                <span class="keyword">continue</span>;
            }

            <span class="keyword">if</span> (![rightObj isEqual:leftObj]) {
                <span class="keyword">continue</span>;
            }

             //  注意点：          
            <span class="type">NSInteger</span> adjustedRightIdx = rightIdx + localDelta;
            // 首先如果前后索引一致，没有变化的区别，没有必要做diff变化
            // 或者如果你前面删除了一条，自身索引是<span class="number">1</span>，然后这边是<span class="number">0</span>，那也没必要做move变化。
            <span class="keyword">if</span> (leftIdx != rightIdx &amp;&amp; adjustedRightIdx != leftIdx) {
                [<span class="literal">result</span> addObject:[<span class="type">WMLArrayDiff</span> arrayDiffForMoveFromIndex:leftIdx toIndex:rightIdx]];
            }
            <span class="keyword">return</span>;
        }
    }];
    <span class="keyword">return</span> [<span class="literal">result</span> copy];
}
</code></pre><p>上述代码一开始我看了也是懵逼了，我觉得直接二重遍历计算同样数在不同两组数据源中的索引区别不就行了？在读了代码一遍以后确定了，作者的思路是这样的：</p>
<ol>
<li><p>如果在旧数组中和新数组中的数据源一样，那就不更新了，也即<code>leftIdx != rightIdx</code>的判断。</p>
</li>
<li><p>如果在旧数组中，索引为1，但是之前的0索引位置的数据删除了；然后这个索引为1的数据在新数据中位置为索引0，那么也不需要改了，因为之前计算删除变化的时候已经做了这个相同的效果。</p>
</li>
</ol>
<h4 id="时间复杂度">时间复杂度</h4><p>虽然不知道苹果内部的数据结构代码实现是如何的，但是我们可以进行数据模拟，同时也可以看看<a href="http://devstreaming.apple.com/videos/wwdc/2013/224xcx5x1y1yx8ra5jbmfyhf/224/224.pdf" target="_blank" rel="external">苹果WWDC的文章</a> 来进行时间复杂度估算。</p>
<p>而从上面实现的计算变动源代码来看，整个库的实现时间复杂度还是有所欠缺的，到达了O(mn) + O(n) ≈ O(mn)的级别，因此我们可以进行一些优化。</p>
<blockquote>
<p>备注：O(mn)就是二重循环遍历的问题。其中m是数据源A的数据个数，n是数据源b的数据个数。简单来看就是O(n^2)级别的运算耗时。</p>
</blockquote>
<p>怎么优化呢，答案很简单，就是利用动态规划思想来求解最小编辑距离。</p>
<p>我们举个简单的例子，还是没有重复数组的数组，<code>A = [1, 3, 5, 6, 8]</code>以及<code>B = [1, 5, 6, 9, 2]</code>。</p>
<p>怎么样最小变化才能从A变成B呢？</p>
<p>我们列一个二维的矩阵先，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-25%20%E4%B8%8A%E5%8D%881.22.02.png?raw=true" alt=""></p>
<blockquote>
<p>备注：蓝色为原数据，绿色为新数据，黄色的为最小变化的开销。</p>
</blockquote>
<p>不难看出，这个算法的时间复杂度就是填满整张表的O(mn)。</p>
<p>看到这，有人会问，你的Big(O) 复杂度都是O(mn)啊，这你优化在什么地方啊。</p>
<p>从时间复杂度分析上看，最大数值都是O(mn)没错，但是在大数量的情况下，还是会有比较大的区别。</p>
<p>究竟原因在于作者的算法做了很多重复性的劳动，而利用动态规划的特征可以合理的储存状态，避免重复性的劳动。</p>
<h4 id="一些细节">一些细节</h4><p>在查看源码的时候，查看过一个代码，</p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p>这里非常有意思，利用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" target="_blank" rel="external">Statements and Declarations in Expressions</a>，具体不多说了，非常巧妙，大开眼界。</p>
<blockquote>
<p>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct</p>
</blockquote>
<p>啥意思呢？就是说这种符合表达式的最后一句必须是一个用分号结尾的表达式，并且这个表达式必须有返回值。而这个返回值就作为整个符号表达式的返回值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Doppelganger_源码剖析">Doppelganger 源码剖析</h3><p>性能优化系列一：如何快速的计算UITableView的数据量变换。</p>
<p>今天要介绍的是一个比较精简但是很实用的库：Doppelganger。平时我们经常会和<code]]>
    </summary>
    
      <category term="Performance" scheme="http://satanwoo.github.io/tags/Performance/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS疑难问题排查之深入探究dispatch_group crash]]></title>
    <link href="http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/"/>
    <id>http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/</id>
    <published>2017-01-07T13:44:39.000Z</published>
    <updated>2017-01-07T14:08:40.000Z</updated>
    <content type="html"><![CDATA[<h3 id="起因">起因</h3><p>昨天其他部门的同事突然反馈一起相对来说比较严重的Crash问题（占比达到了yyyy左右，并且从Crash堆栈上可以发现很多情况下是一启动就Crash了）。去掉隐私数据大致堆栈如下：</p>
<pre><code>Thread <span class="number">0</span> Crashed:
<span class="number">0</span>   libdispatch.dylib               <span class="number">0x000000018953e828</span> _dispatch_group_leave :<span class="number">76</span> (in libdispatch.dylib)
<span class="number">1</span>   libdispatch.dylib               <span class="number">0x000000018954b084</span> __dispatch_barrier_sync_f_slow_invoke :<span class="number">320</span> (in libdispatch.dylib)
<span class="number">2</span>   libdispatch.dylib               <span class="number">0x000000018953a1bc</span> __dispatch_client_callout :<span class="number">16</span> (in libdispatch.dylib)
<span class="number">3</span>   libdispatch.dylib               <span class="number">0x000000018953ed68</span> __dispatch_main_queue_callback_4CF :<span class="number">1000</span> (in libdispatch.dylib)
<span class="number">4</span>   CoreFoundation                  <span class="number">0x000000018a65e810</span> ___CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ :<span class="number">12</span> (in CoreFoundation)
<span class="number">5</span>   CoreFoundation                  <span class="number">0x000000018a65c3fc</span> ___CFRunLoopRun :<span class="number">1660</span> (in CoreFoundation)
<span class="number">6</span>   CoreFoundation                  <span class="number">0x000000018a58a2b8</span> _CFRunLoopRunSpecific :<span class="number">444</span> (in CoreFoundation)
<span class="number">7</span>   GraphicsServices                <span class="number">0x000000018c03e198</span> _GSEventRunModal :<span class="number">180</span> (in GraphicsServices)
<span class="number">8</span>   UIKit                           <span class="number">0x00000001905d17fc</span> -[UIApplication _run] :<span class="number">684</span> (in UIKit)
<span class="number">9</span>   UIKit                           <span class="number">0x00000001905cc534</span> _UIApplicationMain :<span class="number">208</span> (in UIKit)
<span class="number">10</span>  xxxiPhone                       <span class="number">0x0000000100041a98</span> main main.m:<span class="number">26</span> (in xxxiPhone)
<span class="number">11</span>  libdyld.dylib                   <span class="number">0x000000018956d5b8</span> _start :<span class="number">4</span> (in libdyld.dylib)
</code></pre><p>一看到这种堆栈，头就大了，除了<strong>Thread 0 的第10行是和程序本身二进制相关的</strong>堆栈，其余的调用栈全部是系统库里面的，并且唯一一行程序本身二进制的代码还是一个完全没作用的<code>main</code>函数。</p>
<p>好吧，只能重新找找其余的线索。从堆栈上来反推当时的场景应该是如下场景：</p>
<pre><code>启动 -&gt; main函数 -&gt; main_queue 执行 -&gt; dispatch_group_leave -&gt; <span class="constant">Crash</span>
</code></pre><p>于是，我们的线索就从最后的<code>_dispatch_group_leave</code>来进行。  </p>
<p>首先先来最简单的方法：下符号断点：<code>dispatch_group_leave</code>。</p>
<p>当然事情没有这么简单，尝试重复多次也没有断到我们想要的符号断点上，于是这条路暂时考虑放弃（结合Crash率也可以发现这并非必现的Crash场景）。</p>
<p>这条路不通，我们先尝试全局搜索<code>dispatch_group_leave</code>，结果发现有如下几条线索：</p>
<ul>
<li>外部开源库</li>
<li>自身工程代码</li>
</ul>
<p>结合Crash出现的版本以及以上上述各库最后升级时间来判断，我们基本确定出在问题出现在自身工程中的代码里，如下：</p>
<pre><code>dispatch_group_t serviceGroup = dispatch_group_create();
dispatch_group_notify(serviceGroup, dispatch_get_main_queue(), ^{
    <span class="built_in">NSLog</span>(<span class="string">@"ttttttt:%@"</span>,t);
});

<span class="comment">// t 是一个包含一堆字符串的数组 </span>
[t enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) {
    dispatch_group_enter(serviceGroup);
    SDWebImageCompletionWithFinishedBlock completion =
    ^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
        dispatch_group_leave(serviceGroup);
        <span class="built_in">NSLog</span>(<span class="string">@"idx:%zd"</span>,idx);
    };
    [[SDWebImageManager sharedManager] downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:t[idx]]
                                                    options:SDWebImageLowPriority
                                                   progress:<span class="literal">nil</span>
                                                  completed:completion];
}];
</code></pre><p>这段代码逻辑非常简单吧：给你一个数组，里面是一堆图片地址。你使用多线程进行并发下载，直到所有图片都下载完成（可以失败）进行回调，其中图片下载使用的是<code>SDWebImage</code>。</p>
<p>这段代码里面的的确确出现了可疑的<code>dispatch_group_leave</code>，但是这段代码太常见了。和同事认认真真检查了许久，同时也和天猫、手淘中使用<code>dispatch_group_t</code>的地方进行了对比，没发现任何问题。</p>
<p>好吧，问题一下子陷入了僵局，只好上终极调试大法：<strong>汇编分析法</strong>。</p>
<p>通过文章开头的堆栈我们查找<code>libdispatch.dylib</code>中对应的Crash位置，然后通过汇编解析查看相关指令，结果如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/hopper.png?raw=true" alt=""></p>
<p>从上图看出，指令挂掉的原因是因为执行了<code>brk</code> （brk可以理解为跳转指令特殊的一种，一旦执行，就会进入某种Exception模式，导致Crash）。</p>
<p>为什么执行<code>dispatch_group_leave</code>会挂？从上述图中汇编不难发现，<code>dispatch_group_leave</code>具有两条分支：比较x9寄存器和0之间的关系，如果是less equal，就跳转到0x180502808(即会crash的逻辑分支)；反之则正确执行ret返回。</p>
<p>那么x9寄存器是什么？我们继续往上看指令<code>ldxr x9, [x10]</code>，x9中的值是以x10寄存器中的内容作为地址，取64位放入x9寄存器中。继续，那么x10中的内存是什么？x10中的内容是指令<code>add x10, x0, #0x30</code>。也就是x10 = x0 + 48(0x30的10进制表示)。那么，函数调用的时候x0是self，也即是一个类或者结构体的首地址。所以这两句指令加起来的含义就是<strong><b style="color:red">取结构体地址偏移48位置的某个成员变量的值。</b></strong></p>
<p>除此之外，汇编解析还完整保留了Crash的字符串提示： <strong>“BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()”</strong></p>
<p>结合这两点，我们查看<code>libdispatch</code>的源码，代码如下：</p>
<pre><code><span class="function"><span class="keyword">void</span>
<span class="title">dispatch_group_leave</span>(<span class="params">dispatch_group_t dg</span>)
</span>{
    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;
    dispatch_atomic_release_barrier();
    <span class="keyword">long</span> <span class="keyword">value</span> = dispatch_atomic_inc2o(dsema, dsema_value);
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);
    }
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == dsema-&gt;dsema_orig)) {
        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);
    }
}
</code></pre><p><em>注：苹果开发的libdispatch源码经过了各种变形修改，不是真正运行的代码，仅供参考。</em></p>
<p>果不其然，这段代码完整复现了我们之前汇编分析的结果：如果<code>dg</code>信号量中的字段<code>dsema_value</code>原子性自加一后等于LONGMIN，就会<strong>CRASH</strong>。为什么会Crash呢？</p>
<p>我们需要关注下LONG_MIN这个数字，<code>LONG_MIN = -LONG_MAX - 1</code>。理解起来很简单，就是可以表征的(该类型合法范围)最大数和最小数。</p>
<p>搜索下LONGMAX，我们发现在<code>dispatch_group_create</code>里面发现了它的踪影：</p>
<pre><code><span class="keyword">dispatch_group_t</span>
dispatch_group_create(<span class="keyword">void</span>)
{
    <span class="keyword">dispatch_group_t</span> dg = _dispatch_alloc(DISPATCH_VTABLE(group),
            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_semaphore_s));
    _dispatch_semaphore_init(LONG_MAX, dg);
    <span class="keyword">return</span> dg;
}
</code></pre><p>好了， 这下豁然开朗。这两段代码的结合告诉了我们一个事实：当<code>dq</code>这个信号量加一导致<strong><b style="color:red">溢出</b></strong>后，<code>dispatch_group_leave</code>就会Crash。</p>
<p>最简单的复现代码如下：</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad 
{
    [<span class="keyword">super</span> viewDidLoad];
    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();
    dispatch_group_leave(<span class="keyword">group</span>);
    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span>
}
</code></pre><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/symbol.png?raw=true" alt=""></p>
<p>当然，上述代码相当直白简单，我们一般都不会犯这样低级的错误。</p>
<h3 id="代码究竟出错在哪？">代码究竟出错在哪？</h3><p>了解了<code>dispatch_group_leave</code>的出错原因后，我们再回到我们刚刚认为没问题的代码，一定是哪个地方我们欠考虑了。</p>
<p>上述代码执行流程还是非常简单的，我们用模型简述一遍：</p>
<p><strong>遍历数组，对每个URL进行<code>dispatch_group_enter</code>，然后将其丢入一个下载block交由SDWebImage进行并发下载，下载回调（无论失败或者成功）后执行<code>dispatch_group_leave</code>。</strong></p>
<p>我们举个简单的例子，假设我们有一个包含5个URL的数组：</p>
<ol>
<li>遍历的时候，对信号量<code>dq</code> enter了5次，简单理解信号量减去5次。</li>
<li>SDWebImage下载回调的时候，对信号量<code>dq</code> leave了5次，于是信号量增加了5次。</li>
<li>执行完毕，整个group执行完成。</li>
</ol>
<p><strong><b style="color:red">但是，由于SDWebImage的下载是异步且无法保证时间的，如果在整个group没有执行完毕期间，上述函数整体又被执行到了，会怎么样？</b></strong></p>
<p>我们再用上述的例子来走遍流程。</p>
<ol>
<li>第一次遍历，我们创建了信号量<code>dq1</code>，enter了5次，dq1 现在 = -5。</li>
<li>SDWebImage的下载回调捕捉了<code>dq1</code>，准备留待回调后加回来，我们将这次遍历生成的下载回调block统称为b10, b12, b13, b14, b15。</li>
<li><strong>但是，在第一次SDWebImage下载回调还没执行的时候，第二次函数遍历来了。</strong></li>
<li>第二次遍历，我们创建了信号量<code>dq2</code>，enter了5次，dq2 现在 = -5。</li>
<li>创建第二次遍历对应的回调block，称为b20，b21, b22, b23, b24。</li>
</ol>
<p>通过查阅<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m" target="_blank" rel="external">SDWebImageDownloader.m</a>源码我们发现：</p>
<pre><code><span class="function_or_atom">dispatch_barrier_sync</span>(<span class="function_or_atom">self</span>.<span class="function_or_atom">barrierQueue</span>, ^{
    <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">operation</span> = <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>];
    <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">operation</span>) {
    <span class="function_or_atom">operation</span> = <span class="function_or_atom">createCallback</span>();

    // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意这行<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
    <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] = <span class="function_or_atom">operation</span>;

    __weak <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">woperation</span> = <span class="function_or_atom">operation</span>;
    <span class="function_or_atom">operation</span>.<span class="function_or_atom">completionBlock</span> = ^{
      <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">soperation</span> = <span class="function_or_atom">woperation</span>;
      <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">soperation</span>) <span class="function_or_atom">return</span>;
      <span class="function_or_atom">if</span> (<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] == <span class="function_or_atom">soperation</span>) {
          [<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span> <span class="function_or_atom">removeObjectForKey:url</span>];
      };
    };
}
</code></pre><p>SDWebImage的下载器会<strong>根据URL做下载任务对应NSOperation映射，也即之前创建的下载回调Block。</strong></p>
<p>好，就是这行导致Crash的发生。为什么呢？</p>
<p>我们设想下，假设在第二次遍历中包含了第一次遍历中的图片URL，比如b20对应的图片URL和b10对应的图片URL一样，那么在SDWebImage的处理回调里，b20就会替换掉b10。<b style="color:red">于是，在第一次遍历创建的5个下载任务回调中，b10回调的时候实际已经执行的是b20，也就是<code>dq2 + 1</code>；而在后续第二次遍历执行下载任务回调的时候，又分别执行了b20-b24的5个任务，导致<code>dq2 + 5</code>。这从导致<code>dq2</code>实际上leave的次数比enter的次数多了1 (6比5)，导致了dq2信号量的数值溢出，从而进入了Crash分支。</b></p>
<h3 id="最后">最后</h3><p>看起来很简单、清晰易懂的代码，没想到也会造成巨大的问题。所以，写代码一定要谨慎谨慎再谨慎。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="起因">起因</h3><p>昨天其他部门的同事突然反馈一起相对来说比较严重的Crash问题（占比达到了yyyy左右，并且从Crash堆栈上可以发现很多情况下是一启动就Crash了）。去掉隐私数据大致堆栈如下：</p>
<pre><code>Thread <span]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSONRPCKit源码解析]]></title>
    <link href="http://satanwoo.github.io/2017/01/07/JSONRPCKit/"/>
    <id>http://satanwoo.github.io/2017/01/07/JSONRPCKit/</id>
    <published>2017-01-07T13:40:51.000Z</published>
    <updated>2017-01-07T13:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司参与开源项目<code>BeeHive</code>的开发（第一版的代码是由前辈们写的，已经开源在了GitHub上的Alibaba项目里）。在参与开发的过程中，我一直在思考一个问题：基于Protocol的服务调用真的是最合理的方式吗？这种方式从某种方式来说还是一种强依赖（至少需要引入相对应的整个Protocol的头文件），能否有更通用的方式来进行呢？而且，从目前的实现进度来看，也无法做到对方法级的解耦。</p>
<h3 id="C/S架构">C/S架构</h3><p>在传统的开发框架下，我们一般调用HTTP/HTTPS的请求的方式都是一个API接口，配合一些参数外加GET/POST的调用方式来获取远程服务器的响应返回。如：</p>
<pre><code><span class="collection">[self.manager request:@<span class="string">"api.com"</span> withParams:@<span class="collection">{@<span class="string">"name"</span>:<span class="string">"satanwoo"</span>}</span> withCompletionBlock:^<span class="list">(<span class="keyword">id</span> responseObject)</span><span class="collection">{
    NSLog<span class="list">(@<span class="string">"return response is %@"</span>, responseObject)</span><span class="comment">;</span>
)]</span><span class="comment">;</span></span>
</code></pre><h3 id="JSONRPCKit">JSONRPCKit</h3><p>JSONRPCKit是一套基于JSON RPC 2.0协议的远程服务调用框架。这套框架基于JSON格式（NULL，Boolean，String，Number，Array，Object）来传递请求以及接受返回的响应，是一套应用层之上的协议。</p>
<p>什么意思呢？  </p>
<ol>
<li>所有的客户端请求首先都必须构造成JSON格式  </li>
<li>请求中必须带有JSON RPC 2.0协议要求的字段作为标示符。  </li>
<li>服务端在处理客户端请求的时候，就从协议指定的字段去取调用的方法名、参数、版本号等等。</li>
<li>服务端将请求的结果也封装成复合JSON RPC要求的形式，通过JSON格式传回给客户端。</li>
<li>客户端根据指定的字段解析返回的结果。</li>
</ol>
<p>如果还有不懂的，我们可以看看这篇<a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html#3" target="_blank" rel="external">文章</a>。</p>
<p>所以，JSONRPCKit就是一套封装了该协议的框架，它主要包含如下几个类：</p>
<ul>
<li><code>RequestType</code> 代表着当前的请求</li>
<li><code>BatchType</code>   代表着一个批次（即里面可以一次性包含多个请求，减少调用开销）</li>
<li><code>BatchElementType</code> 将业务请求转换成批次请求的数据结构</li>
<li><code>BatchFactory</code> 构造批次请求的地方</li>
<li><code>JSONRPCError</code>  JSONRPC出错的原因</li>
<li><code>Id</code> 代表着一次（或者一批次）请求的识别符，网络回调要和客户端请求进行ID匹配，否则谁知道哪个请求需要哪个响应。</li>
</ul>
<h4 id="RequestType">RequestType</h4><p>RequestType就是一个符合JSONRPCKit定义的数据结构，包含里几个主要的字段：</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">RequestType</span> </span>{
    <span class="comment">/// If `Response == Void`, request is treated as a notification.</span>
    associatedtype <span class="type">Response</span>

    <span class="keyword">var</span> method: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> parameters: <span class="type">AnyObject</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> extendedFields: [<span class="type">String</span>: <span class="type">AnyObject</span>]? { <span class="keyword">get</span> }
    <span class="keyword">var</span> isNotification: <span class="type">Bool</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromResultObject</span><span class="params">(resultObject: AnyObject)</span></span> throws -&gt; <span class="type">Response</span>
}
</code></pre><ol>
<li><code>method</code> 远程调用的方法名</li>
<li><code>parameters</code> 调用该方法需要传入的参数，顺序需要严格按照方法的入餐，<strong>从左至右</strong>。</li>
<li><code>extendFields</code> 这个在协议中并没有定义，可以理解为自身业务需要，扩展字段。</li>
<li><code>isNotification</code> 在JSON RPC协议中规定，当请求或者相应不带有识别ID的时候，意味着这是一个全局通知，可以没有对应的解析结果。</li>
</ol>
<p>此外，还有一个<code>associatedType Response</code>可以定义响应的类型，用作校验。</p>
<h4 id="BatchElementType">BatchElementType</h4><p>大家都知道，网络调用是有其延迟性和资源消耗的，每次都去建立连接（采用TCP长链接或者HTTP keep alive除外）进行资源传输是非常不划算的话，<strong>尤其是当你的数据payload非常小，在整个传输数据占比非常小的情况下就极其的蛋疼</strong>。因此，JSON RPC 协议定义了一种可以批量传输的方式：就是一批请求包在一次传输；服务端处理好了以后，同样也在一次性将数据响应返回。</p>
<p>有人会问，那一次性批处理的响应怎么和请求对应呢？<br>这就是我们之前提到的<code>ID</code>字段的作用了，这是一个全局唯一性的识别符，请求时的id在服务端处理完后，会同样放在数据中进行返回。</p>
<p>好了，我们来看一下这个数据结构的设计：</p>
<pre><code><span class="comment">// 协议定义</span>
public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchElementType</span> </span>{
    associatedtype <span class="type">Request</span>: <span class="type">RequestType</span>

    <span class="keyword">var</span> request: <span class="type">Request</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> version: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> id: <span class="type">Id</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> body: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>
    <span class="func"><span class="keyword">func</span> <span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>

    <span class="func"><span class="keyword">func</span> <span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
    <span class="func"><span class="keyword">func</span> <span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
}

<span class="comment">// 具体实现</span>
public <span class="class"><span class="keyword">struct</span> <span class="title">BatchElement</span>&lt;<span class="title">Request</span>: <span class="title">RequestType</span>&gt;: <span class="title">BatchElementType</span> </span>{
    public <span class="keyword">let</span> request: <span class="type">Request</span>
    public <span class="keyword">let</span> version: <span class="type">String</span>
    public <span class="keyword">let</span> id: <span class="type">Id</span>?
    public <span class="keyword">let</span> body: <span class="type">AnyObject</span>

    public <span class="keyword">init</span>(request: <span class="type">Request</span>, version: <span class="type">String</span>, id: <span class="type">Id</span>) {
        <span class="keyword">let</span> id: <span class="type">Id</span>? = request.isNotification ? <span class="literal">nil</span> : id
        <span class="keyword">var</span> body: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [
            <span class="string">"jsonrpc"</span>: version,
            <span class="string">"method"</span>: request.method,
        ]

        <span class="keyword">if</span> <span class="keyword">let</span> id = id {
            body[<span class="string">"id"</span>] = id.value
        }

        <span class="keyword">if</span> <span class="keyword">let</span> parameters = request.parameters {
            body[<span class="string">"params"</span>] = parameters
        }

        request.extendedFields?.forEach { key, value <span class="keyword">in</span>
            body[key] = value
        }

        <span class="keyword">self</span>.request = request
        <span class="keyword">self</span>.version = version
        <span class="keyword">self</span>.id = id
        <span class="keyword">self</span>.body = body
    }
}
</code></pre><p>从代码中不难看出，<code>BatchElement</code>是对之前的<code>Request</code>的进一步封装，将所有<code>Request</code>的字段塞到了一个<code>body</code>中（我们可以理解为HTTP Body），这个<code>body</code>是真正用于传输的，其余字段都是用于校验的，总共需要进行如下校验：</p>
<ol>
<li>查看JSON RPC协议是不是2.0。</li>
<li>响应数据的id和请求的id是不是能匹配。</li>
</ol>
<p>为了处理这些默认逻辑，BatchElement基于Protocol Extension提供了默认的实现，具体如下：</p>
<pre><code>func <span class="function"><span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; Request<span class="class">.Response</span>
func <span class="function"><span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; Request<span class="class">.Response</span>

func <span class="function"><span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
func <span class="function"><span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
</code></pre><p>从命名中不难看出，上述4个API分成两组，分别对应单个请求和批处理的。出于篇幅考虑，我们仅以单个批次进行分析。</p>
<pre><code><span class="function"><span class="keyword">public</span> func <span class="title">resultFromObject</span>(<span class="params"><span class="keyword">object</span>: AnyObject</span>) -&gt; Result&lt;Request.Response, JSONRPCError&gt; </span>{
    <span class="keyword">let</span> receivedVersion = <span class="keyword">object</span>[<span class="string">"jsonrpc"</span>] <span class="keyword">as</span>? String
    <span class="comment">// 校验协议版本</span>
    guard version == receivedVersion <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.UnsupportedVersion(receivedVersion))
    }

     <span class="comment">// 校验标识符ID</span>
    guard id == <span class="keyword">object</span>[<span class="string">"id"</span>].flatMap(Id.init) <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.ResponseNotFound(requestId: id, <span class="keyword">object</span>: <span class="keyword">object</span>))
    }


    <span class="keyword">let</span> resultObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"result"</span>]
    <span class="keyword">let</span> errorObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"error"</span>]

      <span class="comment">// 根据错误或者结果进行解析</span>
    <span class="keyword">switch</span> (resultObject, errorObject) {
    <span class="keyword">case</span> (nil, <span class="keyword">let</span> errorObject?):
        <span class="keyword">return</span> .Failure(JSONRPCError(errorObject: errorObject))

    <span class="keyword">case</span> (<span class="keyword">let</span> resultObject?, nil):
        <span class="keyword">do</span> {
            <span class="comment">// 请求还要再单独校验一次</span>
            <span class="keyword">return</span> .Success(<span class="keyword">try</span> request.responseFromResultObject(resultObject))
        } <span class="keyword">catch</span> {
            <span class="keyword">return</span> .Failure(.ResultObjectParseError(error))
        }

    <span class="keyword">default</span>:
        <span class="keyword">return</span> .Failure(.MissingBothResultAndError(<span class="keyword">object</span>))
    }
}
</code></pre><p>根据JSON RPC的协议规定，数据在成功处理后，必须将响应结果放在<code>result</code>字段里；而如果有出错的时候，就必须放在<code>error</code>字段中。并且必须包含<code>error code</code>和<code>error message</code>。</p>
<p>所以，上述代码利用Swift强大的Pattern Match机制，进行对应的解析。<strong>有一点需要注意的是，即使是服务端成功返回了数据，但是该数据可能和我们请求需求的数据类型不一致等等，仍然有可能出错。</strong></p>
<h4 id="BatchType">BatchType</h4><p><code>BatchType</code>顾名思义，就是批次对应的数据结构。简单理解就是包着一堆<code>BatchElement</code>，没啥可以特别讲述的。</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchType</span> </span>{
    associatedtype <span class="type">Responses</span>
    associatedtype <span class="type">Results</span>

    <span class="keyword">var</span> requestObject: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responsesFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Responses</span>
    <span class="func"><span class="keyword">func</span> <span class="title">resultsFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Results</span>

    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">responsesFromResults</span><span class="params">(results: Results)</span></span> throws -&gt; <span class="type">Responses</span>
}
</code></pre><h4 id="BatchFactory">BatchFactory</h4><p>通过上面的讲述不难看出，我们要使用JSON RPC 需要有三步骤：</p>
<ol>
<li>构造一个符合JSON RPC 2.0协议的请求</li>
<li>将其转换成批处理元素</li>
<li>将批处理元素合并，构造成一个批次。</li>
</ol>
<p>这样的步骤虽然不困难，但是每次都这么干，估计使用者要吐血。所以<code>BatchFactory</code>的目的是提供简单的工厂方法。我们以构造包含1-2个请求的批处理为例：</p>
<pre><code><span class="keyword">public</span> func create&lt;<span class="string">Request:</span> RequestType&gt;(<span class="string">request:</span> Request) -&gt; Batch&lt;Request&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement = BatchElement(<span class="string">request:</span> request, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch(<span class="string">batchElement:</span> batchElement)
   }

   <span class="keyword">public</span> func create&lt;<span class="string">Request1:</span> RequestType, <span class="string">Request2:</span> RequestType&gt;(<span class="string">request1:</span> Request1, _ <span class="string">request2:</span> Request2) -&gt; Batch2&lt;Request1, Request2&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement1 = BatchElement(<span class="string">request:</span> request1, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       let batchElement2 = BatchElement(<span class="string">request:</span> request2, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch2(<span class="string">batchElement1:</span> batchElement1, <span class="string">batchElement2:</span> batchElement2)
   }
</code></pre><p>看了代码，简单吧。什么高深的都没干，就是用信号量构造了互斥区域，为什么要这么做？<strong>是为了确保<code>idGenerator</code>生成的标识符是连续的，并且是唯一的。</strong></p>
<h4 id="其他">其他</h4><p>借这里正好复习下<code>dispatch_semaphore</code>相关知识。</p>
<p><code>dispatch_semaphore</code>对应的就是信号量，当有多个线程想要访问一个需要并发保护的资源的时候，信号量可以帮助我们协调并发数。</p>
<p>我们用互斥变量（即信号量为1）来举例：<br>    xxx = dispatch_semaphore_create(1);</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) {</span>
    dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">yyy</span>, <span class="number">0</span>)</span>, ^{
        dispatch_semaphore_wait<span class="list">(<span class="keyword">xxx</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
        [self doSomething]<span class="comment">;</span>
        dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
    })</span><span class="comment">;    </span>
}<span class="comment">;</span></span>
</code></pre><p>就可以保证任意时候，只有一个线程中可以访问到资源了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司参与开源项目<code>BeeHive</code>的开发（第一版的代码是由前辈们写的，已经开源在了GitHub上的Alibaba项目里）。在参与开发的过程中，我一直在思考一个问题：基于Protocol的服务调用真的是最合理的方式吗？这种方式从某种方式来说还是一种强]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈一种解决多线程野指针的新思路]]></title>
    <link href="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/"/>
    <id>http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/</id>
    <published>2016-10-22T18:43:25.000Z</published>
    <updated>2016-10-23T12:05:48.000Z</updated>
    <content type="html"><![CDATA[<p>无论是xx还是xx，对于整个App的稳定性要求都非常之高。因此，那些前辈大牛们为了解决一些常见的问题，比如空指针、数组越界等等，开发了xxxxxx这样的底层SDK，用于解决问题。</p>
<p>但是随着业务逐渐的复杂化以及愈发严格的性能要求，xxApp绝大多数的Crash开始往野指针方面靠拢。这些野指针的问题，除了一些<strong>iOS7上delegate是assign声明导致的历史遗留问题以外，绝大多数都是多线程的赋值导致的野指针问题。</strong></p>
<p><span style="color:red">而这些多线程的野指针问题，至今仍未有一个比较好的统一解决方案。因此，今天就想稍微聊下我自身研究的一个方案。</span></p>
<h3 id="什么是多线程的野指针问题">什么是多线程的野指针问题</h3><p>之前在《浅谈多线程编程误区》一文中，曾经举过如下这样的<strong>多线程setter</strong>例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>如果这个<code>self.data</code>是个<code>nonatomic</code>的属性的话，就会造成在多次释放导致的野指针问题。（具体可以见《浅谈多线程编程误区》的原理解释）。</p>
<p>从原理解释中不难发现，本质上会产生野指针的场景是由于我们没有对临界区进行保护。导致赋值替换的操作不是原子性的。</p>
<p>有些人会说，例子中你刻意构建了一万个线程才会导致Crash。而我们平时就用用几个线程，不会有问题的。<br><strong>理论上一万个线程只不过是把两个线程中可能出现问题的概率放大了而已。在一万个线程中会出现的多线程野指针问题在两个线程中一定也会发生。</strong></p>
<h3 id="传统业界方案：赋值加锁">传统业界方案：赋值加锁</h3><p>既然原子性是导致野指针的罪魁祸首，那么我们只要在对应可能产生冲突的临界区内加锁就好了，比如：</p>
<pre><code>[<span class="operator"><span class="keyword">lock</span> <span class="keyword">lock</span>];</span>
self.data = [[NSMutableData alloc] init];
[<span class="operator"><span class="keyword">lock</span> <span class="keyword">unlock</span>]</span>
</code></pre><p>按照这样的做法，同一时间不管有多少线程试图对<code>self.data</code>进行赋值，最终都只有一个线程能够抢到锁对其赋值。</p>
<p>但是这样的做法从安全性角度来说是解决了原子赋值的问题。但是这样的做法却对开发要求比较严格，因为<strong>任意非基础类型的对象(Int, Bool)</strong>都有可能产生多线程赋值的野指针，所以开发需要牢记自身的属性变量究竟有哪些会在多线程场景中被使用到。</p>
<p><b style="color:red">而且，这样的方案还有一个非常大的不确定性！</b></p>
<p>当你开发了一个底层SDK，对外暴露了一些公共的<strong>readwrite</strong>的Property。别人对你的property赋值的时候，你怎么确定他们一定会做到线程安全？</p>
<h3 id="我的方案：runtime追踪对象初始化的GCD_Queue">我的方案：runtime追踪对象初始化的GCD Queue</h3><p>我们都知道，在<code>Objective-C</code>中，对于一个<code>property</code>的赋值最终都会转化成对于<code>ivar</code>的setter方法。所以，如果我们能确保<code>setter</code>方法的线程安全性，就能确保多线程赋值不会产生野指针。</p>
<p>好，按照这个思路进行操作的话，我们大致需要如下几个步骤：</p>
<ol>
<li>获取第一次setter调用的时机及对应的线程。</li>
<li>将这个线程记录下来。</li>
<li>后续调用setter的时候，判断当前setter调用的线程是不是我们之前记录的线程，如果是，直接赋值。如果不是，派发到对应的线程进行调用。</li>
<li>获取所有的setter，重复实现上述步骤。</li>
</ol>
<p>看起来思路很简单，具体实现起来却有一定的难度，容我由浅入深慢慢道来：</p>
<h4 id="1-_获取第一次赋值的线程并记录">1. 获取第一次赋值的线程并记录</h4><p>由于我们不能通过成员变量就记录每个ivar对应的setter的初始化线程(这样setter的个数就无限增长了)，因此本质上我们只有通过局部静态变量的方式来作为存储。同时由于我们只需要在初次执行时进行记录，所以很理所当然就想到了<code>dispatch_once</code>。</p>
<p>具体代码如下：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> initQueue;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueKey;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueContext;

<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{

    <span class="comment">// 1. 主队列</span>
    <span class="keyword">if</span> ([<span class="built_in">UIApplication</span> isMainQueue]) {
        initQueue = dispatch_get_main_queue();
        initQueueKey = [<span class="built_in">UIApplication</span> mainQueueKey];
        initQueueContext = [<span class="built_in">UIApplication</span> mainQueueContext];
    } <span class="keyword">else</span> {
        <span class="comment">// 2. 非主队列</span>
        <span class="keyword">const</span> <span class="keyword">char</span> *label = [<span class="built_in">NSStringFromSelector</span>(_cmd) UTF8String];
        initQueueKey = &amp;initQueueKey;
        initQueueContext = &amp;initQueueContext;
        initQueue = dispatch_queue_create(label, <span class="literal">nil</span>);
        dispatch_queue_set_specific(initQueue, initQueueKey, initQueueContext, <span class="literal">nil</span>);
    }
});
</code></pre><p>从代码中不难发现，由于主队列是全局共用的，所以如果这次setter的赋值是在主队列进行的，那么就直接复用主队列即可；而如果当前的队列我们自身都不确定的话，那么就干脆<strong>开辟一个串行的队列</strong>用语这个setter的后续赋值，并将其记录下来。</p>
<p><strong>细心的读者可能会发现，我们标题里写的是线程，但是在代码中记录的却是GCD的队列（Queue）。而且，我们判断的是主队列而不是主线程。这是为什么呢？</strong></p>
<p>嘿嘿，容我卖个关子，文章最后会有详细的阐述。</p>
<h4 id="2-_判断后续赋值是否是记录的线程">2. 判断后续赋值是否是记录的线程</h4><p>由于我们之前记录的是队列，所以我们是无法直接使用诸如如下代码的方式进行是否是同一个线程的判断  </p>
<pre><code><span class="string">[NSThread currentThread]</span> == xxxThread
</code></pre><p>在iOS7之前，苹果提供了<code>dispatch_get_current_queue()</code>用于获取当前正在执行的队列，如果有这个方法，我们就可以很容易判断这个队列和我们记录的队列是否是同一个了。但是很不幸的是，该方法已经被从GCD的Public API中移除了，一时间研究陷入了僵局。</p>
<p>不过好在<code>libdispatch</code>是开源的，经过一段时间的摸索，我发现了这个方法<code>dispatch_get_specific</code>，其自身实现如下：</p>
<pre><code><span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span> *
<span class="title">dispatch_get_specific</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span>
</span>{
    <span class="keyword">if</span> (slowpath(!key)) {
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }
    <span class="keyword">void</span> *ctxt = <span class="literal">NULL</span>;
    <span class="comment">// 1. 获取当前线程的执行队列</span>
    <span class="keyword">dispatch_queue_t</span> dq = _dispatch_queue_get_current();

    <span class="keyword">while</span> (slowpath(dq)) {
        <span class="comment">// 2. 如果进行过标记</span>
        <span class="keyword">if</span> (slowpath(dq-&gt;dq_specific_q)) {
            ctxt = (<span class="keyword">void</span> *)key;
            dispatch_sync_f(dq-&gt;dq_specific_q, &amp;ctxt,
                    _dispatch_queue_get_specific);
            <span class="keyword">if</span> (ctxt) <span class="keyword">break</span>;
        }
        <span class="comment">// 3. 向上传递至target Queue</span>
        dq = dq-&gt;do_targetq;
    }
    <span class="keyword">return</span> ctxt;
}
</code></pre><p>通过上述代码不难理解，系统会自动获取当前线程正在执行的队列的。如果进行该队列进行过标记，就根据我们传入的key去获取key对应的value(ctxt)。如果查询到了，就返回。否则按照目标队列层层上查，直至root_queue也没找到为止。（关于libdispatch的具体原理，我下周还会专门写篇细细分析的文章）。</p>
<p>通过这个方法，我们可以在直接记录初始化队列的时候对其进行特殊的标定：</p>
<pre><code>dispatch_queue_set_specific<span class="list">(<span class="keyword">initQueue</span>, initQueueKey, initQueueContext, <span class="literal">nil</span>)</span><span class="comment">;</span>
</code></pre><p>随后在后续setter执行的时候通过如下代码进行判断并进行相应的直接赋值或者队列重新派发：</p>
<pre><code><span class="comment">// 如果是当前队列</span>
<span class="keyword">if</span> (dispatch_get_specific(initQueueKey) == initQueueContext) {
    _threadSafeArray = threadSafeArray;
} <span class="keyword">else</span> {
     <span class="comment">// 不是当前队列</span>
    <span class="built_in">dispatch_sync</span>(initQueue, ^{
        _threadSafeArray = threadSafeArray;
    });
}
</code></pre><h4 id="3-_遍历所有的setter，重复上述过程">3. 遍历所有的setter，重复上述过程</h4><p>由于我们的目的是减轻其他开发的负担，所以不得不借助了runtime的Method Swizzling技术。但是传统的Method Swizzling技术是将函数实现两两交换。如果按照这个思路，我们就需要为每一个setter编写一个对应的<code>hook_setter</code>，这工作量无疑太巨大了。</p>
<p>所以，在这里我们需要的一个中心重定向的过程：即，将所有的setter都转移到一个hook_proxy中。代码如下：</p>
<pre><code>- (<span class="function_or_atom">void</span>)<span class="function_or_atom">hookAllPropertiesSetter</span>
{
    <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">outCount</span>;
    <span class="function_or_atom">objc_property_t</span> *<span class="function_or_atom">properties</span> = <span class="function_or_atom">class_copyPropertyList</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], &amp;<span class="function_or_atom">outCount</span>);

    <span class="variable">NSMutableArray</span> *<span class="function_or_atom">readWriteProperties</span> = [[<span class="variable">NSMutableArray</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCapacity:outCount</span>];
    <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">i</span> = <span class="number">0</span>; <span class="function_or_atom">i</span> &lt; <span class="function_or_atom">outCount</span>; <span class="function_or_atom">i</span>++) {
        <span class="function_or_atom">objc_property_t</span> <span class="function_or_atom">property</span> = <span class="function_or_atom">properties</span>[<span class="function_or_atom">i</span>];
        <span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> = [[<span class="variable">NSString</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCString:property_getName</span>(<span class="function_or_atom">property</span>) <span class="function_or_atom">encoding</span>:<span class="variable">NSUTF8StringEncoding</span>];

        <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">attrCount</span>;
        <span class="function_or_atom">objc_property_attribute_t</span> *<span class="function_or_atom">attrs</span> = <span class="function_or_atom">property_copyAttributeList</span>(<span class="function_or_atom">property</span>, &amp;<span class="function_or_atom">attrCount</span>);

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">BOOL</span> <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">NO</span>;
        <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">j</span> = <span class="number">0</span>; <span class="function_or_atom">j</span> &lt; <span class="function_or_atom">attrCount</span>; <span class="function_or_atom">j</span>++) {
            <span class="function_or_atom">if</span> (<span class="function_or_atom">attrs</span>[<span class="function_or_atom">j</span>].<span class="function_or_atom">name</span>[<span class="number">0</span>] == <span class="string">'R'</span>) {
                <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">YES</span>;
                <span class="function_or_atom">break</span>;
            }
        }
        <span class="function_or_atom">free</span>(<span class="function_or_atom">attrs</span>);

        <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">isReadOnlyProperty</span>) {
            [<span class="function_or_atom">readWriteProperties</span> <span class="function_or_atom">addObject:propertyName</span>];
        }
    }
    <span class="function_or_atom">free</span>(<span class="function_or_atom">properties</span>);

    <span class="function_or_atom">for</span> (<span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> <span class="function_or_atom">in</span> <span class="function_or_atom">readWriteProperties</span>) {

        <span class="variable">NSString</span> *<span class="function_or_atom">setterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"set%@%@:"</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringToIndex</span>:<span class="number">1</span>].<span class="function_or_atom">uppercaseString</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringFromIndex</span>:<span class="number">1</span>]];

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">NSString</span> *<span class="function_or_atom">hookSetterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"hook_set%@:"</span>, <span class="function_or_atom">propertyName</span>];

        <span class="variable">SEL</span> <span class="function_or_atom">originSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">setterName</span>);
        <span class="variable">SEL</span> <span class="function_or_atom">newSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">hookSetterName</span>);

        <span class="function_or_atom">swizzleMethod</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], <span class="function_or_atom">originSetter</span>, <span class="function_or_atom">newSetter</span>);
    }
}
</code></pre><p>在这里有两点需要注意的地方：</p>
<ol>
<li><strong>readonly</strong>的property是不具备setter功能的，所以将其过滤。</li>
<li>将每个setter，比如<code>setThreadSafeArray</code>都<strong>swizzle</strong>成了<code>hook__setThreadSafeArray</code>。即为每一个setter都定制了一个对应的hook_setter。</li>
</ol>
<p>哎，有人会问，你刚刚不才说为每一个setter编写对应的hook_setter是费时费力的吗？怎么自己打自己脸啊？</p>
<p>别急，容我慢慢道来。</p>
<p>在Method Swizzling的时候，我们需要调用<code>class_getInstanceMethod</code>来进行对应方法名的函数查找。整个过程简述如下：</p>
<pre><code><span class="keyword">method</span> cache list -&gt; <span class="keyword">method</span> list -&gt; 动态方法决议 -&gt; 方法转交 (forward <span class="type">Invocation</span>)
</code></pre><p>其中，在动态方法决议这步，如果我们添加了之前的没找到的方法，那么整个查找过程又会重新开始一遍。</p>
<p><strong><span style="color:red">由于那些hook_setter是压根不会存在于method list中的，所以在查找这些函数的时候，一定会走到动态决议这一步。</span></strong></p>
<p>基于此，我实现了如下的动态决议函数：</p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *selName = NSStringFromSelector(sel);

    <span class="keyword">if</span> ([selName hasPrefix:@<span class="string">"hook_"</span>]) {
        <span class="function"><span class="keyword">Method</span> <span class="title">proxyMethod</span> =</span> class_getInstanceMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">hook_proxy</span>:));</span>
        class_addMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], <span class="title">sel</span>, <span class="title">method_getImplementation</span>(<span class="title">proxyMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">proxyMethod</span>));</span>
        <span class="keyword">return</span> YES;
    }

    <span class="keyword">return</span> [<span class="variable">super</span> resolveInstanceMethod:sel];
}
</code></pre><p>从代码中很容易发现，如果是之前那么hook_setter的函数名，我就讲这些方法的<strong>函数实现</strong>全部重定向到函数<code>hook__proxy</code>上。</p>
<h4 id="4-_寻找上下文">4. 寻找上下文</h4><p>在传统的Method Swizzling技术中，由于我们是两两交换，因此我们不需要上下文这一个步骤，直接调用hook_setter就可以重新返回对应的原setter方法。</p>
<p>可是在本文的实现中，由于我们将所有的setter都重定向到了<code>hook__proxy</code>中，所以我们需要在<code>hook_proxy</code>中寻找究竟是给哪个property赋值。</p>
<p><strong><span style="color:red">如果对Method Swizzling的理解只停留在表面，是很难想到后续步骤的。</span></strong></p>
<p>Method Swizzling的原理是只是交换IMP，即函数实现。而我们在Objective-C的函数调用统统是通过objc_msgSend结合函数的Selector(可以简单理解为函数名)来找到真正的函数实现。</p>
<p><strong>因此，swizzle后的Selector没变，变的是IMP。</strong></p>
<p>有了这个理解，我们就可以在hook_proxy使用<b style="color:red">__cmd</b>这个隐藏变量，它会指引我们究竟是哪个Setter当前正在被调用，具体代码如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">hook_proxy:</span>(NSObject *)proxyObject
{
    <span class="comment">// 只是实现被换了，但是selector还是没变</span>
    NSString *originSelector = NSStringFromSelector(_cmd);
    NSString *propertyName = [[originSelector <span class="string">stringByTrimmingCharactersInSet:</span>[NSCharacterSet <span class="string">characterSetWithCharactersInString:</span>@<span class="string">":"</span>]] <span class="string">stringByReplacingOccurrencesOfString:</span>@<span class="string">"set"</span> <span class="string">withString:</span>@<span class="string">""</span>];
    <span class="keyword">if</span> (propertyName.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;

    NSString *ivarName = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"_%@%@"</span>, [propertyName <span class="string">substringToIndex:</span><span class="number">1</span>].lowercaseString, [propertyName <span class="string">substringFromIndex:</span><span class="number">1</span>]];

    <span class="comment">//NSLog(@"hook_proxy is %@ for property %@", proxyObject, propertyName);</span>

    重复之前步骤即可。
}
</code></pre><h4 id="5-_其他拓展">5. 其他拓展</h4><p><strong>本文中只是探索了下没有重载setter的那些ivar，因此只需要简单对ivar进行赋值即可。</strong><br>如果你碰到了大量自定义setter的ivar，那么也一样很简单，你只需要维护一个ivar 到对应自定义的setter的imp映射，在hook_proxy将<code>setValue:ForKey:</code>替换成直接的IMP调用即可。</p>
<h3 id="一些额外细节">一些额外细节</h3><ul>
<li><ol>
<li>线程和GCD Queue并不是一一对应的关系。</li>
</ol>
</li>
</ul>
<p>前面提到了，我们要记录的是队列而不是线程。相信很多人可能一开始都不能理解，那么我用如下这样的代码进行解释：</p>
<pre><code><span class="tag">if</span> ([NSThread isMainThread]) {
    <span class="attr_selector">[self doSomeThing]</span>;
} <span class="tag">else</span> {
    <span class="tag">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="attr_selector">[self doSomething]</span>;
    });
}
</code></pre><p>上述代码想必大家非常熟悉，就是全包在主线程执行一些操作，比如UI操作等等。但是事实上，这里有个误区：</p>
<p><strong>主队列一定在主线程执行，而主线程不一定只执行主队列。</strong></p>
<p><b style="color:red">换句话说：上述代码的if 和 else是不等价的。</b> </p>
<p>有时候，主线程有可能会被调度到执行其他队列（其他线程亦是如此），比如如下代码：</p>
<pre><code><span class="comment">// 在主线程创建</span>
dispatch\_queue\_t dq = dispatch\_queue\_create(<span class="string">'com.mingyi.dashuaibi'</span>, <span class="keyword">NULL</span>);
dispatch_sync(dq, ^{
    NSLog(@<span class="string">"current thread is %@"</span>, [NSThread currentThread]);
});
</code></pre><p>具体效果，大家可以自己尝试下，看看Log输出的结果是不是主线程。</p>
<ul>
<li><ol>
<li>为什么不能直接将所有的setter直接hook到hook_proxy，非要通过动态决议来进行。</li>
</ol>
</li>
</ul>
<p>我们举个简单的例子，假设我们有两个property，分别叫A和B。那么在执行下述代码的时候：</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 2; i++) {</span>
     SEL originSetter = NSSelectorFromString<span class="list">(<span class="keyword">setterName</span>)</span><span class="comment">;</span>
     SEL newSetter = NSSelectorFromString<span class="list">(<span class="keyword">hook_proxy</span>)</span><span class="comment">;</span>
     swizzleMethod<span class="list">([self class], originSetter, newSetter)</span><span class="comment">;</span>
}</span>
</code></pre><p>第一次交换的时候，Setter A的 IMP和 hook_proxy的 IMP进行了交换，这一步没问题。<br>第二次交换的时候，Setter B的 IMP和 hook_proxy的 IMP进行了交换，而此时hook_proxy的IMP已经指向了Setter A的IMP，因此导致的结果就是交换错乱了，调用setter B实质上是调用了setter A。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>无论是xx还是xx，对于整个App的稳定性要求都非常之高。因此，那些前辈大牛们为了解决一些常见的问题，比如空指针、数组越界等等，开发了xxxxxx这样的底层SDK，用于解决问题。</p>
<p>但是随着业务逐渐的复杂化以及愈发严格的性能要求，xxApp绝大多数的Crash开]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈iOS的多Window处理]]></title>
    <link href="http://satanwoo.github.io/2016/09/17/uiwindow-iOS/"/>
    <id>http://satanwoo.github.io/2016/09/17/uiwindow-iOS/</id>
    <published>2016-09-17T14:51:46.000Z</published>
    <updated>2016-09-17T14:53:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>想必做iOS的人都知道，我们的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个<code>UIWindow</code>，也就是AppDelegate在<code>applicationDidFinishLaunching</code>里面创建出来的。</p>
<p>但是即使我们什么都不做，在我们的APP里面也会有其他的<code>UIWindow</code>:</p>
<ol>
<li>键盘对应的UITextEffectWindow</li>
<li>状态栏对应的UIStatusBarWindow</li>
</ol>
<p>只不过上述两种<code>UIWindow</code>我们一般不太容易去操作罢了，因此很多问题都无形被掩盖住了。所以接下来我们就说说如果在多个UIWindow状态下存在的一些问题吧。</p>
<p>那么在什么情况下会导致我们想要创建多<code>UIWindow</code>的状态呢？我总结了一下，包括但不限于：</p>
<ol>
<li>全局性的自定义HUD，Alert效果（SCAlert）等等。</li>
<li>需要展示的界面需要盖住UIStatusBar。</li>
</ol>
<p>其中，第一种方案其实不一定需要创建一个新的<code>UIWindow</code>实例，我们也可以将这些自定义的全局性界面添加到AppDelegate的window上。但是这样就会产生一个问题，由于在<strong>iOS8之前</strong>，UIWindow的bounds是不会随着旋转而改变的，拿到的永远是处于<strong>Portrait</strong>模式下的坐标系坐标。因此，<b>对于直接添加在UIWindow上的视图，我们需要自己根据  <code>UIApplicationDidChangeStatusBarOrientationNotification</code>来进行转换处理。</b></p>
<p>苹果这篇<a href="https://developer.apple.com/library/content/qa/qa1688/_index.html" target="_blank" rel="external">Q&amp;A</a>讲述了比较具体的原因：<b style="color:red">UIWindow并不会处理rotation事件，而是UIWindow的rootViewController去处理。</b></p>
<p>而对于第二种问题，添加一个盖在UIStatusBar上的界面，就必须依赖我们自己创建一个新的UIWindow，究其原因在于UIStatusBar本身并不属于我们App内可控的一个控件，而是一个系统级创建出来的产物。<br>因此，<strong>我们必须创建一个WindowLevel大于UIWindowStatusBar的新Window盖在上面才行。</strong></p>
<p>有人会问：咦，奇怪了，为什么你在自己App内添加一个WindowLevel大于statusbar的就可以了呢？你只是在你自身应用内添加了一个UIView（UIWindow的子类），竟然能影响系统级的控件？</p>
<p><b style="color:red">是的，不知道大家有没有了解过<code>CALayer</code>这层有个属性叫zIndex。通过操纵这个属性，我们可以调整视图渲染的前后关系。即使有的UIView在构建<span style="color:black">层级树</span>的时候被后加的UIView所遮盖，但是在构建<span style="color:black">渲染树</span>的时候，zIndex越高的视图就会越处于视觉前方进行渲染。 而渲染树构建完成之后，并不是在我们的App内部进行渲染，而是通过IPC通信，统一交由一个第三方进程<span style="color:black">Render Server</span>进行渲染。而在我们这里处理盖住StatusBar的多Window的情形也是基于这个原理进行。</b></p>
<h3 id="横屏及旋转">横屏及旋转</h3><p>现在绝大多数的iPhone应用都是竖屏应用，即只支持<strong>Portrait</strong>模式。但是随着视频、直播的风口到来，在新闻、购物等等APP内都会插入视频播放这一特性，而视频播放需要的全屏播放特性势必要用到横屏，也就意味着会牵扯到旋转。</p>
<p>横屏旋转分为两种，一种是强制性的，一种是随着设备进行旋转的。什么意思呢？<br>大家还记得手机上有旋转锁这一个开关吧，你将旋转锁开启的时候，手机就保持在锁定对应的模式下，无法自动根据你旋转设备而旋转。在这种模式下，如果你需要更改APP界面对应的UIInterfaceOrientation，就必须要么在对应的<strong>viewcontroller</strong>里面提供实现如下的方法：</p>
<pre><code>- (<span class="built_in">NSUInteger</span>)supportedInterfaceOrientations
{
    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>; <span class="comment">// 表示支持水平右方向</span>
}

- (<span class="built_in">BOOL</span>)shouldAutorotate
{
    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>这样，当你展现到这个页面的时候，就会触发系统检查一下当前页面应该所处的Orientation，从而达到正确的显示效果。</p>
<p><strong>但需要注意的是，如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</strong></p>
<p>PS: <strong><i>其实这个道理和<code>hideBottomBarWhenPushed</code>是一个道理。很多人用了这个属性，发现隐藏Tabbar的时机经常错乱了</i></strong>，这个就在于没有仔细阅读文档，需要在整个导航栈里面的topmostViewController提供正确的属性设置才行。</p>
<blockquote>
<p>The value of this property on the topmost view controller determines whether the toolbar is visible. If the value of this property is true, the toolbar is hidden. If the value of this property is false, the bar is visible</p>
</blockquote>
<p>或者你可以将你需要横屏的ViewController通过present的形势展现出来（有人觉得会狠突兀，那你自己实现专场动画过渡就可以了）。<strong>不过呢，这种实现方式会有一个超级大坑，待会我们细细说。</strong></p>
<p>上面这种就是强制性的。</p>
<p>而自动旋转的就是打开旋转锁，让界面随着<strong>设备的旋转而进行旋转</strong>，这种旋转是物理特性的，非强制性的。</p>
<p>Q: 那么这两种旋转的区别在哪？<br>A: <strong>UIInterfaceOrientation（UIStatusBar的所处方向）和UIDeviceOrientation</strong>是否一致。</p>
<p>Q: 那么有什么问题呢？<br>A: 在iOS8之后，UIScreen的bounds是随着物理设备的旋转而更改的。如果你需要获取iOS8之前的bounds效果，需要使用<strong>nativeBounds</strong>。但是要记得，nativeBounds是像素级别的，你需要换算到对应的point单位来，所以关系是：</p>
<pre><code>bounds<span class="list">( <span class="keyword">&lt;</span> iOS8.<span class="number">0</span>)</span> = nativeBounds / nativeScale<span class="comment">;</span>
</code></pre><p>大家可以参考苹果的<a href="https://developer.apple.com/reference/uikit/uiscreen/1617838-bounds" target="_blank" rel="external">文档</a>来更确切的掌握一下。</p>
<h3 id="坑">坑</h3><p>上面的内容我们曾经提及在采用多<code>UIWindow</code>时候的几个大坑，如果你现在有自定义的界面，想要添加到除了<code>delegate window</code>之外的window，可能会遇到如下几个问题。</p>
<h4 id="直接将自定义的视图作为Subview添加到UIWindow上">直接将自定义的视图作为Subview添加到UIWindow上</h4><p>从理论上来说UIWindow继承于UIView，这种直接用法在认知上没有任何的问题。但是如果涉及的应用牵扯到横屏模式而且又要支持iOS7的话（我相信现在没有哪个产品还需要支持iOS6）吧，那么针对iOS7需要单独处理横屏的坐标系转换。我们摘录一段著名的开源库<strong>MBProgressHUD</strong>的代码作为示例：</p>
<pre><code><span class="preprocessor">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="title">&lt; 80000
    // Only needed pre iOS 8 when added to a window
    BOOL iOS8OrLater = kCFCoreFoundationVersionNumber &gt;</span>= kCFCoreFoundationVersionNumber_iOS_8_0;</span>
    <span class="keyword">if</span> (iOS8OrLater || ![<span class="keyword">self</span><span class="variable">.superview</span> isKindOfClass:[<span class="built_in">UIWindow</span> class]]) <span class="keyword">return</span>;

    <span class="comment">// Make extension friendly. Will not get called on extensions (iOS 8+) due to the above check.</span>
    <span class="comment">// This just ensures we don't get a warning about extension-unsafe API.</span>
    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
    <span class="keyword">if</span> (!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) <span class="keyword">return</span>;

    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="built_in">UIInterfaceOrientation</span> orientation = application<span class="variable">.statusBarOrientation</span>;
    <span class="built_in">CGFloat</span> radians = <span class="number">0</span>;

    <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsLandscape</span>(orientation)) {
        radians = orientation == <span class="built_in">UIInterfaceOrientationLandscapeLeft</span> ? -(<span class="built_in">CGFloat</span>)M_PI_2 : (<span class="built_in">CGFloat</span>)M_PI_2;
        <span class="comment">// Window coordinates differ!</span>
        <span class="keyword">self</span><span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);
    } <span class="keyword">else</span> {
        radians = orientation == <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> ? (<span class="built_in">CGFloat</span>)M_PI : <span class="number">0.</span>f;
    }

        <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(radians);
<span class="preprocessor">#endif</span>
</code></pre><h4 id="通过rootViewController的view添加子视图">通过rootViewController的view添加子视图</h4><p>这种方式就是通过将<code>window.rootViewController = vc</code>，然后我们所有的子视图都添加到<code>vc.view</code>。</p>
<p>这种使用的好处是我们无需去考虑版本兼容的问题，通过vc.view拿到的坐标系对于我们来说都是和<strong>UIInterfaceOrientation</strong>正确转换过的。</p>
<p>在iOS7之前，坐标系的转换是系统通过设置<code>vc.transform</code>更改；而在iOS8之后，vc和window的旋转会根据<strong>UIDeviceOrientation</strong>和viewcontroller自身<code>supportedInterfaceOrientations</code>进行<strong>交集</strong>的操作。</p>
<p>总之，<strong>需要支持横屏的自定义界面，全部放在viewcontroller.view上来做，是准没错的。</strong></p>
<p>而且，在iOS9以后，苹果推荐每个<code>UIWindow</code>都必须有一个rootViewController。否则<span style="color:red">在启动过程使用了不包含rootViewController的UIWindow中会导致必现的crash</span>。</p>
<h4 id="presentViewController的大坑">presentViewController的大坑</h4><p>我们前面提过，如果想要让viewcontroller单独横屏有两种方式。</p>
<blockquote>
<ol>
<li><p>如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</p>
</li>
<li><p>或者你可以将你需要横屏的ViewController通过present的形势展现出来</p>
</li>
</ol>
</blockquote>
<p>第二种方案在实现过程中，会产生一个非常隐晦的大坑，容我慢慢道来。<br>首先我们需要了解下整体响应旋转变化的事件流程，简单来说如下：</p>
<pre><code><span class="constant">UIScreen </span>-&gt; <span class="constant">UIWindow </span>-&gt; <span class="constant">UIViewController </span>-&gt; <span class="constant">ChildViewControllers </span>-&gt; <span class="constant">View </span>-&gt; <span class="constant">Subviews</span>
</code></pre><p>其中，UIWindow对应的处理方法是：<code>supportedInterfaceOrientationsForWindow</code>；而UIViewController对应的处理方法是<code>supportedInterfaceOrientations</code>。</p>
<p>也就是说，当系统通过这个流程向我们请求界面的UIInterfaceOrientation的时候，我们必须确保我们能够提供正确的返回参数。</p>
<p>而这个流程在使用<code>presentViewController</code>弹出<strong>modalViewController</strong>会产生一些问题：即当你想从<strong>modalViewController</strong> 返回（dismiss）原先的界面的时候，你会发现虽然原先界面强制设置了portrait模式，但是如果<strong>设备锁关闭且设备仍然处于水平状态</strong>，那么此时的UIInterfaceOrientation，仍然是不准确的。</p>
<p>其原因在于：当你想要dismiss的时候，系统的确发起了一次新的请求流程。但是此时，modalViewController正处于dismissing的状态中，请求到的<code>supportedInterfaceOrientations</code>还是针对modalViewController的。所以，如果你的modalViewController是横屏模式，那么返回后的效果就是横屏模式，除非你人为的旋转一下设备，让其回到竖直方向。</p>
<p>Q: 那么这种问题有没有解决办法呢？<br>A: 你可以在<code>supportedInterfaceOrientations</code>里面判断下当前的viewcontroller是不是处于<strong>isBeingDismissed</strong>，如果是的话，取其<strong>presentingViewController</strong>的<code>supportedInterfaceOrientations</code>作为返回值。</p>
<p>Q: 有些同学会问，我们怎么从来没遇到过这个问题？<br>A: 那是因为你们使用的<code>UIWindow</code> 99%的可能都是默认的<code>delegate window</code>，对于这个window，所有的旋转事件都自动帮你校准了，因此无需担忧。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li><a href="https://jkyin.me/uiwindow/" target="_blank" rel="external">UIWindow in iOS</a></li>
<li><a href="http://stackoverflow.com/questions/8598315/after-rotation-uiview-coordinates-are-swapped-but-uiwindows-are-not" target="_blank" rel="external">After rotation UIView coordinates are swapped but UIWindow’s are not?</a></li>
<li><a href="http://chun.tips/blog/2014/10/23/xiang-jie-uicoordinatespacehe-uiscreenzai-ios-8shang-de-zuo-biao-wen-ti/" target="_blank" rel="external">详解UICoordinateSpace和UIScreen在iOS 8上的坐标问题</a></li>
<li><a href="http://stackoverflow.com/questions/25391564/ios-7-dismiss-modal-view-controller-and-force-portrait-orientation" target="_blank" rel="external">iOS 7+ Dismiss Modal View Controller and Force Portrait Orientation</a></li>
<li><a href="http://swiftiostutorials.com/ios-orientations-landscape-orientation-one-view-controller/" target="_blank" rel="external">iOS Orientations: Landscape orientation for only one View Controller</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><p>想必做iOS的人都知道，我们的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个<code>UIWindow</code>，也就是AppDelegate在<code>applicationD]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Immutable来谈谈对于线程安全的理解误区]]></title>
    <link href="http://satanwoo.github.io/2016/07/10/immutable-thread/"/>
    <id>http://satanwoo.github.io/2016/07/10/immutable-thread/</id>
    <published>2016-07-10T09:03:47.000Z</published>
    <updated>2016-07-10T09:08:26.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线程安全中真正起到的作用。</p>
<p>所以今天就以这篇文章来谈谈我所理解的线程安全。</p>
<p>首先就允许我从Immutable来开始整篇话题吧。</p>
<h3 id="Swift中的Immutable">Swift中的Immutable</h3><p>用过Swift的人都知道，Swift相较于Objective-C有一个比较明显的改动就是将结构体（Struct）和类型（Class）进行了分离。从某种方面来说，Swift将值类型和引用类型进行了明显的区分。为什么要这么做？</p>
<ol>
<li>避免了引用类型在被作为参数传递后被他人持有后修改，从而引发比较难以排查的问题。</li>
<li>在某些程度上提供了一定的线程安全（因为多线程本身的问题很大程序上出在<strong>写修改</strong>的不确定性）。而Immutable 数据的好处在于一旦创建结束就无法修改，因此相当于任一一个线程在使用它的过程中仅仅是使用了读的功能。</li>
</ol>
<p>看到这，很多人开始欢呼了（嘲讽下WWDC那些“托”一般的粉丝，哈哈），觉得线程安全的问题迎刃而解了。</p>
<p>但事实上，我想说的是<strong>使用Immutable不直接等同于线程安全</strong>，不然在使用NSArray，NSDictionary等等Immutable对象之后，为啥还会有那么多奇怪的bug出现？</p>
<h3 id="指针与对象">指针与对象</h3><p>有些朋友会问，Immutable都将一个对象变为不可变的“固态”了，为什么还是不安全呢，在各个线程间传递的只是一份只读文件啊。</p>
<p>是的，对于一个Immutable的对象来说，它自身是不可变了。但是在我们的程序里，我们总是需要有“东西”去指向我们的对象的吧，那这个“东西”是什么？<strong>指向对象的指针</strong>。</p>
<p>指针想必大家都不会陌生。对于指针来说，其实它本质也是一种对象，我们更改指针的指向的时候，实质上就是对于指针的一种赋值。所以想象这样一种场景，当你用一个指针指向一个Immutable对象的时候，在多线程更改的时候，你觉得你的指针修改是线程安全的吗？这也就是为什么有些人碰到一些跟<strong>NSArray</strong>这种Immutable对象的在多线程出现奇怪bug的时候会显得一脸懵逼。</p>
<p>举例：  </p>
<pre><code><span class="comment">// Thread A 其中immutableArrayA count 7</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayA;

<span class="comment">// Thread B 其中immutableArrayB count 4</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayB 

<span class="comment">// main Thread</span>
<span class="preprocessor">[</span><span class="built_in">self</span><span class="built_in">.</span>xxx objectAtIndex:<span class="number">5</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述这个代码片段，绝对是存在线程的安全的隐患的。</p>
<h3 id="锁">锁</h3><p>既然想到了多线程对于指针（或者对象）的修改，我们很理所当然的就会想到用锁。在现如今iOS博客泛滥的年代，大家都知道NSLock, OSSpinLock之类的可以用于短暂的Critical Section竞态的锁保护。</p>
<p>所以对于一些多线程中需要使用共享数据源并支持修改操作的时候，比如NSMutableArray添加一些object的时候，我们可以写出如下代码：</p>
<pre><code>OSSpinLock(&amp;_lock)<span class="comment">;</span>
[self.array addObject:@"hahah"]<span class="comment">;</span>
OSSpinUnlock(&amp;_lock)<span class="comment">;</span>
</code></pre><p>乍一看，这个没问题了，这个就是最基本的写保护锁。如果有多个代码同时尝试添加进入<code>self.array</code>，是会通过锁抢占的方式一个一个的方式的添加。</p>
<p>但是，这个东西有啥卵用吗？原子锁只能解决Race Condition的问题，但是它并不能解决任何你代码中需要有时序保证的逻辑。</p>
<p>比如如下这段代码：</p>
<pre><code>if (<span class="literal">self</span>.xxx) {
    [<span class="literal">self</span>.dict <span class="built_in">set</span>Object:@<span class="string">"ah"</span> <span class="keyword">for</span>Key:<span class="literal">self</span>.xxx];
}
</code></pre><p>大家第一眼看到这样的代码，是不是会认为是正确的？因为在设置key的时候已经提前进行了<code>self.xxx</code>为<strong>非nil</strong>的判断，只有非nil得情况下才会执行后续的指令。<strong>但是，如上代码只有在单线程的前提下才是正确的。</strong></p>
<p>假设我们将上述代码目前执行的线程为<code>Thread A</code>，当我们执行完<code>if (self.xxx)</code>的语句之后，此时CPU将执行权切换给了<code>Thread B</code>，而这个时候Thread B中调用了一句<strong><em><code>self.xxx = nil</code></em></strong>。<div style="color:red"><b>嘿嘿，后果如何，想必我不用多说了吧。</b></div></p>
<p>那对于这种问题，我们有没有比较好的解决方案呢？答案是存在的，就是使用<strong>局部变量</strong>。<br>针对上述代码，我们进行如下修改：</p>
<pre><code>__strong id <span class="function"><span class="keyword">val</span> =</span> self.xxx;
<span class="keyword">if</span> (<span class="function"><span class="keyword">val</span>) {</span>
    [self.dict setObject:@<span class="string">"ah"</span> forKey:<span class="function"><span class="keyword">val</span>];</span>
}
</code></pre><p>这样，无论多少线程尝试对<code>self.xxx</code>进行修改，本质上的<code>val</code>都会保持现有的状态，符合非nil的判断。</p>
<h3 id="Objective-C的Property_Setter多线程并发bug">Objective-C的Property Setter多线程并发bug</h3><p>最后我们回到经常使用的Objective-C来谈谈现实生活中经常出现的问题。相信各位对于Property的Setter概念都不陌生，<code>self.xxx = @&quot;kks&quot;</code>其实就是调用了<code>xxx</code>的setter方法。而Setter方法本质上就是如下这样一段代码逻辑：</p>
<pre><code>- (void)setXxx:(NSString *)newXXX {
      if (newXXX != _xxx) {
          [newXXX retain]<span class="comment">;</span>
          [_xxx release]<span class="comment">;</span>
          _userName = newXXX<span class="comment">;</span>
      }
}
</code></pre><p>比如<strong>Thread A 和 B</strong>同时对<code>self.xxx</code>进行了赋值，当两者都越过了<code>if (newXXX != _xxx)</code>的判断的时候，就会产生<code>[_xxx release]</code>执行了两次，造成过度释放的crash危险。</p>
<p>有人说，呵呵，你这是MRC时代的写法，我用了ARC，没问题了吧。</p>
<p>ok，那让我们来看看ARC时代是怎么处理的，对于ARC中不复写Setter的属性（我相信是绝大多数情况），Objective-C的<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm" target="_blank" rel="external">底层源码</a>是这么处理的。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, 
  ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) 
{
    <span class="keyword">id</span> oldValue;
    <span class="comment">// 计算结构体中的偏移量</span>
    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);

    <span class="keyword">if</span> (<span class="keyword">copy</span>) {
        newValue = [newValue copyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> {
        <span class="comment">// 某些程度的优化</span>
        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;
        newValue = objc_retain(newValue);
    }

    <span class="comment">// 危险区</span>
    <span class="keyword">if</span> (!atomic) {
         <span class="comment">// 第一步</span>
        oldValue = *slot;

        <span class="comment">// 第二步</span>
        *slot = newValue;
    } <span class="keyword">else</span> {
        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
        _spin_lock(slotlock);
        oldValue = *slot;
        *slot = newValue;        
        _spin_unlock(slotlock);
    }

    objc_release(oldValue);
}
</code></pre><p>由于我们一般声明的对象都是<strong>nonatomic</strong>，所以逻辑会走到上述注释<strong>危险区</strong>处。还是设想一下多线程对一个属性同时设置的情况，我们首先在线程A处获取到了执行第一步代码后的<strong>oldValue</strong>，然后此时线程切换到了B，B也获得了第一步后的oldValue，所以此时就有两处持有oldValue。然后无论是线程A或者线程B执行到最后都会执行<strong>objc_release(oldValue);</strong>。</p>
<div style="color:red"><b>于是，重复释放的场景就出现了，crash在向你招手哦！</b></div>

<p>如果不相信的话，可以尝试如下这个小例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>相信你很容易就能看到如下错误log：<strong>error for object: pointer being freed was not allocated</strong>。</p>
<h3 id="结语">结语</h3><p>说了这么多，本质上线程安全是个一直存在并且相对来说是个比较困难的问题，没有绝对的银弹。用了Immutable不代表可以完全抛弃锁，用了锁也不代表高枕无忧了。希望这篇文章能够帮助大家更深入的思考下相关的问题，不要见到线程安全相关的问题就直接回答加锁、使用Immutable数据之类的。</p>
<p><strong>当然，其实Stick To GCD (dispatch_barrier)是最好的解决方案。</strong></p>
<p>本文写于头昏脑涨之中，写错之处请大神多多指出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么Spotify的付费用户转化率惊人的高？]]></title>
    <link href="http://satanwoo.github.io/2016/05/02/Spotify/"/>
    <id>http://satanwoo.github.io/2016/05/02/Spotify/</id>
    <published>2016-05-02T08:34:03.000Z</published>
    <updated>2016-05-02T08:38:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文由本人独自翻译，同步发表在稀土上</strong></p>
<p>在 2015 年的时候，The Fader <a href="http://www.thefader.com/2015/06/10/new-spotify-statistics" target="_blank" rel="external">报道</a>了一则关于 Spotify 的重磅新闻：在其 7500 万月活跃用户中，有 2000 万左右是付费用户。</p>
<p>26.6% 的转化率对于免费增值产品来说是令人难以置信的。正如 Jason Chen <a href="http://blog.asmartbear.com/freemium.html" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>“如果说免费用户到收费用户的转化率可以达到 4%，那就已经可以说是很不错了，比如 DropBox。但是通常来说，转化率一般都处于 1% 上下浮动，这还是用户十分活跃的情况下才会达到。”</p>
</blockquote>
<p>如果说 1% 是普遍的水准，然后 <a href="https://www.process.st/dropbox-vs-google-drive/" target="_blank" rel="external">DropBox</a> 4% 的转化率是非常不错的话，那26.6%绝对可以称的上是令人匪夷所思了。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/1.jpg" alt=""></p>
<p>至于用户留存率，<a href="http://expandedramblings.com/index.php/spotify-statistics/" target="_blank" rel="external">80%</a>的用户（包括免费用户和付费用户）每周都会多次使用 Spotify。</p>
<p>我写这篇文章的原因在于我在使用 Spotify 仅仅 11 天后，就成为了它的付费用户（似乎我当时还经历了一个 7 天 A/B 测试的试用阶段）。所以，我想从产品、<a href="https://medium.com/@benjbrandall/astonishment-expectations-and-reality-in-user-experience-decb6cc18e28" target="_blank" rel="external">用户体验</a>和市场运营的视角来真正探究一下其中深层次的原因，究竟是什么导致了 Spotify 有如此大的魔力让用户乐意为其付费。</p>
<p>所以，出于这次研究的目的，我又重新注册了一个账号。</p>
<p>我用了一个新账号并且从一个新用户的视角来使用 Spotify，一个个去剖析那些容易激发用户付费的诱因，并调查这些诱因是如何保证如此高的转化率以及用户留存率。</p>
<p><em>在我们开始前，我们需要留意一点:</em> <a href="https://www.process.st/slack-review/" target="_blank" rel="external">Slack</a> 也因为它那令人咋舌的用户转化率而出名，<a href="http://www.nirandfar.com/2014/11/slack.html" target="_blank" rel="external">最新的数据</a>显示它们的转化率达到了 30% 左右。但要注意的是，Slack 是一个 B2B 软件，它的用户群体相对来说是付费能力和意愿比较强的高端用户。但是Spotify 有超过 <a href="http://www.statista.com/statistics/475821/spotify-users-age-usa/" target="_blank" rel="external">20%</a>的用户是处于 13 到 18 岁年龄段。与企业精英不惜代价寻找一种合适的解决方案相比，这个年龄段的用户一般能成为付费用户的可能性很低的…所以，Spotify 真的很令人难以置信。</p>
<h2 id="步骤_1：减少使用障碍，通过_Facebook_注册来形成病毒式营销">步骤 1：减少使用障碍，通过 Facebook 注册来形成病毒式营销</h2><p>Spotfiy 通过 Facebook 获取信息的注册方法是令人称道的。对于那些已经在手机上登录 Facebook 的用户来说，这种注册方式可以直接从 Facebook 获取你的用户数据，意味着你就不用再笨拙地输入你的邮件地址和密码。这无疑会减少用户注册账号的抵触心理。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/2.png" alt=""></p>
<p>只要仅仅一次点击，允许数据导入，你就注册成功了。</p>
<p>除了作为一种注册方式以外，导入 Facebook 的数据还完成了其余两件事：</p>
<ul>
<li>将用户的喜好展示给他们的朋友</li>
<li>可以让你的朋友了解 Spotify，并吸引他们也来注册使用 Spotify</li>
</ul>
<p>正如 Helpshift <a href="https://www.helpshift.com/blog/app-retention-20000-mau/" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>80% 的手机用户拥有 Facebook 账户。所以，当一个应用的注册只需要轻轻点击蓝色按钮的时候，用户的转化率瞬间就能有 20% 的提升。</p>
</blockquote>
<p>所以使用 Facebook 进行注册，对于 Spotify 的营销来说是起了一个非常关键的作用。正如报道中所说的那样，<strong><a href="https://www.digitalmusicnews.com/2015/06/16/for-every-paying-subscriber-spotify-adds-5-free-accounts/" target="_blank" rel="external">每一个付费用户都带来了3个免费用户</a></strong></p>
<h2 id="步骤_2：精挑细选的播放列表可以满足特定的需求">步骤 2：精挑细选的播放列表可以满足特定的需求</h2><p>Spotify 的目的就是帮助用户发现音乐。它在你初次使用的时候会鼓励你使用它“精心调配”的播放列表。</p>
<p>通过选择一个包含你熟悉歌曲的播放列表，或者一个和你品味相契合的主题，Spotify 会循环播放这些歌，并在其中穿插播放一些你所不了解的歌。</p>
<p>对于一首喜爱却又不了解的歌，人们通常的反应是会去寻找这首歌的歌手、所属专辑或者其他具有相似特征的播放列表。这种寻找的流程在 Spotify 的应用中被设计的极其简单，并且会被推荐到你看到的第一屏当中。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/3.png" alt=""></p>
<p>但这里有个需要注意的点：<strong>如果你是一个免费用户，那么你就无法在任意时刻切换到你想听的歌。</strong>即使你已经制作了你自己的播放列表，歌曲也会是随机出现的。</p>
<p>所以对于我来说，我成为付费用户的一个主要原因就在于：在 Spotify 那不可思议却又十分“对味”的推荐算法指引下，我就很自然而然的养成了一种新的并在不断改进的听歌风格。在这个过程中，许许多多的歌曲都会被加入到你的听歌列表中。但一旦加入，随机播放列表就再也不会将其剔除。因此，其中有部分可能是你不怎么想要再听到的歌曲。比如我就不再想听到任何 Brain Food 里的歌。我想要的是可以自由自在的挑选歌曲、对它们进行排序，并对我自己的歌曲列表有绝对的控制权。如果我不是付费用户的话，即使我特别想听 Stars Wars Headspace 专辑中的几首歌，但是我所能做的仅仅是不断地随机跳过我不喜欢的歌曲，直到从 Spotify 听到我想听的歌。</p>
<p>人们会尝试去“挑战”这个系统来听到他们想要听的歌，但是 Spotify 让这种想法近乎不可能。一般来说，在一个随机播放的列表中，你可能需要跳过8首歌才能听到你想要的歌。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/4.png" alt=""></p>
<h2 id="步骤3：Spotify_会强调歌曲和你息息相关的">步骤3：Spotify 会强调歌曲和你息息相关的</h2><p>首页下面是根据心情情况和流派推荐的播放列表。作为一名有音乐文化背景的研究生，我了解到人们听音乐的根本原因在于音乐能够加强情感共鸣。最好的音乐作曲家，如 <a href="https://en.wikipedia.org/wiki/Lester_Bangs" target="_blank" rel="external">Lester Bangs</a>，就曾写到这样的乐评:音乐就像一剂猛药，伴随并强化着你的听音乐体验。</p>
<p>Spotify 通过一些描述性的分类，并在其中播放与描述非常贴切的音乐来引发共鸣，让听众产生一种“音乐就是我人生不可分割的轨迹”、或“这就是我现在的感受”的心境。</p>
<p>比如在 Chill 心情分类中可以找到一些让你冷静下来的歌曲，每首歌曲又会与地点、’亚情绪’及个人听歌品味相契合。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/5.png" alt=""></p>
<p>歌曲列表包含艺术、排版以及<a href="http://blog.tryadhawk.com/content-marketing/headline-checklist/" target="_blank" rel="external">文案</a>。这些东西对于拥有不同审美的用户来说充满诱惑力。因此对用户来说，很容易就会忽略掉那些不重要的。然后立刻识别出那些诉诸于你的音乐。</p>
<p>通过鼓励你多使用播放列表，并将其和你平时的生活习惯紧紧联系到一起，Spotify 就会变得越来越智能：成为一个能够生成适应任何场景的音乐播放器。<strong>构建一个能融入用户日常生活习惯的产品是一个非常有效<a href="https://www.process.st/customer-retention-strategies/" target="_blank" rel="external">提升用户留存率</a>的方法。</strong>而 Spotify 又采用了非常人性化的手段来达成这个目的：通过理解你听音乐时候的场景和心情。比如你聚会时听得音乐；抑或是跑步、学习时听的音乐。一旦你因为这些目的使用过一次播放列表，当失去它的时候你就会非常想念它。</p>
<h2 id="步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。">步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。</h2><p>我之前看过一篇关于<a href="http://usabilitygeek.com/first-time-use-how-to-reduce-initial-friction-of-app-usage/" target="_blank" rel="external"> Flipboard 的入职流程</a>的分析，让用户将应用“培养”<br>成迎合他们自身的喜好是一个久经考验能够提升用户留存率的办法。因为在这个过程中，用户相当于在应用内做了一笔“投资”：如果他们不升级成付费用户，就意味着他们之前所耗费的精力和时间都白白浪费了。</p>
<p>Spotify 也采用了这个策略。他们的做法是允许用户将音乐存储到自己的账户中、建立自己的音乐合集、通过 Facebook 以及Spotify 自己的社交网络和朋友进行分享。</p>
<p><strong>当然，这种投资并是金钱投资，因此你不会感到是被强制消费了。（事实上，现在如果还采用收费合同来绑定用户的行为是不能被容忍的）。但是这种投资对于个人来说，却显得更为重要，因为这是一种跟时间相关的投资，每个人都很珍惜时间，不是吗?</strong></p>
<p>将 Spotify 和 Facebook 打通又是另外一种投资。在不同的应用之间建立依赖关系意味着你需要承担更多的责任。比如，你的朋友喜欢你的播放列表、喜欢听你喜欢的歌。这就意味着你在你的朋友圈中成为了一个传播品味的大师，可以给朋友宣传最新最酷的潮流。我想，你肯定不会因为不想成为付费用户就失去这得之不易的品味大师的头衔吧！</p>
<p>Spotify 并不会强求你选择一个你喜欢的音乐类型，也不会给你许多听歌的建议，它所做的只是让你自行探索音乐。因为自行探索出来的音乐会让你更加感同身受，而且和别人分享这些音乐的时候，也会让你更有成就感。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/6.png" alt="Spotify Personalization"></p>
<p>当你在你自己的设备上使用 Spotify 的时候，除了生成个性化的播放列表，Spotify 并不会耗费你大量的精力。事实上，它根本就不需要。Spotify 的推荐算法已经足够强大，能够理解你的需求。而且多半时候，推荐出来的东西都正是你想要的。所以，你只需要在培养属于你自己喜好的 Spotify 的时候耗费一点精力而已。<strong>_你的_Spotify其实比你自己更懂你的喜好</strong></p>
<h2 id="这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感">这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感</h2><p>另一个能让 Spotify 的付费策略成功伪装成是不激进的原因的是（实际上是非常激进的）你没有意识到你究竟会被一些负面因素激怒到何种程度。</p>
<p><img src="http://i.imgur.com/CIKcZnV.jpg" alt=""></p>
<p>音乐一个非常关键的作用就是它给人带来的代入感。在 Spotify 上，有一些非常流行的播放列表来帮助用户专注于工作，比如学习、<a href="https://www.process.st/writing-process/" target="_blank" rel="external">写作</a>或者要求注意力非常集中的情形。</p>
<p>_你听了15分钟的 chill Brian Eno soundscape。突然，一个刺耳的、极不匹配的流行音乐开始播放。紧跟着出现了一个广告，一个人告诉了你一个你现在毫不关心的东西。然后又过了 30 秒，这些乱七八糟的东西终于结束了，你终于可以听你想要的音乐了。如果是你，你是什么感受？。</p>
<p>对我来说，摆脱广告的烦扰并不是一个足够有说服力可以让我进行付费的理由。我并不把它们当成是对听音乐有着巨大负面影响的因素。因为只要等广告结束了，我就能继续听我想听的音乐。</p>
<p>而且和 <strong>Spotify 会让你跳过 8 首歌才能听过你想要的歌曲</strong>相比，广告是微不足道的，更何况它出现的频率也很低，低到很容易被忽略。但尽管如此，广告对于转化率也有着很大的作用。</p>
<h2 id="允许用户在30天的试用期下载离线音乐是极其明智的">允许用户在30天的试用期下载离线音乐是极其明智的</h2><p>没有什么可以比把你曾经拥有的东西强行夺走更会让你抓狂。</p>
<p>通过允许用户下载歌曲离线使用，又在一段时间后限制他们只能听在线音乐，<strong>这 30 天试用期带来的自由绝对你产生巨大的落差感</strong>。</p>
<p>一个月的试用期对于用户来说完全足够在这段时间内建立起一个音乐合集。更何况 Spotify 大大减少了探索音乐需要耗费的时间：它每天给用户推荐 20 张专辑，而且还会根据你当前的品味和习惯变化。所以 Spotify 通过试用期，给用户画了很大的一个“饼”：如果你们升级成付费用户的话，你们就能享受到多么棒听歌的特权啊。</p>
<p>一旦获得了离线听歌的特权，用户就会囤积尽可能多的歌曲。用他们的话来说，这是<em>属于你的音乐</em>。但囤积的越多，就会让你陷得越深，你再也不会愿意变回免费用户了。</p>
<h2 id="无论用户如何使用_Spotify,_最后都会被引导向升级付费">无论用户如何使用 Spotify, 最后都会被引导向升级付费</h2><p>在用户的使用过程中，有时候 Spotify 会明确的要求用户升级为会员，或者提示这个功能仅仅开放给付费用户。</p>
<p>其中，明确的要求你升级（或者说强迫式的推荐）出现在<strong>一些看似可用的功能实质上仅仅开放给付费用户</strong></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/8.jpg" alt=""></p>
<p>而在如下几种情况当中，Spotify 会采用暗示的方式提示你如果升级到付费用户，使用体验会更好：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/9.jpg" alt=""></p>
<p>所以即使 Spofity 有着巨大基数的免费用户，也很容易就能说明为什么它的付费转化率如此之高。</p>
<p><strong>只要你是音乐的发烧友、渴望发现那些令你狂热的音乐、存储音乐并想要打造出专属你品味的 Spotify。那么，是时候升级成付费用户了。（当然，你也可以选择不升级）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文由本人独自翻译，同步发表在稀土上</strong></p>
<p>在 2015 年的时候，The Fader <a href="http://www.thefader.com/2015/06/10/new-spotify-statistics" targ]]>
    </summary>
    
      <category term="Growth" scheme="http://satanwoo.github.io/tags/Growth/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML中的“空白符”，你真的懂了吗？]]></title>
    <link href="http://satanwoo.github.io/2016/04/26/blank-space-in-html/"/>
    <id>http://satanwoo.github.io/2016/04/26/blank-space-in-html/</id>
    <published>2016-04-26T15:21:22.000Z</published>
    <updated>2016-04-26T16:03:25.000Z</updated>
    <content type="html"><![CDATA[<p>这几天由于某项任务，暂时转型了成为了前端码农（实际上就是个写初级CSS的屌丝）。在这期间，我有一个需求大致是这样的：</p>
<p>我有一个父类容器，比如<strong>div</strong>，这个<strong>div</strong>的宽度是固定的。我现在要在这个<strong>div</strong>中插入5个<strong>img</strong>，这5个<strong>img</strong>等宽。同时伴随这5个<strong>img</strong>的当然还有四个间隙，这四个间隙也是等宽的。</p>
<p><strong>当然</strong>，需要根据百分比宽度进行简单适配。<br>是不是觉得很简单呢？呵呵，别说专业的前端工程师，我这种半吊子都觉得简单。<br>根据PSD效果图，我量出了对应的百分比尺寸，于是写出来如下的<strong>HTML</strong>和<strong>CSS</strong>代码：</p>
<pre><code><span class="comment">// HTML 文件</span>
&lt;div <span class="keyword">class</span>=<span class="string">"parent"</span>&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
&lt;/div&gt;

<span class="comment">// css 文件</span>
.parent {
    width:x%;
}

.parent img {
    width:y%;
    height:auto;
    margin-left:k%;
}

.parent img:first-child {
    margin-left:<span class="number">0</span>;
}
</code></pre><p>这段代码相当简洁明了吧，我通过量好的百分比，对各个图片和之间的间距进行了控制，基本上业界大多数也是这么做的吧。</p>
<p>按理说事情到这基本就结束了，毕竟img是个<strong>行内可替换元素</strong>，会自动布局在一行之内，<strong>当然前提是父容器宽度足够的前提下</strong>。不过既然我都身体力行的量过了，那自然不应该出现问题。</p>
<p>但是，卧槽，你越担心的事就越会发生。整个界面出现了非常奇葩的现象：</p>
<pre><code>这是正常情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图] 

这是实际情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>］
图]
</code></pre><p>卧槽，竟然宽度不够，换行了。尝试了很长时间，后来发现，将<code>.parent img</code>中添加<code>float:left</code>就可以完美解决，但这什么原因呢?</p>
<h3 id="原因">原因</h3><p>经过一番探索研究，我发现，这是由于<strong>空白符</strong>对<strong>inline</strong>类型的元素造成的影响。</p>
<ul>
<li>首先，<strong>img</strong>元素是一种行内可替代元素，效果基本可以理解为<strong>inline-block</strong>。</li>
<li><p>第二，我们在HTML的时候，为了在编辑器内写的美观，常常会使用回车，而回车在HTML中会被识别为空白符。</p>
<pre><code>比如
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;（空白符）
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;
</code></pre></li>
<li><p>第三，空白符具备宽度（和font-size有关），不具备高度。</p>
</li>
</ul>
<p><strong>所以，表面上我们根据设计好的图片进行了</strong>精准<strong>的测量，构造了完全匹配父类宽度的元素和间距，但是实际上却由于空白符所具备的宽度而产生了偏差。</strong></p>
<p>用一张图来表示拥有空白符后的效果：</p>
<pre><code><span class="list">[<span class="keyword">图</span><span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;
图&lt;-&gt;］</span>
</code></pre><h3 id="为什么float可以解决这个问题">为什么float可以解决这个问题</h3><blockquote>
<p>A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float</p>
</blockquote>
<p>看到这个关于float的定义了吗？<strong>float要么依赖前一个（或者后一个）float元素的边界，要么就依赖于父元素的边界。而一个空白符，既不是包含块（父容器）的边界，也不是另一个float元素，因此不受影响，也不会对其余float元素有影响。</strong></p>
<p>所以，当你对<code>.parent img</code>启用<code>float:left</code>之后，效果就成了下图所示：</p>
<pre><code>[<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>]
[空白符]
</code></pre><p>这次我们测量的宽度正好匹配完全，所以将空白符自然而然的挤到了下一行。还记得我们前面说过空白符不具备高度吗？因此，这个空白符压根没起作用！</p>
<blockquote>
<p>文中的 [] 代表父容器，&lt;-&gt; 代表间隔。</p>
</blockquote>
<h3 id="其余方案">其余方案</h3><ol>
<li>将父容器的<code>font-size</code>设置为<strong>0</strong>。</li>
<li>避免换行，写出<img src=""><img src=""><img src=""><img src=""> 这样的代码。</li>
<li>启用HTML压缩。</li>
</ol>
<p>最后：<strong>感谢美团大神FTR和淘宝大神YWJ对本菜比的指导。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天由于某项任务，暂时转型了成为了前端码农（实际上就是个写初级CSS的屌丝）。在这期间，我有一个需求大致是这样的：</p>
<p>我有一个父类容器，比如<strong>div</strong>，这个<strong>div</strong>的宽度是固定的。我现在要在这个<s]]>
    </summary>
    
      <category term="JavaScript" scheme="http://satanwoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[滥用单例之dispatch_once死锁]]></title>
    <link href="http://satanwoo.github.io/2016/04/11/dispatch-once/"/>
    <id>http://satanwoo.github.io/2016/04/11/dispatch-once/</id>
    <published>2016-04-10T16:41:09.000Z</published>
    <updated>2016-08-01T15:11:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="现象">现象</h3><p>上周排查了一个bug，现象很简单，就是个Crash问题。但是读了一下crash Log以后，却发现堆栈报的错误信息却是第一次见到（<strong>吹牛的说，我在国内的iOS也能算第十二人了</strong>），包含以下还未符号化信息：</p>
<pre><code>Application Specific Information:
com.xxx.yyy failed to scene-<span class="operator"><span class="keyword">create</span> <span class="keyword">in</span> <span class="keyword">time</span>

Elapsed total CPU <span class="keyword">time</span> (seconds): hhh秒 (<span class="keyword">user</span> hhh, <span class="keyword">system</span> <span class="number">0.000</span>), <span class="keyword">k</span>% CPU
Elapsed application CPU <span class="keyword">time</span> (seconds): <span class="number">0.</span>h秒, <span class="keyword">k</span>% CPU

<span class="keyword">Thread</span> <span class="number">0</span> <span class="keyword">name</span>:  Dispatch queue: com.apple.<span class="keyword">main</span>-<span class="keyword">thread</span>
<span class="keyword">Thread</span> <span class="number">0</span>:
<span class="number">0</span>   libsystem_kernel.dylib            <span class="number">0x36cb2540</span> semaphore_wait_trap + <span class="number">8</span>
<span class="number">1</span>   libsystem_platform.dylib          <span class="number">0x36d3d430</span> _os_semaphore_wait + <span class="number">8</span>
<span class="number">2</span>   libdispatch.dylib                 <span class="number">0x36be04a6</span> dispatch_once_f + <span class="number">250</span>
<span class="number">3</span>   xxxx                              偏移量 <span class="number">0x4000</span> + <span class="number">947290</span>
...
...</span>
</code></pre><p>无符号化的crash 堆栈暂时不去管它，我们重点关注<strong>com.xxx.yyy failed to scene-create in time</strong>。如果理解无误的话，这句话提示我们：我们的应用程序在规定的时间没能加载成功，无法显示。看起来这个原因是启动加载过长直接被干掉。那么问题来了，原因具体是啥？</p>
<h3 id="查看堆栈">查看堆栈</h3><p>首先我们需要符号化一下，这里涉及公司内部信息，所以我们自己构造个demo试试。<br>demo的代码很简单，如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">"ManageA.h"</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageA</span></span>

+ (ManageA *)sharedInstance
{
    <span class="keyword">static</span> ManageA *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageA alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageB sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageB</span></span>

+ (ManageB *)sharedInstance
{
    <span class="keyword">static</span> ManageB *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageB alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageA sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>运行后的堆栈基本如下：</p>
<pre><code><span class="preprocessor">#<span class="number">0</span>    <span class="number">0x000000011054acd2</span> in semaphore_wait_trap ()</span>
<span class="preprocessor">#<span class="number">1</span>    <span class="number">0x00000001101b1b1a</span> in _dispatch_thread_semaphore_wait ()</span>
<span class="preprocessor">#<span class="number">2</span>    <span class="number">0x00000001101b1d48</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">3</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">4</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">5</span>    <span class="number">0x000000010d01cad8</span> in -[ManageB init] at ManageA.m:<span class="number">54</span></span>
<span class="preprocessor">#<span class="number">6</span>    <span class="number">0x000000010d01ca42</span> in __25+[ManageB sharedInstance]_block_invoke at ManageA.m:<span class="number">44</span></span>
<span class="preprocessor">#<span class="number">7</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">8</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">9</span>    <span class="number">0x000000010d01c9e7</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">10</span>    <span class="number">0x000000010d01c9c9</span> in +[ManageB sharedInstance] at ManageA.m:<span class="number">43</span></span>
<span class="preprocessor">#<span class="number">11</span>    <span class="number">0x000000010d01c948</span> in -[ManageA init] at ManageA.m:<span class="number">29</span></span>
<span class="preprocessor">#<span class="number">12</span>    <span class="number">0x000000010d01c8b2</span> in __25+[ManageA sharedInstance]_block_invoke at ManageA.m:<span class="number">19</span></span>
<span class="preprocessor">#<span class="number">13</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">14</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">15</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">16</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at /ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">17</span>    <span class="number">0x000000010d01c5cc</span> in -[AppDelegate application:didFinishLaunchingWithOptions:]         at /AppDelegate.m:<span class="number">21</span></span>
</code></pre><p>从中我们可以发现，的确在这段调用栈中，出现了多次敏感字样<code>sharedInstance</code>和<code>dispatch_once_f</code>字样。</p>
<p>在查阅相关资料后，感觉是<code>dispatch_once_f</code>函数造成了信号量的永久等待，从而引发死锁。那么，为什么<code>dispatch_once</code>会死锁呢？以前说的<strong>最安全的单例构造方式</strong>还正确不正确呢？</p>
<p>所以，我们一起来看看下面关于<code>dispatch_once</code>的源码分析。</p>
<h3 id="dispatch_once源码分析">dispatch_once源码分析</h3><p>从<a href="git://git.macosforge.org/libdispatch.git" target="_blank" rel="external">libdispatch</a>获取最新版本代码，进入对应的文件<strong>once.c</strong>。去除注释后代码如下，共<strong>66</strong>行代码，但是真的是有很多奇妙的地方。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"internal.h"</span></span>

<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once</span>
<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once_f</span>

<span class="keyword">struct</span> _dispatch_once_waiter_s {
    <span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;
    <span class="keyword">_dispatch_thread_semaphore_t</span> dow_sema;
};

<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~<span class="number">0l</span>)</span>

<span class="preprocessor">#<span class="keyword">ifdef</span> __BLOCKS__</span>
<span class="comment">// 1. 我们的应用程序调用的入口</span>
<span class="function"><span class="keyword">void</span>
<span class="title">dispatch_once</span><span class="params">(dispatch_once_t *val, dispatch_block_t block)</span>
</span>{
    <span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;

    <span class="comment">// 2. 内部逻辑</span>
    dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span>
<span class="title">dispatch_once_f</span><span class="params">(dispatch_once_t *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span>
</span>{
    <span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval =
            (<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;

    <span class="comment">// 3. 地址类似于简单的哨兵位</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = { <span class="literal">NULL</span>, <span class="number">0</span> };

    <span class="comment">// 4. 在Dispatch_Once的block执行期进入的dispatch_once_t更改请求的链表</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;

    <span class="comment">// 5.局部变量，用于在遍历链表过程中获取每一个在链表上的更改请求的信号量</span>
    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;

    <span class="comment">// 6. Compare and Swap（用于首次更改请求）</span>
    <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, <span class="literal">NULL</span>, &amp;dow)) {
        dispatch_atomic_acquire_barrier();

        <span class="comment">// 7.调用dispatch_once的block</span>
        _dispatch_client_callout(ctxt, func);

        dispatch_atomic_maximally_synchronizing_barrier();
        <span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span>

        <span class="comment">// 8. 更改请求成为DISPATCH_ONCE_DONE(原子性的操作)</span>
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);
        tail = &amp;dow;

        <span class="comment">// 9. 发现还有更改请求，继续遍历</span>
        <span class="keyword">while</span> (tail != tmp) {

            <span class="comment">// 10. 如果这个时候tmp的next指针还没更新完毕，等一会</span>
            <span class="keyword">while</span> (!tmp-&gt;dow_next) {
                _dispatch_hardware_pause();
            }

            <span class="comment">// 11. 取出当前的信号量，告诉等待者，我这次更改请求完成了，轮到下一个了</span>
            sema = tmp-&gt;dow_sema;
            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 12. 非首次请求，进入这块逻辑块</span>
        dow.dow_sema = _dispatch_get_thread_semaphore();
        <span class="keyword">for</span> (;;) {
            <span class="comment">// 13. 遍历每一个后续请求，如果状态已经是Done，直接进行下一个</span>
            <span class="comment">// 同时该状态检测还用于避免在后续wait之前，信号量已经发出(signal)造成</span>
            <span class="comment">// 的死锁</span>
            tmp = *vval;
            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) {
                <span class="keyword">break</span>;
            }
            dispatch_atomic_store_barrier();
            <span class="comment">// 14. 如果当前dispatch_once执行的block没有结束，那么就将这些</span>
            <span class="comment">// 后续请求添加到链表当中</span>
            <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) {
                dow.dow_next = tmp;
                _dispatch_thread_semaphore_wait(dow.dow_sema);
            }
        }
        _dispatch_put_thread_semaphore(dow.dow_sema);
    }
}
</code></pre><p>根据以上注释对源代码的分析，我们可以大致知道如下几点：</p>
<ol>
<li><code>dispatch_once</code>并不是简单的只执行一次那么简单</li>
<li><code>dispatch_once</code>本质上可以接受多次请求，会对此维护一个请求链表</li>
<li>如果在block执行期间，多次进入调用同类的<code>dispatch_once</code>函数（即单例函数），会导致整体链表无限增长，造成永久性死锁。(<strong>其实只要进入两次就完蛋，其原因在于<code>block_invoke</code>的完成依赖于第二次进入的请求的完成，而第二次请求的完成又必须依赖之前信号量的出发。可是第一次block不结束，信号量压根不会触发</strong>)</li>
</ol>
<h3 id="备注">备注</h3><ol>
<li>根据以上分析，相对应地写了一个简易的死锁Demo，就是在两个单例的初始化调用中直接相互调用。A&lt;-&gt;B。也许这个Demo过于简单，大家轻易不会犯。但是如果是A-&gt;B-&gt;C-&gt;A，甚至是更多个模块的相互引用，那又该如何轻易避免呢？</li>
<li>以上的Demo，如果在Xcode模拟器测试环境下，是不会死锁从而导致应用启动被杀。这是因为模拟器不具备守护进程，如果要观察现象，可以输出Log或者直接利用真机进行测试。</li>
<li>有时候，启动耗时是因为占用了太多的CPU资源。但是从我们的Crash Log中可以发现，我们仅仅占用了<strong>Elapsed application CPU time (seconds): 0.h秒, k% CPU</strong>。通过这个，我们也可以发现，CPU占用率高并不是导致启动阶段APP Crash的唯一原因。</li>
</ol>
<h3 id="反思">反思</h3><p>虽然这次的问题直接原因是<code>dispatch_once</code>引出的<strong>死锁</strong>问题，但是个人认为，这却是滥用单例造成的后果。各位可以打开自己公司的app源代码查看一下，究竟存在着多少的单例。</p>
<p>实话实说，单例和全局变量几乎没有任何区别，不仅仅占用了全生命周期的内存，还对解耦造成了巨大的负作用。写起来容易，但是对于整个项目的架构梳理却是有着巨大的影响，因为在不读完整个相关代码的前提下，你压根不知道究竟哪里会触发单例的调用。</p>
<p>因此在这里，谈谈个人认为可以不使用单例的几个方面：</p>
<ol>
<li>仅仅使用一次的模块，可以不使用单例，<strong>可以采用在对应的周期内维护成员实例变量进行替换</strong>。</li>
<li>和状态无关的模块，<strong>可以采用静态（类）方法直接替换</strong>。</li>
<li>可以通过页面跳转进行依赖注入的模块，<strong>可以采用依赖注入或者变量传递等方式解决</strong>。</li>
</ol>
<p><strong>当然，的确有一些情况我们仍然需要使用单例。那在这种情况，也请将<code>dispatch_once</code>调用的block内减少尽可能多的任务，最好是仅仅负责初始化，剩下的配置、调用等等在后续进行。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="现象">现象</h3><p>上周排查了一个bug，现象很简单，就是个Crash问题。但是读了一下crash Log以后，却发现堆栈报的错误信息却是第一次见到（<strong>吹牛的说，我在国内的iOS也能算第十二人了</strong>），包含以下还未符号化信息：<]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的静态Dispatch VS 动态Dispatch]]></title>
    <link href="http://satanwoo.github.io/2016/03/22/dispatch-in-swift/"/>
    <id>http://satanwoo.github.io/2016/03/22/dispatch-in-swift/</id>
    <published>2016-03-22T09:14:34.000Z</published>
    <updated>2016-03-28T14:24:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="C++_VS_Swift">C++ VS Swift</h3><p>虽然我很早就了解了Swift（2014年的WWDC），但是在粗略看了一下Swift的语法后，我认为这不过是许多语言语法的大杂烩，感觉和C++没有啥区别。但是实际上，在我使用Swift的这几个月中，我发现了许多问题值得注意的地方，比如</p>
<ul>
<li>函数的返回值可以作为推断函数签名的依据。</li>
<li>Swift中的函数静态Dispatch VS 动态函数Dispatch</li>
</ul>
<p>而第二点，也是本文要阐述的重点。</p>
<p>在展开本文的内容前，如果你曾经有C++的开发背景，不妨回忆下C++中RTTI机制，这也是多态发生的先决条件。简单来说，就是C++的多态函数是基于运行时的，我们可以看看下面这个例子：</p>
<pre><code><span class="keyword">class</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm A"</span>;}
}

<span class="keyword">class</span> B: <span class="keyword">public</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm B"</span>;}
}

A *b = <span class="keyword">new</span> B();
b-&gt;print();
</code></pre><p>相信大家一眼就能知道这个答案，会输出<code>I&#39;m B</code>。那么，Swift中也存在<code>class</code>，那么对于Swift中的函数调用是否和C++一致呢？</p>
<h3 id="Swift_Class">Swift Class</h3><p>首先我们先来验证下最基本的<code>class</code>中的行为。我们采用和C++中相同例子，定义如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>根据Swift的<code>Type Inference</code> 我们分别验证了如下几种调用方式：</p>
<pre><code>let b1:B = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let b2:A = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a1:A = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let a2 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b3 = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b3.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>如果你自己的思考结果和这个一模一样，至少你理解了运行期和编译期的概念，恭喜你，你的C++是过关了。以<code>class B</code>举例，无论是<strong>b1, b2, b3中的哪一个，尽管其中有部分声明的类型是A，但是在实际运行时还是会走类似virtual function那套确认实际类型为B</strong>。但是，事情在Swift中真是这么简单吗？让我们接着往下看。 </p>
<h3 id="Protocol_Extension">Protocol Extension</h3><p>去年，<strong>Swift 2.0</strong>发布，随之而来，一个概念悄然兴起：面向协议的编程。而这种编程范式不可或缺的必要条件就是<strong>Protocol Extension</strong>。在<code>Swift &lt; 2.0</code> 时代，<code>Protocol</code>的作用更类似于一种表征特征的约束。而有了<code>Protocol Extension</code>以后，<code>Protocol</code>更类似于一种插件装配的概念（写过Ruby的人相信会有体会），可以在无须编写代码的情况下，更自定义的元素添加行为能力。</p>
<p>哎？你上面说了这么一大段废话，和我们的文章主题有啥关系？</p>
<p>好，首先我们先看如下定义：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span> {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>然后，我们进行如下调用：</p>
<pre><code>let a1 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b1 = <span class="function"><span class="title">B</span><span class="params">()</span></span>     
b1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a2:Testable = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b2:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>到这里，事情还是还是按照C++那套逻辑在走，如果你把<code>class B</code>中的<code>dynamicInfo</code>删除，那么对应B类型的<code>dynamicInfo</code>函数调用就会输出<strong>I’m Testable</strong>。</p>
<p>好，现在问题来了，如果我们将<code>Testable Protocol Extension</code>添加一下东西，同时保持<code>protocol Testable</code>不变，如下所示：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }

    <span class="comment">// ### 新添加的 ###</span>
    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable Static"</span>)
    }
}
</code></pre><p>如果这个时候，我们进行如下代码的测试：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }

    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A Static"</span>)
    }
}

<span class="keyword">let</span> a1 = <span class="type">A</span>()     
a1.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a2:<span class="type">A</span> = <span class="type">A</span>()
a2.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a3:<span class="type">Testable</span> = <span class="type">A</span>()
a3.staticInfo() <span class="comment">// I'm Testable Static</span>
</code></pre><p>看到没？最后一行的输出是不是出乎了大家的意料，竟然输出了<strong>I’m Testable Static</strong>。 </p>
<p>这是咋回事？回顾下之前我们改变的地方，发现我们在<strong>Protocol Extension中添加了一个<code>func staticInfo()</code>，但是却没在对应的<code>Testable Protocol</code>进行声明</strong>。但是这还不够，我们必须将调用<code>staticInfo</code>的地方的类型显式的声明成<strong>let a3:Testable</strong>。</p>
<p><div style="color:red">也就是说，Swift方法的静态Dispatch必须严格满足如下条件：</div>  </p>
<ul>
<li>方法在Extension中提供了实现，但是在对应的protocol中没有声明。</li>
<li>调用方法的时候必须显示的声明成protocol的类型。</li>
</ul>
<p>如果不好理解，我画了张图帮助大家加深印象：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/Slice%201.png" alt=""></p>
<p><strong>还有一点需要注意的是，Swift中的静态Dispatch不以类的层级和override而转移</strong>，也就是说，如下这种定义：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B Static"</span>)
    }
}
</code></pre><p>当我们使用  </p>
<pre><code>let a4:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
a4.<span class="function"><span class="title">staticInfo</span><span class="params">()</span></span>
</code></pre><p>一样会输出<code>I&#39;m Testable Static</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="C++_VS_Swift">C++ VS Swift</h3><p>虽然我很早就了解了Swift（2014年的WWDC），但是在粗略看了一下Swift的语法后，我认为这不过是许多语言语法的大杂烩，感觉和C++没有啥区别。但是实际上，在我使用Swift的这几个月中，]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxSwift的第一印象]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/RxSwift/"/>
    <id>http://satanwoo.github.io/2016/03/14/RxSwift/</id>
    <published>2016-03-13T16:21:50.000Z</published>
    <updated>2016-03-13T16:48:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>声明：本文由本人独立翻译完成，同步发表在稀土掘金</strong></p>
<p>去年整整一年，我都在试图理解响应式编程的原理是什么，并且试图验证如果在我的app中使用这种编程范式是否会带来好处。于是，我查询了许多相关的解决方案，从<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> &amp; Objective-C开始，及其Swift版本<a href="https://blog.alltheflow.com/reactive-swift-upgrading-to-reactivecocoa-3-0/" target="_blank" rel="external">ReactiveCocoa with Swift</a>，再到我朋友实现的一个轻量级的框架<a href="https://github.com/bvic23/VinceRP" target="_blank" rel="external">VinceRP</a>。上述这些都是令人赞叹不已的项目，ReactiveCocoa的项目成熟度非常高，但是十分复杂；而VinceRP的实现非常容易，所以理解起来非常简单。</p>
<p>在学习的过程中，我写了一系列关于<a href="https://blog.alltheflow.com/tag/reactive" target="_blank" rel="external">我学习响应式编程的经历</a>的文章，所以经常会被读者问到一些关于<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>的问题。惭愧地说，我还从没有使用RxSwift来编写一个项目。实际上我还从来没用过任何语言的<a href="http://reactivex.io/languages.html" target="_blank" rel="external">Rx</a>框架，所以我一直认为，对于那些曾在别的开发环境中有使用Rx经历的人来说，理解RxSwift是非常容易的。既然如此，我也是时候来尝试一把了。</p>
<h2 id="Rx">Rx</h2><p>Rx是最常使用的一个响应式编程框架。它与其他RP框架的一大不同是它的跨平台特性，同时，它有着最大的开源社区，无数的文档以及有参考价值的问题讨论，许许多多的人不断地对其进行改进。</p>
<h2 id="Swift">Swift</h2><p>这门语言在去年一年中飞速的成长，并且现在也进行了<a href="https://github.com/apple/swift" target="_blank" rel="external">开源</a>了。一些像RxSwift之类的项目也随着其一起成长。因此，没有什么理由可以再阻止你去使用这些框架。当然，一些重大的改动仍然被列在radar上，但它们很可能在短时间内不会被解决，这就意味着这个项目会不断地被改进，这不是很好吗？</p>
<h2 id="使用RxSwift开发一个app">使用RxSwift开发一个app</h2><p>如果你从未阅读过<a href="https://blog.alltheflow.com" target="_blank" rel="external">我的博客</a>，可能你现在会猜我使用RxSwift开发了一个app。没错，你是对的。这是个很耗时的习惯，但是我不喜欢依赖于一个理想的环境，所以通常我都会写一个例子来让我有那么一点感觉。通过这种方式，我可以学会如何让成功得运行这个框架。（意译：这里我想说一点个人感受，对于解决问题来说，你所选用的框架只是万千可用方案中的一种，因此，方案的选择是因人而异的。而这些选择所带来的多样性，正是我如此热爱编程的一大原因。）</p>
<p>我所写的这个应用名叫<a href="https://github.com/alltheflow/iCopyPasta" target="_blank" rel="external">iCopyPasta</a>，是一个在去年<a href="http://2015.funswiftconf.com/" target="_blank" rel="external">Functional Swift Conf</a>上展示的免费Mac剪贴板应用<a href="https://github.com/alltheflow/copypasta" target="_blank" rel="external">CopyPasta</a>的iOS姐妹版。显而易见，它们并不是一个完整的产品所以并不可以被用来上架。我现在每天都使用Mac版本的CopyPasta，但是我可能存在某些偏见。我的计划是将来会发布Mac版本和iOS版本的CopyPasta应用，并可能会将这两个版本进行打通。</p>
<blockquote>
<p>难道这不是我一直以来的计划吗？  </p>
</blockquote>
<h3 id="Observables">Observables</h3><p>我首先对<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPasteboard_Class/index.html" target="_blank" rel="external"><code>UIPasteboard</code></a>注册了观察者。 这些观察者会对你拷贝东西时出现在<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>类型进行观察。</p>
<pre><code><span class="keyword">let</span> pasteboard = <span class="type">NSNotificationCenter</span>.defaultCenter().rx_notification(<span class="string">"UIPasteboardChangedNotification"</span>, object: <span class="literal">nil</span>)
<span class="number">_</span> = pasteboard.<span class="built_in">map</span> { [<span class="keyword">weak</span> <span class="keyword">self</span>] (notification: <span class="type">NSNotification</span>) -&gt; <span class="type">PasteboardItem</span>? <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> pb = notification.object <span class="keyword">as</span>? <span class="type">UIPasteboard</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> string = pb.valueForPasteboardType(kUTTypeUTF8PlainText <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(string)
        }
        <span class="keyword">if</span> <span class="keyword">let</span> image = pb.valueForPasteboardType(kUTTypeImage <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(image)
        }
    }
    <span class="keyword">return</span> <span class="literal">nil</span>
}
</code></pre><p>之前我的方法是直接对<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>直接进行观察，但是这个方法是不正确的。原因在于<code>UIPasteboard</code>可能不是一个KVO安全的类型（具体请看下方的评论）。参考别人的建议后，我使用RxSwift另一个非常棒的功能<a href="https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxCocoa/Common/Observables/NSNotificationCenter%2BRx.swift#L23" target="_blank" rel="external"><code>rx_notification</code></a>来监听<code>UIPasteboardChangedNotification</code></p>
<pre><code>.subscribeNext { [<span class="keyword">weak</span> <span class="keyword">self</span>] pasteboardItem <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> item = pasteboardItem {
        <span class="keyword">self</span>?.addPasteboardItem(item)
    }
}
</code></pre><p>这里的<code>pasteboard</code>是一个<code>Observable&lt;NSNotification&gt;</code>，这也是为什么可以很容易得订阅其<code>.Next</code>事件同时相应地去更新<code>tableView</code>。而<code>map</code>则是从监听到的通知所涉及的对象中获取字符串或者图像，并将获取到的结果转换成<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>。</p>
<h3 id="Dispose_bags">Dispose bags</h3><p>订阅信号会产生<code>Disposable</code>。如果不终止订阅，那么这些生成的<code>Disposable</code>将会一直存在，这无疑是非常耗内存的。所以，你要么对这些订阅调用<code>dispose</code>，要么你可以像我一样，使用<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#dispose-bags" target="_blank" rel="external">dispose bags</a>来自动销毁相关的订阅。</p>
<pre><code>.<span class="function"><span class="title">addDisposableTo</span><span class="params">(disposeBag)</span></span>
</code></pre><h3 id="UIKit/Appkit_bindings">UIKit/Appkit bindings</h3><p>你可以很容易地通过<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L46" target="_blank" rel="external"><code>rx_itemsWithCellIdentifier</code></a>将<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences" target="_blank" rel="external"><code>Observable</code></a>序列绑定到table view上。<code>element</code>来自于我定义的<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>枚举类型，这也是为什么我会采用Switch来处理这个对象，这样可以根据其具体的枚举值来显示不同的样式。</p>
<pre><code>pasteViewModel.pasteboardItems()
    .bindTo(tableView.rx_itemsWithCellIdentifier(<span class="string">"pasteCell"</span>, cellType: UITableViewCell.self)) { (row, element, cell) <span class="keyword">in</span>
     <span class="keyword">switch</span> element {
     <span class="keyword">case</span> .Text(let <span class="keyword">string</span>):
         cell.textLabel?.<span class="keyword">text</span> = String(<span class="keyword">string</span>)
     <span class="keyword">case</span> .Image(let <span class="keyword">image</span>):
         cell.imageView?.<span class="keyword">image</span> = <span class="keyword">image</span>
}.addDisposableTo(disposeBag)
</code></pre><p>另外一个很棒的补充是<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L204" target="_blank" rel="external"><code>rx_modelSelected</code></a>。你可以通过它来获取你触发选择事件时对应的<code>element</code>。简单来说，它是一个对<code>tableView:didSelectRowAtIndexPath:</code>的封装，可以将代码变得非常简洁。</p>
<pre><code><span class="tag">tableView</span>
    <span class="class">.rx_modelSelected</span>(PasteboardItem)
    <span class="class">.subscribeNext</span> { <span class="attr_selector">[weak self]</span> <span class="tag">element</span> <span class="tag">in</span>
        <span class="tag">self</span>?<span class="class">.pasteViewModel</span><span class="class">.addItemsToPasteboard</span>(element)
    }<span class="class">.addDisposableTo</span>(disposeBag)
</code></pre><p>你可以通过如下链接来查看所以关于UIKit/AppKit（RxCocoa）的扩展<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md#rxcocoa-extensions" target="_blank" rel="external">RxSwift’s GitHub</a>。</p>
<h2 id="总体感受">总体感受</h2><p>到目前为止，我还只是探索了RxSwift能力的一小部分，但是我已经感受到RxSwift是一个非常棒的框架。如果能够更深入理解它的机制并学会基于它的设计思路进行思考，那肯定会更好。</p>
<p>我非常喜欢一些像<a href="https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground" target="_blank" rel="external">Rx.playground</a>，<a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>这样的资料及<a href="https://github.com/ReactiveX" target="_blank" rel="external">great community</a>这样的社区。这些资料给了我很多的灵感，所以我也乐于将我的学习经验分享给<a href="http://bitrise.io" target="_blank" rel="external">bitrise.io</a>的用户。还有一些比较重要的内容，比如<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md#custom-schedulers" target="_blank" rel="external">schedulers</a>还未被涉及，但是绝对值得研究一番。</p>
<p>对我来说，我还需要一段时间来更好地理解Rx。与我尝试ReactiveCocoa只有个把小时不同，我现在可以每天都在工作中使用RxSwift，并且坚持使用超过了一年。这都得感谢<a href="https://twitter.com/bvic23" target="_blank" rel="external">在Prezi的伙伴们</a>.</p>
<p>作为一个曾经学习过ReactiveCocoa的人来说，我现在更倾向于使用RxSwift，可能是因为我现在自认为已经对于RxSwift已经足够了解，并且使用它可以很快得完成我的编码任务。当然，在将来我可能会同时使用两者，但是我认为对于两者之间任一框架的熟练使用不代表会在学习另外一个框架的时候给你带来很大的优势。它们在几个方面有着<a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons/32581824#32581824" target="_blank" rel="external">不同</a>。同时，这两个框架（概括来说应该是所有的响应式编程框架）都有着陡峭的学习曲线。对于我来说，我已经度过了学习ReactiveCocoa最难的那段时光，但如果你是一个初学者，我建议你自己动手尝试这两种框架，甚至更多。</p>
<h2 id="深入阅读">深入阅读</h2><p>如果你还在思考应该使用哪个响应式编程的框架，那么我建议你去读一读Ash Furrow所写的关于如何挑选响应式编程框架的<a href="https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/" target="_blank" rel="external">文章</a>。</p>
<p>你也可以看看其他一些在iOS中使用响应式编程的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6" target="_blank" rel="external">视频及文章</a>，这些内容都非常得棒，相信你会受益匪浅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>声明：本文由本人独立翻译完成，同步发表在稀土掘金</strong></p>
<p>去年整整一年，我都在试图理解响应式编程的原理是什么，并且试图验证如果在我的app中使用这种编程范式是否会带来好处。于是，我查询了许多相关的解决方案，从<a href="http]]>
    </summary>
    
      <category term="Swift" scheme="http://satanwoo.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向工程SizeUp]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/SizeUp/"/>
    <id>http://satanwoo.github.io/2016/03/14/SizeUp/</id>
    <published>2016-03-13T16:20:57.000Z</published>
    <updated>2016-03-22T12:48:47.000Z</updated>
    <content type="html"><![CDATA[<p>这几天把《汇编语言》好好复习一遍，心里痒痒，就想找个软件来逆向破解一发。破啥好呢？网上逆向工程的教程一大堆，主要都是<em>Sketch</em>啦，<em>Reveal</em>啦，那我照着做一遍也没啥意思啊，体现不出我中国iOS第12人的特点啊。干脆我找个小众一点的软件破解吧。于是，我就盯上了我每天都非常喜欢使用的<strong>SizeUp</strong>，这是一款非常快速的窗口管理软件，可以通过快捷键将窗口扩展到指定的大小和位置，配合外接显示屏简直酷炫到飞起。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-09%20%E4%B8%8B%E5%8D%8810.46.45.png" alt=""></p>
<p>但是这个App有个很大的问题，虽然它是免费的，但是它每次启动的时候，包括你使用的过程中，都会时不时蹦出一个提示你购买的弹框，而且弹框上的取消按钮一定要过5秒才能点击关闭，真是让人蛋疼。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.22.04.png" alt=""></p>
<p>所以，我就讲逆向的目标定在了将这个<strong>可恶的</strong>弹窗给干掉。</p>
<h4 id="准备工作">准备工作</h4><p>首先破解必须要准备的就是逆向工具了，由于这是个Mac app，所以我们无需使用到iPhone。所以，我简单的将SizeUp进行了一次备份就开始了。</p>
<p>逆向一个app，我们当然要去分析其汇编代码，因此必不可少的工具就是IDA或者<strong>Hopper</strong>。在这里，请允许我个人强烈推荐Hopper，那傻瓜式的操作，非常适合我这种高智商人才，哇哈哈。Hopper也是支持免费的，但是免费版不能重新生成可执行文件，所以我先从网上下载了一个破解版的Hopper。</p>
<h4 id="逆向开始">逆向开始</h4><p>首先我们将SizeUp拖入Hopper，得到一系列的汇编代码。这么多的代码我们从哪里下手呢? 答案是<strong>关键字</strong>。在弹窗提示我们购买的界面中，出现了很多关键字，比如<code>license</code>抑或是<code>demo</code>。首先让我们从license开始尝试。我们在Hopper界面左上侧的搜索框中输入license，会得到如下结果：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.09.png" alt=""></p>
<p>从结果来看，我们大致猜测SizeUp的逻辑如下：</p>
<ol>
<li>初始化程序</li>
<li>检查存储的license</li>
<li>（如果有）多个，检查最好的一个（可能是有效期最长的）</li>
<li>和服务器进行验证</li>
</ol>
<p>上述这段逻辑主要来自于高亮的<code>+[License xxx]</code>函数调用。</p>
<p>从上述这段逻辑，我们可以看出，想要伪造license是不可能的了，这是因为牵涉了服务器验证。所以我们只能把想法转变成，干掉本地相关的逻辑。本地逻辑不外乎判断某种分支条件，根据结果进行某些页面的跳转，<strong>比如弹出Demo界面</strong>。</p>
<p>好，现在我们来试试<strong>Demo</strong>关键字，搜索结果如下：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.28.png" alt=""></p>
<p>从这个关键字的搜索结果来看，我们得到了不少有价值的信息，比如<strong>DemoDialogController</strong>。哈哈哈哈，苹果经典的MVC设计模式这时候起了很大的作用，搞过开发的人一般都会知道Controller一般对应的就是一个ViewController。如果你不信，我们继续往下看，可以看到一个<code>-[DemoDialogController showDemoDialog]</code>，这个提示够明显了吧，这分明就是说：老子就是那个界面，你快来把我干掉吧。</p>
<p>好，大功告成一半了，我们已经找到了我们要干掉的界面，现在我们只要干掉分支判断逻辑就好了。于是，我们继续跟着Demo关键字走，不久，我们发现了<code>+[License isDemo]</code>这个嫌疑犯。卧槽，这时候，我这天赋异禀的大脑中形成了这样一段代码：</p>
<pre><code><span class="tag">if</span> ([License isDemo]) {
    <span class="attr_selector">[[[DemoDialogController alloc]</span> <span class="tag">init</span>] <span class="tag">showDemoDialog</span>]
} <span class="tag">else</span> {
    <span class="comment">// Follow your heart</span>
}
</code></pre><p>是不是和我猜测的一样呢？</p>
<p>去掉前面的函数压栈，我们来着重看看这段代码：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.51.30.png" alt=""></p>
<pre><code><span class="keyword">mov</span> <span class="literal">edx</span>, <span class="number">0x1</span>
<span class="keyword">test</span> <span class="literal">al</span>, <span class="literal">al</span>
<span class="keyword">je</span> <span class="number">0x1000008bd9</span>
....
....
<span class="keyword">mov</span> <span class="literal">eax</span>, <span class="literal">edx</span>
</code></pre><p>这段代码不熟悉汇编的人可能不太懂，我将其转换一下。</p>
<pre><code>edx = <span class="literal">true</span>(YES)
<span class="keyword">if</span> al == <span class="number">0</span>
{
    <span class="keyword">goto</span> <span class="number">0x1000008bd9</span>
}

... <span class="number">0x1000008bd9</span>:
val = edx(<span class="literal">true</span>)
<span class="keyword">return</span> val
</code></pre><p>理解了吧，就是首先将0x1（即YES）放入<code>edx</code>寄存器，然后判断<code>al</code>代表的某种分支条件是不是0，如果是0，通过<code>je</code>命令跳转到<code>0x1000008bd9</code>地址。这个地址后面的指令就是讲<code>edx</code>的值塞入<code>eax</code>中，而<code>eax</code>是<strong>x86指令集中默认存放函数返回值的寄存器</strong>。</p>
<p>事情到这，是不是基本理清思路了？我们只需要将je跳转的条件极其后面语句干掉就好了。我在这里采用了更暴力的做法，直接在函数一开始就讲false塞入<code>eax</code>寄存器，然后直接调用<code>ret</code>进行返回。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-14%20%E4%B8%8A%E5%8D%8812.00.45.png" alt=""></p>
<h4 id="结语">结语</h4><p>是不是逆向工程看起来也没那么难呢？其实，SizeUp这种利用函数返回至做文章的逆向是最简单的，下次我们来挑战下更难的逆向目标！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天把《汇编语言》好好复习一遍，心里痒痒，就想找个软件来逆向破解一发。破啥好呢？网上逆向工程的教程一大堆，主要都是<em>Sketch</em>啦，<em>Reveal</em>啦，那我照着做一遍也没啥意思啊，体现不出我中国iOS第12人的特点啊。干脆我找个小众一点的软件]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DXXcodeConsoleUnicodePlugin源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/"/>
    <id>http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/</id>
    <published>2016-03-13T16:18:52.000Z</published>
    <updated>2016-03-13T16:19:38.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Xcode插件开发">Xcode插件开发</h4><p>嘿嘿，今天带大家学习一下基于Xcode的插件开发。可能很多人一听到插件开发，想到的都是Sublime Text，Atom这样轻量级的编辑器的扩展插件，但是实际上，无论是VisualStudio, Eclipse以及Xcode这样重量级的IDE，都是支持自定义的插件开发的。学习好了Xcode的插件开发，不仅可以打造度身定做的<strong>神器</strong>，也有助于你将来进行<strong>Mac OS</strong>的应用开发。</p>
<h4 id="DXXcodeConsoleUnicodePlugin">DXXcodeConsoleUnicodePlugin</h4><p>DXXcodeConsoleUnicodePlugin是一个帮助你自动将<code>\u6061</code>这样的unicode码转换成对应的汉字的插件。</p>
<p>这个有什么用呢？想想看，我们在网络传输的时候，服务器如果返回的数据是中文（<strong>或者非ASCII码</strong>），通过NSLog在console输出的内容是不直观的，基本都是类似<code>\u6061</code>这种，这对于我们开发调试来说是非常困难的。</p>
<p>因此，这款插件可以自动帮助我们将检测到的Unicode字符进行转换，直接输出成我们想要的对应内容。怎么样？让我们赶快来一探究竟吧！</p>
<p><strong> 在开始探讨实现之前，我个人首先强调一点，基于Unicode检测对应的字符是一个非常难的问题。不仅仅是中文，韩文、日文、big-5字符等等都属于Unicode，这些字符集之间好常常有交集。现有比较好的开源实现是</strong>Mozilla的UcharSet**。</p>
<h4 id="实现">实现</h4><p>首先打开工程，文件结构如下：</p>
<ul>
<li>DXXcodeConsoleUnicodePlugin.h/.m</li>
<li>RegExCategories.h/.m</li>
</ul>
<p>其中，<code>DXXcodeConsoleUnicodePlugin</code>是入口。同传统的iOS/Mac OS开发不同，插件开发并不存在传统意义上的main函数，更多的是利用所谓的<code>Template Method</code>设计模式将你需要的自定义部分进行复写。</p>
<p>于是，我们可以看到如下三段函数：</p>
<pre><code>+ (<span class="keyword">void</span>)pluginDidLoad:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
  <span class="built_in">NSString</span> *currentApplicationName = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleName"</span>];
  <span class="keyword">if</span> ([currentApplicationName isEqual:<span class="string">@"Xcode"</span>]) {
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
      sharedPlugin = [[<span class="keyword">self</span> alloc] initWithBundle:plugin];

      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
                                               selector:<span class="keyword">@selector</span>(menuDidChange)
                                                   name:<span class="built_in">NSMenuDidChangeItemNotification</span>
                                                 object:<span class="literal">nil</span>];
    });
  }
}

- (<span class="keyword">id</span>)initWithBundle:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
    <span class="comment">// reference to plugin's bundle, for resource acccess</span>
    <span class="keyword">self</span><span class="variable">.bundle</span> = plugin;

    <span class="comment">// Create menu items, initialize UI, etc.</span>

    <span class="comment">// Sample Menu Item:</span>
    [<span class="keyword">self</span> createMenu];

    I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span> = ReplaceInstanceMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEConsoleItem"</span>), <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:),
                                                                   [XcodeConsoleUnicode_IDEConsoleItem class], <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:));
  }

  <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)createMenu
{
  <span class="built_in">NSMenuItem</span> *menuItem = [[<span class="built_in">NSApp</span> mainMenu] itemWithTitle:<span class="string">@"Edit"</span>];
  <span class="keyword">if</span> (menuItem &amp;&amp; !<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>) {
    [[menuItem submenu] addItem:[<span class="built_in">NSMenuItem</span> separatorItem]];

    <span class="built_in">NSMenuItem</span> *convertItem = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicode"</span> action:<span class="keyword">@selector</span>(convertAction) keyEquivalent:<span class="string">@"c"</span>];
    [convertItem setKeyEquivalentModifierMask:<span class="built_in">NSAlternateKeyMask</span>];
    [convertItem setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:convertItem];

    <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicodeInConsole"</span>
                                                           action:<span class="keyword">@selector</span>(convertUnicodeInConsoleAction)
                                                    keyEquivalent:<span class="string">@""</span>];
    [<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>];

    sIsConvertInConsoleEnabled = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:sConvertInConsoleEnableKey];
    <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOnState</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOffState</span>;
    }
  }
}
</code></pre><p>上面三段函数我们一一进行解析。</p>
<ol>
<li><p><code>pluginDidLoad</code>，大家可以理解为插件的程序入口，在这个入口中我们通过单例进行我们自己开发的插件加载。**之所以使用单例是因为这个<code>pluginDidLoad</code>可能会由于加载多个插件而被多次触发。</p>
</li>
<li><p><code>initWithBundle</code>函数是我们自定义插件的构造函数，我们通过它进行自己任务的创建和调用。</p>
</li>
<li><p><code>createMenu</code>则是对Xcode编辑器上的菜单添加属于我们自己的选项。</p>
</li>
</ol>
<p>在这里，作者在<strong>Edit</strong>菜单下创建了属于自己的<strong>ConvertUnicode</strong>以及<strong>ConvertUnicodeInConsole</strong>，并对这些选项进行了快捷键绑定。</p>
<p>这些东西，除了自定义的菜单项及操作需要我们自己写以外，我们都可以通过<code>Plugin Template</code>这个插件自动生成。</p>
<p>到现在，我们还没有看到任何实质性的转换内容，别急，在<code>initWithBundle</code>中，作者通过<strong>Method Swizzling</strong>将<code>IDEConsoleItem</code>的<code>- (id)initWithAdaptorType:(id)arg1 content:(id)arg2 kind:(int)arg3</code>和自己实现的<code>XcodeConsoleUnicode_IDEConsoleItem</code>进行的调换。</p>
<p>然后在替换后的方法中，实现解析，代码如下：</p>
<pre><code>- (<span class="keyword">id</span>)initWithAdaptorType:(<span class="keyword">id</span>)arg1 content:(<span class="keyword">id</span>)arg2 kind:(<span class="keyword">int</span>)arg3
{
  <span class="keyword">id</span> item = I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span>(<span class="keyword">self</span>, _cmd, arg1, arg2, arg3);

  <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
    <span class="built_in">NSString</span> *logText = [item valueForKey:<span class="string">@"content"</span>];
    <span class="built_in">NSString</span> *resultText = [DXXcodeConsoleUnicodePlugin convertUnicode:logText];
    [item setValue:resultText forKey:<span class="string">@"content"</span>];
  }

  <span class="keyword">return</span> item;
}
</code></pre><p>这个方法非常简单，通过原方法获取console中的<strong>item</strong>，并获取对应的<strong>content</strong>进行解析。而解析也仅仅是采用了<code>UTF8StringEncoding</code>直接进行转换。</p>
<h4 id="补充知识：NSRegularExpression和正则表达式">补充知识：NSRegularExpression和正则表达式</h4><p>在本文的实现当中，作者对于中文字符的Unicode的表达方式<strong>\u4582</strong>这样的格式，采用了正则表达式进行了提取。在传统的Unicode的格式中，<strong>单独一个<code>\</code></strong>表示为转义字符，不能直接表达一般字符。所以，在正则表达式中，我们需要采用<strong><code>\\</code></strong>来表示一个<code>\</code>。同时，对于4582这样的字符，我们当然可以认为其模式为四个连续的字符，所以我们可以采用<code>\w{4}</code>。（<strong>切记，不能采用<code>\W</code></strong>。大写的<code>\W</code>表征的是非字符。）然后<code>{4}</code>表示前面的模式重复<strong>4次</strong>，即<code>\w</code>连续出现4次。</p>
<p>好了，综上所述，我们不难写出针对中文Unicode提取的正则表达式：<strong><code>\\u\w{4}</code></strong></p>
<p>但是，在作者的代码中，作者的正则表达式却是：<code>\\\\[uU]\\w{4}</code>，那这个是怎么回事呢？<br>原因在于， 对于在字符串形式出现的正则表达式，首先解析的是字符串规则，然后才是正则表达式引擎的解析。</p>
<p>所以，<code>\\\\</code>被字符串解析成<code>\\</code>，然后正则解析成<code>\</code>。然后对于<code>[uU]</code>，是一个组，表示或者u或者U，因为有些输出的文本里，对于U的大小写并没有规定，所以两种情况都需要考虑。</p>
<p>后面的就不再赘述了，原理一致。大家有兴趣的自己深入学习下吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Xcode插件开发">Xcode插件开发</h4><p>嘿嘿，今天带大家学习一下基于Xcode的插件开发。可能很多人一听到插件开发，想到的都是Sublime Text，Atom这样轻量级的编辑器的扩展插件，但是实际上，无论是VisualStudio, Eclips]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Check Pods Manifest.lock]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/check-manifest/"/>
    <id>http://satanwoo.github.io/2016/02/27/check-manifest/</id>
    <published>2016-02-27T10:23:21.000Z</published>
    <updated>2016-02-27T10:31:40.000Z</updated>
    <content type="html"><![CDATA[<p>初次看到这个题目的你，可能还不了解这是个啥。但是，我想下面这个错误提示，你肯定会非常熟悉：</p>
<pre><code><span class="keyword">error</span>: The sandbox <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> sync <span class="keyword">with</span> <span class="keyword">the</span>  
Podfile.lock. Run 'pod install' <span class="keyword">or</span> update 
your CocoaPods installation.
</code></pre><p>没错，当我们使用<code>cocoapods</code>的时候，经常会遇到的一个问题。其原因在于我们本地的<code>manifest.lock</code>和通过<code>git</code>同步的<code>Pod.lock</code>的产生了差异。</p>
<p><strong>注：manifest.lock简单可以理解为我们在本地执行一次<code>pod install</code>后生成的当前Podfile的状态的表征文件。而Pod.lock是同步他人更新过Podfile后的状态。</strong></p>
<p>那么，这个差异报错的原因是什么呢？我们可以打开Xcode项目中对应的<code>Target</code>的<code>Build Phase</code>，可以发现，其中存在在一项名为<code>Check Pods Manifest.lock</code>，是一个<code>shell script</code>，内容如下：</p>
<pre><code>// <span class="number">1.</span>
diff <span class="string">"${PODS_ROOT}/../Podfile.lock"</span> <span class="string">"${PODS_ROOT}/Manifest.lock"</span> &gt; /dev/null

// <span class="number">2.</span>
<span class="keyword">if</span> <span class="string">[[ $? != 0 ]]</span> ; <span class="keyword">then</span>

// <span class="number">3.</span>
    cat &lt;&lt; EOM
<span class="built_in">error</span>: The sandbox is <span class="keyword">not</span> <span class="keyword">in</span> sync with the Podfile.lock. Run <span class="string">'pod install'</span> <span class="keyword">or</span> update your CocoaPods installation.
EOM
    exit <span class="number">1</span>
fi
</code></pre><p>我们来解读下这段代码的意思：</p>
<ol>
<li><p>通过diff命令来检查<code>Podfile.lock</code>和<code>Manifest.lock</code>的区别。这个命令中的<code>&gt; /dev/null</code> 可以视为一个<strong>黑洞</strong>，等价于一个只读文件，所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到。由于在执行<code>diff</code>命令的过程中可能产生大量的标准输出，可能会干扰我们的的工作流程执行，所以我们将它们全部丢弃给<strong>黑洞</strong>，只关心<strong>返回值</strong>。</p>
</li>
<li><p><code>if [[ $? != 0 ]] then</code>这个命令指的上一个命令的返回值如果不等于0，就执行xxxx。其中$?也就代表着上一个命令<code>diff</code>的返回值。</p>
</li>
<li><p>好，如果返回值不为0，说明有差异，因此通过<code>cat &lt;&lt; EOM</code> 和 <code>EOM</code>将处于这两者之前的内容输出到标准输出。</p>
</li>
</ol>
<h3 id="改造脚本">改造脚本</h3><p>好，既然我们已经读懂了上述的<code>shell script</code>，我们不如将这个错误的提示来进行整改，当有差异的情况下，自动去进行<code>pod install</code>。</p>
<p>整体改造后的代码如下：</p>
<pre><code><span class="comment">// 1.</span>
diff <span class="string">"<span class="subst">${PODS_ROOT}</span>/../Podfile.lock"</span> <span class="string">"<span class="subst">${PODS_ROOT}</span>/Manifest.lock"</span> &gt; /dev/<span class="keyword">null</span>

<span class="comment">// 2.</span>
<span class="keyword">if</span> [[ $? != <span class="number">0</span> ]] ; then

<span class="comment">// 3.</span>
    pod install --project-directory=<span class="string">"<span class="subst">${PODS_ROOT}</span>/../"</span>
fi
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初次看到这个题目的你，可能还不了解这是个啥。但是，我想下面这个错误提示，你肯定会非常熟悉：</p>
<pre><code><span class="keyword">error</span>: The sandbox <span class="keyword">is</sp]]>
    </summary>
    
      <category term="shell" scheme="http://satanwoo.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发一个简单的Pod Install 插件]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/pod-install-plugin/"/>
    <id>http://satanwoo.github.io/2016/02/27/pod-install-plugin/</id>
    <published>2016-02-27T10:23:09.000Z</published>
    <updated>2016-02-27T10:25:35.000Z</updated>
    <content type="html"><![CDATA[<p>前几天刚刚粗略了学习了一下Xcode的插件开发，一时心痒，就准备做个简单的插件练练手。</p>
<p>哎哟我擦，正当我准备大展身手的时候，我突然想到我该做个啥呢?  我这真是有了程序员，只差一个好Idea了。</p>
<p>好吧，正巧这个时候，我发现我和朋友协作的一个iOS项目在两个分支上同步开发，每次要合并后拉下分支，都发现Pod.lock文件都产生了变化，无法编译成功。每当这个时候，我都要进入<code>terminal</code>输入一大堆的<code>cd ..</code>进入对应的文件目录执行<code>pod install</code>命令，甚是繁琐。</p>
<p>当然啦，你可以通过<code>alias</code> 配置快速的执行命令，但是，你仍然得切换出Xcode的窗口，对于我们这种效率控来说不能接受。</p>
<p>所以，我就想到了，在Xcode中利用插件集成一下关于pod的一些功能，同时绑定快捷键提高操作效率。</p>
<p>说干就干。</p>
<p>首先我们利用Xcode的plugin template生成项目的一些基本流程结构。关于插件的具体思路可以参考我之前的一篇文章《DXXcodeConsoleUnicodePlugin源码解析》</p>
<p>在这里，我们着重介绍一下利用 <code>NSTask</code> 去执行诸如<code>pod install</code>这样的命令。</p>
<h4 id="实现思路">实现思路</h4><p>在实现真正的<code>Objective-C</code>代码之前，我们首先现在<code>terminal</code>中随便找个安全的目录敲入<code>pod install</code>来试试看结果，如下所说：</p>
<pre><code>pod install
[!] <span class="keyword">No</span> <span class="label">`Podfile'</span> found <span class="keyword">in</span> the project directory.
</code></pre><p>从这个错误提示中我们可以大致了解，<code>pod install</code>的命令依赖于所谓的<code>Podfile</code>。于是，我们输入<code>pod install --help</code>查看其对应的帮助手册：</p>
<pre><code>-<span class="ruby">-project-directory=<span class="regexp">/project/dir</span><span class="regexp">/   The path to the root of the project
</span></span>                                       directory
-<span class="ruby"><span class="regexp">-no-clean                          Leave SCM dirs like `.git` and `.svn`
</span></span>                                       intact after downloading
-<span class="ruby"><span class="regexp">-no-integrate                      Skip integration of the Pods libraries
</span></span>                                       in the Xcode project(s)
-<span class="ruby"><span class="regexp">-no-repo-update                    Skip running `pod repo update` before
</span></span>                                       install
-<span class="ruby"><span class="regexp">-silent                            Show nothing
</span></span>-<span class="ruby"><span class="regexp">-verbose                           Show more debugging information
</span></span>-<span class="ruby"><span class="regexp">-no-ansi                           Show output without ANSI codes
</span></span>-<span class="ruby"><span class="regexp">-help                              Show help banner of specified command</span></span>
</code></pre><p>从第一条帮助命令张，我们可以看到，我们需要通过<strong>–project-directory=</strong>来设置<code>pod install</code>的根目录，也即<code>Podfile</code>的所在。</p>
<p>好，事情到这里，我们在编写插件前需要的准备工作就基本完成了，我们现在只需利用<code>NSTask</code>将我们在命令行中输入的命令执行即可。</p>
<p>让我们来看看实现的代码：</p>
<pre><code> <span class="comment">// 1.</span>
 [<span class="keyword">self</span> searchMainProjectPath];

 <span class="comment">// 2.</span>
 <span class="built_in">NSTask</span> *podInstallAction = [[<span class="built_in">NSTask</span> alloc] init];
 podInstallAction<span class="variable">.currentDirectoryPath</span> = <span class="keyword">self</span><span class="variable">.mainProjectPath</span>;
 podInstallAction<span class="variable">.arguments</span> = @[<span class="string">@"install"</span>];
 podInstallAction<span class="variable">.launchPath</span> = <span class="string">@"/usr/bin/pod"</span>;

 <span class="comment">// 3.</span>
 <span class="built_in">NSPipe</span> *pipeOut = [<span class="built_in">NSPipe</span> pipe];
 [podInstallAction setStandardOutput:pipeOut];
 <span class="built_in">NSFileHandle</span> *output = [pipeOut fileHandleForReading];

 [output setReadabilityHandler:^(<span class="built_in">NSFileHandle</span> * _Nonnull fileHandler) {
   <span class="built_in">NSData</span> *data = [fileHandler availableData];
   <span class="built_in">NSString</span> *text = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSASCIIStringEncoding</span>];

   <span class="built_in">NSLog</span>(<span class="string">@"text is %@"</span>, text);
 }];

[podInstallAction launch];
[podInstallAction waitUntilExit];
</code></pre><ol>
<li>我们首先要寻找到当前项目的主目录，也就是<code>Podfile</code>的路径</li>
<li>然后我们构建NSTask，将其的执行目录设置成我们的主目录，然后<code>/usr/bin</code>中调出<code>pod</code>的可执行文件，执行<code>pod install</code>。</li>
<li>我们利用NSPipe将默认的NSTask的输出(stdout)重定向到我们的指定的地方，这样有助于我们查看log或者进行流程工程。</li>
</ol>
<p>到这里，基本上一个简单的小插件就完成了，但是我在这里想要强调一点关于主工程路径搜索的一些问题，我们首先来看代码：</p>
<pre><code><span class="built_in">NSArray</span> *workspaceWindowControllers = [<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEWorkspaceWindowController"</span>) workspaceWindowControllers];
[workspaceWindowControllers enumerateObjectsUsingBlock:^(<span class="keyword">id</span> controller, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) {
  <span class="keyword">if</span> ([[controller valueForKey:<span class="string">@"window"</span>] isMainWindow]) {
    <span class="keyword">id</span> workspace = [controller valueForKey:<span class="string">@"_workspace"</span>];
    <span class="built_in">NSString</span> *filePath = [[workspace valueForKey:<span class="string">@"representingFilePath"</span>] valueForKey:<span class="string">@"pathString"</span>];
    <span class="built_in">NSString</span> *projectName = [[filePath lastPathComponent] stringByDeletingPathExtension];
    <span class="built_in">NSLog</span>(<span class="string">@"CocoaPodUI::ProjectName::%@"</span>, projectName);

    <span class="built_in">NSString</span> *text = [[filePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:<span class="string">@"Podfile"</span>];

    <span class="keyword">self</span><span class="variable">.mainProjectPath</span> = [filePath stringByDeletingLastPathComponent];

    <span class="built_in">NSLog</span>(<span class="string">@"pod ifle is %@"</span>, text);
  }
}];
</code></pre><p><strong>基于Xcode的插件开发实际上利用了大量的私有头文件。由于Objective-C著名的runtime特性，因此，很多时候，我们可以利用key-value-coding的方式获取我们普通途径下无法得到的结果。<br>同时，当有一个类的方法是私有方法的时候，你可以利用一个<code>category</code>声明同样的函数签名，不需要实现，<code>Objective-C</code>的runtime会自动帮你转发对应的<code>message passing</code>。</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天刚刚粗略了学习了一下Xcode的插件开发，一时心痒，就准备做个简单的插件练练手。</p>
<p>哎哟我擦，正当我准备大展身手的时候，我突然想到我该做个啥呢?  我这真是有了程序员，只差一个好Idea了。</p>
<p>好吧，正巧这个时候，我发现我和朋友协作的一个iOS]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FBKVOController 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/27/FBKVOController/"/>
    <id>http://satanwoo.github.io/2016/02/27/FBKVOController/</id>
    <published>2016-02-27T10:21:55.000Z</published>
    <updated>2016-02-27T10:24:22.000Z</updated>
    <content type="html"><![CDATA[<p>开发过iOS的app已经不计其数了，在不同的项目中采用的架构也各不相同，有传统的<strong>MVC</strong>，简化的<strong>VIPER</strong>，以及一些简单的<strong>MVVM</strong>。</p>
<p>这其中，我最不推荐的就是<strong>VIPER</strong>，谁写谁知道，，绝对是增加了项目的复杂性。<strong>MVVM</strong>由于自己总是受限于传统的<code>Object-Oriented</code>的思路，总是想不出真正的Functional Programming的代码，因此，绝大多数情况，写着写着都回归到了<strong>MVC</strong>。</p>
<p>其实，相较于网上大家总喜欢提到的<strong>Massive View Controller</strong>问题，我更想说的是这种传统架构中对于信息流的不友好。</p>
<p>在一个典型的iOS的问题中，我们的代码执行流程，通常都是从View Controller的<strong>生命周期</strong>开始，如果是一个完全基于顺序执行的应用，那整个app的信息流是<strong>单向可跟踪的</strong>。但是往往事情并不会那么简单，我们会包含至少如下这些潜在打乱信息流的<em>坏蛋</em></p>
<ul>
<li>Delegate回调</li>
<li>NSNotification</li>
<li>UIView控件的Target-Action</li>
<li>KVO</li>
</ul>
<p>在这里，你可能会以为我想谈谈<strong>ReactiveCocoa</strong>和<strong>RxSwift</strong>，那你错啦，那个开源项目我暂时还没有能力去深究，所以我想从KVO事件入手，读一读Facebook出品的<strong>FBKVOController</strong>。</p>
<h4 id="FBKVOController">FBKVOController</h4><p>简单来说，FBKVOController是对KVO机制的一层封装，同时提供了线程安全的特性和并对如下这个<strong>臭名昭著</strong>的函数进行了封装，提供了干净的block的回调，避免了处理这个函数的逻辑散落的到处都是。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary *)change <span class="string">context:</span>(<span class="typename">void</span> *)context
</code></pre><h4 id="源码分析">源码分析</h4><p>整个项目的结构非常简单，包含如下四个文件：</p>
<ul>
<li>FBKVOController.h/.m</li>
<li>NSObject+FBKVOController.h/.m</li>
</ul>
<p>其中，<code>NSObject+FBKVOController</code>只是通过<code>AssociateObject</code>给NSObject提供了一个<code>retain</code>及一个<code>非retain</code>型的KVOController。</p>
<p>这两种不同类型的KVOController有啥区别，我们稍后再提，我们将重点投向<code>FBKVOController</code>这个文件。</p>
<p>打开这个<code>FBKVOController.m</code>文件，哎呀，600多行文件，有点蛋疼。没事，配合头文件粗略扫一眼以后，可以发现其中很多方法都是<code>convenience method</code>。</p>
<p>简单剥离一下数据结构以后，我们可以发现，主要的数据结构有如下三个。</p>
<ul>
<li>FBKVOInfo</li>
<li>FBKVOSharedController</li>
<li>FBKVOController</li>
</ul>
<h4 id="FBKVOController-1">FBKVOController</h4><p>既然我们前面通过<code>NSObject+FBKVOController</code>知道了每个对象都会有其对应的<code>FBKVOController</code>，那我们就先来看看这个类吧。</p>
<pre><code><span class="comment">//1.</span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span></span>
{
  <span class="built_in">NSMapTable</span> *_objectInfosMap;
  OSSpinLock _lock;
}

<span class="comment">//2.</span>
- (instancetype)initWithObserver:(<span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved
{
  <span class="keyword">self</span> = [<span class="keyword">super</span> init];
  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) {
    <span class="comment">// 2.</span>
    _observer = observer;

    <span class="comment">// 3.</span>
    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;
    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];

    <span class="comment">// 4.</span>
    _lock = OS_SPINLOCK_INIT;
  }
  <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><ol>
<li><p>首先我们看到，这个对象持有一个<code>OSSpinLock</code>及一个<code>NSMapTable</code>。其中<code>OSSpinLock</code>即为自旋锁，当多个线程竞争相同的<strong>critical section</strong>时，起到保护作用。<code>NSMapTable</code>可能大家接触不是很多，我们在后文会详细介绍，这里大家可以先理解为一个高级的NSDictionary。</p>
</li>
<li><p>在构造函数中，首先将传入的observer进行<code>weak</code>持有，这主要为了避免<strong>Retain Cycle</strong>。</p>
</li>
<li><p>这一段的内容可能大家不太熟悉，<code>NSPointerFunctionsOptions</code>简单来说就是定义<code>NSMapTable</code>中的key和value采用何种内存管理策略，包括<code>strong</code>强引用，<code>weak</code>弱引用以及<code>copy</code>（要支持NSCopying协议）</p>
</li>
<li><p>初始化自旋锁  </p>
</li>
</ol>
<p>接下来，使我们通过<code>FBKVOController</code>来对一个对象的某个或者某些keypath进行观察。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block
{
  NSAssert(<span class="number">0</span> != keyPath.length &amp;&amp; NULL != block, @<span class="string">"missing required parameters observe:%@ keyPath:%@ block:%p"</span>, object, keyPath, block);
  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// 1. create info</span>
  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];

  <span class="comment">// 2. observe object with info</span>
  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];
}
</code></pre><ol>
<li>对于传入的参数，构建一个内部的FBKVOInfo数据结构</li>
<li>调用<code>[self _observe:object info:info];</code></li>
</ol>
<p>接下来，我们来跟踪一下<code>[self _observe:object info:info];</code>，内容如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">_observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="comment">// lock</span>
  OSSpinLockLock(&amp;_lock);

  <span class="comment">// 1.</span>
  NSMutableSet *infos = [_objectInfosMap <span class="string">objectForKey:</span>object];

  <span class="comment">// 2. </span>
  _FBKVOInfo *existingInfo = [infos <span class="string">member:</span>info];
  <span class="keyword">if</span> (nil != existingInfo) {
    NSLog(@<span class="string">"observation info already exists %@"</span>, existingInfo);

    <span class="comment">// unlock and return</span>
    OSSpinLockUnlock(&amp;_lock);
    <span class="keyword">return</span>;
  }

  <span class="comment">// lazilly create set of infos</span>
  <span class="keyword">if</span> (nil == infos) {
    infos = [NSMutableSet set];
    [_objectInfosMap <span class="string">setObject:</span>infos <span class="string">forKey:</span>object];
  }

  <span class="comment">// add info and oberve</span>
  [infos <span class="string">addObject:</span>info];

  <span class="comment">// unlock prior to callout</span>
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 3.</span>
  [[_FBKVOSharedController sharedController] <span class="string">observe:</span>object <span class="string">info:</span>info];
}
</code></pre><p>抛开Facebook自身标记的注释，有三处比较值得我们注意：</p>
<ol>
<li><p>根据被观察的object获取其对应的<strong>infos set</strong>。这个主要作用在于避免多次对同一个keyPath添加多次观察，避免crash。<strong>因为每调用一次<code>addObserverForKeyPath</code>就要有一个对应的<code>removeObserverForKey</code>。</strong></p>
</li>
<li><p>从<strong>infos set</strong>判断是不是已经有了与此次info相同的观察。</p>
</li>
<li><p>如果以上都顺利通过，将观察的信息及关系注册到<code>_FBKVOSharedController</code>中。</p>
</li>
</ol>
<p>至此，FBKVOController的任务基本都结束，<code>unObserve</code>相关的任务逻辑大同小异，不再赘述。</p>
<h4 id="FBKVOSharedController">FBKVOSharedController</h4><p>初次看到这个类的时候，我的脑海中浮现了两个问题，FBKVOSharedController是干嘛的?为什么FBKVOController还需要将观察的信息转交呢？</p>
<p><strong>其实我个人觉得这一层不是必要的</strong>，但是按照Facebook的理念来说就是将所有的观察信息统一交由一个<code>FBKVOSharedController</code>的<strong>单例</strong>进行维护。如果大家读过Facebook出品的<strong>Flux</strong>架构，也会发现，Facebook经常喜欢维护一个类似于中间件的注册表，在这里，<code>FBKVOSharedController</code>承担的也是类似的职责。</p>
<p>于是，通过如下方法，我们像使用注册表一样将对KVOInfo注册。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="keyword">if</span> (nil == info) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// register info</span>
  OSSpinLockLock(&amp;_lock);
  [_infos <span class="string">addObject:</span>info];
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 1.</span>
  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="typename">void</span> *)info];
}
</code></pre><ol>
<li>代表所有的观察信息都首先由<code>FBKVOSharedController</code>进行接受，随后进行转发。</li>
</ol>
<p>实现<code>observeValueForKeyPath:ofObject:Change:context</code><br>来接收通知。</p>
<pre><code>- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context
{
  <span class="built_in">NSAssert</span>(context, <span class="string">@"missing context keyPath:%@ object:%@ change:%@"</span>, keyPath, object, change);

  _FBKVOInfo *info;

  {
    <span class="comment">// 1. </span>
    OSSpinLockLock(&amp;_lock);
    info = [_infos member:(__bridge <span class="keyword">id</span>)context];
    OSSpinLockUnlock(&amp;_lock);
  }

  <span class="keyword">if</span> (<span class="literal">nil</span> != info) {

    <span class="comment">// take strong reference to controller</span>
    FBKVOController *controller = info-&gt;_controller;
    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) {

      <span class="comment">// take strong reference to observer</span>
      <span class="keyword">id</span> observer = controller<span class="variable">.observer</span>;
      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) {

        <span class="comment">// dispatch custom block or action, fall back to default action</span>
        <span class="keyword">if</span> (info-&gt;_block) {
          info-&gt;_block(observer, object, change);
        } <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) {
<span class="preprocessor">#pragma clang diagnostic push</span>
<span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span>
          [observer performSelector:info-&gt;_action withObject:change withObject:object];
<span class="preprocessor">#pragma clang diagnostic pop</span>
        } <span class="keyword">else</span> {
          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];
        }
      }
    }
  }
}
</code></pre><ol>
<li>根据context上下文获取对应的KVOInfo</li>
<li>判断当前<code>info</code>的<code>observer</code>和<code>controller</code>，是否仍然存在（因为之前我们采用的weak持有）</li>
<li>根据    <code>info</code>的<code>block</code>或者<code>selector</code>或者<code>override</code>进行消息转发。</li>
</ol>
<p>到这里，<code>FBKVOController</code>整体的实现就介绍完了，怎么样，是不是局部看自己都会实现，但是一结合起完整的设计思路，就觉得，不亏是Facebook呢。</p>
<h3 id="NSMapTable">NSMapTable</h3><p>之前我们在前文中提到了<code>NSMapTable</code>，现在我们来详细介绍他一下。<br>我们在平常的开发中都使用过<code>NSDictionary</code>或者<code>NSMutableDictionary</code>，但是这两种数据结构有其的局限性。</p>
<p>以<code>NSDictionary</code>为例，<code>NSDictionary</code>将<code>key</code>的<code>hash</code>值作为索引，存储对应的<code>value</code>。因此，<code>key</code>的要求是不能更改。所以，<code>NSDictionary</code>为了确保安全，对于<code>key</code>采用了<strong>copy</strong>的策略。</p>
<p>默认情况下，支持<strong>NSCopying</strong>协议的类型都可以作为key。但是考虑到copy带来的开销，一般情况下我们都使用简单的诸如数字或者字符串作为key。</p>
<p>那么，如果要使用<code>Object</code>作为key，想构建<strong>Object to Object</strong>的关系怎么办呢？这个时候就用到<code>NSMapTable</code>。我们可以通过NSFunctionsPointer来分别定义对key和value的储存关系，简单可以分类为<code>strong</code>,<code>weak</code>以及<code>copy</code>。而当利用<code>object</code>作为key的时候，可以定义评判相等的标准，如：<strong>use shifted pointer hash and direct equality, object description或者size</strong>。</p>
<p>具体你需要去override如下几种方法：</p>
<pre><code><span class="comment">// pointer personality functions</span>
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">BOOL</span> (*isEqualFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item1, <span class="keyword">const</span> <span class="keyword">void</span>*item2, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*sizeFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
<span class="keyword">@property</span> (nullable) <span class="built_in">NSString</span> * __nullable (*descriptionFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
</code></pre><p>在<code>FBKVOController</code>自定义的可以作为key的结构<code>FBKVOInfo</code>，就复写了</p>
<pre><code>- (<span class="type">NSUInteger</span>)hash
{
  <span class="keyword">return</span> [_keyPath hash];
}

- (<span class="type">BOOL</span>)isEqual:(id)<span class="class"><span class="keyword">object</span>
</span>{
  <span class="keyword">if</span> (nil == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">if</span> (self == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">YES</span>;
  }
  <span class="keyword">if</span> (![<span class="class"><span class="keyword">object</span> <span class="title">isKindOfClass</span>:</span>[self <span class="class"><span class="keyword">class</span>]]) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="class"><span class="keyword">object</span>)<span class="title">-&gt;_keyPath</span>];</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>开发过iOS的app已经不计其数了，在不同的项目中采用的架构也各不相同，有传统的<strong>MVC</strong>，简化的<strong>VIPER</strong>，以及一些简单的<strong>MVVM</strong>。</p>
<p>这其中，我最不推荐的就是<]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DGRunKeeperSwitch 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/"/>
    <id>http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/</id>
    <published>2016-02-05T14:35:57.000Z</published>
    <updated>2016-02-05T14:38:35.000Z</updated>
    <content type="html"><![CDATA[<p>DGRunKeeperSwitch是非常有趣的自定义的<em>Segment Control</em>的实现，从其Github上的展现效果来看，可以发现在 <em>同一个</em> UILabel中的文本竟然可以展现出两种不同的颜色，是不是很奇妙？今天就让我们来看看它是如何实现的。</p>
<p><img src="https://raw.githubusercontent.com/gontovnik/DGRunkeeperSwitch/master/DGRunkeeperSwitch.gif" alt=""></p>
<h3 id="源码分析">源码分析</h3><p>打开项目，发现这个项目真的很简单，就一个文件，<code>DGRunkeeperSwitch.swift</code>，并且实现也只有接近260行左右。</p>
<p>既然这个项目是个UI的开源库，我们主要还是先从界面层级入手。和<a href="http:glowing.com" target="_blank" rel="external">Glow的开源库(GLCalendar)</a>不同，这个是纯手写的控件，因此无法从<strong>.xib</strong>文件来快速了解，所以我们把目标首先投向相关的UIKit子属性，包括如下：</p>
<pre><code><span class="comment">// 1. </span>
private <span class="tag">var</span> titleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> leftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> rightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 2.</span>
private <span class="tag">var</span> selectedTitleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedLeftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedRightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 3.</span>
<span class="function"><span class="title">private</span><span class="params">(set)</span></span> <span class="tag">var</span> selectedBackgroundView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span> 
private <span class="tag">var</span> titleMaskView: UIView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
</code></pre><p>其中第一部分我们一看命名就很容易理解了，有一个<code>ContentView</code>作为<code>container</code>，包含了<code>segment control</code>对应的左右两个Label。</p>
<p>然后来看第二部分，第二部分从命名上也很直观，感觉上和第一部分是一致的，但是却<strong>可能代表的是选中的状态</strong>。不过我们很奇怪，作者为什么要构建一个一模一样的来表征不同的状态呢，直接用一个变量比如 <code>var selected = false</code> 进行样式的控制不可以吗？</p>
<p>好，先别急，这里卖个关子，我们继续往下看。</p>
<p>第三部分，<code>selectedBackgroundView</code>和<code>titleMaskView</code>，从名字看，也不能一下子了解含义，我们先全局搜索下相关连的代码，与<code>titleMaskView</code>相关的内容如下：</p>
<pre><code>titleMaskView<span class="class">.backgroundColor</span> = .<span class="function"><span class="title">blackColor</span><span class="params">()</span></span>
selectedTitleLabelsContentView<span class="class">.layer</span><span class="class">.mask</span> = titleMaskView.layer
</code></pre><p>看起来是用<code>titleMaskView</code>给之前<strong>可能的选中状态的</strong><code>selectedTitleLabelsContentView</code>加了一层遮罩。</p>
<p>由于遮罩是白色的地方不显示，黑色的地方（准确来说是非白色的区域）显示，因此我们可以理解上述代码是通过<code>titleMaskView</code>来显示<code>selectedTitleLabelsContentView</code>中的内容（<strong>也就是两个UILabel</strong>），非<code>titleMaskView</code>区域自动隐藏了。</p>
<pre><code>addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"selectedBackgroundView.frame"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)

<span class="keyword">override</span> public <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> {
    <span class="keyword">if</span> keyPath == <span class="string">"selectedBackgroundView.frame"</span> {
        titleMaskView.frame = selectedBackgroundView.frame
    }
}
</code></pre><p>哦，看完上述这段代码，我开始有点恍然大悟了，通过监听<code>selectedBackgroundView.frame</code>，我们实时改变<code>titleMaskView</code>的<code>frame</code>。而通过实际运行项目，我们可以很容易理解<code>selectedBackgroundView</code>就是用户可拖拽的选项高亮条。</p>
<p>到这，我渐渐有点理解作者为什么要构建两个完全一样的contentView，并都包含左右两个UILabel了。</p>
<p>作者应该是对于<code>titleLabelsContentView</code>设定为普通状态的Label，左右两个Label都是未选中的颜色状态，同时将<code>selectedTitleLabelsContentView</code>设定为选定状态，左右Label都使用了选中时候的颜色状态，然后通过<code>titleMaskView</code>进行遮罩，这样，<code>selectedTitleLabelsContentView</code>其余部分就被隐藏，会显示出下部<code>titleLabelsContentView</code>普通状态的Label颜色。</p>
<p>嘿嘿，读一下剩下的源代码，和我的猜测一致，不得不说，<strong>我真是太聪明了</strong>，这个思路真是太赞了。</p>
<h3 id="如何真正实现一个好的UI库">如何真正实现一个好的UI库</h3><p>看到这个小标题，可能有人会产生疑惑，实现好一个UI库不就是功能正确，效果正常吗？错！</p>
<p>我认为这只是基本的两点，还有如下几点需要包含：</p>
<ul>
<li>使用正确的类型</li>
<li>在正确的函数中做正确的事</li>
<li>暴露不过多也不过少的属性</li>
<li>抛出、监听相对应的事件</li>
<li>根据不同屏幕大小、屏幕方向进行适配</li>
<li>横竖屏情况都能展示良好</li>
</ul>
<ol>
<li><p>第一，从DGRunkeeperSwitch来看，首先由于其模仿的是UISegmentControl，所以自然而然的应该继承与<strong>UIControl</strong>而不是UIView。有人要问有啥区别，简单来说就是<strong>UIControl将UIView中能接受的Touch事件，转换成了更高级的UIEvent，比如UITouchUpInside。</strong></p>
</li>
<li><p>第二，作者通过init函数进行初始化，通过layoutSubview进行页面布局，而不是像很多人自己写代码时将很多东西一窝蜂的堆到了init中。</p>
</li>
<li><p>提供了颜色、字体、边距以及动画弹性等属性给外部调用，同时将不应该暴露的内部UIKit变量进行私有化，并将<code>selectedIndex</code>通过<code>private(set)</code>对外设置为只读。</p>
</li>
<li><p>在切换Segment选择后，抛出了相应的<code>sendActionsForControlEvents(.ValueChanged)</code> 用于给外部监听。</p>
</li>
</ol>
<h3 id="效果之外的重点">效果之外的重点</h3><p>作者在实现这个项目之中，有几点是比较值得注意的：</p>
<h4 id="利用元组同时赋值多个属性">利用元组同时赋值多个属性</h4><pre><code><span class="keyword">public</span> var leftTitle: <span class="keyword">String</span> {
    <span class="built_in">set</span> { (leftTitleLabel.<span class="built_in">text</span>, selectedLeftTitleLabel.<span class="built_in">text</span>) = (newValue, newValue) }
    <span class="built_in">get</span> { <span class="keyword">return</span> leftTitleLabel.<span class="built_in">text</span>! }
}
</code></pre><p>在Swift中引入了一个元组的新类型，我们可以利用这个数据结构同时给多个属性赋值。</p>
<h4 id="private(set)">private(set)</h4><pre><code><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="variable"><span class="keyword">var</span> selectedIndex</span>: <span class="typename">Int</span> = <span class="number">0</span>
</code></pre><p>作者在实现过程中保留了一个<code>selectedIndex</code> 变量，但是这个类对外只读，对内可以读写，因此用了<strong>private(set)</strong>。</p>
<p><strong>这相当于在Objective-C时代，我们在.h文件中声明  <code>@property(nonatomic, strong, readonly) Class *A</code><br>然后又在.m文件中，声明  <code>@property(nonatomic, strong, readwrite) Class *A</code></strong></p>
<h4 id="UIView和CALayer">UIView和CALayer</h4><p>很多人写iOS的时候，分不清UIView和CALayer之间的区别，很多人都理解成了继承的关系。大错特错！</p>
<ul>
<li>实际上UIView里面有个成员变量是CALayer，而CALayer的delegate是UIView(这会涉及到很多的隐式动画之类的，不展开了)</li>
<li>UIView可以接受Touch事件，而Layer不行</li>
<li>UIView有个layerClass的类型方法，可以被复写，用于改变这个UIView对应的基础Layer类型，比如你可以将赋值CAGradientLayer给这个View</li>
</ul>
<p>在本项目中，作者复写了layerClass，如下：</p>
<pre><code><span class="keyword">override</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">layerClass</span>() -&gt; <span class="title">AnyClass</span> </span>{
    <span class="keyword">return</span> DGRunkeeperSwitchRoundedLayer.self
}
</code></pre><p>好啦，今天就差不多到这啦~下周再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>DGRunKeeperSwitch是非常有趣的自定义的<em>Segment Control</em>的实现，从其Github上的展现效果来看，可以发现在 <em>同一个</em> UILabel中的文本竟然可以展现出两种不同的颜色，是不是很奇妙？今天就让我们来看看它是如何]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PureLayout 源码解析]]></title>
    <link href="http://satanwoo.github.io/2016/02/05/PureLayout/"/>
    <id>http://satanwoo.github.io/2016/02/05/PureLayout/</id>
    <published>2016-02-05T14:33:20.000Z</published>
    <updated>2016-02-05T14:34:46.000Z</updated>
    <content type="html"><![CDATA[<p>在开始这篇文章之前，想必大家都应该使用过Autolayout方式的界面布局，相信大家都有过类似于如下这样的API调用：    </p>
<pre><code>[NSLayoutConstraint(item: self.viewA, attribute: .CenterY, relatedBy: .Equal, toItem: self.viewB, attribute: .CenterY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0.0</span>)]
</code></pre><p>抑或是Visual Format Language</p>
<pre><code>NSLayoutConstraint.constraintsWithVisualFormat(<span class="string">"|-(leftPadding)-[imageView(imageViewWidth)]-(rigntPadding)-[labelA]-(4)-[labelB]-(&gt;=44)-|"</span>, <span class="string">options:</span> NSLayoutFormatOptions(<span class="string">rawValue:</span> <span class="number">0</span>), <span class="string">metrics:</span> methics, <span class="string">views:</span> views)
</code></pre><p>这种冗长而又晦涩的代码，真是恶心人啊。因此在Github上涌现了一大堆简化布局的开源库，如SnapKit, Mansory以及今天我们要说的PureLayout。  </p>
<p>在这之中，PureLayout是最轻量级的，它仅仅是对Autolayout现成的语法进行了一层封装，相较于Mansory引入的一些<strong>新概念</strong>，Purelayout更直接易懂。</p>
<h3 id="源码解析">源码解析</h3><p>Purelayout的源码基本没什么难懂的地方，我们首先来看一下其项目结构：</p>
<ul>
<li>PurelayoutDefines.h</li>
<li>ALView + PureLayout.h/.m</li>
<li>NSArray + PureLayout.h/.m</li>
<li>NSLayoutConstraint + Purelayout.h/.m</li>
</ul>
<h4 id="PurelayoutDefines">PurelayoutDefines</h4><p>首先从PurelayoutDefines上入手，这个文件主要是进行一些类似<strong>Domain Specific Language</strong>定义的转化，如：</p>
<pre><code>typedef NS_ENUM(NSInteger, ALEdge) {
    /** The <span class="built_in">left</span> edge of the view. */
    ALEdgeLeft = NSLayoutAttributeLeft,
    /** The <span class="built_in">right</span> edge of the view. */
    ALEdgeRight = NSLayoutAttributeRight,
    /** The top edge of the view. */
    ALEdgeTop = NSLayoutAttributeTop,
    /** The bottom edge of the view. */
    ALEdgeBottom = NSLayoutAttributeBottom,
    /** The leading edge of the view (<span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeLeading = NSLayoutAttributeLeading,
    /** The trailing edge of the view (<span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeTrailing = NSLayoutAttributeTrailing
};
</code></pre><p>上述这段代码，就是将传统的UIKit中的NSLayoutAttribute的枚举类型全部转换成对应的PureLayout中的定义，如ALEdgeRight对应到NSLayoutAttributeRight。</p>
<p><strong>LayoutMargins</strong><br>在这里补充一点题外知识，在iOS8中，苹果为Autolayout引入了LayoutMargins这一概念。这个概念乍一听可能都不了解，但是大家回忆下，比如在Storyboard中，我们拖拽一个UIView到ViewController的view并设置边距的时候，上边距和下边距对应的限制都是layout guide，如下图所示：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.55.37.png" alt=""></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.23.png" alt=""><br><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.13.png" alt=""></p>
<p><strong>简单来说，在iOS7上就已经存在了LayoutMargin了，当时的作用是用来限制view的真实内容不会被UINavigationBar（上部）以及UIToolbar（下部）所遮盖</strong>。而从iOS8中开始，苹果将这一技术引入到了任意一个UIView中。</p>
<h4 id="ALView_+_Purelayout">ALView + Purelayout</h4><p><strong>ALView实际上是UIView或者NSView的别名，通过添加ALView的分类，可以通过Define在编译期进行替换，避免为NSView和UIView各创建一份重复的代码</strong>。这个类中的API过多，因此我们以轴对齐为典型的例子来分解下源码：</p>
<ol>
<li>轴对齐<br>在PureLayout中，包括<code>Vertical</code>, <code>Horizontal</code>, <code>Baseline</code>等几种轴对齐方式，其中Baseline指的是View中潜在包含文字的Baseline。</li>
</ol>
<p>好，我们来看看相关的API</p>
<pre><code><span class="comment">/** Aligns an axis of the view to the same axis of another view. */</span>
<span class="tag">-</span> (<span class="tag">NSLayoutConstraint</span> *)<span class="rule"><span class="attribute">autoAlignAxis</span>:<span class="value">(ALAxis)axis toSameAxisOfView:(ALView *)otherView</span></span>;
</code></pre><p>从该API的名称，我们可以直观的感觉出其作用是用于将两个View按照同一个轴对齐。这个API是一个<strong>Convenience Init</strong>，其层层传递</p>
<pre><code>- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView
{
    <span class="keyword">return</span> [self <span class="string">autoAlignAxis:</span>axis <span class="string">toSameAxisOfView:</span>otherView <span class="string">withOffset:</span><span class="number">0.0</span>];
}

- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView <span class="string">withOffset:</span>(CGFloat)offset
{
    <span class="keyword">return</span> [self <span class="string">autoConstrainAttribute:</span>(ALAttribute)axis <span class="string">toAttribute:</span>(ALAttribute)axis <span class="string">ofView:</span>otherView <span class="string">withOffset:</span>offset];
}
</code></pre><p>最后调用了</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoConstrainAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>attribute toAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>toAttribute ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView withOffset:<span class="params">(<span class="variable">CGFloat</span>)</span>offset`</span>
</code></pre><p>好，那就让我们来看看这个上述这个函数的实现，如下所示：</p>
<pre><code><span class="comment">//1.</span>
self.translatesAutoresizingMaskIntoConstraints = NO;

<span class="comment">//2.</span>
NSLayoutAttribute layoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>attribute];
NSLayoutAttribute toLayoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>toAttribute];

<span class="comment">//3.</span>
NSLayoutConstraint *constraint = [NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>layoutAttribute <span class="string">relatedBy:</span>relation <span class="string">toItem:</span>otherView <span class="string">attribute:</span>toLayoutAttribute <span class="string">multiplier:</span><span class="number">1.0</span> <span class="string">constant:</span>offset];

<span class="comment">//4.</span>
[constraint autoInstall];
<span class="keyword">return</span> constraint;
</code></pre><ul>
<li>1.首先将translatesAutoresizingMaskIntoConstraints设置为false，对于要使用autolayout的UIView，必须设置为false，也就是不将传统frame布局中的Autoresizing Mask转换成约束。</li>
<li>2.根据传入的<strong>PureLayout属性</strong>转换成对应的NSLayoutAttribute</li>
<li>3.调用冗长恶心的Autolayout API构建约束</li>
<li>4.添加约束</li>
</ul>
<p>在这里，我们需要注意一下这个<code>[constraint autoInstall]</code>，让我们来探一探实现：</p>
<pre><code>- (<span class="keyword">void</span>)autoInstall
{
<span class="comment">// 1. iOS8+</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10</span>
    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setActive:)]) {
        [<span class="built_in">NSLayoutConstraint</span> al_applyGlobalStateToConstraint:<span class="keyword">self</span>];
        <span class="comment">// 1.1</span>
        <span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_preventAutomaticConstraintInstallation]) {         
            [[<span class="built_in">NSLayoutConstraint</span> al_currentArrayOfCreatedConstraints] addObject:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
        <span class="comment">// 1.2 </span>
            <span class="keyword">self</span><span class="variable">.active</span> = <span class="literal">YES</span>;
        }
        <span class="keyword">return</span>;
    }
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10 */</span>

<span class="comment">// 2. iOS 7</span>
    <span class="built_in">NSAssert</span>(<span class="keyword">self</span><span class="variable">.firstItem</span> || <span class="keyword">self</span><span class="variable">.secondItem</span>, <span class="string">@"Can't install a constraint with nil firstItem and secondItem."</span>);
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.firstItem</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.secondItem</span>) {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]] &amp;&amp; [<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if both items are views."</span>);
            ALView *commonSuperview = [<span class="keyword">self</span><span class="variable">.firstItem</span> al_commonSuperviewWithView:<span class="keyword">self</span><span class="variable">.secondItem</span>];
            [commonSuperview al_addConstraint:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
            [<span class="keyword">self</span><span class="variable">.firstItem</span> al_addConstraint:<span class="keyword">self</span>];
        }
    } <span class="keyword">else</span> {
        <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
        [<span class="keyword">self</span><span class="variable">.secondItem</span> al_addConstraint:<span class="keyword">self</span>];
    }
}
</code></pre><p>整个实现的部分被一分为二，上半部分专门针对iOS8+的，下半部分针对iOS7（<strong>事实上在整个PureLayout的设计中，大部分地方的处理方式都一分为二了</strong>）</p>
<p>我们暂时也不管<code>al_applyGlobalStateToConstraint:self</code> 以及 <code>al_preventAutomaticConstraintInstallation</code>的作用，我们从1.2看起。</p>
<ul>
<li>在iOS8上，启用或者禁用一个AutoLayout的Constraint变得更加容易了，仅仅需要设置active即可</li>
<li>在iOS7上，需要手动的addConstraint或者removeConstraint</li>
<li>在处理iOS7的逻辑当中，需要判断当前这个Constraint是否是针对两个Item的，如果是，找到他们的公共父View，在父View在添加约束，比如添加View A和View B之间的间距；而如果是单一一个View，比如是设置高度或者宽度的，直接在当前View添加即可。</li>
<li>通过调用<code>al_addConstraint</code>进行约束实际的添加。</li>
</ul>
<p>而<strong>al_addConstraint</strong>的实现则如下所示：</p>
<pre><code><span class="attr_selector">[NSLayoutConstraint al_applyGlobalStateToConstraint:constraint]</span>;
<span class="tag">if</span> ([NSLayoutConstraint al_preventAutomaticConstraintInstallation]) {
    <span class="attr_selector">[[NSLayoutConstraint al_currentArrayOfCreatedConstraints]</span> <span class="tag">addObject</span><span class="pseudo">:constraint</span>];
} <span class="tag">else</span> {
    <span class="attr_selector">[self addConstraint:constraint]</span>;
}
</code></pre><p>这里又出现了<code>al_applyGlobalStateToConstraint:constraint</code>以及<code>al_preventAutomaticConstraintInstallation</code>了，这次我们可不能再躲着它了，赶紧瞧一瞧。</p>
<p>首先是<code>al_applyGlobalStateToConstraint:constraint</code>，这个参数对应的是一个全局静态变量，用于判断：</p>
<pre><code><span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_isExecutingPriorityConstraintsBlock]) {
    constraint<span class="variable">.priority</span> = [<span class="built_in">NSLayoutConstraint</span> al_currentGlobalConstraintPriority];
}
</code></pre><p>而这个<code>al_isExecutingPriorityConstraintsBlock</code>则是用于如下这个函数：</p>
<pre><code>+ (void)autoSetPriority:(ALLayoutPriority)priority forConstraints:(ALConstraintsBlock)<span class="keyword">block
</span>{
    NSAssert(<span class="keyword">block, </span><span class="comment">@"The constraints block cannot be nil.");</span>
    <span class="preprocessor">if</span> (<span class="keyword">block) </span>{
        [[<span class="keyword">self </span>al_globalConstraintPriorities] <span class="keyword">addObject:@(priority)];
</span>        <span class="keyword">block();
</span>        [[<span class="keyword">self </span>al_globalConstraintPriorities] removeLastObject]<span class="comment">;</span>
    }
}
</code></pre><p>这里可能大家有点晦涩，主要在于PureLayout对于给Constraint设置Priority定义了一个Block-based的方法，也就是<code>autoSetPriority</code>。在回调的Block中，可以对多个Constraint设置同一个大小的Priority。（<strong>其实我也不是很理解这个集体加Priority设计的目的</strong>）</p>
<p><strong>不过需要有一点可以肯定的是，设置Constraint的Priority的时机一定要在<code>addConstraint</code>或者<code>active = true</code>之前</strong></p>
<p>而对于<code>al_preventAutomaticConstraintInstallation</code>这个变量，作者在API中描述了如下一段话：</p>
<blockquote>Creates all of the constraints in the block, then installs (activates) them all at once.<br> All constraints created from calls to the PureLayout API in the block are returned in a single array.<br> This may be more efficient than installing (activating) each constraint one-by-one.</blockquote>

<p>简而言之，一次性添加所有约束（实际上调用了UIKit的API<code>activateConstraints</code>），比一个个添加要有效率。<strong>然而，Purelayout的这个特性对于iOS7来说，用不上，只能通过<code>addConstraint</code>一个个装，哈哈，么么哒</strong></p>
<h4 id="NSArray_+_Purelayout">NSArray + Purelayout</h4><p>说完了ALView的layout，我们接下来说说另外的NSArray + Purelayout。顾名思义，该分类的主要目的就是给一个NSArray中的所有UIView添加约束。</p>
<p>比如这个API：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoDistributeViewsAlongAxis:<span class="list">(<span class="keyword">ALAxis</span>)</span>axis
                                                           alignedTo:<span class="list">(<span class="keyword">ALAttribute</span>)</span>alignment
                                                    withFixedSpacing:<span class="list">(<span class="keyword">CGFloat</span>)</span>spacing
                                                        insetSpacing:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldSpaceInsets
                                                        matchedSizes:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldMatchSizes</span>
</code></pre><p>其实现如下：</p>
<pre><code><span class="built_in">NSAssert</span>([<span class="keyword">self</span> al_containsMinimumNumberOfViews:<span class="number">1</span>], <span class="string">@"This array must contain at least 1 view to distribute."</span>);

<span class="comment">//1. 第一部分</span>
    ALDimension matchedDimension;
    ALEdge firstEdge, lastEdge;
    <span class="keyword">switch</span> (axis) {
        <span class="keyword">case</span> ALAxisHorizontal:
        <span class="keyword">case</span> ALAxisBaseline: <span class="comment">// same value as ALAxisLastBaseline</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0</span>
        <span class="keyword">case</span> ALAxisFirstBaseline:
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 */</span>
            matchedDimension = ALDimensionWidth;
            firstEdge = ALEdgeLeading;
            lastEdge = ALEdgeTrailing;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ALAxisVertical:
            matchedDimension = ALDimensionHeight;
            firstEdge = ALEdgeTop;
            lastEdge = ALEdgeBottom;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="built_in">NSAssert</span>(<span class="literal">nil</span>, <span class="string">@"Not a valid ALAxis."</span>);
            <span class="keyword">return</span> <span class="literal">nil</span>;
    }
    <span class="built_in">CGFloat</span> leadingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;
    <span class="built_in">CGFloat</span> trailingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;

<span class="comment">//2. 第二部分  </span>
    __<span class="built_in">NSMutableArray_of</span>(<span class="built_in">NSLayoutConstraint</span> *) *constraints = [<span class="built_in">NSMutableArray</span> new];
    ALView *previousView = <span class="literal">nil</span>;
    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>) {
        <span class="keyword">if</span> ([object isKindOfClass:[ALView class]]) {
            ALView *view = (ALView *)object;
            view<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;
            <span class="keyword">if</span> (previousView) {
                <span class="comment">// Second, Third, ... View</span>
                [constraints addObject:[view autoPinEdge:firstEdge toEdge:lastEdge ofView:previousView withOffset:spacing]];
                <span class="keyword">if</span> (shouldMatchSizes) {
                    [constraints addObject:[view autoMatchDimension:matchedDimension toDimension:matchedDimension ofView:previousView]];
                }
                [constraints addObject:[view al_alignAttribute:alignment toView:previousView forAxis:axis]];
            }
            <span class="keyword">else</span> {
                <span class="comment">// First view</span>
                [constraints addObject:[view autoPinEdgeToSuperviewEdge:firstEdge withInset:leadingSpacing]];
            }
            previousView = view;
        }
    }
    <span class="keyword">if</span> (previousView) {
        <span class="comment">// Last View</span>
        [constraints addObject:[previousView autoPinEdgeToSuperviewEdge:lastEdge withInset:trailingSpacing]];
    }
    <span class="keyword">return</span> constraints;            
</code></pre><ol>
<li>这个API的目的是将一组UIView按照Spacing间距进行均分，同时每个UIView的宽度或者高度保持一致。</li>
<li>第一部分是根据传入的轴，进行判断，是在竖直方向均分还是水平方向均分，同时影响的还有是宽度一致还是高度一致。</li>
<li>第二部分是根据传入的轴（比如水平方向），将前一个View的右边距和后一个View的左边距添加间距，循环添加，直至最后一个View的右边距和父View的右边距添加完成约束。  </li>
</ol>
<p>其他方面，这个分类的作用基本和<code>ALView + PureLayout一致</code>，也就不再重复解释了。<br>至此，PureLayout的源码解析基本上差不多了，其余类似于边对齐的API，如：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoPinEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>edge toEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>toEdge ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView;</span>
</code></pre><p>又或者是约束尺寸的，如：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoSetDimensionsToSize:<span class="list">(<span class="keyword">CGSize</span>)</span>size<span class="comment">;</span></span>
</code></pre><p>都大同小异，在此就不一一赘述了。</p>
<p>最后，<strong>强调一点</strong>：</p>
<ol>
<li>PureLayout必须在主线程使用，其本身实现非常依赖于静态的全局变量。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开始这篇文章之前，想必大家都应该使用过Autolayout方式的界面布局，相信大家都有过类似于如下这样的API调用：    </p>
<pre><code>[NSLayoutConstraint(item: self.viewA, attribute: .CenterY,]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重构你的ViewController]]></title>
    <link href="http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/"/>
    <id>http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/</id>
    <published>2015-12-29T16:37:56.000Z</published>
    <updated>2015-12-29T16:48:37.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章来自阅读<a href="https://realm.io/news/andy-matuschak-refactor-mega-controller/" target="_blank" rel="external">Let’s Play: Refactor the Mega Controller!</a></p>
<p>在该文中，作者阐述了如何使用Swift重构一个臭名昭著的Massive View Controller。从中，我们可以一窥Swift诸多优秀的特性以及如何利用这些特性将ViewController的职责进行解耦。</p>
<p>但是作者由于时间有限，并没有讲述完全，因此本文是我阅读<a href="https://github.com/andymatuschak/refactor-the-mega-controller" target="_blank" rel="external">源码</a>后的理解。</p>
<p><strong>建议大家在阅读本文之前，能够先去看看链接中的视频。</strong></p>
<h3 id="Let’s_get_started">Let’s get started</h3><p>首先我们下载源码，可以看到如下文件：</p>
<pre><code>-<span class="ruby"> <span class="constant">NavigationController</span>.swift
</span>-<span class="ruby"> <span class="constant">ViewController</span>.swift
</span>-<span class="ruby"> <span class="constant">AddViewController</span>.swift</span>
</code></pre><p>其中，<code>ViewController.swift</code>是项目的核心，代码行数超过<strong>246</strong>行。在这里我要强调一下，并不是代码行数多不好，而是要看你这个职责是不是相关。如果246行都是在实现一个数据结构或者算法，当然可行。但是如果246行里面包含了逻辑业务、网络请求、数据持久化，那必然是可以分离一部分职责出去。</p>
<p>在本文的<code>ViewController.swift</code>，这个类在初始状态下包含了<code>UITableViewDataSource</code>, <code>UITableViewDelegate</code>, <code>UIViewControllerTransitioningDelegate</code>, <code>UIViewControllerAnimatedTransitioning</code>, <code>NSFetchedResultsController</code>以及一系类跟UI显示相关的代码。</p>
<h4 id="1-_干掉UINavigationBar相关的内容">1. 干掉UINavigationBar相关的内容</h4><p>作者在app中构建了可变化的NavigationBar，因此bar的样式是根据不同状态进行改变的。原来的逻辑整体写在了<code>ViewController.swift</code>中，如下所示：</p>
<pre><code> func updateNavigationBar() {
        <span class="keyword">switch</span> fetchedResultsController!<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
        <span class="keyword">case</span> <span class="number">0.</span>.<span class="number">.3</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        <span class="keyword">default</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }

override func preferredStatusBarStyle() -&gt; <span class="built_in">UIStatusBarStyle</span> {
    <span class="keyword">switch</span> fetchedResultsController?<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
    <span class="keyword">case</span> <span class="variable">.Some</span>(<span class="number">0.</span>.<span class="number">.3</span>), <span class="variable">.None</span>:
        <span class="keyword">return</span> <span class="variable">.Default</span>
    <span class="keyword">case</span> <span class="variable">.Some</span>(_):
        <span class="keyword">return</span> <span class="variable">.LightContent</span>
    }
}
</code></pre><p>同时，还在几个事件回调的地方，如Core Data的<code>controllerDidChange</code>，调用了<code>setNeedsStatusBarAppearanceUpdate()</code>。</p>
<p>这个想法粗略想想并没什么问题，因为我们需要根据一系列的事件变化来改变我们的界面样式，这是很明显的业务逻辑。而我们都很清楚，ViewController就是用来写业务逻辑的地方。</p>
<p>先抛开ViewController是否是应该写业务逻辑的地方这一个有待商榷的论点之外，我们先看看，我们可以如何重构现有代码。</p>
<p><strong>首先</strong>，<code>updateNavigationBar</code>中多个case中的代码有了重复，因此我们可以将其重构成一个函数，接受三个关于样式的参数，如下：</p>
<pre><code>func applyTheme(<span class="string">barTintColor:</span>newBarTintColor, <span class="string">tintColor:</span>newTintColor, <span class="string">titleTextAttributes:</span>newTextAttributes) {
    barTintColor = <span class="string">barTintColor:</span>newBarTintColor
    tintColor = <span class="string">tintColor:</span>newTintColor
    titleTextAttributes = <span class="string">titleTextAttributes:</span>newTextAttributes
}
</code></pre><p>重构完函数以后，我们发现在多个样式中用到了switch case进行业务逻辑参数转换样式参数的过程。<strong>这说明什么，我们可以将转换逻辑和switch case一起通过Enum进行重构（这里说的东西都是基于你懂Enum）</strong></p>
<pre><code><span class="keyword">enum</span> NavigationTheme {
    <span class="keyword">case</span> Normal
    <span class="keyword">case</span> Warning
    <span class="keyword">case</span> Doomed

    var statusBarStyle: <span class="built_in">UIStatusBarStyle</span> {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>: <span class="keyword">return</span> <span class="variable">.Default</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>: <span class="keyword">return</span> <span class="variable">.LightContent</span>
        }
    }

    var barTintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        <span class="keyword">case</span> <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        }
    }

    var titleTextAttributes: [String: <span class="built_in">NSObject</span>]? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
        }
    }

    var tintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }
}

extension NavigationTheme {
    init(numberOfImminentTasks: Int) {
        <span class="keyword">switch</span> numberOfImminentTasks {
        <span class="keyword">case</span> -Int<span class="variable">.max</span> ... <span class="number">3</span>:
            <span class="keyword">self</span> = <span class="variable">.Normal</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            <span class="keyword">self</span> = <span class="variable">.Warning</span>
        <span class="keyword">default</span>:
            <span class="keyword">self</span> = <span class="variable">.Doomed</span>
        }
    }
}    
</code></pre><p>由于Enum在swift中是一等公民，因此可以可以在其中构建大量的<strong>Computed Properties</strong>，这些计算变量依赖于当前enum的状态。不仅如此，我们还将之前分散的三种样式，组合成了一个<strong>紧凑的结构体</strong>，大大简化了变量传输。</p>
<p>重构结束后，我们在<code>Viewcontroller.swift</code>中设置一个计算变量<code>navigationTheme</code>，其的构造函数是之前的<code>fetchedResultsController?.fetchedObjects?.count</code>。</p>
<p>最后是在相应的事件后触发更新UINavigationBar即可，在本文的视线中，是采用了closure的形式完成：</p>
<pre><code>navigationThemeDidChangeHandler = { [<span class="keyword">weak</span> <span class="keyword">self</span>] theme <span class="keyword">in</span>
            <span class="keyword">if</span> <span class="keyword">let</span> navigationController = <span class="keyword">self</span>?.navigationController {
                navigationController.navigationBar.applyTheme(theme)
                navigationController.statusBarStyle = theme.statusBarStyle
            }
        }
</code></pre><h3 id="2-_干掉时间相关的转换逻辑">2. 干掉时间相关的转换逻辑</h3><p>相信很多人做app的时候遇到过，服务器返回的是一系列标准时间参数，而你需要将其转换成界面需要的生日、星座、年龄等等，这又是一大堆的业务逻辑。为了解决这种逻辑代码和ViewController的耦合，很多人提出了<code>ViewModel</code>，将部分弱业务逻辑代码剥离出来，单独写在一个地方。</p>
<p><strong>但是，我需要强调一点，这种形式的剥离，并不能叫ViewModal，而是一个简单的adapter而已。</strong></p>
<p>在本文中，列表Cell里面需要根据日期距离当前时间的差距显示成昨天、今天、明天等等。因此，其构建了一个单独的的DateFormatter，根据传入的两个Date进行转换，代码如下：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">RelativeTimeDateFormatter</span> </span>{
    <span class="keyword">let</span> calendar: <span class="type">NSCalendar</span>

    <span class="keyword">init</span>(calendar: <span class="type">NSCalendar</span> = <span class="type">NSCalendar</span>.autoupdatingCurrentCalendar()) {
        <span class="keyword">self</span>.calendar = calendar
    }

    <span class="func"><span class="keyword">func</span> <span class="title">stringForDate</span><span class="params">(date: NSDate, relativeToDate baseDate: NSDate)</span></span> -&gt; <span class="type">String</span> {
        <span class="keyword">var</span> beginningOfDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>
        <span class="keyword">var</span> beginningOfBaseDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>

        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfDate, interval: <span class="literal">nil</span>, forDate: date)
        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfBaseDate, interval: <span class="literal">nil</span>, forDate: baseDate)
        <span class="keyword">let</span> numberOfCalendarDaysBetweenDates = calendar.components(<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, fromDate: beginningOfBaseDate!, toDate: beginningOfDate!, options: <span class="type">NSCalendarOptions</span>()).day

        <span class="keyword">switch</span> numberOfCalendarDaysBetweenDates {
        <span class="keyword">case</span> -<span class="type">Int</span>.<span class="built_in">max</span> ... -<span class="number">2</span>:
            <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="built_in">abs</span>(numberOfCalendarDaysBetweenDates)</span>) days ago"</span>
        <span class="keyword">case</span> -<span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Yesterday"</span>
        <span class="keyword">case</span> <span class="number">0</span>:
            <span class="keyword">return</span> <span class="string">"Today"</span>
        <span class="keyword">case</span> <span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Tomorrow"</span>
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="string">"In <span class="subst">\(numberOfCalendarDaysBetweenDates)</span> days"</span>
        }
    }
}
</code></pre><p><strong>这里需要注意的是，NSCalendar的初始化非常耗时，过去在Objective-C时代常常使用dispatch_once构建单例传输，在这里通过结构体中的成员变量维护了一份，作用是同样的。</strong></p>
<h3 id="3-_干掉NSPredicate">3. 干掉NSPredicate</h3><p>对于NSPredicate，有些人可能还不熟悉，他就是类似于SQLite中的查询语句，只不过其应用范围是CoreData。咦，查询语句还能重构？</p>
<p>其实在本文中，对于NSPredicate的使用只有原先这一句  <code>fetchRequest.predicate = NSPredicate(format: &quot;dueDate &lt;= %@&quot;, argumentArray: [NSCalendar.currentCalendar().dateByAddingUnit(.Day, value: 10, toDate: NSDate(), options: NSCalendarOptions())!])</code></p>
<p>这段代码从重复性上来说是不需要重构的。但是，我们可以看到，在这里的构造参数里面，我们还是进行了一定的业务逻辑转换。所以，和DateFormatter一样，我们也可以将这部分所谓为的”弱业务逻辑”代码进行剥离：</p>
<pre><code>extension NSPredicate {
    convenience init(forTasksWithinNumberOfDays <span class="string">numberOfDays:</span> Int, ofDate <span class="string">date:</span> NSDate, <span class="string">calendar:</span> NSCalendar = NSCalendar.currentCalendar()) {
        self.init(<span class="string">format:</span> <span class="string">"dueDate &lt;= %@"</span>, <span class="string">argumentArray:</span> [calendar.dateByAddingUnit(.Day, <span class="string">value:</span> numberOfDays, <span class="string">toDate:</span> date, <span class="string">options:</span> NSCalendarOptions())!])
    }
}
</code></pre><p><strong>除了业务逻辑剥离之外，其实我们也可以看到，在这个NSPredicate的新构造参数，可以接受一个<code>calendar</code>，这对于测试用例编写的依赖注入是非常有好处的。</strong></p>
<h3 id="4-_Core_Data_Stack">4. Core Data Stack</h3><p>用过Core Data的人都知道，Core Data的使用非常麻烦，需要配置大量的选项，照着苹果源码写的经历相信大家都有过，那恶心的200-300行配置代码，真是么么哒了。</p>
<p><strong>但是，这几百行代码又是无法省略的</strong>，那该怎么办呢？</p>
<p>一个比较好的解决方案就<code>Core Data Stack</code>    。意为将CoreData的初始化以及多个NSManagerObjectContext封装进<code>CoreDataStack</code> 维护。 </p>
<p>在本文中，因为只是使用了一个主线程的NSManagerObjectContext，所以可能读者在阅读源码的时候可能觉得这个重构只是将CoreData配置从View剥离了。但是实际上，使用CoreDataStack可以做到更多，建议大家阅读Github上相关项目。</p>
<h3 id="5-_干掉NSFetchedResultsControllerDelegate">5. 干掉NSFetchedResultsControllerDelegate</h3><p>NSFetchedResultsController大家可以简单理解为获取CoreData数据的一个中介层。根据传输进入的谓语NSPredicate进行查询，查询结束后通过相应的Delegate事件回调。</p>
<p>在作者的代码中，作者通过构建<code>manager</code>的方式剥离了NSFetchedResultsController的职责，将NSFetchedResultsController的初始化、回调封装进了<code>UpcomingTaskDataManager.swift</code>中。</p>
<p><strong>不过值得注意的一点是，尽管作者封装的NSFetchedResultsControllerDelegate的回调，但是为了让调用者可以自定义处理事件，实际上作者还是需要暴露一些的Delegate，当然，新的回调相对来说进行了一定的简化，同时在数据回调时经过了业务转化。</strong></p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerWillChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerDidChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didInsertRowAtIndexPath indexPath: NSIndexPath)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didDeleteRowAtIndexPath indexPath: NSIndexPath)</span></span>
}
</code></pre><h3 id="6-_CoreDataModel_&lt;=&gt;_Model">6. CoreDataModel &lt;=&gt; Model</h3><p>这一步是将从Core Data中获取的NSManagedObject Model 转换成业务中使用的Model。为什么要这么做呢？原因有三个：  </p>
<ul>
<li>CoreData中的属性一更改，就会触发NSFetchedResultsController，这会很影响性能。</li>
<li>CoreData中的属性存在很多bug</li>
<li>NSManagedObject不是一个struct类型，很有可能<strong>误伤</strong></li>
</ul>
<pre>
import CoreData  
import Foundation

struct Task: Equatable {
    var id: String
    var title: String
    var dueDate: NSDate
}

func ==(lhs: Task, rhs: Task) -> Bool {
    return lhs.id == rhs.id && lhs.title == rhs.title && lhs.dueDate == rhs.dueDate
}

extension Task {
    init(managedTask: NSManagedObject) {
        self.id = managedTask.valueForKey("id") as! String
        self.title = managedTask.valueForKey("title") as! String
        self.dueDate = managedTask.valueForKey("dueDate") as! NSDate
    }
}
</pre>

<p>作者用以上的Task类型替换了CoreData中的ManagedObject，可以有效的避免以上问题。</p>
<h3 id="7-封装数据结构">7.封装数据结构</h3><p>在这一步里，我将作者自定义<code>TaskTableViewCell</code>和构建<code>AddCompletionSegue</code>合并到了一块说。</p>
<p>这两步的重构，看似简单，但是其实也蕴含了一个思想：<strong>类型越确定，编程越容易，运行越安全</strong></p>
<p>在原文的实现，一开始作者都是通过采用基础的数据结构UITableViewCell和UISegue。这样带来的坏处就是类型不明确导致的职责不明确。对于基础的数据结构，我们常常还要进行类型判断和转换，容易犯错。</p>
<h3 id="8-干掉UITableViewDelegate和UITableViewDataSource">8.干掉UITableViewDelegate和UITableViewDataSource</h3><p>这一步想必大家都很熟悉了，微博上整天热传了<em>用ViewModel重构你的ViewController</em>经常提及的就是干掉UITableViewDelegate和UITableViewDataSource。</p>
<p>那说了那么多，我们来看看究竟如何干掉它。</p>
<p>毫无以为，我们首先要构建一个类型，来实现UITableViewDelegate和DataSource，如下所示：</p>
<pre><code><span class="comment">// 1. </span>
<span class="class"><span class="keyword">class</span> <span class="title">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="title">CellType</span>: <span class="title">UITableViewCell</span>&gt;: <span class="title">NSObject</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    private <span class="keyword">let</span> tableView: <span class="type">UITableView</span>
    private <span class="keyword">let</span> upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>
    private <span class="keyword">let</span> cellReuseIdentifier: <span class="type">String</span>
    private <span class="keyword">let</span> cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; ()
    private <span class="keyword">let</span> didChangeHandler: () -&gt; <span class="type">Void</span>

<span class="comment">// .2</span>
    <span class="keyword">init</span>(tableView: <span class="type">UITableView</span>, upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>, cellReuseIdentifier: <span class="type">String</span>, cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; (), didChangeHandler: () -&gt; <span class="type">Void</span>) {
        <span class="keyword">self</span>.tableView = tableView
        <span class="keyword">self</span>.upcomingTaskDataManager = upcomingTaskDataManager
        <span class="keyword">self</span>.cellReuseIdentifier = cellReuseIdentifier
        <span class="keyword">self</span>.cellConfigurationHandler = cellConfigurationHandler
        <span class="keyword">self</span>.didChangeHandler = didChangeHandler

        <span class="keyword">super</span>.<span class="keyword">init</span>()
    }

<span class="comment">// 3.</span>
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> {
        upcomingTaskDataManager.deleteTask(upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row])
    }

    <span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].title
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].items.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> {
        <span class="keyword">let</span> task = upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row]
        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellReuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">CellType</span>
        cellConfigurationHandler(cell, task)
        <span class="keyword">return</span> cell
    }
</code></pre><ol>
<li>这个<code>UpcomingTaskDataManagerTableViewAdapter</code>通过传入一个CellType支持泛型。  </li>
<li>通过接受几个closure来进行自定义的配置，包括cell的样式配置以及tableview数据更新后的回调。  </li>
<li>实现的UITableViewDataSource</li>
</ol>
<p>同样，由于职责的重新分配，我们要将跟<code>TaskManager</code>（包括NSFetchedResultsController）相关的划入到这个adapter中。</p>
<h3 id="大结局">大结局</h3><p>最后重构后的ViewController，只有<strong>37</strong>代码，效果如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UITableViewController</span> </span>{
    <span class="keyword">var</span> navigationThemeDidChangeHandler: ((<span class="type">NavigationTheme</span>) -&gt; <span class="type">Void</span>)?
    <span class="keyword">var</span> navigationTheme: <span class="type">NavigationTheme</span> {
        <span class="keyword">return</span> <span class="type">NavigationTheme</span>(numberOfImminentTasks: upcomingTaskDataManager.totalNumberOfTasks)
    }

    private <span class="keyword">let</span> upcomingTaskDataManager = <span class="type">UpcomingTaskDataManager</span>()
    private <span class="keyword">var</span> upcomingTaskDataManagerTableViewAdapter: <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="type">TaskTableViewCell</span>&gt;!

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
        <span class="keyword">super</span>.viewDidLoad()

        upcomingTaskDataManagerTableViewAdapter = <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>(
            tableView: tableView,
            upcomingTaskDataManager: upcomingTaskDataManager,
            cellReuseIdentifier: <span class="string">"Cell"</span>,
            cellConfigurationHandler: { cell, task <span class="keyword">in</span>
                cell.viewData = <span class="type">TaskTableViewCell</span>.<span class="type">ViewData</span>(task: task, relativeToDate: <span class="type">NSDate</span>())
            },
            didChangeHandler: { [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="keyword">self</span>?.updateNavigationBar() }
        )
        upcomingTaskDataManager.delegate = upcomingTaskDataManagerTableViewAdapter
        tableView.dataSource = upcomingTaskDataManagerTableViewAdapter

        updateNavigationBar()
    }

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> <span class="literal">true</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">updateNavigationBar</span><span class="params">()</span></span> {
        navigationThemeDidChangeHandler?(navigationTheme)
    }

    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">unwindFromAddController</span><span class="params">(segue: AddCompletionSegue)</span></span> {
        upcomingTaskDataManager.createTaskWithTitle(segue.taskTitle, dueDate: segue.taskDueDate)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章来自阅读<a href="https://realm.io/news/andy-matuschak-refactor-mega-controller/" target="_blank" rel="external">Let’s Play: Refactor the ]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
