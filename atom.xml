<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://satanwoo.github.io/"/>
  <updated>2018-03-31T16:59:45.000Z</updated>
  <id>http://satanwoo.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[动手制作一个简易的iOS动态执行器]]></title>
    <link href="http://satanwoo.github.io/2018/04/01/jsengine/"/>
    <id>http://satanwoo.github.io/2018/04/01/jsengine/</id>
    <published>2018-03-31T16:26:55.000Z</published>
    <updated>2018-03-31T16:59:45.000Z</updated>
    <content type="html"><![CDATA[<p>之前听说滴滴的<code>DynamicCocoa</code>是基于JavaScriptCore搞得，一直期待看到他们的真正实现，不过可能后来由于公司机密，应该不能再开源了。</p>
<p>借着最近开始研究JavaScriptCore的契机，我决定利用这一两天所学的JavaScript知识，在业余时间做一个简单的iOS动态执行器玩具。</p>
<blockquote>
<p>题外话1：听说滴滴基于LLVM backend搞了一套中间语言解释器，不知道最后用了哪个？不过LLVM IR解释器的话，嘿嘿，还是有点意思的。</p>
<p>题外话2：我研究这个并不是想做iOS动态化，因为xxxxxxx。我只是纯粹想看看JavaScriptCore的一些实现而已。</p>
</blockquote>
<h3 id="效果">效果</h3><p>一张Gif图想必能最佳得展示我做的玩具，请各位大佬过目：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/jstester.gif?raw=true" alt=""></p>
<h3 id="前置知识点">前置知识点</h3><p>在实现我们的执行器前，我们还是要稍微要了解一下一些前置的知识点。</p>
<h4 id="JSWrapper_Object">JSWrapper Object</h4><p>大家都知道，Objective-C中的诸多类型在JavaScript的环境里是不能直接用的，需要通过JSValue进行一层包装，具体的类型转换如下图展示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/762048-c669c91024c9308b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>基本上图上的转换都很容易理解，唯一需要我们注意的是<code>Wrapper Object</code>。什么是<code>Wrapper Object</code>呢？</p>
<p>举个例子：</p>
<pre><code><span class="built_in">self</span><span class="built_in">.</span>context<span class="preprocessor">[</span>@<span class="string">"a"</span><span class="preprocessor">]</span><span class="markup"> = </span><span class="preprocessor">[</span>CustomObject <span class="literal">new</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述代码将我们一个自定义类型<code>CustomObject</code>的实例以变量名<code>a</code>的方式注入到了JavaScript的运行环境里。但是她是怎么知道我们的定义呢，又是如何知道我们是否能调用特定的方法？</p>
<p>从默认的角度看，JS运行环境只会把OC中<code>init</code>初始化方法以及类的继承关系给同步到JS环境中（如果有JSExport我们下文说），然后这个对象会包装给一个JSWrapperValue用于JS环境中使用。而当JS环境调用OC并且涉及到这个对象的时候，JavaScriptCore会自动将其解包还原成原始的OC对象类型。</p>
<pre><code>- <span class="list">(<span class="keyword">JSValue</span> <span class="variable">*)jsWrapperForObject:(id)object
{
    JSC::JSObject*</span> jsWrapper = m_cachedJSWrappers.get<span class="list">(<span class="keyword">object</span>)</span><span class="comment">;</span>
    if <span class="list">(<span class="keyword">jsWrapper</span>)</span>
        return [JSValue valueWithJSValueRef<span class="keyword">:toRef</span><span class="list">(<span class="keyword">jsWrapper</span>)</span> inContext<span class="keyword">:m_context</span>]<span class="comment">;</span>

     // 注意点!!!!!!!!!!!!!!!!!!
    JSValue <span class="variable">*wrapper;
    if (class_isMetaClass(object_getClass(object)))
        wrapper = [[self classInfoForClass:(Class)object] constructor];
    else {
        JSObjCClassInfo*</span> classInfo = [self classInfoForClass:[object class]]<span class="comment">;</span>
        wrapper = [classInfo wrapperForObject<span class="keyword">:object</span>]<span class="comment">;</span>
    }

    JSC:<span class="keyword">:ExecState*</span> exec = toJS<span class="list">([m_context JSGlobalContextRef])</span><span class="comment">;</span>
    jsWrapper = toJS<span class="list">(<span class="keyword">exec</span>, valueInternalValue<span class="list">(<span class="keyword">wrapper</span>)</span>)</span>.toObject<span class="list">(<span class="keyword">exec</span>)</span><span class="comment">;</span>
    m_cachedJSWrappers.set<span class="list">(<span class="keyword">object</span>, jsWrapper)</span><span class="comment">;</span>
    return wrapper<span class="comment">;</span>
}</span>
</code></pre><ul>
<li>整体分析下，就是基于一个缓存来判断是否对特定的对象或类型已经构建果<code>Wrapper Object</code>，没有的话就进行构建，构建过程如下：</li>
</ul>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSClassDefinition definition<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">definition = kJSClassDefinitionEmpty<span class="comment">;</span></span><br><span class="line">definition.className = className<span class="comment">;</span></span><br><span class="line">m_classRef = JSClassCreate(&amp;definition)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">[self allocateConstructorAndPrototypeWithSuperClassInfo:superClassInfo]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>没啥特别的，就是OC对象创建对应的JS对象，类型对类型。</li>
<li>OC类型的继承关系在JS里面通过设置Constructor和Prototype进行构建，其实就是简单的JavaScript原型链继承。</li>
</ul>
<h4 id="JSExport协议_&amp;_JSExportAs">JSExport协议 &amp; JSExportAs</h4><p><code>JSExport</code>协议本质上只是个<code>Protocol</code>标记，用于让JavaScriptCore加载那些打上这个特殊标记的类，用于特定方式的注册及初始化。</p>
<p>上文我们提过，默认情况下，JavaScriptCore会对象创建一个默认的<code>Wrapper Object</code>，但是这个对象除了简单继承关系外，也就一个按照特殊格式命令的<code>Constructor</code>而已：</p>
<p><code>[NSString stringWithFormat:@&quot;%sConstructor&quot;, className]</code></p>
<p>那如果我们需要将OC环境中的方法注入到JS环境中，就需要用到<code>JSExport</code>协议了，这个协议在运行时会按照如下逻辑进行处理，将方法和属性进行诸如注入：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">检查init方法簇的方法，并根据这么合法提供合理的</span><br><span class="line"></span><br><span class="line">__block <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">Protocol</span> *&gt; initTable;</span><br><span class="line">    <span class="type">Protocol</span> *exportProtocol = getJSExportProtocol();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Class</span> currentClass = cls; currentClass; currentClass = class_getSuperclass(currentClass)) &#123;</span><br><span class="line">        forEachProtocolImplementingProtocol(currentClass, exportProtocol, ^(<span class="type">Protocol</span> *protocol) &#123;</span><br><span class="line">            forEachMethodInProtocol(protocol, <span class="type">YES</span>, <span class="type">YES</span>, ^(<span class="type">SEL</span> selector, <span class="keyword">const</span> <span class="type">char</span>*) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="type">char</span>* name = sel_getName(selector);</span><br><span class="line">                <span class="keyword">if</span> (!isInitFamilyMethod(@(name)))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                initTable.<span class="type">set</span>(name, protocol);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Class</span> currentClass = cls; currentClass; currentClass = class_getSuperclass(currentClass)) &#123;</span><br><span class="line">        __block unsigned numberOfInitsFound = <span class="number">0</span>;</span><br><span class="line">        __block <span class="type">SEL</span> initMethod = <span class="number">0</span>;</span><br><span class="line">        __block <span class="type">Protocol</span> *initProtocol = <span class="number">0</span>;</span><br><span class="line">        __block <span class="keyword">const</span> <span class="type">char</span>* types = <span class="number">0</span>;</span><br><span class="line">        forEachMethodInClass(currentClass, ^(<span class="type">Method</span> <span class="keyword">method</span>) &#123;</span><br><span class="line">            <span class="type">SEL</span> selector = method_getName(<span class="keyword">method</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="type">char</span>* name = sel_getName(selector);</span><br><span class="line">            <span class="type">auto</span> iter = initTable.find(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iter == initTable.<span class="keyword">end</span>())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            numberOfInitsFound++;</span><br><span class="line">            initMethod = selector;</span><br><span class="line">            initProtocol = iter-&gt;value;</span><br><span class="line">            types = method_getTypeEncoding(<span class="keyword">method</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!numberOfInitsFound)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numberOfInitsFound &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"ERROR: Class %@ exported more than one init family method via JSExport. Class %@ will not have a callable JavaScript constructor function."</span>, cls, cls);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">JSObjectRef</span> <span class="keyword">method</span> = objCCallbackFunctionForInit(context, cls, initProtocol, initMethod, types);</span><br><span class="line">        <span class="keyword">return</span> [<span class="type">JSValue</span> valueWithJSValueRef:<span class="keyword">method</span> inContext:context];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注入方法和属性</span><br><span class="line">Protocol *exportProtocol = getJSExportProtocol()<span class="comment">;</span></span><br><span class="line">forEachProtocolImplementingProtocol(m_class, exportProtocol, ^(Protocol *protocol)&#123;</span><br><span class="line">  copyPrototypeProperties(m_context, m_class, protocol, prototype)<span class="comment">;</span></span><br><span class="line">  copyMethodsToObject(m_context, m_class, protocol, NO, constructor)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>而至于<code>JSExportAs</code>，就是做了个简单的名称映射而已，毕竟JS函数传参和OC有很大的区别：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *createRenameMap(Protocol *protocol, <span class="built_in">BOOL</span> isInstanceMethod)
{
    <span class="built_in">NSMutableDictionary</span> *renameMap = [[<span class="built_in">NSMutableDictionary</span> alloc] init];

    forEachMethodInProtocol(protocol, <span class="literal">NO</span>, isInstanceMethod, ^(SEL sel, <span class="keyword">const</span> <span class="keyword">char</span>*){
        <span class="built_in">NSString</span> *rename = @(sel_getName(sel));
        <span class="built_in">NSRange</span> range = [rename rangeOfString:<span class="string">@"__JS_EXPORT_AS__"</span>];
        <span class="keyword">if</span> (range<span class="variable">.location</span> == <span class="built_in">NSNotFound</span>)
            <span class="keyword">return</span>;
        <span class="built_in">NSString</span> *selector = [rename substringToIndex:range<span class="variable">.location</span>];
        <span class="built_in">NSUInteger</span> begin = range<span class="variable">.location</span> + range<span class="variable">.length</span>;
        <span class="built_in">NSUInteger</span> length = [rename length] - begin - <span class="number">1</span>;
        <span class="built_in">NSString</span> *name = [rename substringWithRange:(<span class="built_in">NSRange</span>){ begin, length }];
        renameMap[selector] = name;
    });

    <span class="keyword">return</span> renameMap;
}
</code></pre><h3 id="实现过程">实现过程</h3><p><b style="color:red">说了那么多基础原理，下面让我们来看看具体实现流程：</b></p>
<h4 id="类、实例和方法">类、实例和方法</h4><p>在我看来，要实现一个动态化的执行环境，有三要素是必不可少的：</p>
<p><b style="color:red">类（包括元类）、实例对象以及方法。</b></p>
<p>基于我们上文对于<code>Wrapper Object</code>的分析，我们可以构建特殊类型的Wrapper Object对这三个元素进行包装，具体就不说了，还是建议大家自行思考，基本上类似我上文分析<code>JSWrapperObject</code>的步骤。</p>
<p>除了上述三要素，我们还需要定义一个全局变量，<code>WZGloablObject</code>（大家可以理解为浏览器的window对象），用于拦截顶层的属性访问。</p>
<p><b style="color:red">按照这个设计，大家可以自行思考下，如果是你做，你会如何继续下面的工作，文章下周随着代码一起发布吧。</b></p>
<h4 id="Choose_调试">Choose 调试</h4><p>搞过逆向用过<strong>Cycript</strong>的朋友都知道，<strong>Cycript</strong>在调试时候有个非常方便的调试功能：<code>Choose</code>。该功能可以快速的帮助我们根据类名在堆上的对象全部查询返回。</p>
<p>这么实用的功能必须提供，我基本上直接照搬了Cycript的实现。代码很清晰，基本能够自解释其逻辑。核心基本上就是遍历每个<code>malloc_zone</code>，然后根据获取的<code>vmaddress_range</code>判断获取到的<strong>数据</strong>其类型是不是我们要的。</p>
<pre><code>// 遍历zone
<span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i != size; ++i) {
    <span class="keyword">const</span> malloc_zone_t * zone = reinterpret_cast&lt;<span class="keyword">const</span> malloc_zone_t *&gt;(zones[i]);
    <span class="keyword">if</span> (zone == <span class="type">NULL</span> || zone-&gt;introspect == <span class="type">NULL</span>)
        <span class="keyword">continue</span>;
    zone-&gt;introspect-&gt;enumerator(mach_task_self(), &amp;choice, <span class="type">MALLOC_PTR_IN_USE_RANGE_TYPE</span>, zones[i], &amp;read_memory, &amp;choose_);
}

// 检查对象
<span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i &lt; count; ++i) {
   vm_range_t &amp;<span class="type">range</span> = ranges[i];
   <span class="type">void</span> * data = reinterpret_cast&lt;<span class="type">void</span> *&gt;(<span class="type">range</span>.address);
   size_t size = <span class="type">range</span>.size;

   <span class="keyword">if</span> (size &lt; sizeof(<span class="type">ObjectStruct</span>))
       <span class="keyword">continue</span>;

   uintptr_t * pointers = reinterpret_cast&lt;uintptr_t *&gt;(data);
<span class="comment">#ifdef __arm64__</span>
   <span class="type">Class</span> isa = (__bridge <span class="type">Class</span>)((<span class="type">void</span> *)(pointers[<span class="number">0</span>] &amp; <span class="number">0x1fffffff8</span>));
<span class="comment">#else</span>
   <span class="type">Class</span> isa = reinterpret_cast&lt;<span class="type">Class</span>&gt;(pointers[<span class="number">0</span>]);
<span class="comment">#endif</span>
   std::<span class="type">set</span>&lt;<span class="type">Class</span>&gt;::const_iterator <span class="literal">result</span>(choice-&gt;query_.find(isa));
   <span class="keyword">if</span> (<span class="literal">result</span> == choice-&gt;query_.<span class="keyword">end</span>())
       <span class="keyword">continue</span>;

   size_t needed = class_getInstanceSize(*<span class="literal">result</span>);
   size_t boundary = <span class="number">496</span>;
<span class="comment">#ifdef __LP64__</span>
   boundary *= <span class="number">2</span>;
<span class="comment">#endif</span>
   <span class="keyword">if</span> ((needed &lt;= boundary &amp;&amp; (needed + <span class="number">15</span>) / <span class="number">16</span> * <span class="number">16</span> != size) || (needed &gt; boundary &amp;&amp; (needed + <span class="number">511</span>) / <span class="number">512</span> * <span class="number">512</span> != size))
       <span class="keyword">continue</span>;
   choice-&gt;result_.insert((__bridge id)(data));
}
</code></pre><p><b style="color:red">不过这里一大堆的511、512的数字构成的公式，实话说我不是很懂，有了解的大佬麻烦告知我一下。</b></p>
<h4 id="类型转换">类型转换</h4><p>首先我们需要记住，JavaScript的基础类型如下：</p>
<pre><code>-<span class="ruby"> 字符串、
</span>-<span class="ruby"> 数字、
</span>-<span class="ruby"> 布尔、
</span>-<span class="ruby"> 数组、
</span>-<span class="ruby"> 对象、
</span>-<span class="ruby"> <span class="constant">Null</span>、
</span>-<span class="ruby"> <span class="constant">Undefined</span></span>
</code></pre><p>所以我们只要根据对应的进行转换就可以，如下所示：</p>
<ul>
<li>JS字符串 &lt;-&gt; NSString</li>
<li>数字 &lt;-&gt; NSNumber</li>
<li>数组 &lt;-&gt; NSArray</li>
<li>Null &lt;-&gt; NSNull</li>
<li>Undefined &lt;-&gt; Void (仅当返回值的时候处理，否则直接抛出异常)</li>
</ul>
<blockquote>
<p>题外话，JavaScript里面没有什么整数和浮点数类型区分一说，所以我们可以无脑将其通过double的方式构建<code>NSNumber</code></p>
</blockquote>
<p>最后再来说下对对象类型的处理：</p>
<p>在JavaScript，任何对象都可以简单理解为包含了属性（方法）的一个包装体，如下所示:</p>
<pre><code>var a = {x:<span class="number">10</span>, y:<span class="number">100</span>};
</code></pre><p>因此，我们在对类型进行转换的时候，要特别注意以下几点：</p>
<ul>
<li>这个对象是不是我们刚刚上文提过的<b style="color:red">类、实例、方法</b>，是的话在其进入到Objective-C执行上下文的之前从JSWrapperObject中取出来。</li>
<li>这个对象是不是特定类型的结构体，是的话我们将其转换成结构体，比如<code>CGRect</code>之类的，是的话需要特别转换</li>
<li>是不是可以直接转换成特定类型的对象，比如<code>Date &lt;-&gt; NSDate</code>的转换。</li>
<li>最后，将其可遍历的属性和对应的属性值，转换到<code>NSDictionary</code>之中。</li>
<li><strong>当然，别忘了，需要注意递归处理</strong>。</li>
</ul>
<h4 id="Calling_Convention">Calling Convention</h4><p>关于<code>Calling Convention</code>，本文就不再赘述，有兴趣的读者可以参考我和同事一起写的知乎专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target="_blank" rel="external">iOS调试进阶</a></p>
<p>简单来重新描述下就是：</p>
<p>一个函数的调用过程中，函数的参数既可以使用栈传递，也可以使用寄存器传递，参数压栈的顺序可以从左到右也可以从右到左，函数调用后参数从栈弹出这个工作可以由函数调用方完成，也可以由被调用方完成。如果函数的调用方和被调用方(函数本身)不遵循统一的约定，有这么多分歧这个函数调用就没法完成。这个双方必须遵守的统一约定就叫做调用惯例(Calling Convention)，调用惯例规定了参数的传递的顺序和方式，以及栈的维护方式。</p>
<p>由于业界已经有知名大佬写的<code>libffi</code>，所以我们不需要重复发明轮子，直接使用即可。如果真的要了解具体原理，也可以参考<a href="http://satanwoo.github.io/2017/06/29/Macho-2/">我的文章</a>，具体分析<code>objc_msgSend</code>的实现流程。</p>
<h3 id="其他">其他</h3><p>为了偷懒，我直接用JavaScript实现了这些的效果。其实理论上，如果我完整的实现编译前端，构建抽象语法树分析执行上下文，将Objective-C的代码转换成JavaScript，那么就能实现动态执行Objective-C代码了。(当然本质上还是障眼法)</p>
<blockquote>
<p>其实更快的方式，且不能保证完全正确的方式，就是调用一下<code>JSPatchConvertor</code>就好了，哈哈哈。</p>
</blockquote>
<h3 id="结语">结语</h3><p>每篇文章的最后，请允许我按照惯例吟诗一首致敬我的偶像，<strong>杨萧玉</strong>。</p>
<p>杨萧玉，腾讯星，90后中属第一。<br>人低调，还谦虚，iOS技术无人敌。<br>搞逆向，他在行，微信破解太容易。<br>论深度，特服气，深入汇编来分析。<br>动态化，不用提，想发patch就patch。<br>论收入，没得比，一年交税几个亿。  </p>
<p>我的偶像杨萧玉，为何你竟如此牛逼？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前听说滴滴的<code>DynamicCocoa</code>是基于JavaScriptCore搞得，一直期待看到他们的真正实现，不过可能后来由于公司机密，应该不能再开源了。</p>
<p>借着最近开始研究JavaScriptCore的契机，我决定利用这一两天所学的Jav]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈ivar的直接访问]]></title>
    <link href="http://satanwoo.github.io/2018/02/04/iOS-iVar/"/>
    <id>http://satanwoo.github.io/2018/02/04/iOS-iVar/</id>
    <published>2018-02-04T15:14:33.000Z</published>
    <updated>2018-02-04T15:15:33.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>大水文一篇<br>大水文一篇<br>大水文一篇  </p>
</blockquote>
<h3 id="起因">起因</h3><p>最近对<code>Block</code>的一些实现细节又进行了一次复习，主要涉及的是捕捉变量的部分。有一个点我之前一直没太关注：对<code>ivar</code>变量的直接访问为啥会产生循环引用。</p>
<p>在我原先的理解中，之所以会产生循环引用，绝大多数场景都是由于<code>block</code>里面涉及了<strong>self</strong>关键字，比如<code>[self doSomething]</code>（同理，对于<code>property</code>的访问本质也是一堆方法），但是为啥对<code>ivar</code>的访问也会导致循环引用呢？</p>
<p>不是直接采用 <code>*(void *)address = xxx</code>这样的直接对编译好的静态地址赋值就好了？</p>
<blockquote>
<p>当时傻逼了，写完本文后想想就算编译成地址了，基地址从哪算还是要依赖<code>self</code>变量。</p>
</blockquote>
<h3 id="谈谈ivar的访问是啥形式">谈谈ivar的访问是啥形式</h3><p>还是回到runtime来看看吧，万变不离其宗，从<code>objc_class</code>结构体看起：</p>
<pre><code>struct objc<span class="number">_</span><span class="keyword">class</span> : objc<span class="number">_</span><span class="keyword">object</span> {
    <span class="comment">// Class ISA; // 8byte</span>
    Class superclass; <span class="comment">// 8byte</span>
    cache<span class="number">_</span>t cache;             <span class="comment">// formerly cache pointer and vtable // 4 + 4 + 8</span>
    <span class="keyword">class</span><span class="number">_</span>data<span class="number">_</span>bits<span class="number">_</span>t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span>

    <span class="keyword">class</span><span class="number">_</span>rw<span class="number">_</span>t *data() { 
        <span class="keyword">return</span> bits.data();
    }
</code></pre><p>主要的运行时数据都是<code>class_rw_t</code>表示，继续瞅瞅：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_rw_t</span> {
    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span>
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> version;

    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;
</code></pre><p>其中<code>class_ro_t</code>基本上是从二进制产物中读取的“副本”数据，我们看看：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;
</code></pre><p>看起来<code>ivar_list_t</code>就是存放<code>ivar</code>的列表，他的实现是一个模版类，看看具体结构表示：</p>
<pre><code><span class="title">struct</span> entsize_list_tt {
    <span class="title">uint32_t</span> entsizeAndFlags;
    <span class="title">uint32_t</span> count;
    <span class="title">Element</span> first;
</code></pre><p>具体对应<code>ivar</code>，替换掉模版就是：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">ivar_list_t</span> {
    <span class="keyword">uint32_t</span> entsizeAndFlags;
    <span class="keyword">uint32_t</span> count;
    <span class="keyword">ivar_t</span> first;
</code></pre><p>其中，<code>ivar_t</code>表征的就是我们每个<code>ivar</code>，</p>
<pre><code><span class="keyword">int32_t</span> *offset;
<span class="keyword">const</span> <span class="keyword">char</span> *name;
<span class="keyword">const</span> <span class="keyword">char</span> *type;
</code></pre><p>嗯，从这里开始<code>offset</code>是用一个<code>int32_t *</code>的指针来表示，就开始有意思了。<strong>这里我们先暂时忽略</strong></p>
<p>看起来，如果按照这种方式访问<code>ivar</code>，整个流程要经过好多次指针转移：</p>
<pre><code>class -&gt; class<span class="class">.rw_data</span> -&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span> -&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span><span class="class">.ivars</span> -&gt; 
-&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span><span class="class">.ivars</span><span class="class">.first</span>[n]
</code></pre><p>如果是这样，大量使用<code>ivar</code>肯定很耗时。那么，对于<code>ivar</code>的访问究竟是怎么玩的呢？</p>
<h3 id="全局变量">全局变量</h3><p>我们用如下这个非常简单的例子来瞅瞅：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^MyBlock)(<span class="keyword">void</span>);

<span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> haha;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlock block;

- (<span class="keyword">void</span>)inits;

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span>
- (<span class="keyword">void</span>)inits
{
    <span class="keyword">self</span><span class="variable">.block</span> = ^{
        _haha = <span class="number">5</span>;
    };
}
<span class="keyword">@end</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    MyObject *object = [MyObject new];
    [object inits];
}
</code></pre><p>重写一把，基本转化成如下的形式：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(*MyBlock)(<span class="keyword">void</span>);


<span class="preprocessor">#ifndef _REWRITER_typedef_MyObject</span>
<span class="preprocessor">#define _REWRITER_typedef_MyObject</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object MyObject;
<span class="keyword">typedef</span> <span class="keyword">struct</span> {} _objc_exc_MyObject;
<span class="preprocessor">#endif</span>

<span class="comment">// 注意点1!!!!!!!!!!!!!!!!!!!!</span>
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_haha;
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_block;
<span class="keyword">struct</span> MyObject_I<span class="built_in">MPL</span> {
    <span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;
    <span class="built_in">NSUInteger</span> _haha;
    MyBlock _block;
};

<span class="comment">// @property (nonatomic) NSUInteger haha;</span>
<span class="comment">// @property (nonatomic, copy) MyBlock block;</span>

<span class="comment">// - (void)inits;</span>

<span class="comment">/* @end */</span>


<span class="comment">// @implementation MyObject</span>

<span class="keyword">struct</span> __MyObject__inits_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __MyObject__inits_block_desc_0* Desc;
  MyObject *<span class="keyword">self</span>;

  <span class="comment">// 注意点2！！！！！！！！！！！！！！！</span>
  __MyObject__inits_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __MyObject__inits_block_desc_0 *desc, MyObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) {
    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;
    impl<span class="variable">.Flags</span> = flags;
    impl<span class="variable">.FuncPtr</span> = fp;
    Desc = desc;
  }
};

／／ 注意点<span class="number">3</span>！！！！！！！！！！！！
<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_func_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0 *__cself) {
  MyObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span>

        (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = <span class="number">5</span>;
    }
<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_copy_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*dst, <span class="keyword">struct</span> __MyObject__inits_block_impl_0*src) {_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}

<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_dispose_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}

<span class="keyword">static</span> <span class="keyword">struct</span> __MyObject__inits_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*, <span class="keyword">struct</span> __MyObject__inits_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*);
} __MyObject__inits_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __MyObject__inits_block_impl_0), __MyObject__inits_block_copy_0, __MyObject__inits_block_dispose_0};

<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_inits(MyObject * <span class="keyword">self</span>, SEL _cmd) {
    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, MyBlock))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"setBlock:"</span>), ((<span class="keyword">void</span> (*)())&amp;__MyObject__inits_block_impl_0((<span class="keyword">void</span> *)__MyObject__inits_block_func_0, &amp;__MyObject__inits_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>)));
}

<span class="keyword">static</span> <span class="built_in">NSUInteger</span> _I_MyObject_haha(MyObject * <span class="keyword">self</span>, SEL _cmd) { <span class="keyword">return</span> (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)); }
<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_setHaha_(MyObject * <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSUInteger</span> haha) { (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = haha; }

<span class="keyword">static</span> <span class="keyword">void</span>(* _I_MyObject_block(MyObject * <span class="keyword">self</span>, SEL _cmd) )(){ <span class="keyword">return</span> (*(MyBlock *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_block)); }
<span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> objc_setProperty (<span class="keyword">id</span>, SEL, <span class="keyword">long</span>, <span class="keyword">id</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>);

<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_setBlock_(MyObject * <span class="keyword">self</span>, SEL _cmd, MyBlock block) { objc_setProperty (<span class="keyword">self</span>, _cmd, __OFFSETOFIVAR__(<span class="keyword">struct</span> MyObject, _block), (<span class="keyword">id</span>)block, <span class="number">0</span>, <span class="number">1</span>); }
<span class="comment">// @end</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    MyObject *object = ((MyObject *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"MyObject"</span>), sel_registerName(<span class="string">"new"</span>));
    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)object, sel_registerName(<span class="string">"inits"</span>));
}
</code></pre><p>一大堆东西，没啥特别的地方，我们只要关注几个地方：</p>
<ul>
<li><p>对于每个<code>ivar</code>，都有对应的全局变量</p>
<pre><code><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_haha;
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_block;
</code></pre></li>
<li><p>block_invoke对应的实现是通过对象自身作为基地址，全局变量作为偏移去对<code>haha</code>这个<code>ivar</code>进行赋值。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_func_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0 *__cself) {
  MyObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span>

        (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = <span class="number">5</span>;
    }
</code></pre></li>
<li><p>block的构造函数，确实捕捉了<code>self</code></p>
<pre><code>__MyObject__inits_block_impl_0(void *fp, <span class="keyword">struct</span> __MyObject__inits_block_desc_0 *desc, MyObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) {
    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
    <span class="keyword">impl</span>.Flags = flags;
    <span class="keyword">impl</span>.FuncPtr = fp;
    Desc = desc;
  }
</code></pre></li>
</ul>
<p>由于全局变量的地址是在编译期就确定了，所以这里也就不难解释<code>ivar_t</code>里面为什么要保存<code>int32_t *</code>，保存的就是对应的全局变量地址。而全局变量的值则是对应的动态偏移。</p>
<h3 id="结语">结语</h3><p>水完了，其实虽然runtime的结构体设计的比较绕，但是最后对于变量的访问和很多静态语言设计一样，也不会损失很多性能。</p>
<p><b style="color:red">从另外一个角度看，如果声明了巨多的<code>ivar</code>，看来也会对包大小产生不可忽视的影响。</b></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>大水文一篇<br>大水文一篇<br>大水文一篇  </p>
</blockquote>
<h3 id="起因">起因</h3><p>最近对<code>Block</code>的一些实现细节又进行了一次复习，主要涉及的是捕捉变量的部分。有一个点我之前]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XNU之四：iOS虚拟内存限制（一）]]></title>
    <link href="http://satanwoo.github.io/2018/01/14/iOS-virtual/"/>
    <id>http://satanwoo.github.io/2018/01/14/iOS-virtual/</id>
    <published>2018-01-14T13:37:12.000Z</published>
    <updated>2018-01-14T13:51:47.000Z</updated>
    <content type="html"><![CDATA[<p>XNU之二和之三两篇由于涉及的量过大，就不发了，当然本文我也删除了一定的内容，哈哈哈。</p>
<p><b style="color:red">欢迎加入我们<strong>手淘／天猫的架构组</strong>来内网阅读</b></p>
<p>提起iOS的内存管理，大多数人第一反应想到的都是引用计数、<code>ARC</code>、<code>AutoreleasePool</code>之类的词眼。但是事实上，这只是iOS内存管理的冰山一角，今天就让我们来探究水面之下的内存管理。</p>
<h3 id="虚拟内存的限制">虚拟内存的限制</h3><p>我之所以想研究这个议题，主要还是之前有个UC同事问了我一个问题：</p>
<blockquote>
<p>“现在绝大多数都是ARM64的设备，即64位寻址空间，而且iOS上的通过malloc申请的内存只是虚拟内存，还不是真正物理内存，为什么分配了两三G就会失败了。”</p>
</blockquote>
<p>按照他的想法，我在我的iPhone上测试了如下代码：</p>
<pre><code><span class="keyword">void</span> *buffer = <span class="built_in">malloc</span>(<span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>);
</code></pre><p>果不其然，报出了如下错误：</p>
<pre><code>malloc: <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> mach_vm_map(size=2097152000) failed (error code=3)
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> error: can't allocate region
</code></pre><p>次奥，我xxxxx分配一个<strong>2G<b style="color:red">虚拟</b>内存</strong>就懵逼？</p>
<p>还是赶紧翻翻看源码，由于我分配的是一个超大的内存，所以按照<code>nano_zone</code>和<code>scalable_zone</code>的设计理念，</p>
<ul>
<li>小于256byte的走<code>nano_zone</code>进行分配。</li>
<li>剩下的我记不得了</li>
</ul>
<p>赶紧翻翻<code>scalable_zone</code>看看源码，如下所示：</p>
<pre><code>void *    szone_malloc_should_clear<span class="list">(<span class="keyword">szone_t</span> <span class="variable">*szone, size_t size, boolean_t cleared_requested)
{
    void *</span>ptr<span class="comment">;</span>
    msize_t msize<span class="comment">;</span>

    if <span class="list">(<span class="keyword">size</span> &lt;= SMALL_THRESHOLD)</span> {
        // tiny size: &lt;1024 bytes <span class="list">(<span class="number">64</span>-bit)</span>, &lt;512 bytes <span class="list">(<span class="number">32</span>-bit)</span>
        // think tiny
        msize = TINY_MSIZE_FOR_BYTES<span class="list">(<span class="keyword">size</span> + TINY_QUANTUM - <span class="number">1</span>)</span><span class="comment">;</span>
        if <span class="list">(!msize)</span> {
            msize = <span class="number">1</span><span class="comment">;</span>
        }
        ptr = tiny_malloc_should_clear<span class="list">(<span class="keyword">szone</span>, msize, cleared_requested)</span><span class="comment">;</span>
    } else if <span class="list">(<span class="keyword">size</span> &lt;= szone-&gt;large_threshold)</span> {
        // small size: &lt;15k <span class="list">(<span class="keyword">&lt;1GB</span> machines)</span>, &lt;127k <span class="list">(<span class="keyword">&gt;1GB</span> machines)</span>
        // think small
        msize = SMALL_MSIZE_FOR_BYTES<span class="list">(<span class="keyword">size</span> + SMALL_QUANTUM - <span class="number">1</span>)</span><span class="comment">;</span>
        if <span class="list">(!msize)</span> {
            msize = <span class="number">1</span><span class="comment">;</span>
        }
        ptr = small_malloc_should_clear<span class="list">(<span class="keyword">szone</span>, msize, cleared_requested)</span><span class="comment">;</span>
    } else {
        // large: all other allocations
        size_t num_kernel_pages = round_page_quanta<span class="list">(<span class="keyword">size</span>)</span> &gt;&gt; vm_page_quanta_shift<span class="comment">;</span>
        if <span class="list">(<span class="keyword">num_kernel_pages</span> == <span class="number">0</span>)</span> { /* Overflowed <span class="variable">*/
            ptr = 0;
        } else {
            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);
        }
    }
#if DEBUG_MALLOC
    if (LOG(szone, ptr)) {
        malloc_printf("szone_malloc returned %p\n", ptr);
    }
#endif
    /*</span>
     <span class="variable">* If requested, scribble on allocated memory.
     *</span>/
    if <span class="list">(<span class="list">(<span class="keyword">szone-&gt;debug_flags</span> &amp; MALLOC_DO_SCRIBBLE)</span> <span class="keyword">&amp;&amp;</span> ptr <span class="keyword">&amp;&amp;</span> !cleared_requested <span class="keyword">&amp;&amp;</span> size)</span> {
        memset<span class="list">(<span class="keyword">ptr</span>, SCRIBBLE_BYTE, szone_size<span class="list">(<span class="keyword">szone</span>, ptr)</span>)</span><span class="comment">;</span>
    }

    return ptr<span class="comment">;</span>
}</span>
</code></pre><ul>
<li>小于1k的走<code>tiny_malloc</code></li>
<li>小于15k或者127k的走<code>small_malloc</code>（视具体不同的设备内存上限不同）</li>
<li>剩下的走<code>large_malloc</code>。</li>
</ul>
<p>OK，由于我们分配的非常大，我们可以确定我们的逻辑是落入<code>large_malloc</code>中。需要特别注意的是：<code>large_malloc</code>分配内存的基本单位是一页大小，而对于其他的几种分配方式，则不是必须按照页大小进行分配。</p>
<p>由于<code>large_malloc</code>这个函数本身并没有特殊需要注意的地方，我们直接关注其真正分配内存的地方，即<code>allocate_pages</code>，如下所示：</p>
<pre><code>vm_addr = vm_page_quanta_size;
kr = mach_vm_map(mach_task_self(), &amp;vm_addr, allocation_size, allocation_mask, alloc_flags, MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE,
            VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);
<span class="keyword">if</span> (kr) {
    szone_error(szone, <span class="number">0</span>, <span class="string">"can't allocate region"</span>, <span class="literal">NULL</span>, <span class="string">"*** mach_vm_map(size=%lu) failed (error code=%d)\n"</span>, size, kr);
    <span class="keyword">return</span> <span class="literal">NULL</span>;
}
addr = (<span class="keyword">uintptr_t</span>)vm_addr;
</code></pre><p>从上我们不难看出，如果分配失败，就是提示报错。而<code>mach_vm_map</code>则是整个内存的分配核心。</p>
<p>可能你一开始看到这个<code>mach_vm_map</code>会比较懵逼，可以先看下我下面这张图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/virtual.png?raw=true" alt="屏幕快照 2018-01-03 上午10.55.41.png"> </p>
<p>OK，是不是有冒出很多名词。没关系，你其实只要记住两点：<code>vm_map</code>代表就是一个进程运行时候涉及的虚拟内存，<code>pmap</code>代表的就是和具体硬件架构相关的物理内存。（这里我们暂时先不考虑<strong>submap</strong>这种情况）。</p>
<p>好，<code>vm_map</code>本身是进程（或者从Mach内核的角度看是task的地址分布图）。这个地址分布图维护着一个<strong><b style="color:red">双向列表</b></strong>，列表的每一项都是<code>vm_entry_t</code>，代表着虚拟地址上连续的一个范围。而<code>pmap</code>这个结构体代表了个硬件相关的内存转换：即利用<code>pmap</code>这个结构体来描述抽象的物理地址访问和使用。</p>
<h3 id="进程（任务）的创建">进程（任务）的创建</h3><p>在继续深入我们的话题之前，我们还需要具备一个额外的知识，就是iOS上的进程创建和加载执行Mach-O过程。</p>
<p>类UNIX系统本质上是没法无缘无故创建出一个全新的进程的，基本上必须要通过<code>fork</code>的形式来创建。(这块不太熟悉，有错请指正)。</p>
<p>在XNU的实现里，不论用户态调用<code>posix</code>相关API还是别的API，落入到内核里面都走的是<code>fork_create_child</code>函数来创建属于Mach内核的任务（task）。其实现如下：</p>
<pre><code>thread_t
fork_create_child(task_t parent_task, coalition_t *parent_coalitions, proc_t child_proc, <span class="type">int</span> inherit_memory, <span class="type">int</span> is64bit, <span class="type">int</span> in_exec)
{
    thread_t    child_thread = <span class="type">NULL</span>;
    task_t        child_task;
    kern_return_t    <span class="literal">result</span>;

    /* <span class="type">Create</span> a new task <span class="keyword">for</span> the child process */
    <span class="literal">result</span> = task_create_internal(parent_task,
                    parent_coalitions,
                    inherit_memory,
                    is64bit,
                    <span class="type">TF_LRETURNWAIT</span> | <span class="type">TF_LRETURNWAITER</span>,         /* <span class="type">All</span> created threads will wait <span class="keyword">in</span> task_wait_to_return */
                    in_exec ? <span class="type">TPF_EXEC_COPY</span> : <span class="type">TPF_NONE</span>,   /* <span class="type">Mark</span> the task exec copy <span class="keyword">if</span> <span class="keyword">in</span> execve */
                    &amp;child_task);

    <span class="keyword">if</span> (<span class="literal">result</span> != <span class="type">KERN_SUCCESS</span>) {
        printf(<span class="string">"%s: task_create_internal failed.  Code: %d\n"</span>,
            __func__, <span class="literal">result</span>);
        goto bad;
    }

    <span class="keyword">if</span> (!in_exec) {
        /*
         * <span class="type">Set</span> the child process task to the new task <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">in</span> exec,
         * will <span class="type">set</span> the task <span class="keyword">for</span> exec <span class="keyword">case</span> <span class="keyword">in</span> proc_exec_switch_task after image activation.
         */

         // 注意点：
        child_proc-&gt;task = child_task;
    }
</code></pre><ul>
<li>这个函数本身实现并没什么出彩的，我们唯一要注意的就是<strong>Mach内核里面没有进程的概念，只有任务</strong>，进程是属于BSD之上的抽象。它们之间的联系就是通过指针建立，<code>child_proc-&gt;task = child_task。</code></li>
</ul>
<p><code>fork</code>出来的进程更像是一个空壳，我们需要利用这个进程壳去执行可执行文件变成我们通常意义上理解的<code>程序进程</code>。</p>
<p>从XNU上来看，可执行的文件种类如下：</p>
<pre><code>{ <span class="built_in">exec</span>_mach_imgact,        <span class="string">"Mach-o Binary"</span> },
{ <span class="built_in">exec</span>_fat_imgact,        <span class="string">"Fat Binary"</span> },
{ <span class="built_in">exec</span>_shell_imgact,    <span class="string">"Interpreter Script"</span> }
</code></pre><p>这里咱们先只看最常用的<code>Mach-O</code>文件：</p>
<pre><code>exec_mach_imgact(struct image_params *imgp)
{
    ... 省略无数

    <span class="keyword">if</span> ((mach_header-&gt;magic == MH_CIGAM) ||
        (mach_header-&gt;magic == MH_CIGAM_64)) {
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;
        (mach_header-&gt;magic != MH_MAGIC_64)) {
        error = -<span class="number">1</span>;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> (mach_header-&gt;filetype != MH_EXECUTE) {
        error = -<span class="number">1</span>;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> (imgp-&gt;ip_origcputype != <span class="number">0</span>) {
        <span class="comment">/* Fat header previously had an idea about this thin file */</span>
        <span class="keyword">if</span> (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||
            imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) {
            error = EBADARCH;
            <span class="keyword">goto</span> bad;
        }
    } <span class="keyword">else</span> {
        imgp-&gt;ip_origcputype = mach_header-&gt;cputype;
        imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;
    }

    task = current_task();
    thread = current_thread();
    uthread = get_bsdthread_info(thread);

    <span class="keyword">if</span> ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
        imgp-&gt;ip_flags |= IMGPF_IS_64BIT;

    <span class="comment">/* If posix_spawn binprefs exist, respect those prefs. */</span>
    psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;
    <span class="keyword">if</span> (psa != <span class="keyword">NULL</span> &amp;&amp; psa-&gt;psa_binprefs[<span class="number">0</span>] != <span class="number">0</span>) {
        <span class="keyword">int</span> pr = <span class="number">0</span>;
        <span class="keyword">for</span> (pr = <span class="number">0</span>; pr &lt; NBINPREFS; pr++) {
            cpu_type_t pref = psa-&gt;psa_binprefs[pr];
            <span class="keyword">if</span> (pref == <span class="number">0</span>) {
                <span class="comment">/* No suitable arch in the pref list */</span>
                error = EBADARCH;
                <span class="keyword">goto</span> bad;
            }

            <span class="keyword">if</span> (pref == CPU_TYPE_ANY) {
                <span class="comment">/* Jump to regular grading */</span>
                <span class="keyword">goto</span> grade;
            }

            <span class="keyword">if</span> (pref == imgp-&gt;ip_origcputype) {
                <span class="comment">/* We have a match! */</span>
                <span class="keyword">goto</span> grade;
            }
        }
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }
grade:
    <span class="keyword">if</span> (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) {
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }

    <span class="comment">/* Copy in arguments/environment from the old process */</span>
    error = exec_extract_strings(imgp);
    <span class="keyword">if</span> (error)
        <span class="keyword">goto</span> bad;

    AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, 
        imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);
    AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,
        imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);

    <span class="comment">/* reset local idea of thread, uthread, task */</span>
    thread = imgp-&gt;ip_new_thread;
    uthread = get_bsdthread_info(thread);
    task = new_task = get_threadtask(thread);

    <span class="comment">// 注意点：</span>
    lret = load_machfile(imgp, mach_header, thread, &amp;map, &amp;load_result);

    ... 省略无数
</code></pre><p>整个代码都没啥用，就是做些检查，分配个进程壳，然后通过<code>load_machfile</code>加载真正的二进制文件。</p>
<pre><code>load_return_t
load_machfile(
    struct image_params    *imgp,
    struct mach_header    *header,
    thread_t         thread,
    vm_map_t         *mapp,
    load_result_t        *<span class="literal">result</span>
)
{
    ... 省略一大堆

    <span class="keyword">if</span> (macho_size &gt; file_size) {
        <span class="keyword">return</span>(<span class="type">LOAD_BADMACHO</span>);
    }

    <span class="literal">result</span>-&gt;is64bit = ((imgp-&gt;ip_flags &amp; <span class="type">IMGPF_IS_64BIT</span>) == <span class="type">IMGPF_IS_64BIT</span>);

    task_t ledger_task;
    <span class="keyword">if</span> (imgp-&gt;ip_new_thread) {
        ledger_task = get_threadtask(imgp-&gt;ip_new_thread);
    } <span class="keyword">else</span> {
        ledger_task = task;
    }

    // 注意点<span class="number">1</span>
    pmap = pmap_create(get_task_ledger(ledger_task),
               (vm_map_size_t) <span class="number">0</span>,
               <span class="literal">result</span>-&gt;is64bit);

    // 注意点<span class="number">2</span>
    map = vm_map_create(pmap,
            <span class="number">0</span>,
            vm_compute_max_offset(<span class="literal">result</span>-&gt;is64bit),
            <span class="type">TRUE</span>);

<span class="comment">#if defined(__arm64__)</span>
    // 注意点三
    <span class="keyword">if</span> (<span class="literal">result</span>-&gt;is64bit) {
        /* enforce <span class="number">16</span>KB alignment <span class="keyword">of</span> <span class="type">VM</span> map entries */
        vm_map_set_page_shift(map, <span class="type">SIXTEENK_PAGE_SHIFT</span>);
    } <span class="keyword">else</span> {
        vm_map_set_page_shift(map, page_shift_user32);
    }
</code></pre><ul>
<li>利用<code>pmap_create</code>创建硬件相关的物理内存抽象。</li>
<li>利用<code>vmap_create</code>创建虚拟内存的地址图。</li>
<li>ARM64下的页是16k一个虚拟页对应一个物理页。</li>
</ul>
<p>别的没啥关注，我们重点关注<code>vm_map_create</code><b style="color:red"><code>0</code>和<code>vm_compute_max_offset(result-&gt;is64bit)</code></b>。</p>
<p><b style="color:red">因为这个代表了这个任务分配的虚拟地址上下限！</b>这个函数的实现如下：</p>
<pre><code><span class="tag">vm_map_offset_t</span>
<span class="tag">vm_compute_max_offset</span>(boolean_t is64)
{
<span class="id">#if</span> <span class="tag">defined</span>(__arm__) || <span class="tag">defined</span>(__arm64__)
    <span class="tag">return</span> (<span class="function">pmap_max_offset</span>(is64, ARM_PMAP_MAX_OFFSET_DEVICE));
<span class="id">#else</span>
    <span class="tag">return</span> (is64 ? (vm_map_offset_t)<span class="attribute">MACH_VM_MAX_ADDRESS </span>: (vm_map_offset_t)VM_MAX_ADDRESS);
<span class="id">#endif</span>
}
</code></pre><p>继续往下看：</p>
<pre><code><span class="keyword">vm_map_offset_t</span> pmap_max_offset(
    <span class="keyword">boolean_t</span>    is64 __unused,
    <span class="keyword">unsigned</span> <span class="keyword">int</span>    option)
{
    <span class="keyword">vm_map_offset_t</span>    max_offset_ret = <span class="number">0</span>;

<span class="preprocessor">#<span class="keyword">if</span> defined(__arm64__)</span>
    assert (is64);
    <span class="keyword">vm_map_offset_t</span> min_max_offset = SHARED_REGION_BASE_ARM64 + SHARED_REGION_SIZE_ARM64 + <span class="number">0x20000000</span>; <span class="comment">// end of shared region + 512MB for various purposes</span>
    <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEFAULT) {
        max_offset_ret = arm64_pmap_max_offset_default;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MIN) {
        max_offset_ret = min_max_offset;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MAX) {
        max_offset_ret = MACH_VM_MAX_ADDRESS;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEVICE) {
        <span class="keyword">if</span> (arm64_pmap_max_offset_default) {
            max_offset_ret = arm64_pmap_max_offset_default;
        } <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) {
            max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="comment">// Max offset is 12.375GB for devices with &gt; 3GB of memory</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) {
            max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="comment">// Max offset is 8.375GB for devices with &gt; 1GB and &lt;= 3GB of memory</span>
        } <span class="keyword">else</span> {
            max_offset_ret = min_max_offset;
        }
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_JUMBO) {
        max_offset_ret = <span class="number">0x0000000518000000</span>ULL;     <span class="comment">// Max offset is 20.375GB for pmaps with special "jumbo" blessing</span>
    } <span class="keyword">else</span> {
        panic(<span class="string">"pmap_max_offset illegal option 0x%x\n"</span>, option);
    }

    assert(max_offset_ret &gt;= min_max_offset);
    <span class="keyword">return</span> max_offset_ret;
</code></pre><p>其实关键点就是这里的代码：</p>
<pre><code><span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) {
    max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="regexp">//</span> <span class="constant">Max</span> offset is <span class="number">12.375</span>GB <span class="keyword">for</span> devices <span class="keyword">with</span> &gt; <span class="number">3</span>GB <span class="keyword">of</span> memory
} <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) {
    max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="regexp">//</span> <span class="constant">Max</span> offset is <span class="number">8.375</span>GB <span class="keyword">for</span> devices <span class="keyword">with</span> &gt; <span class="number">1</span>GB and &lt;= <span class="number">3</span>GB <span class="keyword">of</span> memory
} <span class="keyword">else</span> {
    max_offset_ret = min_max_offset;
}
</code></pre><p><code>max_offset_ret</code>这个值就代表了我们任务对应的<code>vm_map_t</code>的最大地址范围，比如说这里是8.375GB。</p>
<h3 id="虚拟内存分配的限制">虚拟内存分配的限制</h3><p>好，在说了那么多前置知识后，我们言归正传，来谈谈为什么虚拟内存有限制。</p>
<p>之前我们提到了<code>large_malloc</code>会走入到最后的<code>vm_map_enter</code>，那么我们来看看<code>vm_map_enter</code>的实现：</p>
<pre><code>vm_map_enter(
    <span class="keyword">vm_map_t</span>        <span class="built_in">map</span>,
    <span class="keyword">vm_map_offset_t</span>        *address,    <span class="comment">/* IN/OUT */</span>
    <span class="keyword">vm_map_size_t</span>        size,
    <span class="keyword">vm_map_offset_t</span>        mask,
    <span class="keyword">int</span>            flags,
    <span class="keyword">vm_map_kernel_flags_t</span>    vmk_flags,
    <span class="keyword">vm_tag_t</span>        alias,
    <span class="keyword">vm_object_t</span>        object,
    <span class="keyword">vm_object_offset_t</span>    offset,
    <span class="keyword">boolean_t</span>        needs_copy,
    <span class="keyword">vm_prot_t</span>        cur_protection,
    <span class="keyword">vm_prot_t</span>        max_protection,
    <span class="keyword">vm_inherit_t</span>        inheritance)
{

<span class="preprocessor">#<span class="keyword">if</span> CONFIG_EMBEDDED</span>
    <span class="comment">// 注意点1:检查页的权限</span>
    <span class="keyword">if</span> (cur_protection &amp; VM_PROT_WRITE){
        <span class="keyword">if</span> ((cur_protection &amp; VM_PROT_EXECUTE) &amp;&amp; !entry_for_jit){
            <span class="built_in">printf</span>(<span class="string">"EMBEDDED: %s: curprot cannot be write+execute. "</span>
                   <span class="string">"turning off execute\n"</span>,
                   __FUNCTION__);
            cur_protection &amp;= ~VM_PROT_EXECUTE;
        }
    }
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>

    <span class="keyword">if</span> (resilient_codesign || resilient_media) {
        <span class="keyword">if</span> ((cur_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE)) ||
            (max_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE))) {
            <span class="keyword">return</span> KERN_PROTECTION_FAILURE;
        }
    }

    <span class="comment">// 1. 获取任务的可用的地址最小值和最大值</span>
    effective_min_offset = <span class="built_in">map</span>-&gt;min_offset;
    effective_max_offset = <span class="built_in">map</span>-&gt;max_offset;

    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;pmap == kernel_pmap) {
        user_alias = VM_KERN_MEMORY_NONE;
    } <span class="keyword">else</span> {
        user_alias = alias;
    }

<span class="preprocessor">#<span class="keyword">define</span>    RETURN(value)    { result = value; goto BailOut; }</span>

    assert(page_aligned(*address));
    assert(page_aligned(size));

    <span class="keyword">if</span> (!VM_MAP_PAGE_ALIGNED(size, VM_MAP_PAGE_MASK(<span class="built_in">map</span>))) {
        clear_map_aligned = TRUE;
    }

StartAgain: ;

    start = *address;

    <span class="keyword">if</span> (anywhere) {
        vm_map_lock(<span class="built_in">map</span>);
        map_locked = TRUE;

        <span class="keyword">if</span> (start &lt; effective_min_offset)
            start = effective_min_offset;
        <span class="keyword">if</span> (start &gt; effective_max_offset)
            RETURN(KERN_NO_SPACE);


        <span class="keyword">if</span>( FALSE ) {

        } <span class="keyword">else</span> {

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                hole_entry = (<span class="keyword">vm_map_entry_t</span>)<span class="built_in">map</span>-&gt;holes_list;

                <span class="keyword">if</span> (hole_entry == <span class="literal">NULL</span>) {
                    <span class="comment">/*
                     * No more space in the map?
                     */</span>
                    result = KERN_NO_SPACE;
                    <span class="keyword">goto</span> BailOut;
                } <span class="keyword">else</span> {

                    <span class="keyword">boolean_t</span> found_hole = FALSE;

                    <span class="keyword">do</span> {
                        <span class="keyword">if</span> (hole_entry-&gt;vme_start &gt;= start) {
                            start = hole_entry-&gt;vme_start;
                            found_hole = TRUE;
                            <span class="keyword">break</span>;
                        }

                        <span class="keyword">if</span> (hole_entry-&gt;vme_end &gt; start) {
                            found_hole = TRUE;
                            <span class="keyword">break</span>;
                        }
                        hole_entry = hole_entry-&gt;vme_next;

                    } <span class="keyword">while</span> (hole_entry != (<span class="keyword">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list);

                    <span class="keyword">if</span> (found_hole == FALSE) {
                        result = KERN_NO_SPACE;
                        <span class="keyword">goto</span> BailOut;
                    }

                    entry = hole_entry;

                    <span class="keyword">if</span> (start == <span class="number">0</span>)
                        start += PAGE_SIZE_64;
                }
            }
        }

        <span class="keyword">while</span> (TRUE) {
            <span class="keyword">vm_map_entry_t</span>    next;

            end = ((start + mask) &amp; ~mask);
            end = vm_map_round_page(end,
                        VM_MAP_PAGE_MASK(<span class="built_in">map</span>));

            <span class="keyword">if</span> (end &lt; start)
                RETURN(KERN_NO_SPACE);

            start = end;
            end += size;

            <span class="keyword">if</span> ((end &gt; effective_max_offset) || (end &lt; start)) {
                RETURN(KERN_NO_SPACE);
            }

            next = entry-&gt;vme_next;

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                <span class="keyword">if</span> (entry-&gt;vme_end &gt;= end)
                    <span class="keyword">break</span>;
            } <span class="keyword">else</span> {

                <span class="keyword">if</span> (next == vm_map_to_entry(<span class="built_in">map</span>))
                    <span class="keyword">break</span>;

                <span class="keyword">if</span> (next-&gt;vme_start &gt;= end)
                    <span class="keyword">break</span>;
            }

            entry = next;

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                <span class="keyword">if</span> (entry == (<span class="keyword">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list) {
                    result = KERN_NO_SPACE;
                    <span class="keyword">goto</span> BailOut;
                }
                start = entry-&gt;vme_start;
            } <span class="keyword">else</span> {
                start = entry-&gt;vme_end;
            }

            start = vm_map_round_page(start,
                          VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
        }

        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
            <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, entry-&gt;vme_start, &amp;entry)) {
                panic(<span class="string">"Found an existing entry (%p) instead of potential hole at address: 0x%llx.\n"</span>, entry, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)entry-&gt;vme_start);
            }
        }

        *address = start;
    } 
</code></pre><ul>
<li>注意点1：基本上就是检查页的权限啥的，iOS上不允许可写和可执行并存。</li>
<li>剩下的就是作各种前置检查</li>
</ul>
<p>老实说，我一开始看苹果这最新的XNU代码，我压根没读懂。这一堆<code>hole</code>啥的在干啥，后来我就往之前XNU版本翻了翻，果然好懂了很多：</p>
<pre><code>entry = <span class="built_in">map</span><span class="subst">-&gt;</span>first_free;

<span class="keyword">if</span> (entry == vm_map_to_entry(<span class="built_in">map</span>)) {
    entry = <span class="built_in">NULL</span>;
} <span class="keyword">else</span> {
       <span class="keyword">if</span> (entry<span class="subst">-&gt;</span>vme_next == vm_map_to_entry(<span class="built_in">map</span>)){
            entry = <span class="built_in">NULL</span>;
       } <span class="keyword">else</span> {
            <span class="keyword">if</span> (start &lt; (entry<span class="subst">-&gt;</span>vme_next)<span class="subst">-&gt;</span>vme_start ) {
                start = entry<span class="subst">-&gt;</span>vme_end;
                start = vm_map_round_page(start,
                              VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
            } <span class="keyword">else</span> {
                entry = <span class="built_in">NULL</span>;
            }
       }
}

<span class="keyword">if</span> (entry == <span class="built_in">NULL</span>) {
    vm_map_entry_t    tmp_entry;
    <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, start, <span class="subst">&amp;</span>tmp_entry)) {
        assert(<span class="subst">!</span>entry_for_jit);
        start = tmp_entry<span class="subst">-&gt;</span>vme_end;
        start = vm_map_round_page(start,
                      VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
    }
    entry = tmp_entry;
}
</code></pre><ul>
<li><p>整个这段代码的意思是，就是要我们要找个一个比我们这个<code>start</code>地址大的<code>vm_entry_t</code>。(这句话比较绕口)，<b style="color:red">我们最终的目的是为了在两个已经存在<code>vm_entry_t</code>之间尝试插入一个能包含从<code>start</code>到<code>start + size</code>的新的<code>vm_entry_t</code></b></p>
</li>
<li><p>如果没找到的话，就尝试利用<code>vm_map_lookup_entry</code>找一个<code>preceding</code>我们地址的的<code>vm_entry_t</code>。</p>
</li>
</ul>
<p>好，现在我们找到了一个满足<code>start</code>其实地址条件的<code>vm_entry_t</code>了，剩下就是要满足分配大小<code>size</code>的需求了。</p>
<pre><code><span class="label">while</span> (TRUE) {
    register vm_map_entry_t    next<span class="comment">;</span>

    <span class="preprocessor">end</span> = ((start + mask) &amp; ~mask)<span class="comment">;</span>
    <span class="preprocessor">end</span> = vm_map_round_page(<span class="preprocessor">end</span>,
                VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>))<span class="comment">;</span>
    <span class="preprocessor">if</span> (<span class="preprocessor">end</span> &lt; start)
        RETURN(KERN_NO_SPACE)<span class="comment">;</span>

    start = <span class="preprocessor">end</span><span class="comment">;</span>
    <span class="preprocessor">end</span> += size<span class="comment">;</span>

    <span class="preprocessor">if</span> ((<span class="preprocessor">end</span> &gt; effective_max_offset) <span class="title">||</span> (<span class="preprocessor">end</span> &lt; start)) {
        RETURN(KERN_NO_SPACE)<span class="comment">;</span>
    }

    next = <span class="preprocessor">entry</span>-&gt;vme_next<span class="comment">;</span>

    // 如果是空的头
    <span class="preprocessor">if</span> (next == vm_map_to_entry(<span class="preprocessor">map</span>))
        <span class="keyword">break;
</span>
    // 如果下一个的start 
    <span class="preprocessor">if</span> (next-&gt;vme_start &gt;= <span class="preprocessor">end</span>)
        <span class="keyword">break;
</span>
    <span class="preprocessor">entry</span> = next<span class="comment">;</span>
    start = <span class="preprocessor">entry</span>-&gt;vme_end<span class="comment">;</span>
    start = vm_map_round_page(start,
                  VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>))<span class="comment">;</span>
}
*<span class="keyword">address </span>= start<span class="comment">;</span>
<span class="label">assert</span>(VM_MAP_PAGE_ALIGNED(*<span class="keyword">address,
</span>               VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>)))<span class="comment">;</span>
</code></pre><p>这段代码相对来说就很简单了，我们判断<code>start + size</code>是不是可以正好插入在<code>vm_entry_t</code>代表的地址范围的空隙内，如果一直遍历到最后的任务地址上限都找不到，那就说明不存在我们需求的连续的虚拟内存空间用于作分配了。</p>
<h3 id="其他">其他</h3><p>除了本文说明的虚拟内存分配的连续性限制以外，虚拟内存作为堆内存分配的一种，在布局范围上也有限制。此文不表，且听下回分解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>XNU之二和之三两篇由于涉及的量过大，就不发了，当然本文我也删除了一定的内容，哈哈哈。</p>
<p><b style="color:red">欢迎加入我们<strong>手淘／天猫的架构组</strong>来内网阅读</b></p>
<p>提起iOS的内存管理，大多数人第]]>
    </summary>
    
      <category term="XNU" scheme="http://satanwoo.github.io/tags/XNU/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一种基于KVO的页面加载，渲染耗时监控方法]]></title>
    <link href="http://satanwoo.github.io/2017/11/27/KVO-Swizzle/"/>
    <id>http://satanwoo.github.io/2017/11/27/KVO-Swizzle/</id>
    <published>2017-11-26T16:08:28.000Z</published>
    <updated>2017-11-26T16:11:36.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>打广告：有兴趣加入阿里巴巴手淘基础架构平台移动高可用团队的请微博联系我@盗版五子棋</p>
<p>和同事zb一起维护了一个ARM64的专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target="_blank" rel="external">iOS调试进阶</a>，有兴趣的可以读读</p>
</blockquote>
<p>在介绍本文之前，请先允许我提出一个问题，如果你要无痕监控任意一个页面（UIViewController及其子类）的加载或者渲染时间，你会怎么做。</p>
<p>很多人都会想到说用AOP啊，利用<code>Method Swizzling</code>来进行方法替换从而获得方法调用耗时。<br>比如我们有一个<code>ViewController</code>，如果其实现了一个<code>viewDidLoad</code>方法进行睡眠<strong>5</strong>秒，如下所示：</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>

- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
    sleep(<span class="number">5</span>);
}

<span class="keyword">@end</span>
</code></pre><p>相信很多人的第一直觉会是如下AOP代码（我们省略Method Swizzling相关的代码）：</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">TestCase</span>)</span>

+ (<span class="keyword">void</span>)load
{
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
        wzq_swizzleMethod([<span class="built_in">UIViewController</span> class], <span class="keyword">@selector</span>(viewDidLoad), <span class="keyword">@selector</span>(wzq_viewDidLoad));
    });
}

- (<span class="keyword">void</span>)wzq_viewDidLoad
{
    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];
    [<span class="keyword">self</span> wzq_viewDidLoad];

    <span class="built_in">NSTimeInterval</span> duration = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:date];
    <span class="built_in">NSLog</span>(<span class="string">@"Page %@ cost %g in viewDidLoad"</span>, [<span class="keyword">self</span> class], duration); 
}

<span class="keyword">@end</span>
</code></pre><p>但是，如果你自己尝试了你会发现，你测算的时间压根不是<span style="color:red"><strong>5</strong></span>秒。</p>
<p>为什么呢？其原因在于我们<code>Method Swizzling</code>的时候，因为采用了对基类<code>UIViewController</code>进行替换，获取到的<code>viewDidLoad</code>对应的IMP是属于基类<code>UIViewController</code>的，而并不是<code>ViewController</code>自身覆写的，所以我们监控的其实从子类<code>ViewController</code>调用<code>[super viewDidLoad]</code>的时候调用基类IMP的耗时。</p>
<p>好，看到这，有人就想了对应的方法，把<code>-[ViewController viewDidLoad]</code>的IMP替换掉就行了。方法很多种，比如创建一个<code>ViewController</code>的<strong>Category</strong>进行替换。<strong>但是这种方法你好像没办法任意对某个页面进行替换。</strong></p>
<blockquote>
<p>有人说你可以runtime遍历所有类判断是不是<code>UIViewController</code>的子类，然后动态替换。理论是可行的，效率嘛，是比较低的。</p>
</blockquote>
<h3 id="方案">方案</h3><p>根据上述我们所知的缺陷，我们需要有一个兼顾动态性和性能的方案，能够直接获取到子类的IMP，这样才能达到我们对于页面加载渲染时间（<code>viewDidLoad</code>, <code>viewDidAppear</code>和<code>viewWillAppear</code>）监控的需求。</p>
<p>基于这个需求，我很快想到了<strong>基于KVO</strong>的方案（如果你对KVO不了解，可以参考<a href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/">我的文章：KVO在不同的二进制中多个符号并存的Crash问题</a>）。我们知道，在对于任意对象进行KVO监控的时候，iOS底层实际上帮你动态创建了一个隐蔽的类，同时帮了做了大量的<code>setter，getter</code>函数的override，并调用原来类对应函数实现，从而让你神不知鬼不觉的以为你还在用原来的类进行操作。</p>
<p>那我们该怎么做呢？</p>
<ol>
<li>对我们需要监听的类的实例进行KVO，随便监听一个不存在的KeyPath。我们压根不需要KVO的任何回调，我们只是需要它能帮我们<strong>创建子类</strong>而已。</li>
<li>对KVO创建出来的子类添加我们需要Swizzle的方法对应的SEL及其IMP。因为本质上KVO只是对setter和getter方法进行了<strong>override</strong>，<b style="color:red">如果我们不提供我们自己的实现，还是会调用到原来的类的IMP。</b></li>
<li>在实例销毁的时候，将KVO监听移除，不然会导致<b style="color:red">KVO still registering when deallocated这样的Crash。</b></li>
</ol>
<p>总体来说，我们需要做的就是三件事。</p>
<h4 id="1-_对实例进行KVO">1. 对实例进行KVO</h4><p>KVO方法只能在对象实例上进行操作，我们首先要获取到的就是<code>UIViewController</code>及其子类的实例。</p>
<p>遍历头文件，发现UIViewController的初始化方法比较少，归纳为如下三种：</p>
<pre><code>init
<span class="string">initWithCoder:</span>
<span class="string">initWithNibName:</span><span class="string">bundle:</span>
</code></pre><p>我们先Swizzle这几个方法：</p>
<pre><code> wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">initWithNibName</span><span class="keyword">:bundle</span>:)</span>, @selector<span class="list">(<span class="keyword">wzq_initWithNibName</span><span class="keyword">:bundle</span>:)</span>)</span><span class="comment">;</span>
wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">initWithCoder</span>:)</span>, @selector<span class="list">(<span class="keyword">wzq_initWithCoder</span>:)</span>)</span><span class="comment">;</span>
wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">init</span>)</span>, @selector<span class="list">(<span class="keyword">wzq_init</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>这几个方法调用的时候，实例对象对应的内存已经分配出来了，无非就是构造函数还没赋值，但是我们也能进行KVO了。KVO的代码如下所示：</p>
<pre><code>NSString *identifier = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"wzq_%@"</span>, [[NSProcessInfo processInfo] globallyUniqueString]];
[vc <span class="string">addObserver:</span>[NSObject <span class="keyword">new</span>] <span class="string">forKeyPath:</span>identifier <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
</code></pre><h4 id="2-_添加我们想要的方法">2. 添加我们想要的方法</h4><p>我们刚刚已经对页面实例进行了KVO操作，此时对于原先类别为<code>ViewController</code>的<code>vc</code>对象来说，内部其实已经变成<b style="color:red">NSKVONotifying_ViewController类型了。</b>。如果我们想对其所在的类型添加方法的话，不能直接用<code>[vc class]</code>，因为这个方法已经被内部override成了<code>ViewController</code>。我们需要使用<code>object_getClass</code>这个类进行真正的类型获取，如下所示：</p>
<pre><code> <span class="comment">// NSKVONotifying_ViewController</span>
Class kvoCls = <span class="keyword">object</span><span class="number">_</span>getClass(vc);
<span class="comment">// ViewController</span>
Class originCls = <span class="keyword">class</span><span class="number">_</span>getSuperclass(kvoCls);

<span class="comment">// 获取原来实现的encoding</span>
const char *originViewDidLoadEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewDidLoad)));
const char *originViewDidAppearEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewDidAppear:)));
const char *originViewWillAppearEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewWillAppear:)));

<span class="comment">// 重点，添加方法。</span>
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewDidLoad), (IMP)wzq<span class="number">_</span>viewDidLoad, originViewDidLoadEncoding);
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewDidAppear:), (IMP)wzq<span class="number">_</span>viewDidAppear, originViewDidAppearEncoding);
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewWillAppear:), (IMP)wzq<span class="number">_</span>viewWillAppear, originViewWillAppearEncoding);
</code></pre><p>上述代码非常通俗易懂，不再赘述，替换完的方法如下，我们以<code>wzq_viewDidLoad</code>举例：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> wzq_viewDidLoad(<span class="built_in">UIViewController</span> *kvo_self, SEL _sel)
{
    Class kvo_cls = object_getClass(kvo_self);
    Class origin_cls = class_getSuperclass(kvo_cls);

    <span class="comment">// 注意点</span>
    IMP origin_imp = method_getImplementation(class_getInstanceMethod(origin_cls, _sel));
    assert(origin_imp != <span class="literal">NULL</span>);

    <span class="keyword">void</span>(*func)(<span class="built_in">UIViewController</span> *, SEL) =  (<span class="keyword">void</span>(*)(<span class="built_in">UIViewController</span> *, SEL))origin_imp;

    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];

    func(kvo_self, _sel);

    <span class="built_in">NSTimeInterval</span> duration = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:date];
    <span class="built_in">NSLog</span>(<span class="string">@"Class %@ cost %g in viewDidLoad"</span>, [kvo_self class], duration);
}
</code></pre><p>重点关注下上述代码中的<b style="color:red">注意点</b>，之前我们在KVO生成的类中对应添加了原本没有的实现，因此<code>-[ViewController viewDidLoad]</code>会走到我们的<code>wzq_viewDidLoad</code>方法中，但是我们怎么才能调用到原来的<code>viewDidLoad</code>的呢？我们之前并没有保存对应的IMP呀。</p>
<p><b style="color:red">这里还是利用了KVO的特殊性：内部生成的NSKVONotifying_ViewController实际上是继承自ViewController的</b></p>
<p>因此，<code>Class origin_cls = class_getSuperclass(kvo_cls);</code>实际上获取到了<code>ViewController</code>类，我们从中取出对应的IMP，进行直接调用即可。</p>
<h4 id="3-_移除KVO">3. 移除KVO</h4><p>我们利用Associate Object去移除就好了。一个对象释放的时候会自动去清除其所在的<code>assoicate object</code>。</p>
<p>基于这个原理，我们可以实现如下代码：</p>
<p>我们构建一个桩，把所有无用的KVO监听都设置给这个桩，如下所示：</p>
<pre><code><span class="attr_selector">[vc addObserver:[WZQKVOObserverStub stub]</span> <span class="tag">forKeyPath</span><span class="pseudo">:identifier</span> <span class="tag">options</span><span class="pseudo">:NSKeyValueObservingOptionNew</span> <span class="tag">context</span><span class="pseudo">:nil</span>];
</code></pre><p>然后我们构建一个移除器，这个移除器弱引用保存了vc的实例和对应的keypath，如下：</p>
<pre><code>WZQKVORemover *remover = [WZQKVORemover new]<span class="comment">;</span>
remover.obj = vc<span class="comment">;</span>
remover.keyPath = identifier.copy<span class="comment">;</span>
</code></pre><p>然后我们把这个移除器利用<code>associate object</code>设置给对应的vc。</p>
<pre><code>objc_setAssociatedObject<span class="list">(<span class="keyword">vc</span>, <span class="keyword">&amp;wzq_associateRemoveKey</span>, remover, OBJC_ASSOCIATION_RETAIN)</span><span class="comment">;</span>
</code></pre><p>而在对应的移除器的<code>dealloc</code>方法里，我们把kvo监听给移除就可以了。</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span>
{
<span class="id">#ifdef</span> <span class="tag">DEBUG</span>
    <span class="tag">NSLog</span>(@<span class="string">"WZQKVORemover called"</span>);
<span class="id">#endif</span>
    <span class="tag">if</span> (_obj) {
        <span class="attr_selector">[_obj removeObserver:[WZQKVOObserverStub stub]</span> <span class="tag">forKeyPath</span><span class="pseudo">:_keyPath</span>];
    }
}
</code></pre><h3 id="额外">额外</h3><p>利用<code>associate object</code>移除KVO的正确性是有保障的，具体见runtime中<code>associate object</code>的源码：</p>
<pre><code><span class="type">void</span> objc_removeAssociatedObjects(id <span class="keyword">object</span>) 
{
    <span class="keyword">if</span> (<span class="keyword">object</span> &amp;&amp; <span class="keyword">object</span>-&gt;hasAssociatedObjects()) {
        _object_remove_assocations(<span class="keyword">object</span>);
    }
}

<span class="type">void</span> _object_remove_assocations(id <span class="keyword">object</span>) {
    vector&lt; <span class="type">ObjcAssociation</span>,<span class="type">ObjcAllocator</span>&lt;<span class="type">ObjcAssociation</span>&gt; &gt; elements;
    {
        <span class="type">AssociationsManager</span> manager;
        <span class="type">AssociationsHashMap</span> &amp;associations(manager.associations());
        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;
        disguised_ptr_t disguised_object = <span class="type">DISGUISE</span>(<span class="keyword">object</span>);
        <span class="type">AssociationsHashMap</span>::<span class="keyword">iterator</span> i = associations.find(disguised_object);
        <span class="keyword">if</span> (i != associations.<span class="keyword">end</span>()) {
            // copy all <span class="keyword">of</span> the associations that need to be removed.
            <span class="type">ObjectAssociationMap</span> *refs = i-&gt;second;
            <span class="keyword">for</span> (<span class="type">ObjectAssociationMap</span>::<span class="keyword">iterator</span> j = refs-&gt;begin(), <span class="keyword">end</span> = refs-&gt;<span class="keyword">end</span>(); j != <span class="keyword">end</span>; ++j) {
                elements.push_back(j-&gt;second);
            }
            // remove the secondary table.
            delete refs;
            associations.erase(i);
        }
    }
    // the calls to releaseValue() happen outside <span class="keyword">of</span> the lock.
    for_each(elements.begin(), elements.<span class="keyword">end</span>(), <span class="type">ReleaseValue</span>());
}
</code></pre><h3 id="代码">代码</h3><p>本文的工程代码托管在<a href="">Github</a>上，包含了测试用例（默认带干扰测试），还没来得及搞成cocoapods，等我有时间了搞一下。但是你直接拖拽源码使用是一点问题都没有。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>打广告：有兴趣加入阿里巴巴手淘基础架构平台移动高可用团队的请微博联系我@盗版五子棋</p>
<p>和同事zb一起维护了一个ARM64的专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[注意系统库的坑之load函数调用多次]]></title>
    <link href="http://satanwoo.github.io/2017/11/02/load-twice/"/>
    <id>http://satanwoo.github.io/2017/11/02/load-twice/</id>
    <published>2017-11-01T16:55:05.000Z</published>
    <updated>2017-11-05T16:39:44.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>水文一篇</p>
</blockquote>
<p>今天在群友逆向企业微信的时候，发现了一个比较有意思的现象了，发现对于<code>NSObject</code>添加的<code>load</code>的方法执行了两次，导致原本意图的<code>Swizzle</code>出现了问题。</p>
<p>之前在个人的理解中，<code>load</code>和<code>initialize</code>函数有所不同，<code>load</code>是在加载二进制程序的时候，将这些二进制程序中的类中包含的<code>load</code>方法进行一一调用，调用过程中不会有调用父类的情况。而<code>initialize</code>则不同，是在类第一次使用的过程中进行调用，同时也会有过程中调用父类的情况。</p>
<p><strong>所以，今天一开始这个情况有点懵逼啊，来看看究竟是为啥。</strong></p>
<h2 id="准备工作（略）">准备工作（略）</h2><ol>
<li>PP助手上下载一个企业微信</li>
<li>重签名 -&gt; Build</li>
<li><p>写一个诸如下面这么简单的<code>NSObject Category</code>，并实现<code>+(void)Load</code>方法</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">injectLocation</span>)</span>
+ (<span class="keyword">void</span>)load
{
    <span class="built_in">NSLog</span>(<span class="string">@"我好弱"</span>);
}
<span class="keyword">@end</span>
</code></pre></li>
</ol>
<h2 id="排查过程">排查过程</h2><p>按照我们对<code>load</code>函数的理解，程序加载开始的时候，会通过<code>libobjc</code>的<code>call_load_methods</code>遍历逐一执行所有的<code>load</code>方法，如下图印证：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/load_twice_2.png?raw=true" alt=""></p>
<p>一开始当我在使用iOS 10.3.3的设备进行测试的时候，这就是唯一一次调用，没有二次重入的状况。</p>
<p>于是我按照群友的提示换了iOS 11的设备，果不其然，iOS 11的企业微信在登录过程中，会再次调用我这个分类的<code>load</code>方法，让我们一起来看看调用栈：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/load_twice_1.png?raw=true" alt=""></p>
<p>卧槽，又从<code>WebThread</code>这个类里面进行了调用了<code>load</code>，匪夷所思啊。</p>
<p>lldb调试下，结果如下：</p>
<pre><code>frame <span class="preprocessor">#<span class="number">0</span>: <span class="number">0x0000000107a2558c</span> libZXLQYWechatDylib.dylib`+[NSObject(self=SKUIMetricsAppLaunchEvent, _cmd=<span class="string">"load"</span>) load] at TestCategory.m:<span class="number">15</span></span>
frame <span class="preprocessor">#<span class="number">1</span>: <span class="number">0x0000000196767f9c</span> StoreKitUI`+[SKUIMetricsAppLaunchEvent load] + <span class="number">44</span></span>
frame <span class="preprocessor">#<span class="number">2</span>: <span class="number">0x00000001807fa91c</span> libobjc.A.dylib`call_load_methods + <span class="number">184</span></span>
frame <span class="preprocessor">#<span class="number">3</span>: <span class="number">0x00000001807fba84</span> libobjc.A.dylib`load_images + <span class="number">76</span></span>
frame <span class="preprocessor">#<span class="number">4</span>: <span class="number">0x00000001074e6170</span> dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + <span class="number">488</span></span>
frame <span class="preprocessor">#<span class="number">5</span>: <span class="number">0x00000001074f6ce8</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">348</span></span>
frame <span class="preprocessor">#<span class="number">6</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">7</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">8</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">9</span>: <span class="number">0x00000001074f5d40</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">136</span></span>
frame <span class="preprocessor">#<span class="number">10</span>: <span class="number">0x00000001074f5dfc</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">84</span></span>
frame <span class="preprocessor">#<span class="number">11</span>: <span class="number">0x00000001074e979c</span> dyld`dyld::runInitializers(ImageLoader*) + <span class="number">88</span></span>
frame <span class="preprocessor">#<span class="number">12</span>: <span class="number">0x00000001074f0324</span> dyld`dlopen + <span class="number">976</span></span>
frame <span class="preprocessor">#<span class="number">13</span>: <span class="number">0x0000000180ccf4d4</span> libdyld.dylib`dlopen + <span class="number">116</span></span>
frame <span class="preprocessor">#<span class="number">14</span>: <span class="number">0x0000000189caec58</span> WebCore`initWebFilterEvaluator() + <span class="number">36</span></span>
</code></pre><p>从上述链路看起来：<code>WebCore</code>通过<code>dlopen</code>加载了<code>/System/Library/PrivateFrameworks/StoreKitUI.framework/StoreKitUI</code>这个动态库，然后动态库加载完成后，执行了和主二进制一样的<code>call_load_methods</code>过程。</p>
<p>逐一执行<code>load</code>的过程中，会调用到这个类<code>SKUIMetricsAppLaunchEvent</code>，然后这个类执行的汇编我们看看：</p>
<pre><code>StoreKitUI`+[SKUIMetricsAppLaunchEvent load]:
-&gt;  <span class="number">0x196767f70</span> &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="preprocessor">#<span class="number">0x20</span>             ; =<span class="number">0x20</span> </span>
    <span class="number">0x196767f74</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x196767f78</span> &lt;+<span class="number">8</span>&gt;:  add    x29, sp, <span class="preprocessor">#<span class="number">0x10</span>            ; =<span class="number">0x10</span> </span>
    <span class="number">0x196767f7c</span> &lt;+<span class="number">12</span>&gt;: str    x0, [sp]
    <span class="number">0x196767f80</span> &lt;+<span class="number">16</span>&gt;: adrp   x8, <span class="number">108130</span>
    <span class="number">0x196767f84</span> &lt;+<span class="number">20</span>&gt;: ldr    x8, [x8, <span class="preprocessor">#<span class="number">0xff8</span>]</span>
    <span class="number">0x196767f88</span> &lt;+<span class="number">24</span>&gt;: str    x8, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    <span class="number">0x196767f8c</span> &lt;+<span class="number">28</span>&gt;: adrp   x8, <span class="number">108114</span>
    <span class="number">0x196767f90</span> &lt;+<span class="number">32</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xf70</span>]</span>
    <span class="number">0x196767f94</span> &lt;+<span class="number">36</span>&gt;: mov    x0, sp
    <span class="number">0x196767f98</span> &lt;+<span class="number">40</span>&gt;: bl     <span class="number">0x1902ccaac</span>
    <span class="number">0x196767f9c</span> &lt;+<span class="number">44</span>&gt;: adrp   x8, <span class="number">111804</span>
    <span class="number">0x196767fa0</span> &lt;+<span class="number">48</span>&gt;: ldr    x8, [x8, <span class="preprocessor">#<span class="number">0x6e0</span>]</span>
    <span class="number">0x196767fa4</span> &lt;+<span class="number">52</span>&gt;: cmn    x8, <span class="preprocessor">#<span class="number">0x1</span>                  ; =<span class="number">0x1</span> </span>
    <span class="number">0x196767fa8</span> &lt;+<span class="number">56</span>&gt;: b.ne   <span class="number">0x196767fb8</span>               ; &lt;+<span class="number">72</span>&gt;
    <span class="number">0x196767fac</span> &lt;+<span class="number">60</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x196767fb0</span> &lt;+<span class="number">64</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x20</span>             ; =<span class="number">0x20</span> </span>
    <span class="number">0x196767fb4</span> &lt;+<span class="number">68</span>&gt;: ret    
    <span class="number">0x196767fb8</span> &lt;+<span class="number">72</span>&gt;: adrp   x0, <span class="number">111804</span>
    <span class="number">0x196767fbc</span> &lt;+<span class="number">76</span>&gt;: add    x0, x0, <span class="preprocessor">#<span class="number">0x6e0</span>            ; =<span class="number">0x6e0</span> </span>
    <span class="number">0x196767fc0</span> &lt;+<span class="number">80</span>&gt;: adrp   x1, <span class="number">93832</span>
    <span class="number">0x196767fc4</span> &lt;+<span class="number">84</span>&gt;: add    x1, x1, <span class="preprocessor">#<span class="number">0xf60</span>            ; =<span class="number">0xf60</span> </span>
    <span class="number">0x196767fc8</span> &lt;+<span class="number">88</span>&gt;: bl     <span class="number">0x19684f598</span>               ; symbol stub <span class="keyword">for</span>: __copy_helper_block_<span class="number">.236</span>
    <span class="number">0x196767fcc</span> &lt;+<span class="number">92</span>&gt;: b      <span class="number">0x196767fac</span>               ; &lt;+<span class="number">60</span>&gt;
</code></pre><p>看起来没有关键字<code>stub for objc_msgSend</code>之类的关键字，那我们就重点关注几个跳转指令对应的地址。</p>
<p>排除掉 <code>b      0x196767fac</code>和<code>b.ne   0x196767fb8</code>，因为这两地址就属于本函数。</p>
<p>通过lldb一查询看看剩下的<code>0x1902ccaac</code>是干啥的，卧槽，没结果。那干脆断这个地址试试，然后继续执行，得到如下结果：</p>
<pre><code><span class="number">0x1902ccaac</span>: b      <span class="number">0x1886362ac</span>
<span class="number">0x1902ccab0</span>: b      <span class="number">0x188637ae8</span>
<span class="number">0x1902ccab4</span>: b      <span class="number">0x1886362e8</span>
<span class="number">0x1902ccab8</span>: b      <span class="number">0x1886365a4</span>
<span class="number">0x1902ccabc</span>: b      <span class="number">0x18863ada8</span>
<span class="number">0x1902ccac0</span>: b      <span class="number">0x1886365b4</span>
<span class="number">0x1902ccac4</span>: b      <span class="number">0x18863889c</span>
<span class="number">0x1902ccac8</span>: b      <span class="number">0x188636b2c</span>
</code></pre><p>好吧，看起来这是运行时创建的桥(trampoline)。继续断<code>0x1886362ac</code>，然后执行：</p>
<pre><code><span class="number">0x1886362</span>ac: b      <span class="number">0x18080c62</span>0               <span class="comment">; objc_msgSendSuper2</span>
<span class="number">0x1886362</span>b0: b      <span class="number">0x180814250</span>               <span class="comment">; objc_release</span>
<span class="number">0x1886362</span>b4: b      <span class="number">0x180814190</span>               <span class="comment">; objc_retain</span>
<span class="number">0x1886362</span>b8: b      <span class="number">0x1808165f0</span>               <span class="comment">; objc_retainAutorelease</span>
<span class="number">0x1886362</span>bc: b      <span class="number">0x180816558</span>               <span class="comment">; objc_retainAutoreleaseReturnValue</span>
<span class="number">0x1886362</span>c0: b      <span class="number">0x180816588</span>               <span class="comment">; objc_retainAutoreleasedReturnValue</span>
<span class="number">0x1886362</span>c4: b      <span class="number">0x180802</span>fa8               <span class="comment">; class_addMethod</span>
<span class="number">0x1886362</span>c8: b      <span class="number">0x18080157</span>c               <span class="comment">; class_getInstanceMethod</span>
</code></pre><p>哈哈，看到我们想要的代码了：</p>
<p><strong>0x1886362ac: b      0x18080c620               ; objc_msgSendSuper2</strong></p>
<p>从这段汇编不难看出，在<code>+[SKUIMetricsAppLaunchEvent load]</code>方法里面，会调用<code>[super load]</code>这样的代码。</p>
<h3 id="为啥iOS_10上没有问题">为啥iOS 10上没有问题</h3><p>在iOS 10上其实也有同样的问题，但是由于<code>WebCore</code>不会主动把对应的<strong>StoreKitUI</strong>加载进来，所以也就没出触发这样的问题，但是如果我们主动通过<code>dlopen</code>加载这个系统库，也一样有问题：</p>
<pre><code>__attribute__((<span class="constructor"><span class="keyword">constructor</span>)) void load_private()
</span>{
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        <span class="built_in">void</span> *libHandleIMD = dlopen(<span class="string">"/System/Library/PrivateFrameworks/StoreKitUI.framework/StoreKitUI"</span>, RTLD_LAZY);
        NSLog(@<span class="string">"libHandleIMD is %p"</span>, libHandleIMD);
        <span class="keyword">if</span> (!libHandleIMD) {
            printf(<span class="string">"error is %s\n"</span>, dlerror());
        }
    });
}
</code></pre><h3 id="提醒">提醒</h3><p>对于在系统类上添加的<code>load</code>方法，建议还是做是否是重入的判断或者保护，不然很可能出现与预期不相符的结果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>水文一篇</p>
</blockquote>
<p>今天在群友逆向企业微信的时候，发现了一个比较有意思的现象了，发现对于<code>NSObject</code>添加的<code>load</code>的方法执行了两次，导致原本意图的<code>S]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS内存abort(Jetsam) 原理探究]]></title>
    <link href="http://satanwoo.github.io/2017/10/18/abort/"/>
    <id>http://satanwoo.github.io/2017/10/18/abort/</id>
    <published>2017-10-18T14:46:01.000Z</published>
    <updated>2017-10-18T14:51:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="招人">招人</h3><p>手淘架构组招人 iOS／Android 皆可，地点杭州，有兴趣的请联系我！！</p>
<h3 id="iOS内存abort(Jetsam)_原理探究">iOS内存abort(Jetsam) 原理探究</h3><p>苹果最近开源了iOS系统上的XNU内核代码，加上最近又开始负责手淘/猫客的稳定性及性能相关的工作，所以赶紧拜读下苹果的大作。今天主要开始想分析跟abort相关的内存Jetsam原理。</p>
<h3 id="什么是Jetsam">什么是Jetsam</h3><p>关于Jetsam，可能有些人还不是很理解。我们可以从<strong>手机设置-&gt;隐私-&gt;分析</strong>这条路径看看系统的日志，会发现手机上有许多<code>JetsamEvent</code>开头的日志。打开这些日志，一般会显示一些内存大小，CPU时间什么的数据。</p>
<p>之所以会发生这么JetsamEvent，主要还是由于iOS设备不存在交换区导致的内存受限，所以iOS内核不得不把一些<strong>优先级不高或者占用内存过大的</strong>杀掉。这些<code>JetsamEvent</code>就是系统在杀掉App后记录的一些数据信息。</p>
<p>从某种程度来说，JetsamEvent是一种另类的Crash事件，但是在常规的Crash捕获工具中，由于iOS上能捕获的信号量的限制，所以因为内存导致App被杀掉是无法被捕获的。为此，许多业界的前辈通过设计<code>flag</code>的方式自己记录所谓的<code>abort</code>事件来采集数据。但是这种采集的abort，一般情况下都只能简单的记录次数，而没有详细的堆栈。</p>
<h3 id="源码探究">源码探究</h3><p>MacOS/iOS是一个从BSD衍生而来的系统。其内核是Mach，但是对于上层暴露的接口一般都是基于BSD层对于Mach包装后的。虽然说Mach是个微内核的架构，真正的虚拟内存管理是在其中进行，但是BSD对于内存管理提供了相对较为上层的接口，同时，各种常见的<strong>JetSam事件也是由BSD产生</strong>，所以，我们从<code>bsd_init</code>这个函数作为入口，来探究下原理。</p>
<p><code>bsd_init</code>中基本都是在初始化各个子系统，比如虚拟内存管理等等。</p>
<p>跟内存相关的包括如下几步可能：</p>
<pre><code><span class="number">1.</span> 初始化BSD内存Zone，这个Zone是基于Mach内核的zone构建
kmeminit();

<span class="number">2.</span> iOS上独有的特性，内存和进程的休眠的常驻监控线程
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_FREEZE</span>
<span class="preprocessor">#<span class="keyword">ifndef</span> CONFIG_MEMORYSTATUS</span>
    <span class="preprocessor">#<span class="keyword">error</span> <span class="string">"CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS"</span></span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
    <span class="comment">/* Initialise background freezing */</span>
    bsd_init_kprintf(<span class="string">"calling memorystatus_freeze_init\n"</span>);
    memorystatus_freeze_init();
<span class="preprocessor">#<span class="keyword">endif</span>&gt;</span>

<span class="number">3.</span> iOS独有，JetSAM（即低内存事件的常驻监控线程）
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_MEMORYSTATUS</span>
    <span class="comment">/* Initialize kernel memory status notifications */</span>
    bsd_init_kprintf(<span class="string">"calling memorystatus_init\n"</span>);
    memorystatus_init();
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_MEMORYSTATUS */</span></span>
</code></pre><p>这两步代码都是调用<code>kern_memorystatus.c</code>里面暴露的接口，主要的作用就是从内核中开启了两个最高优先级的线程，来监控整个系统的内存情况。</p>
<p>首先先来看看<code>CONFIG_FREEZE</code>涉及的功能。当启用这个效果的时候，内核会对<strong>进程</strong>进行冷冻而不是Kill。</p>
<p>这个冷冻的功能是通过在内核中启动一个<code>memorystatus_freeze_thread</code>进行。这个线程在收到信号后调用<code>memorystatus_freeze_top_process</code>进行冷冻。</p>
<p>当然，涉及到进程休眠相关的代码，就需要谈谈苹果系统里面其他相关概念了。扯开又是一个比较大的话题，后续单独开文章来进行阐述。</p>
<p>回到iOS Abort问题上的话，我们只需要关注<code>memorystatus_init</code>即可，去除平台无关的代码后如下：</p>
<pre><code>__private_extern__ <span class="keyword">void</span>
memorystatus_init(<span class="keyword">void</span>)
{
    thread_t thread = THREAD_NULL;
    kern_return_t result;
    <span class="keyword">int</span> i;

    <span class="comment">/* Init buckets */</span>
    <span class="comment">// 注意点1：优先级数组，每个数组都持有了一个同优先级进程的列表</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MEMSTAT_BUCKET_COUNT; i++) {
        TAILQ_INIT(&amp;memstat_bucket[i]<span class="variable">.list</span>);
        memstat_bucket[i]<span class="variable">.count</span> = <span class="number">0</span>;
    }
    memorystatus_idle_demotion_call = thread_call_allocate((thread_call_func_t)memorystatus_perform_idle_demotion, <span class="literal">NULL</span>);

<span class="preprocessor">#if CONFIG_JETSAM</span>

    nanoseconds_to_absolutetime((uint64_t)DEFERRED_IDLE_EXIT_TIME_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_sysprocs_idle_delay_time);
    nanoseconds_to_absolutetime((uint64_t)DEFERRED_IDLE_EXIT_TIME_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_apps_idle_delay_time);

    <span class="comment">/* Apply overrides */</span>
    <span class="comment">// 注意点2：获取一系列内核参数</span>
    PE_get_default(<span class="string">"kern.jetsam_delta"</span>, &amp;delta_percentage, <span class="keyword">sizeof</span>(delta_percentage));
    <span class="keyword">if</span> (delta_percentage == <span class="number">0</span>) {
        delta_percentage = <span class="number">5</span>;
    }
    assert(delta_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_critical_threshold"</span>, &amp;critical_threshold_percentage, <span class="keyword">sizeof</span>(critical_threshold_percentage));
    assert(critical_threshold_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_idle_offset"</span>, &amp;idle_offset_percentage, <span class="keyword">sizeof</span>(idle_offset_percentage));
    assert(idle_offset_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_pressure_threshold"</span>, &amp;pressure_threshold_percentage, <span class="keyword">sizeof</span>(pressure_threshold_percentage));
    assert(pressure_threshold_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_freeze_threshold"</span>, &amp;freeze_threshold_percentage, <span class="keyword">sizeof</span>(freeze_threshold_percentage));
    assert(freeze_threshold_percentage &lt; <span class="number">100</span>);

    <span class="keyword">if</span> (!PE_parse_boot_argn(<span class="string">"jetsam_aging_policy"</span>, &amp;jetsam_aging_policy,
            <span class="keyword">sizeof</span> (jetsam_aging_policy))) {

        <span class="keyword">if</span> (!PE_get_default(<span class="string">"kern.jetsam_aging_policy"</span>, &amp;jetsam_aging_policy,
                <span class="keyword">sizeof</span>(jetsam_aging_policy))) {

            jetsam_aging_policy = kJetsamAgingPolicyLegacy;
        }
    }

    <span class="keyword">if</span> (jetsam_aging_policy &gt; kJetsamAgingPolicyMax) {
        jetsam_aging_policy = kJetsamAgingPolicyLegacy;
    }

    <span class="keyword">switch</span> (jetsam_aging_policy) {

        <span class="keyword">case</span> kJetsamAgingPolicyNone:
            system_procs_aging_band = JETSAM_PRIORITY_IDLE;
            applications_aging_band = JETSAM_PRIORITY_IDLE;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicyLegacy:
            <span class="comment">/*
             * Legacy behavior where some daemons get a 10s protection once
             * AND only before the first clean-&gt;dirty-&gt;clean transition before
             * going into IDLE band.
             */</span>
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            applications_aging_band = JETSAM_PRIORITY_IDLE;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicySysProcsReclaimedFirst:
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            applications_aging_band = JETSAM_PRIORITY_AGING_BAND2;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicyAppsReclaimedFirst:
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND2;
            applications_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
    }

    <span class="comment">/*
     * The aging bands cannot overlap with the JETSAM_PRIORITY_ELEVATED_INACTIVE
     * band and must be below it in priority. This is so that we don't have to make
     * our 'aging' code worry about a mix of processes, some of which need to age
     * and some others that need to stay elevated in the jetsam bands.
     */</span>
    assert(JETSAM_PRIORITY_ELEVATED_INACTIVE &gt; system_procs_aging_band);
    assert(JETSAM_PRIORITY_ELEVATED_INACTIVE &gt; applications_aging_band);

    <span class="comment">/* Take snapshots for idle-exit kills by default? First check the boot-arg... */</span>
    <span class="keyword">if</span> (!PE_parse_boot_argn(<span class="string">"jetsam_idle_snapshot"</span>, &amp;memorystatus_idle_snapshot, <span class="keyword">sizeof</span> (memorystatus_idle_snapshot))) {
            <span class="comment">/* ...no boot-arg, so check the device tree */</span>
            PE_get_default(<span class="string">"kern.jetsam_idle_snapshot"</span>, &amp;memorystatus_idle_snapshot, <span class="keyword">sizeof</span>(memorystatus_idle_snapshot));
    }

    memorystatus_delta = delta_percentage * atop_64(max_mem) / <span class="number">100</span>;
    memorystatus_available_pages_critical_idle_offset = idle_offset_percentage * atop_64(max_mem) / <span class="number">100</span>;
    memorystatus_available_pages_critical_base = (critical_threshold_percentage / delta_percentage) * memorystatus_delta;
    memorystatus_policy_more_free_offset_pages = (policy_more_free_offset_percentage / delta_percentage) * memorystatus_delta;

    <span class="comment">/* Jetsam Loop Detection */</span>
    <span class="keyword">if</span> (max_mem &lt;= (<span class="number">512</span> * <span class="number">1024</span> * <span class="number">1024</span>)) {
        <span class="comment">/* 512 MB devices */</span>
        memorystatus_jld_eval_period_msecs = <span class="number">8000</span>;    <span class="comment">/* 8000 msecs == 8 second window */</span>
    } <span class="keyword">else</span> {
        <span class="comment">/* 1GB and larger devices */</span>
        memorystatus_jld_eval_period_msecs = <span class="number">6000</span>;    <span class="comment">/* 6000 msecs == 6 second window */</span>
    }

    memorystatus_jld_enabled = <span class="literal">TRUE</span>;

    <span class="comment">/* No contention at this point */</span>
    memorystatus_update_levels_locked(<span class="literal">FALSE</span>);

<span class="preprocessor">#endif /* CONFIG_JETSAM */</span>

    memorystatus_jetsam_snapshot_max = maxproc;
    memorystatus_jetsam_snapshot = 
        (memorystatus_jetsam_snapshot_t*)kalloc(<span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) +
        <span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * memorystatus_jetsam_snapshot_max);
    <span class="keyword">if</span> (!memorystatus_jetsam_snapshot) {
        panic(<span class="string">"Could not allocate memorystatus_jetsam_snapshot"</span>);
    }

    nanoseconds_to_absolutetime((uint64_t)JETSAM_SNAPSHOT_TIMEOUT_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_jetsam_snapshot_timeout);

    memset(&amp;memorystatus_at_boot_snapshot, <span class="number">0</span>, <span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_t));

    result = kernel_thread_start_priority(memorystatus_thread, <span class="literal">NULL</span>, <span class="number">95</span> <span class="comment">/* MAXPRI_KERNEL */</span>, &amp;thread);
    <span class="keyword">if</span> (result == KERN_SUCCESS) {
        thread_deallocate(thread);
    } <span class="keyword">else</span> {
        panic(<span class="string">"Could not create memorystatus_thread"</span>);
    }
}
</code></pre><p><strong><b style="color:red">下面先介绍几个知识点</b></strong></p>
<ul>
<li><p>内核里面对于所有的进程都有一个优先级的分布，通过一个数组维护，数组每一项是一个进程的list。这个数组的大小是<code>JETSAM_PRIORITY_MAX + 1</code>。其结构体定义如下：</p>
<pre><code>typedef struct memstat_bucket {
    <span class="type">TAILQ_HEAD</span>(, <span class="keyword">proc</span>) list;
    <span class="type">int</span> count;
} memstat_bucket_t;
</code></pre><p>这结构体非常通俗易懂。</p>
</li>
<li><p>线程在Mach下采用了不同的优先级，其中<code>MAXPRI_KERNEL</code>代表的是分配给内核可用范围内最高优先级的线程。其他级别还有如下这些：</p>
</li>
</ul>
<hr>
<pre><code><span class="keyword">*</span> // 优先级最高的实时线程 (不太清楚谁用)
 <span class="keyword">*</span> 127        Reserved (real-time)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (32 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 96        Reserved (real-time)
 <span class="keyword">*</span> // 给内核用的线程优先级(MAXPRI_KERNEL)
 <span class="keyword">*</span> 95        Kernel mode only
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (16 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 80        Kernel mode only
 <span class="keyword">*</span> // 给操作系统分配的线程优先级
 <span class="keyword">*</span> 79        System high priority
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (16 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 64        System high priority
 <span class="keyword">*</span> // 剩下的全是用户态的普通程序可以用的
 <span class="keyword">*</span> 63        Elevated priorities
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (12 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 52        Elevated priorities
 <span class="keyword">*</span> 51        Elevated priorities (incl. BSD +nice)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (20 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 32        Elevated priorities (incl. BSD +nice)
 <span class="keyword">*</span> 31        Default (default base for threads)
 <span class="keyword">*</span> 30        Lowered priorities (incl. BSD -nice)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (20 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 11        Lowered priorities (incl. BSD -nice)
 <span class="keyword">*</span> 10        Lowered priorities (aged pri's)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (11 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 0        Lowered priorities (aged pri's / idle)
 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
</code></pre><ul>
<li>从上图不难看出，用户态的应用程序的线程<strong>不</strong>可能高于操作系统和内核。而且，在用户态的应用程序间的线程优先级分配也有区别，前台活动的应用程序优先级高于后台的应用程序。<b style="color:red">iOS上大名鼎鼎的SpringBoard是应用程序中优先级最高的程序。</b></li>
<li>当然线程的优先级也不是一成不变。Mach会针对每一个线程的利用率和整体系统负载动态调整优先级。如果耗费CPU太多就降低优先级，如果一个线程过度挨饿CPU则会提升其优先级。<b style="color:red">但是无论怎么变，程序都不能超过其所在的线程优先级区间范围。</b></li>
</ul>
<p>好，预备知识说完，那苹果究竟是怎么处理<code>JetSam</code>事件呢？</p>
<pre><code><span class="literal">result</span> = kernel_thread_start_priority(memorystatus_thread, <span class="type">NULL</span>, <span class="number">95</span> /* <span class="type">MAXPRI_KERNEL</span> */, &amp;thread);
</code></pre><p>苹果其实处理的思路非常简单。如上述代码，BSD层起了一个内核优先级最高的线程<code>VM_memorystatus</code>，这个线程会在维护两个列表，一个是我们之前提到的基于进程优先级的进程列表，还有一个是所谓的内存快照列表，即保存了每个进程消耗的内存页<code>memorystatus_jetsam_snapshot</code>。</p>
<p>这个常驻线程接受从内核对于内存的守护程序<code>pageout</code>通过内核调用给每个App进程发送的内存压力通知，来处理事件，这个事件转发成上层的UI事件就是平常我们会收到的全局内存警告或者每个ViewController里面的<code>didReceiveMemoryWarning</code>。</p>
<p><b style="color:red">当然，我们自己开发的App是不会主动注册监听这个内存警告事件的，帮助我们在底层完成这一切的都是<code>libdispatch</code>，如果你感兴趣的话，可以钻研下<code>_dispatch_source_type_memorypressure</code>和<code>__dispatch_source_type_memorystatus</code>。</b></p>
<p>那么在哪些情况下会出现内存压力呢？我们来看一看<code>memorystatus_action_needed</code>这段函数： </p>
<pre><code><span class="function"><span class="keyword">static</span> boolean_t
<span class="title">memorystatus_action_needed</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_EMBEDDED</span>
    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||
            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||
           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);
<span class="preprocessor">#<span class="keyword">else</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>
    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||
            is_reason_zone_map_exhaustion(kill_under_pressure_cause));
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>
}
</code></pre><p>概括来说：</p>
<p>频繁的的页面换进换出<code>is_reason_thrashing</code>，Mach Zone耗尽了<code>is_reason_zone_map_exhaustion</code>（这个涉及Mach内核的虚拟内存管理了，单独写）以及可用的页低于一个门槛了<code>memorystatus_available_pages</code>。</p>
<p>在这几种情况下，就会准备去Kill 进程了。但是，在这个处理下面，有一段代码特别有意思，我们看看这个函数<code>memorystatus_act_aggressive</code>：</p>
<pre><code><span class="keyword">if</span> ( (jld_bucket_count == <span class="number">0</span>) || 
     (jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs))) {

    <span class="comment">/* 
     * Refresh evaluation parameters 
     */</span>
    jld_timestamp_msecs     = jld_now_msecs;
    jld_idle_kill_candidates = jld_bucket_count;
    *jld_idle_kills         = <span class="number">0</span>;
    jld_eval_aggressive_count = <span class="number">0</span>;
    jld_priority_band_max    = JETSAM_PRIORITY_UI_SUPPORT;
}
</code></pre><p>这段代码很明显，是基于某个时间间隔在做条件判断。如果不满足这个判断，后续真正执行的Kill也不会走到。那我们来看看<code>memorystatus_jld_eval_period_msecs</code>这个变量：</p>
<pre><code><span class="comment">/* Jetsam Loop Detection */</span>
<span class="keyword">if</span> (max_mem &lt;= (<span class="number">512</span> * <span class="number">1024</span> * <span class="number">1024</span>)) {
    <span class="comment">/* 512 MB devices */</span>
    memorystatus_jld_eval_period_msecs = <span class="number">8000</span>;    <span class="comment">/* 8000 msecs == 8 second window */</span>
} <span class="keyword">else</span> {
    <span class="comment">/* 1GB and larger devices */</span>
    memorystatus_jld_eval_period_msecs = <span class="number">6000</span>;    <span class="comment">/* 6000 msecs == 6 second window */</span>
}
</code></pre><p>这个时间窗口是根据设备的物理内存上限来设定的，但是无论如何，看起来至少有个<strong><span style="color:red">6秒</span></strong>的时间可以给我们来做点事情。</p>
<p>当然，如果满足了时间窗口的需求，就会根据我们提到的优先级进程列表进行寻找可杀目标：</p>
<pre><code>proc_list_lock()<span class="comment">;</span>
switch (jetsam_aging_policy) {
case kJetsamAgingPolicyLegacy:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_AGING_BAND1]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
case kJetsamAgingPolicySysProcsReclaimedFirst:
case kJetsamAgingPolicyAppsReclaimedFirst:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[system_procs_aging_band]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[applications_aging_band]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
case kJetsamAgingPolicyNone:
default:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
}

bucket = &amp;memstat_bucket[JETSAM_PRIORITY_ELEVATED_INACTIVE]<span class="comment">;</span>
elevated_bucket_count = bucket-&gt;count<span class="comment">;</span>
</code></pre><p><b style="color:red">需要注意的是，JETSAM不一定只杀一个进程，他可能会大杀特杀，杀掉N多进程。</b></p>
<pre><code><span class="keyword">if</span> (memorystatus_avail_pages_below_pressure()) {
    <span class="comment">/*
     * Still under pressure.
     * Find another pinned processes.
     */</span>
    <span class="keyword">continue</span>;
} <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="keyword">TRUE</span>;
}
</code></pre><p>至于杀进程的话，最终都会落到函数<code>memorystatus_do_kill</code>-&gt;<code>jetsam_do_kill</code>去执行。</p>
<h3 id="其他">其他</h3><p>看苹果代码的时候，发现了不少内核的参数，一一进行了尝试后，发现<code>sysctlname</code>和<code>sysctl</code>的系统调用都被苹果禁用了，比如这些：</p>
<pre><code><span class="string">"kern.jetsam_delta"</span>
<span class="string">"kern.jetsam_critical_threshold"</span>
<span class="string">"kern.jetsam_idle_offset"</span>
<span class="string">"kern.jetsam_pressure_threshold"</span>
<span class="string">"kern.jetsam_freeze_threshold"</span>
<span class="string">"kern.jetsam_aging_policy"</span>
</code></pre><p>不过，我试了下通过<code>kern.boottime</code>获取机器的开机时间还是可以的，代码示例如下：</p>
<pre><code><span class="keyword">size_t</span> size;
sysctlbyname(<span class="string">"kern.boottime"</span>, <span class="literal">NULL</span>, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);

<span class="keyword">char</span> *boot_time = <span class="built_in">malloc</span>(size);
sysctlbyname(<span class="string">"kern.boottime"</span>, boot_time, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);

<span class="keyword">uint32_t</span> timestamp = <span class="number">0</span>;
<span class="built_in">memcpy</span>(&amp;timestamp, boot_time, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));
<span class="built_in">free</span>(boot_time);

NSDate* bootTime = [NSDate dateWithTimeIntervalSince1970:timestamp];
</code></pre><h3 id="最后">最后</h3><p>嘻嘻，技术原理研究了一些，心里顿时对解决公司的Abort问题有了一定的眉目。嘿嘿，我写了个DEMO验证了我的思路，是可行的。哇咔咔。等我的好消息吧～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="招人">招人</h3><p>手淘架构组招人 iOS／Android 皆可，地点杭州，有兴趣的请联系我！！</p>
<h3 id="iOS内存abort(Jetsam)_原理探究">iOS内存abort(Jetsam) 原理探究</h3><p>苹果最近开源了iOS系]]>
    </summary>
    
      <category term="XNU" scheme="http://satanwoo.github.io/tags/XNU/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于桥的全量方法Hook方案 - 探究苹果主线程检查实现]]></title>
    <link href="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/"/>
    <id>http://satanwoo.github.io/2017/09/24/mainthreadchecker1/</id>
    <published>2017-09-24T14:46:43.000Z</published>
    <updated>2017-09-24T15:01:10.000Z</updated>
    <content type="html"><![CDATA[<p>最近随着iOS11的正式发布，手淘／天猫也开始逐步用Xcode 9开始编译。在调试过程中，很多同事发现经常报许多API会报线程使用错误的问题。摸索了下，发现是Xcode 9里面带上了一个叫<code>libMainThreadChecker.dylib</code>的动态库，在运行时提供了主线程检查的功能，今天就从探究苹果的实现开始讲起。</p>
<h3 id="0x1_苹果的实现">0x1 苹果的实现</h3><p>把苹果的动态库拖入hopper里面看看，基本上扫一眼以后，比较可疑的是<code>__library_initializer</code>和<code>__library_deintializer</code>。</p>
<blockquote>
<p>我看反汇编，第一直觉就是猜，然后都试一把。</p>
</blockquote>
<p>我们来看看其伪代码实现，可以分为几个部分来探究：</p>
<h4 id="1-1_环境变量">1.1 环境变量</h4><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_1.png?raw=true" alt=""></p>
<p>从图中不难看出，<code>libMainThreadChecker</code>的运行依赖于许多的环境变量，我们可以在<code>Xcode</code>-&gt;<code>Scheme</code>-&gt;<code>Arguments</code>里面一个个输入这些变量进行测试，我发现比较重要的是<code>MTC_VERBOSE</code>这个参数，使用后，可以输出究竟对于哪些类进行了线程监控。</p>
<pre><code>...
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardEmojiCollectionViewCell</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardEmojiSectionHeader</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupPINScrollView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupPINView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupConnectingView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UICollectionViewTableHeaderFooterView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupDisplayPINView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarMapsCompassItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarCarPlayTimeItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateBarCell</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateBarCell_SecondaryCandidate</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIActionSheetiOSDismissActionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateFloatingArrowView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateGridOverlayBackgroundView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateGridHeaderContainerView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarBreadcrumbItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIInterfaceActionGroupView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardFlipTransitionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardAssistantBar</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UITextMagnifier</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardSliceTransitionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIWKSelectionView</span></span>
Swizzled <span class="number">10717</span> methods <span class="keyword">in</span> <span class="number">384</span> classes.
</code></pre><p>可以看出，苹果会在启动前对于这些类进行所谓的线程监控。</p>
<h4 id="1-2_逻辑">1.2 逻辑</h4><p>看完了输出，我们来看看其中的逻辑实现，如下所示：</p>
<pre><code>CFAbsoluteTimeGetCurrent();
   var_270 = intrinsic_movsd(var_270, xmm0);
   *_indirect__main_thread_checker_on_report = dlsym(<span class="number">0xfffffffffffffffd</span>, <span class="string">"__main_thread_checker_on_report"</span>);
   <span class="keyword">if</span> (objc_getClass(<span class="string">"UIView"</span>) != <span class="number">0x0</span>) {
           *_XXKitImage = dyld_image_header_containing_address(objc_getClass(<span class="string">"UIView"</span>));
           *_CoreFoundationImage = dyld_image_header_containing_address(_CFArrayGetCount);
           rax = objc_getClass(<span class="string">"WKWebView"</span>);
           rax = dyld_image_header_containing_address(rax);
           *_WebKitImage = rax;
           *_InlineCallsMachHeaders = *_XXKitImage;
           *<span class="number">0x1ec3e8</span> = *_CoreFoundationImage;
           *<span class="number">0x1ec3f0</span> = rax;
           *___CATransaction = objc_getClass(<span class="string">"CATransaction"</span>);
           *___NSGraphicsContext = objc_getClass(<span class="string">"NSGraphicsContext"</span>);
           *_SEL_currentState = sel_registerName(<span class="string">"currentState"</span>);
           *_SEL_currentContext = sel_registerName(<span class="string">"currentContext"</span>);
           *_MyOwnMachHeader = dyld_image_header_containing_address(___library_initializer);
           *_classesToSwizzle = CFArrayCreateMutable(<span class="number">0x0</span>, <span class="number">0x200</span>, <span class="number">0x0</span>);
           var_240 = objc_getClass(<span class="string">"UIView"</span>);
           _FindClassesToSwizzleInImage(*_XXKitImage, &amp;var_240, <span class="number">0x2</span>);
           <span class="keyword">if</span> (*_WebKitImage != <span class="number">0x0</span>) {
                   var_230 = objc_getClass(<span class="string">"WKWebView"</span>);
                   *(&amp;var_230 + <span class="number">0x8</span>) = objc_getClass(<span class="string">"WKWebsiteDataStore"</span>);
                   *(&amp;var_230 + <span class="number">0x10</span>) = objc_getClass(<span class="string">"WKUserScript"</span>);
                   *(&amp;var_230 + <span class="number">0x18</span>) = objc_getClass(<span class="string">"WKUserContentController"</span>);
                   *(&amp;var_230 + <span class="number">0x20</span>) = objc_getClass(<span class="string">"WKScriptMessage"</span>);
                   *(&amp;var_230 + <span class="number">0x28</span>) = objc_getClass(<span class="string">"WKProcessPool"</span>);
                   *(&amp;var_230 + <span class="number">0x30</span>) = objc_getClass(<span class="string">"WKProcessGroup"</span>);
                   *(&amp;var_230 + <span class="number">0x38</span>) = objc_getClass(<span class="string">"WKContentExtensionStore"</span>);
                   _FindClassesToSwizzleInImage(*_WebKitImage, &amp;var_230, <span class="number">0x8</span>);
           }
           rcx = CFArrayGetCount(*_classesToSwizzle);
           <span class="keyword">if</span> (rcx != <span class="number">0x0</span>) {
                   rax = <span class="number">0x0</span>;
                   var_278 = rcx;
                   <span class="keyword">do</span> {
                           var_288 = rax;
                           rax = CFArrayGetValueAtIndex(*_classesToSwizzle, rax);
                           var_258 = rax;
                           rbx = objc_getClass(rax);
                           var_290 = dyld_image_header_containing_address(rbx);
                           var_230 = <span class="number">0x0</span>;
                           var_280 = rbx;
                           r14 = class_copyMethodList(rbx, &amp;var_230);
                           <span class="keyword">if</span> (var_230 != <span class="number">0x0</span>) {
                                   rbx = <span class="number">0x0</span>;
                                   <span class="keyword">do</span> {
                                           r13 = *(r14 + rbx * <span class="number">0x8</span>);
                                           r12 = method_getName(r13);
                                           r15 = sel_getName(r12);
                                           <span class="keyword">if</span> ((((((((((((((((*(<span class="keyword">int8_t</span> *)r15 != <span class="number">0x5f</span>) &amp;&amp; (dyld_image_header_containing_address(method_getImplementation(r13)) == var_290)) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreRetainRelease == <span class="number">0x0</span>) || (((<span class="built_in">strcmp</span>(r15, <span class="string">"retain"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"release"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"autorelease"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreDealloc == <span class="number">0x0</span>) || ((<span class="built_in">strcmp</span>(r15, <span class="string">"dealloc"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">".cxx_destruct"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreNSObjectThreadSafeMethods == <span class="number">0x0</span>) || ((((<span class="built_in">strcmp</span>(r15, <span class="string">"description"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"debugDescription"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"self"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"class"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"beginBackgroundTaskWithExpirationHandler:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"beginBackgroundTaskWithName:expirationHandler:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"endBackgroundTask:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocus"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocusIfCanDraw"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocusIfCanDrawInContext:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"unlockFocus"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"openGLContext"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"webThread"</span>, <span class="number">0x9</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"nsli_"</span>, <span class="number">0x5</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"nsis_"</span>, <span class="number">0x5</span>) != <span class="number">0x0</span>)) {
                                                   <span class="keyword">if</span> (*_userSuppressedClasses != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithCStringNoCopy(<span class="number">0x0</span>, var_258, <span class="number">0x8000100</span>, *_kCFAllocatorNull);
                                                           var_244 = CFSetContainsValue(*_userSuppressedClasses, rax) != <span class="number">0x0</span> ? <span class="number">0x1</span> : <span class="number">0x0</span>;
                                                           CFRelease(rax);
                                                   }
                                                   <span class="keyword">else</span> {
                                                           var_244 = <span class="number">0x0</span>;
                                                   }
                                                   <span class="keyword">if</span> (*_userSuppressedSelectors != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithCStringNoCopy(<span class="number">0x0</span>, r15, <span class="number">0x8000100</span>, *_kCFAllocatorNull);
                                                           var_250 = rax;
                                                           <span class="keyword">if</span> (CFSetContainsValue(*_userSuppressedSelectors, rax) != <span class="number">0x0</span>) {
                                                                   var_244 = <span class="number">0x1</span>;
                                                           }
                                                           CFRelease(var_250);
                                                   }
                                                   <span class="keyword">if</span> (*_userSuppressedMethods != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithFormat(<span class="number">0x0</span>, <span class="number">0x0</span>, @<span class="string">"-[%s %s]"</span>);
                                                           var_250 = CFSetContainsValue(*_userSuppressedMethods, rax);
                                                           CFRelease(rax);
                                                           rax = var_250 | var_244;
                                                           <span class="keyword">if</span> (rax == <span class="number">0x0</span>) {
                                                                   _addSwizzler(r13, r12, var_258, r15, <span class="number">0x1</span>);
                                                           }
                                                           <span class="keyword">else</span> {
                                                                   *_userSuppressionsCount = *_userSuppressionsCount + <span class="number">0x1</span>;
                                                           }
                                                   }
                                                   <span class="keyword">else</span> {
                                                           <span class="keyword">if</span> (var_244 != <span class="number">0x0</span>) {
                                                                   *_userSuppressionsCount = *_userSuppressionsCount + <span class="number">0x1</span>;
                                                           }
                                                           <span class="keyword">else</span> {
                                                                   _addSwizzler(r13, r12, var_258, r15, <span class="number">0x1</span>);
                                                           }
                                                   }
                                           }
                                           rbx = rbx + <span class="number">0x1</span>;
                                   } <span class="keyword">while</span> (rbx &lt; var_230);
                           }
                           _objc_flush_caches(var_280);
                           <span class="built_in">free</span>(r14);
                           rax = var_288 + <span class="number">0x1</span>;
                           rcx = var_278;
                   } <span class="keyword">while</span> (rax != rcx);
           }
           *_totalSwizzledClasses = rcx;
           <span class="keyword">if</span> (*(<span class="keyword">int8_t</span> *)_envVerbose != <span class="number">0x0</span>) {
                   rdx = *_totalSwizzledMethods;
                   <span class="built_in">fprintf</span>(*___stderrp, <span class="string">"Swizzled %zu methods in %zu classes.\n"</span>, rdx, rcx);
           }
</code></pre><p>代码乍一看很多，其实逻辑非常简单，概述如下：</p>
<ul>
<li>通过获取<code>UIView的类实体</code>(不理解类实体的去看runtime)所在的地址来反推所在的image（二进制产物，基本是动态库），这里基本能猜测是<code>UIKit</code>。</li>
<li>从<code>UIKit</code>中获取所有继承自<code>UIView</code>和<code>UIApplication</code>的类及其子类(这也是你为什么会在刚刚上文提到的输出中发现<code>UIIBApplication</code>这种不知道啥类的原因)，过滤到带<code>_</code>的私有类，然后对剩下的类的所有的方法进行Swizzle。</li>
<li><b style="color:red">对于需要Swizzle的方法，要额外判断是不是真正属于<code>UIKit</code>这个动态库的。</b> 比如我们在调试的时候，Xcode会加载<code>libViewDebugging.dylib</code>等不会用于用于线上的动态库，里面会给<code>UIView</code>填上很多奇奇怪怪的方法。</li>
<li><p>过滤如下的方法，以及以<code>nsli_</code>和<code>nsis_</code>开头的方法。</p>
<pre><code>retain
release
autorelease
.cxx_destruct
description
debugDescription
class
self
beginBackgroundTaskWithExpiratonHandler
<span class="label">beginBackgroundTaskWithName:</span>expirationHandler:
<span class="label">endBackgroundTask:</span>
<span class="label">opneGLContext:</span>
<span class="label">lockFocusIfCanDrawInContext:</span>
lockFocus
lockFocusIfCanDraw
unlockFocus
</code></pre></li>
<li><p>可选，如果还要检查<code>WebKit</code>相关的方法，还可以Hook如下这些类的子类：</p>
<pre><code><span class="title">WKWebView</span>
WKWebsiteDataStore
WKUserScript
WKUserContentController
WKScriptMessage
WKProcessPool
WKProcessGroup
WKContentExtensionStore
</code></pre></li>
</ul>
<h3 id="0x2_自己实现">0x2 自己实现</h3><p>当时看到这，关于苹果的实现我觉得实在是太简单了，即使不用私有API，结合现在Github上的轮子我自己造一个估计1、2个小时就解决了。现在回想起来，自己还是<b style="color:red">too simple, sometimes native</b></p>
<p>大致代码获取<code>UIKit</code>中<code>UIView</code>和<code>UIApplication</code>所有子类的代码如下：</p>
<pre><code><span class="built_in">NSArray</span> *findAll<span class="built_in">UIKitClasse</span>()
{
    <span class="keyword">static</span> <span class="built_in">NSMutableArray</span> *viewClasses = <span class="literal">nil</span>;
    <span class="keyword">if</span> (!viewClasses) <span class="keyword">return</span> classes;

    uint32_t image_count = _dyld_image_count();
    <span class="keyword">for</span> (uint32_t image_index = <span class="number">0</span>; image_index &lt; image_count; image_index++) {
        <span class="keyword">const</span> my_macho_header *mach_header = (<span class="keyword">const</span> my_macho_header *)_dyld_get_image_header(image_index);

        <span class="keyword">const</span> <span class="keyword">char</span> *image_name = _dyld_get_image_name(image_index);

        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithUTF8String:image_name];
        <span class="keyword">if</span> ([imageName hasSuffix:<span class="string">@"UIKit"</span>]) {

            <span class="keyword">unsigned</span> <span class="keyword">int</span> count;
            <span class="keyword">const</span> <span class="keyword">char</span> **classes;
            Dl_info info;

            dladdr(mach_header, &amp;info);
            classes = objc_copyClassNamesForImage(info<span class="variable">.dli_fname</span>, &amp;count);

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {
                <span class="keyword">const</span> <span class="keyword">char</span> *className = (<span class="keyword">const</span> <span class="keyword">char</span> *)classes[i];

                <span class="built_in">NSString</span> *classname = [<span class="built_in">NSString</span> stringWithUTF8String:className];
                <span class="keyword">if</span> ([classname hasPrefix:<span class="string">@"_"</span>]) {
                    <span class="keyword">continue</span>;
                }

                Class cls = objc_getClass(className);
                Class superCls = cls;

                <span class="keyword">bool</span> isNeedChild = <span class="literal">NO</span>;
                <span class="keyword">while</span> (superCls != [<span class="built_in">NSObject</span> class]) {

                    <span class="keyword">if</span> (superCls == <span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>) || superCls == <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>)) {
                        isNeedChild = <span class="literal">YES</span>;
                        <span class="keyword">break</span>;
                    }
                    superCls = class_getSuperclass(superCls);
                }

                <span class="keyword">if</span> (isNeedChild) {
                    <span class="comment">// 备注：需要在这同时对这个类的方法进行Hook。</span>
                    [viewClasses addObject:cls];
                }
            }

            <span class="keyword">break</span>;
        }

    <span class="keyword">return</span> viewClasses;
}
</code></pre><h4 id="2-1_现有方案Hook的缺陷">2.1 现有方案Hook的缺陷</h4><p>到这，我们就只差把这些类的方法都Hook掉就行了。传统的<code>Method Swizzling</code>肯定不行，那样我们需要对每个方法对应实现一个新的方法进行替换，工作量太大。所以我们需要一个思路能够<b>中心重定向整个过程。</b></p>
<p><b style="color:red">之前跟着网易iOS大佬刘培庆</b>学习iOS的时候，了解到了<code>AnyMethodLog</code>，听说能监控所有类所有方法的执行，于是我就直接套用了这个框架，嘿嘿，使用起来真方便，看起来大功告成了，<b>Build &amp; Run</b>。</p>
<p>卧槽，怎么运行了就启动崩了，一脸懵逼。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_2.png?raw=true" alt=""></p>
<p>没事，我换个开源库<code>BigBang</code>改改。卧槽，还是崩了。这下必须要开下源码分析下原因了。</p>
<p>从<code>AnyMethodLog</code>的实现来看，如下所示：</p>
<pre><code><span class="built_in">BOOL</span> qhd_replaceMethod(Class cls, SEL originSelector, <span class="keyword">char</span> *returnType) {
    Method originMethod = class_getInstanceMethod(cls, originSelector);
    <span class="keyword">if</span> (originMethod == <span class="literal">nil</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }
    <span class="keyword">const</span> <span class="keyword">char</span> *originTypes = method_getTypeEncoding(originMethod);
    IMP msgForwardIMP = _objc_msgForward;
<span class="preprocessor">#if !defined(__arm64__)</span>
    <span class="keyword">if</span> (qhd_isStructType(returnType)) {
        <span class="comment">//Reference JSPatch:</span>
        <span class="comment">//In some cases that returns struct, we should use the '_stret' API:</span>
        <span class="comment">//http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html</span>
        <span class="comment">//NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.</span>
        <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:originTypes];
        <span class="keyword">if</span> ([methodSignature<span class="variable">.debugDescription</span> rangeOfString:<span class="string">@"is special struct return? YES"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) {
            msgForwardIMP = (IMP)_objc_msgForward_stret;
        }
    }
<span class="preprocessor">#endif</span>

    IMP originIMP = method_getImplementation(originMethod);

    <span class="keyword">if</span> (originIMP == <span class="literal">nil</span> || originIMP == msgForwardIMP) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">//把原方法的IMP换成_objc_msgForward，使之触发forwardInvocation方法</span>
    class_replaceMethod(cls, originSelector, msgForwardIMP, originTypes);

    <span class="comment">//把方法forwardInvocation的IMP换成qhd_forwardInvocation</span>
    class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)qhd_forwardInvocation, <span class="string">"v@:@"</span>);

    <span class="comment">//创建一个新方法，IMP就是原方法的原来的IMP，那么只要在qhd_forwardInvocation调用新方法即可</span>
    SEL newSelecotr = qhd_createNewSelector(originSelector);
    <span class="built_in">BOOL</span> isAdd = class_addMethod(cls, newSelecotr, originIMP, originTypes);
    <span class="keyword">if</span> (!isAdd) {
        DEV_LOG(<span class="string">@"class_addMethod fail"</span>);
    }

    <span class="keyword">return</span> <span class="literal">YES</span>;
}

    <span class="comment">// 中心重定向函数</span>
<span class="keyword">void</span> qhd_forwardInvocation(<span class="keyword">id</span> target, SEL selector, <span class="built_in">NSInvocation</span> *invocation) {
    <span class="built_in">NSArray</span> *argList = qhd_method_arguments(invocation);

    SEL originSelector = invocation<span class="variable">.selector</span>;

    <span class="built_in">NSString</span> *originSelectorString = <span class="built_in">NSStringFromSelector</span>(originSelector);



    [invocation setSelector:qhd_createNewSelector(originSelector)];
    [invocation setTarget:target];

    [invocation invoke];
}
</code></pre><p>作者的意图比较简单，主要可以概述为如下几点：</p>
<ul>
<li>把每个类的<code>forwardInvocation</code>，替换成自己实现的一个C函数。</li>
<li>把需要Hook原来<code>selector</code>获取的<code>method</code>的IMP指向<code>objc_msgForward</code>，通过其触发消息转发，也就是触发forwardInvocation;</li>
<li>对每个需要重定向的<code>selector</code>，生成一个特定的格式的新<code>selector</code>，将其IMP指向原来<code>method</code>的IMP。</li>
<li>对于刚刚重定向的C函数，通过<code>NSInvocation</code>获取要调用的target和selector，再次将这个<code>selector</code>生成特定格式的新<code>selector</code>，反射调用。</li>
</ul>
<blockquote>
<p>为啥能把OC的函数<code>forwardInvocation</code>换成C函数，原因就在于只要补上OC函数隐式的前两个参数<code>self, selector</code>，让其的函数签名一致即可。</p>
</blockquote>
<p><b style="color:red">读到这，看起来没有啥问题吧？为什么会崩溃呢！！<br><br>原因在于这种调用方式，缺少了super上下文。<br></b></p>
<p>假设我们现在对<code>UIView</code>、<code>UIButton</code>都Hook了<code>initWithFrame:</code>这个方法，在调用<code>[[UIView alloc] initWithFrame:]</code>和<code>[[UIButton alloc] initWithFrame:]</code>都会定向到C函数<code>qhd_forwardInvocation</code>中，在<code>UIView</code>调用的时候没问题。但是在<code>UIButton</code>调用的时候，由于其内部实现获取了<code>super initWithFrame:</code>，就产生了循环定向的问题。</p>
<p><b style="color:red">问题本质的原因是，由于我们对于父类、子类同名的方法都换成了同一个IMP，那么不论是走<code>objc_msgSend</code>抑或是<code>objc_msgSendSuper2</code>，获取到的IMP都是一致的。而在Hook之前，<code>objc_msgSendSuper2</code>拿到的是super_imp, <code>objc_msgSend</code>拿到是imp，从而不会有问题。</b> </p>
<h4 id="2-2_基于桥的全量Hook方法">2.2 基于桥的全量Hook方法</h4><p>好，上面的一个小节我们说，如果我们把所有方法都重定向到一个IMP上的时候，就会丧失关于继承关系之间的父子上下文关系，导致重定向循环。所以，我们需要一个思路，能够正确解决上下文的问题。</p>
<p>首先我们来回顾下runtime的消息转发机制：</p>
<pre><code><span class="number">1.</span> 调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。

<span class="number">2.</span> 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。

<span class="number">3.</span> 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。

<span class="number">4.</span> 调用forwardInvocation:方法，将第<span class="number">3</span>步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。

<span class="number">5.</span> 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第<span class="number">3</span>步没能获得一个方法签名，执行该步骤。
</code></pre><p><b style="color:red">对于我们来说，我们至少要在第四步之前（确切的是第三步之前），我们就要保留好<code>super</code>上下文。一旦到了<code>forwardInvocation</code>函数，留给我们的又只有<code>self</code>这样的残缺信息了。 </b></p>
<p><b>哎，我就是卡在这思考了一天，最终我想出了一个思路。</b></p>
<ul>
<li>提供一个桩<code>WZQMessageStub</code>，这个桩保留了class和selector，拼接成不一样的函数名，这样就能区分<code>UIButton</code>和<code>UIView</code>的同名<code>initWithFrame:</code>方法，<b style="color:red">因为不同的selector找到的IMP肯定不一样。</b></li>
<li>在<code>NSObject</code>里面实现<code>forwardingTargetForSelector</code>，在消息转发的时候指定把消息全部转发给<code>WZQMessageStub</code>。</li>
<li><code>WZQMessageStub</code>实现<code>methodSignatureForSelector</code>和<code>forwardInvocation:</code>方法，承担真正的方法反射调用的职责。</li>
</ul>
<p>好，思路确定了，难点还剩一个。对于<code>forwardingTargetForSelector</code>这个函数来说，能拿到的参数也是<code>target</code>和<code>selector</code>。在<code>super</code>和<code>self</code>调用场景下，这个参数毫无价值，因此我们需要从<code>selector</code>上着手。如果不做任何改变，我们这里拿到的<code>selector</code>肯定是诸如<code>initWithFrame:</code>的<code>old selector</code>，所以我们需要在这之前桥一下，可以按照下述流程理解：</p>
<pre><code>每个方法置换到不同的IMP桥上 <span class="subst">-&gt; </span>从桥上反推出当前的调用关系（class和<span class="keyword">select</span><span class="subst">or</span>）<span class="subst">-&gt; </span>构造一个中间态新名字 <span class="subst">-&gt; </span>forwardingTargetForSelect<span class="subst">or</span>(<span class="built_in">self</span>, 中间态新名字) 
</code></pre><p>OK，大功告成。具体桥的实现我待会再单独开篇博客讲一讲。</p>
<p><b style="color:red">嘿嘿，看起来很简单的任务也学习到了不少新知识。一会把代码开源到Github上。</b></p>
<h3 id="0x3_遗留问题">0x3 遗留问题</h3><p>我在开启<code>Main Thread Chekcer</code>后，build了一次产物，但是在通过<code>Mach-O</code>文件中<code>Load Commands</code>部分的时候，却没有发现<code>libMainThreadChecker.dylib</code>的踪影，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_4.png?raw=true" alt=""></p>
<p>符号断点<code>dlopen</code>也并没有发现这个动态库调用的踪影，所以非常好奇苹果是怎么加载这个动态库的，有大佬知道请赐教。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近随着iOS11的正式发布，手淘／天猫也开始逐步用Xcode 9开始编译。在调试过程中，很多同事发现经常报许多API会报线程使用错误的问题。摸索了下，发现是Xcode 9里面带上了一个叫<code>libMainThreadChecker.dylib</code>的动态库]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KVO在不同的二进制中多个符号并存的Crash问题]]></title>
    <link href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/"/>
    <id>http://satanwoo.github.io/2017/09/11/KVO-CRASH/</id>
    <published>2017-09-11T15:14:29.000Z</published>
    <updated>2017-09-11T15:31:23.000Z</updated>
    <content type="html"><![CDATA[<p>现在各大公司的App容纳的功能越来越多，导致应用包大小越来越大。而苹果对于<code>text</code>段的大小现在在60MB，为了避免无法上架的问题，所以很多App都开始用了动态库来避免这个问题。</p>
<p>这两天在帮支付宝开发一个功能的时候，由于支付宝许多模块的代码保密设计，因此只能采用动态库注入的方式进行调试。</p>
<p>一开始都没啥问题，但是当我在调试一个API接口的时候，却出现了一个必现的和MBProgressHUD有关的Crash问题。今天就让我用这个Crash开始，来探讨下<strong><span style="color:red">KVO在不同的二进制中多个符号并存的Crash问题</span></strong>。</p>
<h3 id="不同产物中同名符号的处理问题">不同产物中同名符号的处理问题</h3><p>我们都知道，在同一个编译-&gt;Link的最终产物中，符号（类、MetaClass、甚至是全局的函数符号）定义是不能重复的(当然，我们需要排除weak symbol)。否则在<code>ld</code>期间，就会报<code>duplicate symbol</code>这样的错误。</p>
<p>但是在不同的最终产物里，比如一个主二进制和其相关的动态库，由于这两种MachO类型为产物完全脱离，因此在这两个产物中分别定义相同的符号是完全行得通的。</p>
<p>有人会问了，那我们在主二进制中定义一个类，在动态库中又定义了一个同名的类，当我在主二进制中加载了动态库后，两个同名的类会冲突吗？</p>
<p><strong><span style="color:red">答案是不会的</span></strong>，其原因在于苹果使用的是<code>two level namespace</code>的技术。在这种形式下，符号所在的“库”的名称也会作为符号的一部分。链接的时候，<code>staic linker</code>会标记住在这个符号是来自于哪个库的。这样不仅大大减少了<code>dyld</code>搜索符号所需要的时间，也更好对后续库的更新进行了兼容。</p>
<h3 id="类的加载">类的加载</h3><p>熟悉<code>runtime</code>的人都知道，iOS中的类和其metaClass都是<code>objc_class</code>对象，这些“类”所代表的结构体，在编译期间都存在于Mach-O文件中了，位于<code>objc_data</code>这个section中。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_1.png?raw=true" alt=""></p>
<p>而这个对象所包含的如方法、协议等等，则是以<code>class_ro_t</code>的形式存在于<code>objc_const</code>节中。</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;
    <span class="keyword">property_list_t</span> *baseProperties;

    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> {
        <span class="keyword">return</span> baseMethodList;
    }
};
</code></pre><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_5.png?raw=true" alt=""></p>
<p>无论Mach-O的产物如何，这都是静态的数据。当我们在程序使用的过程中想调用这些类，都需要将这些类从二进制中读取并进行<code>realize</code>变成一个正确的类。而整个<code>realize</code>的过程，是在主二进制程序和其依赖的动态库加载完成后进行调用的，realize的过程如下：</p>
<pre><code><span class="keyword">static</span> Class realizeClass(Class cls)
{
    runtimeLock.assertWriting();

    <span class="keyword">const</span> class_ro_t *ro;
    class_rw_t *rw;
    Class supercls;
    Class metacls;
    <span class="keyword">bool</span> isMeta;

    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;

    <span class="comment">// 1. 如果realize过了，就直接返回了</span>
    <span class="keyword">if</span> (cls-&gt;isRealized()) <span class="keyword">return</span> cls;
    assert(cls == remapClass(cls));

    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span>

     <span class="comment">// 2. 读取刚刚提到的read only data，将其变成rw的data。</span>
    ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();
    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) {
        <span class="comment">// This was a future class. rw data is already allocated.</span>
        rw = cls-&gt;data();
        ro = cls-&gt;data()-&gt;ro;
        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);
    } <span class="keyword">else</span> {
        <span class="comment">// Normal class. Allocate writeable class data.</span>
        rw = (class_rw_t *)calloc(<span class="keyword">sizeof</span>(class_rw_t), <span class="number">1</span>);
        rw-&gt;ro = ro;
        rw-&gt;flags = RW_REALIZED|RW_REALIZING;
        cls-&gt;setData(rw);
    }

    isMeta = ro-&gt;flags &amp; RO_META;

    rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span>


    <span class="comment">// Choose an index for this class.</span>
    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span>
    cls-&gt;chooseClassArrayIndex();

    <span class="keyword">if</span> (PrintConnecting) {
        _objc_inform(<span class="string">"CLASS: realizing class '%s'%s %p %p #%u"</span>, 
                     cls-&gt;nameForLogging(), isMeta ? <span class="string">" (meta)"</span> : <span class="string">""</span>, 
                     (void*)cls, ro, cls-&gt;classArrayIndex());
    }

    <span class="comment">// Realize superclass and metaclass, if they aren't already.</span>
    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span>
    <span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span>

    <span class="comment">// 注意点3：对父类和metaClass先进行realize</span>
    supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()));

#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA
    <span class="comment">// Disable non-pointer isa for some classes and/or platforms.</span>
    <span class="comment">// Set instancesRequireRawIsa.</span>
    <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();
    <span class="keyword">bool</span> rawIsaIsInherited = <span class="keyword">false</span>;
    <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="keyword">false</span>;

    <span class="keyword">if</span> (DisableNonpointerIsa) {
        <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span>
        instancesRequireRawIsa = <span class="keyword">true</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  
             <span class="number">0</span> == strcmp(ro-&gt;name, <span class="string">"OS_object"</span>)) 
    {
        <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span>
        hackedDispatch = <span class="keyword">true</span>;
        instancesRequireRawIsa = <span class="keyword">true</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  
             supercls-&gt;instancesRequireRawIsa()) 
    {
        <span class="comment">// This is also propagated by addSubclass() </span>
        <span class="comment">// but nonpointer isa setup needs it earlier.</span>
        <span class="comment">// Special case: instancesRequireRawIsa does not propagate </span>
        <span class="comment">// from root class to root metaclass</span>
        instancesRequireRawIsa = <span class="keyword">true</span>;
        rawIsaIsInherited = <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (instancesRequireRawIsa) {
        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);
    }
<span class="comment">// SUPPORT_NONPOINTER_ISA</span>
#endif

    <span class="comment">// Update superclass and metaclass in case of remapping</span>
    <span class="comment">// 更新当前类的父类和meta类</span>
    cls-&gt;superclass = supercls;
    cls-&gt;initClassIsa(metacls);

    <span class="comment">// Reconcile instance variable offsets / layout.</span>
    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span>
    <span class="comment">// 如果有的话，对ivar进行重新的布局</span>
    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);

    <span class="comment">// Set fastInstanceSize if it wasn't set already.</span>
    cls-&gt;setInstanceSize(ro-&gt;instanceSize);

    <span class="comment">// Copy some flags from ro to rw</span>
    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) {
        cls-&gt;setHasCxxDtor();
        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) {
            cls-&gt;setHasCxxCtor();
        }
    }

    <span class="comment">// Connect this class to its superclass's subclass lists</span>
    <span class="comment">// 简单理解就是构建层次结构的拓扑关系</span>
    <span class="keyword">if</span> (supercls) {
        addSubclass(supercls, cls);
    } <span class="keyword">else</span> {
        addRootClass(cls);
    }

    <span class="comment">// Attach categories</span>
    <span class="comment">// 把category里面的东西也合并进来进来</span>
    methodizeClass(cls);

    <span class="keyword">return</span> cls;
}
</code></pre><p>从上述代码不难看出，整个过程非常简单，分为几个步骤：</p>
<ul>
<li>把从二进制里面读取的readonly data变成rw data，这也是我们在iOS编程中很多运行时黑魔法的基础。</li>
<li>把父类和metaclass都realize一下，然后建立合理的层次依赖关系。</li>
<li>根据父类的布局，把自己的<code>ivar</code>布局动态更新，这也是大名鼎鼎的<code>non-fragile layout</code></li>
<li>把<code>category</code>里面的东西都加载进来。</li>
<li>整个过程结束。</li>
</ul>
<h3 id="KVO的机制">KVO的机制</h3><p>说了这么多铺垫的知识，我们来开始分析下我们程序在加载动态库后会KVO Crash的原因。处于公司数据保密的原因，我构造了一个最简单的场景，这个主二进制和动态库都包含了<code>MBProgressHUD</code>对应的代码，</p>
<p>我们可以通过<code>nm</code>来查看下符号：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_6.png?raw=true" alt=""></p>
<p>在<code>MBProgressHUD</code>里面，有如下一段代码：</p>
<pre><code>- (<span class="keyword">void</span>)registerForKVO {
    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> [<span class="keyword">self</span> observableKeypaths]) {
        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];
    }
}
</code></pre><p>它会分别对所有的对应属性进行KVO监听，由于KVO本身的机制是通过创建一个“xxxNotify_KVO类”，所以，整体的调用顺序如下图所示:</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_2.png?raw=true" alt=""></p>
<p>概括如下：</p>
<ul>
<li>整个流程会为<code>MBProgressHUD</code>这个类以<code>NSKVONotifying_MBProgressHUD</code>的名称，动态添加一个类。</li>
<li>对这个类构建和原先类的父子关系，注册到全局的类表中。</li>
<li>对KVO中使用到的监听的属性进行<code>setter</code>方法的覆写。</li>
</ul>
<p>这几个流程的代码分别如下：</p>
<ol>
<li><p>创建类代码非常简单，逻辑上就是这父类-子类的关系构建一个新的类出来：</p>
<pre><code><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, 
                             size_t extraBytes)</span>
</span>{
    Class cls, meta;

    <span class="function">rwlock_writer_t <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;

    <span class="comment">// Fail if the class name is in use.</span>
    <span class="comment">// Fail if the superclass isn't kosher.</span>
    <span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="keyword">true</span><span class="comment">/*rootOK*/</span>)) {
        <span class="keyword">return</span> nil;
    }

    <span class="comment">// Allocate new classes.</span>
    cls  = alloc_class_for_subclass(superclass, extraBytes);
    meta = alloc_class_for_subclass(superclass, extraBytes);

    <span class="comment">// fixme mangle the name if it looks swift-y?</span>
    objc_initializeClassPair_internal(superclass, name, cls, meta);

    <span class="keyword">return</span> cls;
}
</code></pre></li>
<li><p>当创建完成后，就会对这个类进行<code>registerClassPair</code>的工作，这一步的目的很简单，就是将类注册到一个全局的map中<code>gdb_objc_realized_classes</code>。</p>
</li>
<li><p>重写<code>setter, class, description</code>之类的</p>
</li>
</ol>
<h3 id="Crash原因">Crash原因</h3><p>知道了原理，我们来分析Crash的原因就非常简单了，我们先看Crash的堆栈。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_3.png?raw=true" alt=""></p>
<p>从汇编中不难看出，<code>[x19, #0x20]</code>对应的地址是个非法访问地址，导致了Crash。而<code>x19</code>寄存器又是从<code>x0</code>中赋值而来，根据函数<code>objc_registerClassPair</code>的参数，<code>x0</code>为<code>Class</code>，那很明显，就是从<code>Class</code>对象的<code>0x20</code>，即32 bytes偏移地方的数据。根据定义，</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> : <span class="title">objc_object</span> {</span>
    /<span class="regexp">/ Class ISA; /</span><span class="regexp">/ 8byte
    Class superclass; /</span><span class="regexp">/ 8byte
    cache_t cache;             /</span><span class="regexp">/ formerly cache pointer and vtable /</span><span class="regexp">/ 4 + 4 + 8
    class_data_bits_t bits;    /</span><span class="regexp">/ class_rw_t * plus custom rr/alloc</span> flags
</code></pre><p>我们要获取的数据就是bits。通过输出寄存器，我们发现<code>x0</code>为0，也就是nil。而<code>x0</code>又是从哪来的呢？</p>
<p>倒推堆栈，我们发现，在函数<code>_NSKVONotifyingCreateInfoWithOriginalClass</code>，我们首先调用了<code>objc_allocateClassPair</code>，将其返回值传入<code>objc_registerClassPair</code>(ARM64 Calling Convention)</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_4.png?raw=true" alt=""></p>
<p>所以，问题的本质就出现在<code>allocateClassPair</code>返回了nil，而<code>allocateClassPair</code>只有在如下场景下才会返回nil。</p>
<pre><code><span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="constant">true</span><span class="comment">/*rootOK*/</span>)) {
    <span class="keyword">return</span> <span class="constant">nil</span>;
}
</code></pre><p>通过LLDB调试，在根据name查询<code>NSKVONotifying_MBProgressHUD</code>时，由于全局的类表已经存在了对应的类，所以在<code>getClass</code>就会返回之前注册的类，从而使得<code>allocate</code>直接返回了nil。</p>
<pre><code><span class="type">NXMapTable</span> *gdb_objc_realized_classes;  // exported <span class="keyword">for</span> debuggers <span class="keyword">in</span> objc-gdb.h

<span class="keyword">static</span> <span class="type">Class</span> getClass_impl(<span class="keyword">const</span> <span class="type">char</span> *name)
{
    runtimeLock.assertLocked();

    // allocated <span class="keyword">in</span> _read_images
    assert(gdb_objc_realized_classes);

    // <span class="type">Try</span> runtime-allocated table
    <span class="type">Class</span> <span class="literal">result</span> = (<span class="type">Class</span>)<span class="type">NXMapGet</span>(gdb_objc_realized_classes, name);
    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;

    // <span class="type">Try</span> table <span class="keyword">from</span> dyld <span class="literal">shared</span> cache
    <span class="keyword">return</span> getPreoptimizedClass(name);
}

<span class="keyword">static</span> <span class="type">Class</span> getClass(<span class="keyword">const</span> <span class="type">char</span> *name)
{
    runtimeLock.assertLocked();

    // <span class="type">Try</span> name <span class="keyword">as</span>-<span class="keyword">is</span>
    <span class="type">Class</span> <span class="literal">result</span> = getClass_impl(name);
    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;

    // <span class="type">Try</span> <span class="type">Swift</span>-mangled equivalent <span class="keyword">of</span> the given name.
    <span class="keyword">if</span> (<span class="type">char</span> *swName = copySwiftV1MangledName(name)) {
        <span class="literal">result</span> = getClass_impl(swName);
        free(swName);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    <span class="keyword">return</span> <span class="keyword">nil</span>;
}
</code></pre><h3 id="结论">结论</h3><p>当两个产物都有相同的类名时，这两个类都会被realize，都能够被正常调用。但是由于全局类表的存在，在动态创建KVO的子类时，只能产生一个。所以就导致allocate失败，从而引发register过程的Crash问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在各大公司的App容纳的功能越来越多，导致应用包大小越来越大。而苹果对于<code>text</code>段的大小现在在60MB，为了避免无法上架的问题，所以很多App都开始用了动态库来避免这个问题。</p>
<p>这两天在帮支付宝开发一个功能的时候，由于支付宝许多模块的]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIKit解剖（-）逆向UITableViewController分析Bug]]></title>
    <link href="http://satanwoo.github.io/2017/08/06/UITableViewController/"/>
    <id>http://satanwoo.github.io/2017/08/06/UITableViewController/</id>
    <published>2017-08-06T14:28:23.000Z</published>
    <updated>2017-08-06T14:43:12.000Z</updated>
    <content type="html"><![CDATA[<p>之前在做XXXSDK的时候，我hook的<code>UITableView</code>的<code>setDelegate:</code>方法。整个SDK在接入手淘、天猫以及闲鱼等其他App的时候都没啥问题。</p>
<p>上周，UC的同学突然找到说，给我说了如下图所示的问题：</p>
<p><strong><span style="color:red">商业保密，不显示了</span></strong></p>
<p>卧槽，这下我就懵逼了，看样子是把整个<code>rowHeight</code>给Hook坏了，那这是为什么呢？</p>
<p>从开发<code>UITableView</code>的正向角度来说：我们一般都需要给其提供一个必选的<code>UITableViewDataSource</code>和一个可选的<code>UITableViewDelegate</code>，其中，涉及到高度的是如下这个API：</p>
<pre><code><span class="tag">-</span> (<span class="tag">CGFloat</span>)<span class="rule"><span class="attribute">tableView</span>:<span class="value">(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span></span>;
</code></pre><blockquote>
<p>有人说可以直接通过tableview.rowHeight设置高度，但是对于不同cell不同高度的动态需求，但是这里我们暂不提这种分支情况。</p>
</blockquote>
<p>通过UC同学的协助，我们发现了如下输出：</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/delegate.png?raw=true" alt=""></p>
<p>通过输出不难发现，是最后的<code>delegate</code>被从对应的<code>UIViewController</code>改成了一个乱七八糟没实现对应<code>heightForRowAtIndexPath</code>方法的对象。</p>
<p>为什么会这样呢？</p>
<p>通过如下图所示的调用栈，</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/stack.png?raw=true" alt=""></p>
<p>调用栈最下层是UC同学的代码；</p>
<p><code>self.tableview = [[xxxTableView alloc] init]</code></p>
<p>调用栈最上层是我们的一层防护性hook，其代码如下：</p>
<pre><code>+ (<span class="keyword">void</span>)load {
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
        Swizzle([<span class="built_in">UIScrollView</span> class], <span class="keyword">@selector</span>(init), <span class="keyword">@selector</span>(swizzled_init));
    });
}

- (instancetype)swizzled_init
{
    <span class="keyword">id</span> obj = [<span class="keyword">self</span> swizzled_init];
    <span class="built_in">UIScrollView</span> *scrollView = (<span class="built_in">UIScrollView</span> *)obj;
    <span class="keyword">if</span> (!scrollView<span class="variable">.delegate</span>) {
        <span class="comment">//scrollView.delegate = [UIScrollViewDelegateDummyStub sharedStub];</span>
    }
    <span class="keyword">return</span> obj;
}
</code></pre><p>这段代码是什么作用呢？</p>
<p><span style="color:red"><strong>我们之前提了<code>UITableViewDelegate</code>不是必需，因此，为了能够抓去所有UITableView的代码，我们会提供一个内置的默认delegate(当时的实现存在bug，没有实现heightForRowAtIndexPath方法)</strong></span>。</p>
<p>而且，为了防止我们的delegate覆盖了有delegate的情况，我们还特地做了<code>!scroll.delegate</code>的判断。</p>
<p>按照我们的预期设想，存在两种时间顺序情况：</p>
<ol>
<li>我们的init先执行，此时肯定会进入我们设置默认的逻辑；然后当外部代码调用<code>tableview.delegate = xxx</code>的时候，会把我们这个替换掉，不会影响正常的逻辑。</li>
<li>我们的init后执行（比如某些子类覆盖的情况），那这样的话，当子类已经设置好<code>delegate</code>后，压根不会进入我们的设置逻辑。</li>
</ol>
<p><strong>然而，就是这一小段看起来无错的代码导致了UC的App出现了文章开头的Bug。</strong></p>
<h3 id="逆向分析UITableViewController">逆向分析UITableViewController</h3><p>基于<strong>10.2</strong>的UIKit，我们通过汇编来分析<code>-[UITableViewController setTableView:]</code>的流程：</p>
<pre><code>     <span class="comment">// 保存寄存器</span>
-&gt;  <span class="number">0x18c84c640</span> &lt;+<span class="number">0</span>&gt;:   stp    x26, x25, [sp, <span class="preprocessor">#-<span class="number">0x50</span>]!</span>
    <span class="number">0x18c84c644</span> &lt;+<span class="number">4</span>&gt;:   stp    x24, x23, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x18c84c648</span> &lt;+<span class="number">8</span>&gt;:   stp    x22, x21, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    <span class="number">0x18c84c64c</span> &lt;+<span class="number">12</span>&gt;:  stp    x20, x19, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    <span class="number">0x18c84c650</span> &lt;+<span class="number">16</span>&gt;:  stp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span>

    <span class="comment">// 获取原先UITableViewController的旧tableView</span>
    <span class="number">0x18c84c654</span> &lt;+<span class="number">20</span>&gt;:  add    x29, sp, <span class="preprocessor">#<span class="number">0x40</span>            ; =<span class="number">0x40</span> </span>
    <span class="number">0x18c84c658</span> &lt;+<span class="number">24</span>&gt;:  mov    x20, x0
    <span class="number">0x18c84c65c</span> &lt;+<span class="number">28</span>&gt;:  mov    x0, x2
    <span class="number">0x18c84c660</span> &lt;+<span class="number">32</span>&gt;:  bl     <span class="number">0x1851c8090</span>               ; objc_retain
    <span class="number">0x18c84c664</span> &lt;+<span class="number">36</span>&gt;:  mov    x19, x0
    <span class="number">0x18c84c668</span> &lt;+<span class="number">40</span>&gt;:  adrp   x8, <span class="number">124100</span>
    <span class="number">0x18c84c66c</span> &lt;+<span class="number">44</span>&gt;:  ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xd78</span>]</span>
    <span class="number">0x18c84c670</span> &lt;+<span class="number">48</span>&gt;:  mov    x0, x20
    <span class="number">0x18c84c674</span> &lt;+<span class="number">52</span>&gt;:  bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c678</span> &lt;+<span class="number">56</span>&gt;:  mov    x29, x29
    <span class="number">0x18c84c67c</span> &lt;+<span class="number">60</span>&gt;:  bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue

    <span class="comment">// 比较旧的tableview和新的tableview</span>
    <span class="number">0x18c84c680</span> &lt;+<span class="number">64</span>&gt;:  mov    x21, x0
    <span class="number">0x18c84c684</span> &lt;+<span class="number">68</span>&gt;:  cmp    x21, x19

    <span class="comment">// 如果两个tableView一致，直接返回</span>
    <span class="number">0x18c84c688</span> &lt;+<span class="number">72</span>&gt;:  b.eq   <span class="number">0x18c84c7d4</span>               ; &lt;+<span class="number">404</span>&gt;

    <span class="comment">// 获取旧的tableView的datasource</span>
    <span class="number">0x18c84c68c</span> &lt;+<span class="number">76</span>&gt;:  adrp   x8, <span class="number">124074</span>
    <span class="number">0x18c84c690</span> &lt;+<span class="number">80</span>&gt;:  ldr    x23, [x8, <span class="preprocessor">#<span class="number">0x2e0</span>]</span>
    <span class="number">0x18c84c694</span> &lt;+<span class="number">84</span>&gt;:  mov    x0, x21
    <span class="number">0x18c84c698</span> &lt;+<span class="number">88</span>&gt;:  mov    x1, x23
    <span class="number">0x18c84c69c</span> &lt;+<span class="number">92</span>&gt;:  bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c6a0</span> &lt;+<span class="number">96</span>&gt;:  mov    x29, x29
    <span class="number">0x18c84c6a4</span> &lt;+<span class="number">100</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue


    <span class="comment">// 从self的成员对象便宜792处取出UIFilteredDataSource</span>
    <span class="number">0x18c84c6a8</span> &lt;+<span class="number">104</span>&gt;: mov    x22, x0
    <span class="number">0x18c84c6ac</span> &lt;+<span class="number">108</span>&gt;: adrp   x8, <span class="number">124145</span>
    <span class="number">0x18c84c6b0</span> &lt;+<span class="number">112</span>&gt;: ldrsw  x8, [x8, <span class="preprocessor">#<span class="number">0x7ac</span>]</span>
    <span class="number">0x18c84c6b4</span> &lt;+<span class="number">116</span>&gt;: ldr    x8, [x20, x8]
    <span class="number">0x18c84c6b8</span> &lt;+<span class="number">120</span>&gt;: cmp    x22, x20
    <span class="number">0x18c84c6bc</span> &lt;+<span class="number">124</span>&gt;: ccmp   x22, x8, <span class="preprocessor">#<span class="number">0x4</span>, ne</span>

    <span class="comment">// 如果不一致，把旧的tableview的datasource 置为nil</span>
    <span class="number">0x18c84c6c0</span> &lt;+<span class="number">128</span>&gt;: b.ne   <span class="number">0x18c84c6d8</span>               ; &lt;+<span class="number">152</span>&gt;
    <span class="number">0x18c84c6c4</span> &lt;+<span class="number">132</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c6c8</span> &lt;+<span class="number">136</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c0</span>]</span>
    <span class="number">0x18c84c6cc</span> &lt;+<span class="number">140</span>&gt;: mov    x2, <span class="preprocessor">#<span class="number">0x0</span></span>
    <span class="number">0x18c84c6d0</span> &lt;+<span class="number">144</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c6d4</span> &lt;+<span class="number">148</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 获取旧的tableview的delegate</span>
    <span class="number">0x18c84c6d8</span> &lt;+<span class="number">152</span>&gt;: adrp   x8, <span class="number">124074</span>
    <span class="number">0x18c84c6dc</span> &lt;+<span class="number">156</span>&gt;: ldr    x24, [x8, <span class="preprocessor">#<span class="number">0x7d8</span>]</span>
    <span class="number">0x18c84c6e0</span> &lt;+<span class="number">160</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c6e4</span> &lt;+<span class="number">164</span>&gt;: mov    x1, x24
    <span class="number">0x18c84c6e8</span> &lt;+<span class="number">168</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c6ec</span> &lt;+<span class="number">172</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c6f0</span> &lt;+<span class="number">176</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
        <span class="number">0x18c84c6f4</span> &lt;+<span class="number">180</span>&gt;: mov    x25, x0
    <span class="number">0x18c84c6f8</span> &lt;+<span class="number">184</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release

    <span class="comment">// 判断旧的delegate是不是当前的UITableViewController</span>
    <span class="number">0x18c84c6fc</span> &lt;+<span class="number">188</span>&gt;: cmp    x25, x20
    <span class="number">0x18c84c700</span> &lt;+<span class="number">192</span>&gt;: b.ne   <span class="number">0x18c84c718</span>               ; &lt;+<span class="number">216</span>&gt;
    <span class="number">0x18c84c704</span> &lt;+<span class="number">196</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c708</span> &lt;+<span class="number">200</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c8</span>]</span>

    <span class="comment">// 如果不是，就把旧的tableview的delegate置为nil</span>
    <span class="number">0x18c84c70c</span> &lt;+<span class="number">204</span>&gt;: mov    x2, <span class="preprocessor">#<span class="number">0x0</span></span>
    <span class="number">0x18c84c710</span> &lt;+<span class="number">208</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c714</span> &lt;+<span class="number">212</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c718</span> &lt;+<span class="number">216</span>&gt;: adrp   x8, <span class="number">124080</span>
    <span class="number">0x18c84c71c</span> &lt;+<span class="number">220</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xe80</span>]</span>
    <span class="number">0x18c84c720</span> &lt;+<span class="number">224</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c724</span> &lt;+<span class="number">228</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c728</span> &lt;+<span class="number">232</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c72c</span> &lt;+<span class="number">236</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c730</span> &lt;+<span class="number">240</span>&gt;: mov    x25, x0

    <span class="comment">// 将uitableviewcontroller的tableview通过setView:置为新的</span>
    <span class="number">0x18c84c734</span> &lt;+<span class="number">244</span>&gt;: adrp   x8, <span class="number">124076</span>
    <span class="number">0x18c84c738</span> &lt;+<span class="number">248</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x4b0</span>]</span>
    <span class="number">0x18c84c73c</span> &lt;+<span class="number">252</span>&gt;: mov    x0, x20
    <span class="number">0x18c84c740</span> &lt;+<span class="number">256</span>&gt;: mov    x2, x19
    <span class="number">0x18c84c744</span> &lt;+<span class="number">260</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 新的tableview的datasource判断是不是为空，为空通过_applyDefaultDataSourceToTable将其UIFilteredDataSource</span>
    <span class="number">0x18c84c748</span> &lt;+<span class="number">264</span>&gt;: adrp   x8, <span class="number">124080</span>
    <span class="number">0x18c84c74c</span> &lt;+<span class="number">268</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x810</span>]</span>
    <span class="number">0x18c84c750</span> &lt;+<span class="number">272</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c754</span> &lt;+<span class="number">276</span>&gt;: mov    x2, x25
    <span class="number">0x18c84c758</span> &lt;+<span class="number">280</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c75c</span> &lt;+<span class="number">284</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c760</span> &lt;+<span class="number">288</span>&gt;: mov    x1, x23
    <span class="number">0x18c84c764</span> &lt;+<span class="number">292</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c768</span> &lt;+<span class="number">296</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c76c</span> &lt;+<span class="number">300</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c770</span> &lt;+<span class="number">304</span>&gt;: mov    x23, x0
    <span class="number">0x18c84c774</span> &lt;+<span class="number">308</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c778</span> &lt;+<span class="number">312</span>&gt;: cbnz   x23, <span class="number">0x18c84c790</span>          ; &lt;+<span class="number">336</span>&gt;
    <span class="number">0x18c84c77c</span> &lt;+<span class="number">316</span>&gt;: adrp   x8, <span class="number">124100</span>
    <span class="number">0x18c84c780</span> &lt;+<span class="number">320</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xd80</span>]</span>
    <span class="number">0x18c84c784</span> &lt;+<span class="number">324</span>&gt;: mov    x0, x20
    <span class="number">0x18c84c788</span> &lt;+<span class="number">328</span>&gt;: mov    x2, x19
    <span class="number">0x18c84c78c</span> &lt;+<span class="number">332</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 新的tableview的delegaate判断是不是为空，为空通过将delegate置为self（即当前的UITableViewController）</span>
    <span class="number">0x18c84c790</span> &lt;+<span class="number">336</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c794</span> &lt;+<span class="number">340</span>&gt;: mov    x1, x24
    <span class="number">0x18c84c798</span> &lt;+<span class="number">344</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c79c</span> &lt;+<span class="number">348</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c7a0</span> &lt;+<span class="number">352</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c7a4</span> &lt;+<span class="number">356</span>&gt;: mov    x23, x0
    <span class="number">0x18c84c7a8</span> &lt;+<span class="number">360</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release


    <span class="number">0x18c84c7ac</span> &lt;+<span class="number">364</span>&gt;: cbnz   x23, <span class="number">0x18c84c7c4</span>          ; &lt;+<span class="number">388</span>&gt;
    <span class="number">0x18c84c7b0</span> &lt;+<span class="number">368</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c7b4</span> &lt;+<span class="number">372</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c8</span>]</span>
    <span class="number">0x18c84c7b8</span> &lt;+<span class="number">376</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c7bc</span> &lt;+<span class="number">380</span>&gt;: mov    x2, x20
    <span class="number">0x18c84c7c0</span> &lt;+<span class="number">384</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c7c4</span> &lt;+<span class="number">388</span>&gt;: mov    x0, x25
    <span class="number">0x18c84c7c8</span> &lt;+<span class="number">392</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c7cc</span> &lt;+<span class="number">396</span>&gt;: mov    x0, x22
    <span class="number">0x18c84c7d0</span> &lt;+<span class="number">400</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c7d4</span> &lt;+<span class="number">404</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c7d8</span> &lt;+<span class="number">408</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release

    <span class="comment">// 恢复寄存器</span>

    <span class="number">0x18c84c7dc</span> &lt;+<span class="number">412</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c7e0</span> &lt;+<span class="number">416</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span>
    <span class="number">0x18c84c7e4</span> &lt;+<span class="number">420</span>&gt;: ldp    x20, x19, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    <span class="number">0x18c84c7e8</span> &lt;+<span class="number">424</span>&gt;: ldp    x22, x21, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    <span class="number">0x18c84c7ec</span> &lt;+<span class="number">428</span>&gt;: ldp    x24, x23, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x18c84c7f0</span> &lt;+<span class="number">432</span>&gt;: ldp    x26, x25, [sp], <span class="preprocessor">#<span class="number">0x50</span></span>
    <span class="number">0x18c84c7f4</span> &lt;+<span class="number">436</span>&gt;: b      <span class="number">0x1851c8150</span>               ; objc_release
</code></pre><ul>
<li>一看到adrp, ldr的搭配，基本可以确定是取某个方法进行调用。</li>
<li>看到一大堆的<code>bl objc_retain</code>，<code>bl objc_release</code>，不用管，反正都是ARC帮我们自动插入的。</li>
<li>可以看出，当传入给UITableViewController的tableView含有<code>dataSource</code>和<code>delegate</code>，UITableViewController都不会对其进行处理；否则会进行一个默认的设置。</li>
</ul>
<p>我自己理解后转写的伪代码如下：</p>
<pre><code><span class="built_in">UITableView</span> *oldTableView = [<span class="keyword">self</span> __existingTableView]; 

<span class="keyword">if</span> (oldTableView == xxxtableView) {
    <span class="keyword">return</span> 
} <span class="keyword">else</span> {
    <span class="keyword">id</span> oldDataSource = [oldTableView dataSource];
    <span class="comment">// x21 被赋值成了oldTableView, x22 oldDataSource</span>

    <span class="comment">// 取UITableViewController 792偏移的成员变量 filteredDataSource</span>
    <span class="keyword">id</span> filteredDataSource = [<span class="keyword">self</span> _filteredDataSource];

    <span class="keyword">if</span> (oldDataSource != filteredDataSource) 
    {

    } <span class="keyword">else</span> {
        [oldTableView setDataSource:<span class="literal">nil</span>];
    }

    <span class="keyword">id</span> oldDelegate = [oldTableView delegate];
    <span class="comment">// x25 被赋值了oldDelegate</span>

    <span class="keyword">if</span> (oldeDelegate != <span class="keyword">self</span>)
    {
        <span class="keyword">goto</span> <span class="comment">//</span>
    } <span class="keyword">else</span> {
        [oldTableView setDelegate:<span class="literal">nil</span>];
    }

    <span class="keyword">id</span> oldRefreshControl = [oldTableView _refreshControl];
    <span class="comment">// x25 被赋值了oldRefreshControl</span>

    [<span class="keyword">self</span> setView:xxtableView];
    [xxxtableView _setRefreshControl:oldRefreshControl];

    <span class="keyword">id</span> newDataSource = [xxxtableview dataSource];
    <span class="keyword">if</span> (!newDataSource) {
        [<span class="keyword">self</span> _applyDefaultDataSourceToTable:xxxTableView];
    }

    <span class="keyword">id</span> newDelegate = [xxxtableview delegate];
    <span class="keyword">if</span> (!newDelegate) {
        [xxxTableView setDelegate:<span class="keyword">self</span>];
    }
}
</code></pre><h3 id="结论">结论</h3><p>通过上面对汇编和伪代码的理解，我们可以很轻易的得出结论：当我们处于第一种情形的实现，我们将<code>tableview.delegate</code>设置成了我们的stub。因为不为空，所以<code>UITableViewController</code>默认不会对其进行处理，而由于我们当时没有提供stub对于<code>heightForRowAtIndexPath</code>的实现，导致出现了UC的bug。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做XXXSDK的时候，我hook的<code>UITableView</code>的<code>setDelegate:</code>方法。整个SDK在接入手淘、天猫以及闲鱼等其他App的时候都没啥问题。</p>
<p>上周，UC的同学突然找到说，给我说了如下图所示的]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微信高性能线上日志系统xlog剖析]]></title>
    <link href="http://satanwoo.github.io/2017/07/30/xlog/"/>
    <id>http://satanwoo.github.io/2017/07/30/xlog/</id>
    <published>2017-07-30T02:05:14.000Z</published>
    <updated>2017-07-30T02:08:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="微信高性能线上日志系统xlog剖析">微信高性能线上日志系统xlog剖析</h3><p>做移动开发的同学经常会遇到一个头疼的问题，就是当用户反馈一些问题，又比较冷僻难以复现的时候（不是Crash），常常就会陷入一筹莫展的境地。因此，很多人就研发了相关的监控系统，比如一些知名的APM来监测帧率、内存、电量等等，将这些数据进行采集、合并再上报至专门的平台供开发测试同学查看。但是这些APM往往都是粗粒度的监控，究其原因就在于如果特别精细的进行监控，线上的性能会吃不消，一些监控反而影响了用户的正常使用。</p>
<p>说了这么多，抛开获取数据方面的难度不提，线上监控的本质还是在于信息（日志）记录，而端上的日志记录存在一个社会主义初级阶段的供需矛盾：</p>
<p><strong>即实时细粒度的日志记录的性能落差和日志的完整不丢失无法兼顾。</strong></p>
<p>如果你要高性能、细粒度的记录日志，那你势必大量使用内存。而大量使用使用内存，万一没电了、程序突然崩了，这些中间态的日志还没持久化，就相当于白费了精力；而如果你想保证可靠性，那你就需要经常实时落盘。我们知道，写磁盘的行为是会设计用户态和内核态的切换，在高流畅性的要求下是绝对会影响性能了，而且这还不是你开多线程能够解决的问题。</p>
<h3 id="写磁盘为什么会非常慢">写磁盘为什么会非常慢</h3><p>现如今、几乎所有的操作系统在管理内存的时候，基本采用了页式管理的策略。即将连续的内存空间（注意空间，不是地址）换成了一个个页式大小。这样的好处有几点：</p>
<ol>
<li>按页这种大小进行管理、可以有效的减少内存碎片的粒度。</li>
<li>按页加载，可以充分利用磁盘上的交换空间，使得程序使用的空间能大大超过内存限制。</li>
</ol>
<blockquote>
<p>当然，iOS设备上不存在交换空间，但是也依然按照页式结构进行内存管理。</p>
</blockquote>
<p>回到为什么写磁盘会慢的问题上。我们一般会把内存中的数据进行持久化储存到磁盘上。但是写入磁盘并不是你想写就立刻写的，数据是通过flush的方式从内存写回到磁盘，一般有如下几种情况：</p>
<ol>
<li>通过页的<code>flag</code>标记为有改动，操作系统定时将这种脏页写回到磁盘上，时机不可控。</li>
<li>调用用户态的写接口-&gt;触发内核态的<code>sys_write</code>-&gt;文件系统将数据写回磁盘。</li>
</ol>
<p><strong><b style="color:red">乍一看上述第二种方式非常适合写日志，但是其包含两个非常明显的问题：</b></strong></p>
<ul>
<li>文件系统处于效率不会立刻将数据写回到磁盘（比如磁道寻址由于机械操作的原因相对非常耗时），而是以Block块的形式缓存在队列中，经过排序、合并到达一定比例之后再写回磁盘。</li>
<li>这种方式在将数据写回到磁盘时，需要经历两次拷贝。一次是把数据从用户态拷贝到内核态，需要经历上下文切换；还有一次是内核空间到硬盘上真正的数据拷贝。当切换次数过于频繁，整体性能也会下降。</li>
</ul>
<p>基于上述这些问题，<code>xlog</code>采用了<code>mmap</code>的方案进行日志系统的设计：</p>
<blockquote>
<p>mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。</p>
</blockquote>
<p>除了系能耐，使用mmap还能保证日志的完整性，因为如下这些情况下回自动回写磁盘：</p>
<ul>
<li>内存不足</li>
<li>进程 crash</li>
<li>调用 msync 或者 munmap</li>
<li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li>
</ul>
<h3 id="xlog源码分析">xlog源码分析</h3><p><code>xlog</code>的代码主要分为两块，面向上层的使用封装<code>xlogger</code>，暴露了一系列的借口。以及核心的<code>appender</code>和<code>log</code>等。</p>
<h4 id="log_buffer">log_buffer</h4><p><code>log_buffer</code>其目的是封装了一个对mmap/传统内存操作的数据结构。其核心思想就是将上层的操作转换对实际开辟出来的日志缓存地址进行读写（也封装了加密压缩操作等等）。我们以写操作为例子进行剖析：</p>
<pre><code><span class="keyword">bool</span> LogBuffer::Write(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _length) {
    <span class="comment">// 一些异常处理，不说了</span>
    <span class="keyword">if</span> (<span class="literal">NULL</span> == _data || <span class="number">0</span> == _length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">if</span> (buff_.Length() == <span class="number">0</span>) {
        <span class="keyword">if</span> (!__Reset()) <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">size_t</span> before_len = buff_.Length();
    <span class="keyword">size_t</span> write_len = _length;

    <span class="keyword">if</span> (is_compress_) {
        <span class="comment">// 是否开启压缩</span>
        cstream_.avail_in = (uInt)_length;
        cstream_.next_in = (Bytef*)_data;

        uInt avail_out = (uInt)(buff_.MaxLength() - buff_.Length());
        cstream_.next_out = (Bytef*)buff_.PosPtr();
        cstream_.avail_out = avail_out;

        <span class="keyword">if</span> (Z_OK != deflate(&amp;cstream_, Z_SYNC_FLUSH)) {
            <span class="keyword">return</span> <span class="literal">false</span>;
        }

        write_len = avail_out - cstream_.avail_out;
    } <span class="keyword">else</span> {
          <span class="comment">// 1. 写入数据到mmap文件或者内存当中</span>
        buff_.Write(_data, _length);
    }

    <span class="comment">// 2. 检查之前尝试加密但是还剩的未能成功加密的数据长度</span>
    before_len -= remain_nocrypt_len_;

    AutoBuffer out_buffer;
    <span class="keyword">size_t</span> last_remain_len = remain_nocrypt_len_;

    <span class="comment">// 3. 异步加密，更新未能加密的数据长度</span>
    log_crypt_-&gt;CryptAsyncLog((<span class="keyword">char</span>*)buff_.Ptr() + before_len, write_len + remain_nocrypt_len_, out_buffer, remain_nocrypt_len_);

    <span class="comment">// 4. 将加密的文本重新写入到之前最后一次加密的数据结尾位置</span>
    buff_.Write(out_buffer.Ptr(), out_buffer.Length(), before_len);

    <span class="comment">// 5. 更新数据</span>
    before_len += out_buffer.Length();
    buff_.Length(before_len, before_len);

    <span class="comment">// 6. 添加一下加密的长度之类的辅助信息补充在真实数据之后，主要用于解密时候用</span>
    log_crypt_-&gt;UpdateLogLen((<span class="keyword">char</span>*)buff_.Ptr(), (<span class="keyword">uint32_t</span>)(out_buffer.Length() - last_remain_len));

    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><p>不难看出，整体上就是对写入的数据进行加密，如果有压缩的需求同时进行压缩。并将修改后的数据存入真正的mmap文件/内存缓存中。</p>
<p>如果不能理解的话，可以看下我画的这幅图进行表示：</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-30%20%E4%B8%8A%E5%8D%889.58.00.png?raw=true" alt=""></p>
<h4 id="appender">appender</h4><p><code>xlog</code>方案真正的核心实际上只有一个appender文件，本质上的思路都比较清晰，将添加日志分为同步写和异步写。异步写的方式比较常用，下文会基于这个分析。</p>
<p><strong><span style="color:red">首先是日志系统的初始化配置</span></strong></p>
<pre><code>assert(_dir);
assert(_nameprefix);

<span class="keyword">if</span> (!sg_log_close) {
    __writetips2file(<span class="string">"appender has already been opened. _dir:%s _nameprefix:%s"</span>, _dir, _nameprefix);
    <span class="keyword">return</span>;
}

 <span class="comment">// 1. 设置真正的添加log信息函数，供上层调用</span>
xlogger_SetAppender(&amp;xlogger_appender);

<span class="comment">//mkdir(_dir, S_IRWXU|S_IRWXG|S_IRWXO);</span>
boost::filesystem::create_directories(_dir);
<span class="keyword">tickcount_t</span> tick;
tick.gettickcount();
__del_timeout_file(_dir);

<span class="keyword">tickcountdiff_t</span> del_timeout_file_time = <span class="keyword">tickcount_t</span>().gettickcount() - tick;

tick.gettickcount();

<span class="keyword">char</span> mmap_file_path[<span class="number">512</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(mmap_file_path, <span class="keyword">sizeof</span>(mmap_file_path), <span class="string">"%s/%s.mmap2"</span>, sg_cache_logdir.empty()?_dir:sg_cache_logdir.c_str(), _nameprefix);

<span class="keyword">bool</span> use_mmap = <span class="literal">false</span>;
<span class="comment">// 2. 尝试使用mmap</span>
<span class="keyword">if</span> (OpenMmapFile(mmap_file_path, kBufferBlockLength, sg_mmmap_file))  {
    sg_log_buff = <span class="keyword">new</span> LogBuffer(sg_mmmap_file.data(), kBufferBlockLength, <span class="literal">true</span>, _pub_key);
    use_mmap = <span class="literal">true</span>;
} <span class="keyword">else</span> {
    <span class="comment">// 3. 失败了回退到普通内存的方案</span>
    <span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[kBufferBlockLength];
    sg_log_buff = <span class="keyword">new</span> LogBuffer(buffer, kBufferBlockLength, <span class="literal">true</span>, _pub_key);
    use_mmap = <span class="literal">false</span>;
}

 <span class="number">4.</span> 注意点<span class="number">1</span>!!!!!!!!!!!!!!!!!!!!
<span class="keyword">if</span> (<span class="literal">NULL</span> == sg_log_buff-&gt;GetData().Ptr()) {
    <span class="keyword">if</span> (use_mmap &amp;&amp; sg_mmmap_file.is_open())  CloseMmapFile(sg_mmmap_file);
    <span class="keyword">return</span>;
}


<span class="number">5.</span> 注意点<span class="number">2</span>!!!!!!!!!!!!!!!!
AutoBuffer buffer;
sg_log_buff-&gt;Flush(buffer);

<span class="function">ScopedLock <span class="title">lock</span><span class="params">(sg_mutex_log_file)</span></span>;
sg_logdir = _dir;
sg_logfileprefix = _nameprefix;
sg_log_close = <span class="literal">false</span>;
appender_setmode(_mode);
lock.unlock();

<span class="keyword">char</span> mark_info[<span class="number">512</span>] = {<span class="number">0</span>};
get_mark_info(mark_info, <span class="keyword">sizeof</span>(mark_info));

<span class="keyword">if</span> (buffer.Ptr()) {
    __writetips2file(<span class="string">"~~~~~ begin of mmap ~~~~~\n"</span>);
    __log2file(buffer.Ptr(), buffer.Length());
    __writetips2file(<span class="string">"~~~~~ end of mmap ~~~~~%s\n"</span>, mark_info);
}

 <span class="number">6.</span> 添加一些关于xlog自身的信息
<span class="keyword">tickcountdiff_t</span> get_mmap_time = <span class="keyword">tickcount_t</span>().gettickcount() - tick;


<span class="keyword">char</span> appender_info[<span class="number">728</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(appender_info, <span class="keyword">sizeof</span>(appender_info), <span class="string">"^^^^^^^^^^"</span> __DATE__ <span class="string">"^^^"</span> __TIME__ <span class="string">"^^^^^^^^^^%s"</span>, mark_info);

xlogger_appender(<span class="literal">NULL</span>, appender_info);
<span class="keyword">char</span> logmsg[<span class="number">64</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"del time out files time: %"</span> PRIu64, (<span class="keyword">int64_t</span>)del_timeout_file_time);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"get mmap time: %"</span> PRIu64, (<span class="keyword">int64_t</span>)get_mmap_time);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_URL: "</span> MARS_URL);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_PATH: "</span> MARS_PATH);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_REVISION: "</span> MARS_REVISION);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_BUILD_TIME: "</span> MARS_BUILD_TIME);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_BUILD_JOB: "</span> MARS_TAG);

<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"log appender mode:%d, use mmap:%d"</span>, (<span class="keyword">int</span>)_mode, use_mmap);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

BOOT_RUN_EXIT(appender_close);
</code></pre><p><strong>有几点需要特别注意点：</strong></p>
<ul>
<li>注意点1:    如果我们尝试打开mmap成功了，但是mmap对应的数据地址是NULL，那我们必须停止映射。因为NULL所代表的地址处于内核态，一旦映射了，势必造成Crash。</li>
<li>注意点2：使用mmap的情况下，如果上次应用断电了、Crash，日志的信息还是存在的，但是并不一定能及时的转换成我们想要的日志文件。因此我们首先检查下mmap文件里面有没有数据，有的话先把这部分转换成日志。</li>
</ul>
<p>而通过上层添加的日志，都会通过之前的<code>xlogger_appender</code>进行调用，进而往下层的<code>__appender_async</code> 记录日志。</p>
<h4 id="__appender_async">__appender_async</h4><p><code>__appender_async</code> 需要和其异步dump线程一起搭配看，是两段非常有意思的代码，它涉及了一个将mmap/内存数据写回到磁盘的策略。</p>
<p><strong><span style="color:red">首先是添加日志：</span></strong></p>
<pre><code><span class="keyword">static</span> void __appender_async(<span class="keyword">const</span> XLoggerInfo* _info, <span class="keyword">const</span> <span class="keyword">char</span>* _log) {
    ScopedLock lock(sg_mutex_buffer_async);
    <span class="keyword">if</span> (NULL == sg_log_buff) <span class="keyword">return</span>;

    <span class="keyword">char</span> temp[<span class="number">16</span>*<span class="number">1024</span>] = {<span class="number">0</span>};       <span class="comment">//tell perry,ray if you want modify size.</span>
    PtrBuffer log_buff(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));
    log_formater(_info, _log, log_buff);

    <span class="keyword">if</span> (sg_log_buff-&gt;GetData().Length() &gt;= kBufferBlockLength*<span class="number">4</span>/<span class="number">5</span>) {
       <span class="keyword">int</span> ret = snprintf(temp, <span class="keyword">sizeof</span>(temp), <span class="string">"[F][ sg_buffer_async.Length() &gt;= BUFFER_BLOCK_LENTH*4/5, len: %d\n"</span>, (<span class="keyword">int</span>)sg_log_buff-&gt;GetData().Length());
       log_buff.Length(ret, ret);
    }

    <span class="keyword">if</span> (!sg_log_buff-&gt;Write(log_buff.Ptr(), (unsigned <span class="keyword">int</span>)log_buff.Length())) <span class="keyword">return</span>;

     <span class="comment">// mmap/内存超出一定限度就写通知异步线程写回到文件中。</span>
    <span class="keyword">if</span> (sg_log_buff-&gt;GetData().Length() &gt;= kBufferBlockLength*<span class="number">1</span>/<span class="number">3</span> || (NULL!=_info &amp;&amp; kLevelFatal == _info-&gt;level)) {
       sg_cond_buffer_async.notifyAll();
    }
}
</code></pre><p><strong><span style="color:red">其次是异步线程Dump成日志</span></strong></p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __async_log_thread() {
    <span class="keyword">while</span> (<span class="literal">true</span>) {

        <span class="function">ScopedLock <span class="title">lock_buffer</span><span class="params">(sg_mutex_buffer_async)</span></span>;

        <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_log_buff) <span class="keyword">break</span>;

        AutoBuffer tmp;
        sg_log_buff-&gt;Flush(tmp);
        lock_buffer.unlock();

        <span class="keyword">if</span> (<span class="literal">NULL</span> != tmp.Ptr())  __log2file(tmp.Ptr(), tmp.Length());

        <span class="keyword">if</span> (sg_log_close) <span class="keyword">break</span>;

        sg_cond_buffer_async.wait(<span class="number">15</span> * <span class="number">60</span> *<span class="number">1000</span>);
    }
}
</code></pre><p>不难看出，整个日志的主要策略就是利用mmap将日志写入到磁盘映射上，当超过三分之一的时候通知异步线程去写日志。</p>
<p>这样就利用了mmap的实时性、完整性打造了一个逻辑非常清晰易懂的日志，整体架构图如下：</p>
<p><img src="https://blog.desmondyao.com/image/mars-xlog/xlog.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="微信高性能线上日志系统xlog剖析">微信高性能线上日志系统xlog剖析</h3><p>做移动开发的同学经常会遇到一个头疼的问题，就是当用户反馈一些问题，又比较冷僻难以复现的时候（不是Crash），常常就会陷入一筹莫展的境地。因此，很多人就研发了相关的监控系统，比]]>
    </summary>
    
      <category term="C" scheme="http://satanwoo.github.io/tags/C/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Macho文件（二）- 消失的__OBJC段与新生的__DATA段]]></title>
    <link href="http://satanwoo.github.io/2017/06/29/Macho-2/"/>
    <id>http://satanwoo.github.io/2017/06/29/Macho-2/</id>
    <published>2017-06-29T15:22:32.000Z</published>
    <updated>2017-06-29T15:40:03.000Z</updated>
    <content type="html"><![CDATA[<p>在上文中，我们提到了有个神秘的<code>__OBJC</code>段，Runtime的许多机制就是依赖于它。但是无论我怎么搜索网上相关的资料、苹果的官方文档，都发现找不到这个段了。</p>
<p>一脸懵逼。没事，打开class-dump，看看它怎么处理的。嘿嘿，果不其然，在Class-Dump的代码里，有着如下注释：</p>
<blockquote>
<p>@0xced Old ABI has an <strong>OBJC segment. New ABI has a </strong>DATA,__objc_info section</p>
</blockquote>
<p>通俗解释来说，我们先如今使用的都是Objective-C2.0，所以原先的<code>__OBJC</code>段的东西都不存在了，而是存入了<code>__DATA</code>段里。所以，我们就以如下这张图来探究下这些与Runtime加载有关的节。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_1.png?raw=true" alt=""></p>
<h4 id="__objc_imageinfo节"><code>__objc_imageinfo</code>节</h4><p>这个节可以看作是区别Objective-C 1.0与2.0的区别。从苹果的<strong>OBJC源码</strong>中能看到这个节的数据结构定义（去除Swift相关）如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">uint32_t</span> version; <span class="comment">// currently 0</span>
    <span class="keyword">uint32_t</span> flags;
} objc_image_info;
</code></pre><p>其中<code>version</code>这个字段目前永远为0。<code>flags</code>是用于做表示需要支持的特性的，比如是否需要/支持 <code>Garbage Collection</code>。</p>
<pre><code>SupportsGC          = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,  <span class="comment">// image supports GC</span>
  RequiresGC          = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,  <span class="comment">// image requires GC</span>

<span class="keyword">if</span> (ii.flags &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) {
    <span class="comment">// App wants GC. </span>
    <span class="comment">// Don't return yet because we need to </span>
    <span class="comment">// check the AppleScriptObjC exception.</span>
    wantsGC = YES;
}
</code></pre><h4 id="__objc__classlist节"><code>__objc _classlist</code>节</h4><p>这个节列出了所有的<code>class</code>（<strong>metaclass自身也是一种class</strong>）。</p>
<p>以计算器举例：我们先从<strong>MachoView</strong>找出一段数据，这个数据代表的就是class结构体所在的地址，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_2.png?raw=true" alt=""></p>
<p>通过hopper查看地址：<code>000000010002A128</code>，得到如下结果：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_3.png?raw=true" alt=""></p>
<p>内存地址（还没rebase过）中包含一个类本身的含义是什么意思呢？这都需要从Runtime里面来说起。</p>
<p>我们假设说我们有个类A，其父类为AA。有两个A类型的实例<code>a1, a2</code>。</p>
<p>我们都知道在真正调用<code>[a haha]</code>的方法的时候，实质上是通过<code>objc_msgSend</code>执行一系列的函数查询来找到真正的函数IMP，进而产生函数调用的。</p>
<p>由于objc_msgSend的调用返回值是不确定的，需要根据不同的状态来返回，比如ARM64下的<a href="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/">Indirect Result Location</a>。因此其本身的实现需要通过汇编来，我们截取最终要的一段ARM64的汇编如下：</p>
<pre><code><span class="comment">// 1. 定义全局函数符号 _objc_msgSend</span>
ENTRY _objc_msgSend

<span class="comment">// 2. 为Exception做准备</span>
UNWIND _objc_msgSend, NoFrame
MESSENGER_START

<span class="comment">// 3. 逻辑实现体</span>
cmp    x0, #<span class="number">0</span>            <span class="comment">// nil check and tagged pointer check</span>
<span class="tag">b</span><span class="class">.le</span>    LNilOrTagged        <span class="comment">//  (MSB tagged pointer looks negative)</span>
ldr    x13, [x0]        <span class="comment">// x13 = isa</span>
and    x16, x13, <span class="id">#ISA_MASK</span>    <span class="comment">// x16 = class    </span>
LGetIsaDone:
    CacheLookup NORMAL        <span class="comment">// calls imp or objc_msgSend_uncached</span>
</code></pre><ul>
<li>X0是函数调用者，即Self，比较其和nil的关系，如果是nil（或者tagged pointer）就走另外一种分支。<strong><span style="color:red">通过此，我们也不难理解为什么可以对nil发送消息了</span></strong></li>
<li>根据self所在的地址，取其成员变量<code>isa</code>。</li>
<li><code>x16 = x13 &amp; MASK</code>，也就意味着<code>x16</code>指向了内存里面的对应<code>A class</code>对象（<div style="color:red">注意：不是A class的实例对象）</div></li>
<li>上述为什么要对<code>ISA</code>进行一个mask的位与操作，主要原因和Tagged Pointer类似，理由就不再赘述。</li>
<li><p>执行<code>CacheLookUp</code>，具体的代码流程简要如下：</p>
<pre><code><span class="class">.macro</span> CacheLookup
<span class="comment">// x1 = SEL, x16 = isa</span>
ldp    x10, x11, [x16, <span class="hexcolor">#CAC</span>HE]    <span class="comment">// x10 = buckets, x11 = occupied|mask</span>
and    w12, w1, w11        <span class="comment">// x12 = _cmd &amp; mask</span>
add    x12, x10, x12, LSL #<span class="number">4</span>    <span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span>
<span class="comment">// x9 = key, x17 = _imp</span>
ldp    x9, x17, [x12]        <span class="comment">// {x9, x17} = *bucket</span>
<span class="number">1</span>:    cmp    x9, x1            <span class="comment">// if (bucket-&gt;sel != _cmd)</span>
    <span class="tag">b</span><span class="class">.ne</span>    <span class="number">2</span>f            <span class="comment">//     scan more</span>
    CacheHit $<span class="number">0</span>            <span class="comment">// call or return imp</span>

<span class="number">2</span>:    <span class="comment">// not hit: x12 = not-hit bucket</span>
    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span>
    cmp    x12, x10        <span class="comment">// wrap if bucket == buckets</span>
    <span class="tag">b</span><span class="class">.eq</span>    <span class="number">3</span>f
    ldp    x9, x17, [x12, #-<span class="number">16</span>]!    <span class="comment">// {x9, x17} = *--bucket</span>
    <span class="tag">b</span>    <span class="number">1</span>b            <span class="comment">// loop</span>

<span class="number">3</span>:    <span class="comment">// wrap: x12 = first bucket, w11 = mask</span>
    add    x12, x12, w11, UXTW #<span class="number">4</span>    <span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span>

<span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span>
<span class="comment">// The slow path may detect any corruption and halt later.</span>

ldp    x9, x17, [x12]        <span class="comment">// {x9, x17} = *bucket</span>
<span class="number">1</span>:    cmp    x9, x1            <span class="comment">// if (bucket-&gt;sel != _cmd)</span>
    <span class="tag">b</span><span class="class">.ne</span>    <span class="number">2</span>f            <span class="comment">//     scan more</span>
    CacheHit $<span class="number">0</span>            <span class="comment">// call or return imp</span>

<span class="number">2</span>:    <span class="comment">// not hit: x12 = not-hit bucket</span>
    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span>
    cmp    x12, x10        <span class="comment">// wrap if bucket == buckets</span>
    <span class="tag">b</span><span class="class">.eq</span>    <span class="number">3</span>f
    ldp    x9, x17, [x12, #-<span class="number">16</span>]!    <span class="comment">// {x9, x17} = *--bucket</span>
    <span class="tag">b</span>    <span class="number">1</span>b            <span class="comment">// loop</span>

<span class="number">3</span>:    <span class="comment">// double wrap</span>
    JumpMiss $<span class="number">0</span>

.endmacro
</code></pre></li>
</ul>
<p>我们接着再来读读这段汇编。</p>
<ul>
<li><code>x16</code>承接上段汇编，是<code>A class</code>的实体，取出其<code>cache</code>成员变量。</li>
<li><p>按照<code>_cmd</code>和<code>mask</code>的位运算，找出其在bucket数组中的偏移量。取出的数据结构是个<code>bucket_t</code>，如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">bucket_t</span> {
<span class="keyword">private</span>:
    <span class="keyword">cache_key_t</span> _key;
    IMP _imp;
}
</code></pre></li>
<li><p>从上述数据结构不难理解，<code>cache</code>对象里面存了一个bucket数组，用于进行<code>SEL</code>对应的<code>IMP</code>，缓存。<code>key</code>是<code>SEL</code>对应的地址。</p>
</li>
<li>如果地址相同，就代表命中，执行<strong>CacheHit</strong>，其实就是简单的<code>br x17</code>。由于此时<code>x17</code>是IMP，即对应的函数地址，直接跳过去就完事了，这个分支下的<code>objc_msgSend</code>就执行完成了。</li>
<li>那如果不相同，即命中的bucket里面不是我们要的<code>SEL</code>，就检查这个命中的桶是不是没有<code>SEL</code>，如果是空的，执行<code>__objc_msgSend_uncached</code>。这步后续开始就是去查找类方法列表-&gt;父类方法列表了。</li>
<li>如果不为空，否则就执行循环，进行查询。</li>
</ul>
<p>**<span style="color:red">一些细节知识：  </span></p>
<ol>
<li>.macro可以在汇编里面定义一段可以被复用的代码段。   </li>
<li>.1b 代表的是向回找label定义为1的代码片段起始；1f代表向下找label定义为1的代码片段起始。  </li>
<li>为什么在计算isa的时候先要位与一个mask，其原因在于现在的isa是一个兼具多种含义的指针。<br>**</li>
</ol>
<blockquote>
<p>本文重点不在讲述Runtime上，所以objc_msgSend的细节就不去更深入的探究了。</p>
</blockquote>
<p>所以，按照上述步骤来理解，我们可以发现，苹果实例对象的<code>objc_msgSend</code>的机制可以简要抽象如下图例子：</p>
<h4 id="__objc__catlist节"><code>__objc _catlist</code>节</h4><p>该节顾名思义，代表的就是程序里面有哪些<code>Category</code>。我们还是通过MachoView和Hopper来看一看：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_4.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_5.png?raw=trueg" alt=""></p>
<p>从Hopper里面看出的内容我们不难得到，<code>catlist</code>也对应着一个<code>Category_t</code>的实体，会在程序运行的过程中存在于内存中。这个结构体的数据定义如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">category_t</span> {
    <span class="keyword">const</span> <span class="keyword">char</span> *name;
    <span class="keyword">classref_t</span> cls;
    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;
    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;
    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;
    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties;
    <span class="comment">// Fields below this point are not always present on disk.</span>
    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *_classProperties;
}
</code></pre><h4 id="__objc_protolist"><code>__objc_protolist</code></h4><p>该节的理解也非常简单，代表的就是程序里面有哪些<code>Protocol</code>。数据结构定义如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">protocol_t</span> : objc_object {
    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;
    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;
    <span class="keyword">method_list_t</span> *instanceMethods;
    <span class="keyword">method_list_t</span> *classMethods;
    <span class="keyword">method_list_t</span> *optionalInstanceMethods;
    <span class="keyword">method_list_t</span> *optionalClassMethods;
    <span class="keyword">property_list_t</span> *instanceProperties;
    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span>
    <span class="keyword">uint32_t</span> flags;
    <span class="comment">// Fields below this point are not always present on disk.</span>
    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;
    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;
    <span class="keyword">property_list_t</span> *_classProperties;
}
</code></pre><h4 id="__objc_classrefs"><code>__objc_classrefs</code></h4><p>一开始这个节的意义我实在是没看懂。实在不理解在已经存在classlist这个数据节的情况下，为啥还是需要用这个类。后来经过一番实验发现，该节的目的是为了标记这个类究竟有没有被引用</p>
<p>那有没有被引用的意义是什么？<strong><span style="color:red">可以包瘦身。如果在MachoView中都能直观告诉我们没有引用的类甚至是方法，都可以直接剔除了。</span></strong></p>
<blockquote>
<p>但是，作为一名经常奋战在包瘦身一线的同学，我可以直接告诉你，上述的想法是大错特错的。苹果这种可以利用字符串拼接从而调用大量runtime的方法，绝对坑哭了做包瘦身的人。</p>
</blockquote>
<p><strong><span style="color:blue">嘿嘿，不过其实这样也没啥难度，下一篇我会写一个基于Macho的包瘦身方案，绝对轻便简洁，不用基于AST来分析各种调用关系，这里卖个关子。</span></strong></p>
<h4 id="__objc_selrefs"><code>__objc_selrefs</code></h4><p>这节的原理同上，告诉你究竟有哪些SEL对应的字符串被引用了。</p>
<h4 id="__objc_superrefs"><code>__objc_superrefs</code></h4><p>这节虽然中字面意义上我们知道，是对超类（即父类）的引用，但是没理解啊，为什么要有这么一个破玩意。<br>不懂就一点点摸索，从MachoView里面来看，数据对应的地址还是指向一个个在classlist出现的类实体。</p>
<p>通过和classlist里面出现的数据进行diff对比，如下图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_5.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_6.png?raw=true" alt=""></p>
<p>可以发现，所有出现的<code>objc_superrefs</code>都是会被继承的类。那么，为什么要单独设计这样一个来存放这样的信息呢？</p>
<p><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong><br><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong><br><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong></p>
<p>真正的原因如下：<br>我们知道，我们在子类调用一个方法的时候，为了调用上层的父类的实现（如果有），常常会写出一个<code>[super message]</code>的代码。而这样的代码，在底层是会转换成调用<code>objc_msgSendSuper2</code>。而其接受的参数，第一个为结构体<code>objc_super2</code>，第二个为<code>SEL</code>。其中<code>objc_super2</code>的定义如下：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> </span>{
    id receiver;
    Class current_class;
};
</code></pre><p>为了构造这样的数据结构体，在汇编层面会将<code>[super message]</code>转换成如下的汇编指令：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_7.png?raw=true" alt=""></p>
<p>注意看红框内的汇编代码，我们来分步骤解释下整体的汇编结构：</p>
<ul>
<li>首先在调用<code>[ViewController viewDidLoad]</code>的时候，x0是self（ViewController的实例），x1是@selector（viewDidLoad）。</li>
<li>0x1000046c0 偏移的地方将<code>sp</code>向下申请了<code>48</code>(0x30)bytes的空间。</li>
<li>0x1000046c4 将<code>SP</code>的地址存到的<code>x8</code>寄存器中。 <div style="color:red">这个X8寄存器会很关键</div></li>
<li>0x1000046d0 通过<strong>adrp</strong>指令加载内存数据中的一个page，根据这个page的offset找到对应的<code>viewDidLoad</code>方法的ref。存入<code>x9</code>。</li>
<li>0x1000046f8 通过<code>x9</code>寄存器中ref指向的地址，以该地址为内存读取真正的SEL，存入<code>x1</code>。</li>
</ul>
<p><strong><span style="color:red">至此，调用objc_msgSendSuper2的第二个参数准备完毕</span></strong>，我们再来看看第一个的参数是如何设置的。</p>
<ul>
<li><p>0x1000046d8 同样的方式，加载一个page的0x78的偏移位置的数据，点进去会发现是个class地址，存到<code>x10</code>中。<br><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_8.png?raw=true" alt=""></p>
</li>
<li><p>然后，就轮到我们的栈空间出场了。我们先把<code>x0</code>存到sp处，然后再把<code>x10</code>，也就是上面说的class地址存入<code>sp+8 (str x10, [sp, #0x8]</code>。</p>
</li>
<li>最后，还记得我们之前提到的<code>x8</code>寄存器吗？我们之前可是将<code>sp</code>的值赋予了<code>x8</code>了。所以，在<code>1000046fc x0, x8</code>这个地方，我们将<code>x8</code>的值赋予了<code>x0</code>。<strong><span style="color:red">至此，调用objc_msgSendSuper2的第一个参数也准备完毕</span></strong></li>
</ul>
<p>最后附上<code>objc_msgSendSuper2</code>的代码供参考，逻辑非常简单，不再赘述。</p>
<pre><code>ENTRY _objc_msgSendSuper2
    UNWIND _objc_msgSendSuper2, NoFrame
    MESSENGER_START

    ldp    x0, x16, <span class="attr_selector">[x0]</span>        <span class="comment">// x0 = real receiver, x16 = class</span>
    ldr    x16, <span class="attr_selector">[x16, #SUPERCLASS]</span>    <span class="comment">// x16 = class-&gt;superclass</span>
    CacheLookup <span class="attribute">NORMAL</span>

    END_ENTRY _objc_msgSendSuper2
</code></pre><p><strong><span style="color:red">等等，心急的读者会问：你说了那么一大堆，你还是没解释到底为什么要存在superrefs?</span></strong></p>
<p><strong>在Objective-C的设计里面，函数就是函数，它并不知道自己属于哪个类里面。换句通俗的话来说，必须是你（编译器）说去哪个class实体的方法列表里面寻找调用，才会真正的去找对应的方法，函数自身不知道是父类还是子类。同时，由于苹果的设计原因，一个类初始化的实例，是不具备了解superclass的条件的，只有通过isa对应的类实体才能获得。因此，在构建<code>objc_msgSendSuper2</code>的第一个参数的时候，就不如指在编译期定其对应的<code>current_class</code>，以方便后续的<code>superclass</code>方法列表查找。</strong></p>
<p><strong><span style="color:red">而且，也必须在编译期间，根据当前的类，去定义<code>current_class</code>这个字段的值，不然当我们有多个层级的继承关系时，在运行时如何从单一的self参数构建正确的向上查找层级，就当前的OC设计里，就做不到了。</span></strong></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_9.png?raw=true" alt=""></p>
<blockquote>
<p>C++里面，对于函数来说，是可以明确知道对应的所属类的。究其原因，在于C++的不同类，都是不同的命名空间，调用父类的方法时，需明确指定父类的命名空间，如BASE::method。</p>
</blockquote>
<h4 id="__objc_const"><code>__objc_const</code></h4><p>这个节的含义是所有初始化的常量的都显示在这。但是很多人都对此节有着巨大的误解，认为<strong><span style="color:red"><code>const int k = 5</code></span></strong>对应的数据会存放在<code>__objc_const</code>节中。</p>
<p>但是这是大错特错的，在代码里声明的<code>const</code>类型，实质上都属于<code>__TEXT</code>段，并属于其中的<code>const</code>节。而在<code>__objc_const</code>中存放的，是一些需要在类加载过程中用到的<code>readonly data</code>。具体这个<code>readonly data</code>包含了如下（但不限于）的数据结构：</p>
<pre><code><span class="comment">// 只读数据</span>
<span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;
    <span class="keyword">property_list_t</span> *baseProperties;

    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> {
        <span class="keyword">return</span> baseMethodList;
    }
};

<span class="comment">// 方法列表</span>
<span class="keyword">struct</span> <span class="keyword">method_list_t</span>:entsize_list_tt {
     <span class="keyword">uint32_t</span> entsizeAndFlags;
     <span class="keyword">uint32_t</span> count;
     Element first;
}

<span class="comment">// 方法实体</span>
<span class="keyword">struct</span> <span class="keyword">method_t</span> {
    SEL name;
    <span class="keyword">const</span> <span class="keyword">char</span> *types;
    IMP imp;
}
</code></pre><p>关于<code>readonly data</code>后续会再开一个章节单独讲解。</p>
<h3 id="结尾">结尾</h3><p>基本上MachO 关于Runtime涉及的主要的类就分析到这了，下一次继续剖析其他细枝末节。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上文中，我们提到了有个神秘的<code>__OBJC</code>段，Runtime的许多机制就是依赖于它。但是无论我怎么搜索网上相关的资料、苹果的官方文档，都发现找不到这个段了。</p>
<p>一脸懵逼。没事，打开class-dump，看看它怎么处理的。嘿嘿，果不其然，]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入剖析Macho (1)]]></title>
    <link href="http://satanwoo.github.io/2017/06/13/Macho-1/"/>
    <id>http://satanwoo.github.io/2017/06/13/Macho-1/</id>
    <published>2017-06-13T15:25:34.000Z</published>
    <updated>2017-06-13T15:34:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="起因">起因</h3><p>最近在公司里和一些同事搞了一些东西，略微底层。于是希望借这个机会好好把<code>Macho</code>相关的知识点梳理下。</p>
<p>虽然网上关于<code>Macho</code>的文章介绍一大堆，但是我希望能够从<code>Macho</code>的构成，加载过程以及需要了解的相关背景角度去进行分析，每一个点都力图深入。也会在这篇文章最后打造一个类似<code>class-dump</code>的小型工具。</p>
<h3 id="程序启动加载的过程">程序启动加载的过程</h3><p>当你点击一个icon启动应用程序的时候，系统在内部大致做了如下几件事：</p>
<ul>
<li>内核（OS Kernel）创建一个进程，分配虚拟的进程空间等等，加载动态链接器。</li>
<li>通过动态链接器加载主二进制程序引用的库、绑定符号。</li>
<li>启动程序</li>
</ul>
<p>虽然简要概述很简单，但是有几个需要特别主要的地方：</p>
<ol>
<li>二进制程序的格式是怎么样的？内核是如何加载它的？</li>
<li>内核是如何得知要使用哪种动态链接器的？</li>
<li>动态链接器和静态链接器的区别是啥？</li>
<li>程序在运行前究竟要做哪些步骤？顺序是怎么样的？</li>
</ol>
<p><strong>带着这些问题，我将一步步来剖析整个过程</strong></p>
<h3 id="二进制程序格式">二进制程序格式</h3><p>在MacOS或者iOS上可执行的程序格式叫做<code>Macho-O</code>，它的主要成分如下图所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20150122/1421892661838860.gif" alt=""></p>
<ul>
<li>一个<code>mach_header</code>标记一些元信息，比如架构、CPU、大小端等等</li>
<li>多个<code>Load Command</code>告诉你究竟如何加载每个段的信息。</li>
<li>多个<code>Segement</code>及<code>Section</code>，包含了每个段自身的信息。包括一些数据、代码以及<del>段的执行权限</del>等等。</li>
</ul>
<p><strong><div style="color:red">需要注意的是，不仅仅是可执行文件是<code>Macho-O</code>，目标文件(.o)以及动态库，静态库都是<code>Mach-O</code>格式。</div></strong></p>
<p>所以，下面我们就用64位的定义从每个部分来介绍一下具体的数据结构：</p>
<h3 id="mach_header_64">mach_header_64</h3><p>这个结构体代表的都是<code>Mach-O</code>文件的一些元信息，它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p>
<p>从源码中可以看出，整个结构题定义如下：</p>
<pre><code><span class="keyword">struct</span> mach_header_64 {
    <span class="keyword">uint32_t</span>    magic;        <span class="comment">/* mach magic number identifier */</span>
    <span class="keyword">cpu_type_t</span>    cputype;    <span class="comment">/* cpu specifier */</span>
    <span class="keyword">cpu_subtype_t</span>    cpusubtype;    <span class="comment">/* machine specifier */</span>
    <span class="keyword">uint32_t</span>    filetype;    <span class="comment">/* type of file */</span>
    <span class="keyword">uint32_t</span>    ncmds;        <span class="comment">/* number of load commands */</span>
    <span class="keyword">uint32_t</span>    sizeofcmds;    <span class="comment">/* the size of all the load commands */</span>
    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* flags */</span>
    <span class="keyword">uint32_t</span>    reserved;    <span class="comment">/* reserved */</span>
};
</code></pre><ul>
<li><strong>magic</strong> 用于标识当前设备的是大端序还是小端序。如果是<code>0xfeedfacf(MH_MAGIC_64)</code>就是大端序，而<code>0xcffaedfe(MH_CIGAM_64)</code>是小端序，iOS系统上是小端序。</li>
<li><strong>cputype</strong> 标识CPU的架构，比如ARM，X86，i386等等，进行了宏观划分。</li>
<li><strong>cpusubtype</strong> 具体的CPU类型，区分不同版本的处理器。</li>
<li><strong>filetype</strong> 划分之前我们提到的文件类型，比如是可执行文件还是目标文件。</li>
<li><strong>ncmds</strong> 有几个<code>LoadCommands</code>，每个<code>LoadCommands</code>代表了一种<code>Segment</code>的加载方式。</li>
<li><strong>sizeofcmds</strong> <code>LoadCommand</code>的大小，主要用于划分Mach-O文件的‘区域’。</li>
<li><strong>flags</strong> 标记了一些dyld过程中的参数。</li>
<li><strong>reversed</strong> 没用。</li>
</ul>
<p>这里有个比较有意思的问题是，我为了验证大端序小端序的问题的时候，用了MacOS上的计算器进行<br>验证，本质上这应该是个小端序的应用程序，其二进制如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.12.33.png?raw=true" alt="屏幕快照 2017-06-11 下午3.12.33.png"> </p>
<p>但是在<code>otool</code>和<code>MachoView</code>上看出来都是<code>MH_MAGIC_64</code>，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.13.47.png?raw=true" alt="屏幕快照 2017-06-11 下午3.13.47.png"> </p>
<p>我擦，这下看了懵逼，难道是我理解错了？于是赶紧翻了下<code>class-dump</code>代码，其解析header部分代码如下：</p>
<pre><code>// 解析部分代码
_byteOrder = <span class="type">CDByteOrder_LittleEndian</span>;

<span class="type">CDDataCursor</span> *cursor = [[<span class="type">CDDataCursor</span> alloc] initWithData:data];
_magic = [cursor readBigInt32];
<span class="keyword">if</span> (_magic == <span class="type">MH_MAGIC</span> || _magic == <span class="type">MH_MAGIC_64</span>) {
    _byteOrder = <span class="type">CDByteOrder_BigEndian</span>;
} <span class="keyword">else</span> <span class="keyword">if</span> (_magic == <span class="type">MH_CIGAM</span> || _magic == <span class="type">MH_CIGAM_64</span>) {
    _byteOrder = <span class="type">CDByteOrder_LittleEndian</span>;
} <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="keyword">nil</span>;
}

// readBigInt32的代码
- (uint32_t)readBigInt32;
{
    uint32_t <span class="literal">result</span>;

    <span class="keyword">if</span> (_offset + sizeof(<span class="literal">result</span>) &lt;= [_data length]) {
        <span class="literal">result</span> = <span class="type">OSReadBigInt32</span>([_data bytes], _offset);
        _offset += sizeof(<span class="literal">result</span>);
    } <span class="keyword">else</span> {
        [<span class="type">NSException</span> <span class="keyword">raise</span>:<span class="type">NSRangeException</span> format:@<span class="string">"Trying to read past end in %s"</span>, __cmd];
        <span class="literal">result</span> = <span class="number">0</span>;
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>我们在用LLDB看下<code>_data</code>里面的内容指向的内存地址：</p>
<pre><code>(lldb) po _<span class="preprocessor">data</span>
&lt;OS_dispatch_data: <span class="preprocessor">data</span>[<span class="number">0x100600b40</span>] = { leaf, size = <span class="number">199520</span>, <span class="keyword">buf </span>= <span class="number">0x100281000</span> }&gt;
</code></pre><p>用<code>Xcode Memory</code>看下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.25.06.png?raw=true" alt="屏幕快照 2017-06-11 下午3.25.06.png"> </p>
<p>看起来是没错的。然后由于MacOSX本身是小端序的，<code>CFFAEDFE</code>这样的数据会被自动解析成<code>FE ED FA CF</code>。所以这样是有问题的。因此，<code>class-dump</code>采用了<code>OSReadBigInt32</code>的方式去解析：</p>
<pre><code><span class="constant">OS_INLINE</span>
<span class="constant">UInt32</span>
<span class="constant">OSReadSwapInt32</span>(
    volatile void               * base,
    volatile <span class="constant">UInt</span>                 offset
)
{
    <span class="class"><span class="keyword">union</span> <span class="title">lconv</span> {</span>
    <span class="constant">UInt32</span> ul;
    <span class="constant">UInt8</span>  uc[<span class="number">4</span>];
    } *inp, outv;

    <span class="regexp">//</span> 步骤<span class="number">1</span>
    inp = (<span class="class"><span class="keyword">union</span> <span class="title">lconv</span> *)((<span class="title">UInt8</span> *)<span class="title">base</span> + <span class="title">offset</span>);</span>

    /<span class="regexp">/ 步骤2
    outv.uc[0] = inp-&gt;uc[3];
    outv.uc[1] = inp-&gt;uc[2];
    outv.uc[2] = inp-&gt;uc[1];
    outv.uc[3] = inp-&gt;uc[0];

    ／／ 步骤3
    return (outv.ul);
}</span>
</code></pre><p>这个方法会利用<code>union</code>的特性，进行数据交换。我们还是用刚刚的例子来验证：</p>
<ul>
<li>步骤1按照默认方式读出数据：<code>FE ED FA CF</code>。</li>
<li>步骤2进行交换，地址从低到高，分别是<code>FE ED FA CF</code>。</li>
<li>步骤3利用<code>union</code>的特性，当成一个32的数输出，按照默认小端序解析，会成为<code>CF FA ED FE</code>。也即是<code>MH_CIGAM_64</code>，是小端序。</li>
</ul>
<p><strong>其实按照MachoView的解析方式，将<code>MH_CIGAM_64</code>和<code>MH_MAGIC_64</code>理解成MACHO文件和当前平台的编码顺序是否一致更好，如果解析出来是<code>MH_CIGAM_64</code>则表示不一致；否则一致。</strong></p>
<h3 id="Segment（段）">Segment（段）</h3><p>讲完了<code>Mach-O</code>文件的header部分，我们需要进行Load Commands部分。但是在这之前，我想先大致介绍下Mach-O中的Segment及其下属的Section（节），让大家能更好的理解Load Commands。</p>
<p>从整体上来说，<code>Mach-O</code>里面包含的段有以下这些：</p>
<ul>
<li><strong>__TEXT</strong> 代码段/只读数据段</li>
<li><strong>__PAGEZERO</strong> Catch访问NULL指针的非法操作的段</li>
<li><strong>__DATA</strong> 数据段</li>
<li><strong>__LINKEDIT</strong> 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等。</li>
<li><strong>__OBJC</strong> 包含会被<code>Objective Runtime</code>使用到的一些数据。</li>
</ul>
<blockquote>
<p>关于<code>__OBJC</code>这个段，我是一脸懵逼的，从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述，具体让我研究研究再说。</p>
</blockquote>
<h4 id="Section（节）">Section（节）</h4><p>刚刚我们提到的<code>__TEXT</code>和<code>__DATA</code>段都分别有下属的节。</p>
<p><strong><div style="color:red">之所以按照段-&gt;节的方式组织，是因为同一个段下的节，在内存的权限相同，可以不完全按照页大小进行对齐，节省内存空间。而对外整体暴露段，在装载程序的时候完整映射成一个vma，可以更好的做内存对齐。</div></strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT.</strong>text</td>
<td><strong>只有</strong>可执行的机器码</td>
</tr>
<tr>
<td><strong>TEXT.</strong>cstring</td>
<td>去重后的C字符串</td>
</tr>
<tr>
<td><strong>TEXT.</strong>const</td>
<td>初始化过的常量</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs</td>
<td>符号桩。本质上是一小段会直接跳入lazybinding的表对应项指针指向的地址的代码。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stub_helper</td>
<td>辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>unwind_info</td>
<td>用于存储处理异常情况信息</td>
</tr>
<tr>
<td><strong>TEXT.</strong>eh_frame</td>
<td>调试辅助信息</td>
</tr>
<tr>
<td><strong>DATA.</strong>data</td>
<td>初始化过的可变的数据</td>
</tr>
<tr>
<td><strong>DATA.</strong>nl_symbol_ptr</td>
<td>非lazy-binding的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td><strong>DATA.</strong>la_symbol_ptr</td>
<td>lazy-binding的指针表，每个表项中的指针一开始指向stub_helper</td>
</tr>
<tr>
<td><strong>DATA.</strong>const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td><strong>DATA.</strong>mod_init_func</td>
<td>初始化函数，在main之前调用</td>
</tr>
<tr>
<td><strong>DATA.</strong>mod_term_func</td>
<td>终止函数，在main返回之后调用</td>
</tr>
<tr>
<td><strong>DATA.</strong>bss</td>
<td>没有初始化的静态变量</td>
</tr>
<tr>
<td><strong>DATA.</strong>common</td>
<td>没有初始化过的符号声明</td>
</tr>
</tbody>
</table>
<p>其中，比较难以理解的可能是<code>__la_symbol_ptr</code>，让我们还是来以计算器的例子来理解：</p>
<ul>
<li>我们先从MachoView上找一个<code>stub</code>，比如[xxxx -&gt; _CFRelease]。</li>
<li>其数据是<strong>FF256A7C0000</strong>，结合这个节是在__TEXT段中，我猜测是应该一段汇编代码的16进制表示。</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.48.21.png?raw=true" alt="屏幕快照 2017-06-12 上午10.48.21.png"> </p>
<ul>
<li>从Hopper中打开，查看对应偏移量的stub含义：</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.40.50.png?raw=true" alt="屏幕快照 2017-06-12 上午10.40.50.png"> </p>
<p>我们可以看到这段代码的16进制表达就是：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%883.47.50.png?raw=true" alt="屏幕快照 2017-06-13 下午3.47.50.png"> </p>
<p>从上图不难看出，stub的含义就是跳转到以<code>__la_symbol_ptr</code>对应表项数据所指向地址的代码。</p>
<ul>
<li>跳入以后，我们可以看到如下代码：</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.41.02.png?raw=true" alt="屏幕快照 2017-06-12 上午10.41.02.png"> </p>
<p>可以看到，在还没加载程序的时候，对应表项的数据还是<code>dq _CFRelease</code>。双击点进去看一下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%883.51.34.png?raw=true" alt="屏幕快照 2017-06-13 下午3.51.34.png"> </p>
<p>这里显示的应该是有点问题，如果全0的话是不可能使用lazy binding的。</p>
<p>我们还是用MachOView来看一下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.04.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.04.png"> </p>
<p>跳转到这个地址看看，没错了，处于stub_helper节里了：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.28.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.28.png"> </p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.33.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.33.png"> </p>
<blockquote>
<p><code>__la_symbol_ptr</code> 里面所有表项的数据都会被bind成<code>dyld_stub_helper</code>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="起因">起因</h3><p>最近在公司里和一些同事搞了一些东西，略微底层。于是希望借这个机会好好把<code>Macho</code>相关的知识点梳理下。</p>
<p>虽然网上关于<code>Macho</code>的文章介绍一大堆，但是我希望能够从<code>]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从FBTweak 源码剖析一些中阶知识]]></title>
    <link href="http://satanwoo.github.io/2017/06/01/FBTweak/"/>
    <id>http://satanwoo.github.io/2017/06/01/FBTweak/</id>
    <published>2017-06-01T15:43:05.000Z</published>
    <updated>2017-06-01T15:46:16.000Z</updated>
    <content type="html"><![CDATA[<p>在开发的过程中，我们进场要做一些类似于参数调整之类的琐碎问题。如果每次都通过<code>CMD + R</code>来编译运行查看效果，浪费的时间真是得不偿失。因此，在看到了<code>FBTweak</code>这个项目以后，就感觉比较有意思，让我们来对这个项目一探究竟。</p>
<h3 id="晕头转向的宏定义">晕头转向的宏定义</h3><p>打开项目，整个项目非常简单，抛去UI部分，主要使用的主API就是在<code>FBTweakInline.h</code>中的4个宏定义：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakInline</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakInline(category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakValue</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakValue(category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakBind</span><span class="params">(object_, property_, category_, collection_, name_, ...)</span></span> _FBTweakBind(object_, property_, category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakAction</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakAction(category_, collection_, name_, __VA_ARGS__)
</code></pre><p>看起来很简单，但是随便点一个深入进去看，就会发现如下这些令人头昏脑胀的宏定义。熟悉Facebook开源项目的人可能都知道，它们就好这口。所以在进行整个项目的介绍前，我们先大致分析下各个宏的作用。</p>
<pre><code>#define __FBTweakConcat_<span class="list">(<span class="keyword">X</span>, Y)</span> X ## Y
#define __FBTweakConcat<span class="list">(<span class="keyword">X</span>, Y)</span> __FBTweakConcat_<span class="list">(<span class="keyword">X</span>, Y)</span>

#define __FBTweakIndex<span class="list">(<span class="keyword">_1</span>, _2, _3, value, ...)</span> value
#define __FBTweakIndexCount<span class="list">(...)</span> __FBTweakIndex<span class="list">(<span class="keyword">__VA_ARGS__</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span>

#define __FBTweakDispatch1<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withoutRange
#define __FBTweakDispatch2<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withPossible
#define __FBTweakDispatch3<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withRange
#define _FBTweakDispatch<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __FBTweakConcat<span class="list">(<span class="keyword">__FBTweakDispatch</span>, __FBTweakIndexCount<span class="list">(<span class="keyword">__VA_ARGS__</span>)</span>)</span><span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible)</span>
</code></pre><h4 id="_FBTweakBind">_FBTweakBind</h4><p>我们以<code>_FBTweakBind</code>作为突破口，来进行深入分析。</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakBind</span><span class="params">(object_, property_, category_, collection_, name_, ...)</span></span> _FBTweakBind(object_, property_, category_, collection_, name_, __VA_ARGS__)
</code></pre><p>这个宏包了层皮，就是接受至少5个参数的可变参数，并将参数传递给<code>_FBTweakBind</code>这个宏。在这层定义中，我们看到了<code>...</code>和<code>__VA_ARGS__</code>。</p>
<p><code>...</code>对于一个宏/函数来说，意味着接受可变参数。这个参数的形参（换句话说，你要使用或者传递给其他函数的载体）就是<code>__VA_ARGS__</code>。</p>
<p>好，接下来我们看下<code>_FBTweakBind</code>，其定义如下：</p>
<pre><code><span class="hexcolor">#def</span>ine _FBTweakBind(object_, property_, category_, collection_, name_, ...) _FBTweakDispatch(_FBTweakBindWithoutRange, _FBTweakBindWithRange, _FBTweakBindWithPossible, __VA_ARGS__)(object_, property_, category_, collection_, name_, __VA_ARGS__)
</code></pre><p>卧槽，一开始看的时候，头大了，怎么两个括号呢？仔细一看，<code>_FBTweakBindWithoutRange</code>，<code>_FBTweakBindWithRange</code>， <code>_FBTweakBindWithPossible</code> 都是不同的宏定义。那么整个<code>_FBTweakBind</code>的作用就是根据可变参数，传递给<code>_FBTweakDispatch</code>，从上述三个宏定义中选择出一个对应的，然后继续调用宏展开。</p>
<p>好，再看<code>__FBTweakDispatch</code>，如下：</p>
<pre><code><span class="hexcolor">#def</span>ine _FBTweakDispatch(__withoutRange, __withRange, __withPossible, ...) __FBTweakConcat(__FBTweakDispatch, __FBTweakIndexCount(__VA_ARGS__))(__withoutRange, __withRange, __withPossible)
</code></pre><p>这个也比较绕，我们继续抽丝剥茧，可以发现，核心的本质就变成：</p>
<ul>
<li><code>__FBTweakIndexCount(args)</code> 返回一个具体数字（1、2、3）</li>
<li><code>__FBTweakConcat(__FBTweakDispatch, 数字)</code> 生成具体的宏定义Token，比如<code>__FBTweakDispatch1</code>，<code>__FBTweakDispatch2</code>之类的。</li>
<li>利用刚刚的token继续做函数展开。</li>
</ul>
<p><b>到这里，整体思路都没啥特别困难的，但是让我有点诧异的如下两个宏定义：</b></p>
<pre><code><span class="hexcolor">#def</span>ine __FBTweakIndex(_1, _2, _3, value, ...) value
<span class="hexcolor">#def</span>ine __FBTweakIndexCount(...) __FBTweakIndex(__VA_ARGS__, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)
</code></pre><p>我们刚刚提到，<code>__FBTweakIndexCount</code>会根据参数返回具体的数字，那它本质上是依靠<code>__FBTweakIndex</code>去返回第4个参数。（<code>_1, _2, _3</code>就是普通的宏展开占位符，别被骗了，和x, y, z没区别）。</p>
<p><b>好，这个<code>__FBTweakIndex</code>按定义来说，至少需要<span style="color:red">4个</span>参数，但是我在试了<code>__FBTweakIndexCount()</code>，他竟然也能给返回<span style="color:red">1</span></b>，这就让我懵逼了。</p>
<p>按照我的理解，当我传递参数为空的时候，<code>__VA_ARGS__</code>就是空，那么宏定义展开的时候，这个应该是不作数的，就导致缺少了一个参数啊？？？</p>
<p><b style="color:red">后来，我发现我思考错了，我从语法分析的角度去分析了这个宏，但是实际上，宏就是简单的“token”展开！！！</b></p>
<p>我们再来看看<code>__FBTweakIndex的定义</code>，展开后其实就是要了第4个参数，前面的都没啥用。</p>
<p>也就是说，我直接写</p>
<pre><code>__FBTweakIndex(..., <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
__FBTweakIndex(,, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
__FBTweakIndex(, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
</code></pre><p>这种虽然没意义的、甚至是直觉上觉得都不能编译通过的代码，都是<strong>合理正确的</strong>。</p>
<p>是不是有点懵逼，休息一下，消化一下。</p>
<p>好，我们假设我们获取了数字1，因此，新的宏展开为<code>_FBTweakBindWithoutRange</code>，定义如下：</p>
<pre><code><span class="number">#def</span>ine <span class="number">_</span>FBTweakBindWithoutRange(<span class="keyword">object</span><span class="number">_</span>, property<span class="number">_</span>, category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>) \
((^{ \
  FBTweak *<span class="number">__</span>bind<span class="number">_</span>tweak = <span class="number">_</span>FBTweakInlineWithoutRange(category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>); \
  <span class="number">_</span>FBTweakBindInternal(<span class="keyword">object</span><span class="number">_</span>, property<span class="number">_</span>, category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>, <span class="number">__</span>bind<span class="number">_</span>tweak); \
})())
</code></pre><p>这写法，也是醉了，我以前只是在JavaScript中看到过这样匿名函数自调用的写法，Facebook太强了。</p>
<p>整个过程继续抽丝剥茧，<code>_FBTweakInlineWithoutRange</code>会调用到如下函数：</p>
<pre><code><span class="comment">#define _FBTweakInlineWithPossibleInternal(category_, collection_, name_, default_, possible_) \</span>
((^{ <span class="string">\</span>
  <span class="comment">/* store the tweak data in the binary at compile time. */</span> <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString category__ = category_; <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString collection__ = collection_; <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString name__ = name_; <span class="string">\</span>
  __attribute__((used)) static <span class="literal">void</span> *default__ = (__bridge <span class="literal">void</span> *) ^{ <span class="keyword">return</span> default_; }; <span class="string">\</span>
  __attribute__((used)) static <span class="literal">void</span> *possible__ = (__bridge <span class="literal">void</span> *)  ^{ <span class="keyword">return</span> possible_; }; <span class="string">\</span>
  __attribute__((used)) static char *encoding__ = (char *)<span class="property">@encode</span>(__typeof__(default_)); <span class="string">\</span>
  __attribute__((used)) __attribute__((section (FBTweakSegmentName <span class="string">","</span> FBTweakSectionName))) static fb_tweak_entry entry = <span class="string">\</span>
    { &amp;category__, &amp;collection__, &amp;name__, (<span class="literal">void</span> *)&amp;default__, (<span class="literal">void</span> *)&amp;possible__, &amp;encoding__ }; <span class="string">\</span>
<span class="string">\</span>
  <span class="comment">/* find the registered tweak with the given identifier. */</span> <span class="string">\</span>
  FBTweakStore *store = [FBTweakStore sharedInstance]; <span class="string">\</span>
  FBTweakCategory *category = [store <span class="attribute">tweakCategoryWithName</span>:category__]; <span class="string">\</span>
  FBTweakCollection *collection = [category <span class="attribute">tweakCollectionWithName</span>:collection__]; <span class="string">\</span>
<span class="string">\</span>
  NSString *identifier = _FBTweakIdentifier(&amp;entry); <span class="string">\</span>
  FBTweak *__inline_tweak = [collection <span class="attribute">tweakWithIdentifier</span>:identifier]; <span class="string">\</span>
<span class="string">\</span>
  <span class="keyword">return</span> __inline_tweak; <span class="string">\</span>
})())
</code></pre><p>这里相对来说比较复杂，我们逐个知识点进行查看。</p>
<pre><code>__attribute__<span class="list">(<span class="list">(<span class="keyword">used</span>)</span>)</span> static FBTweakLiteralString category__ = category_<span class="comment">;</span>
</code></pre><p>这个前面出来了<code>__attribute__((used))</code>，它的作用是告诉编译器，我声明的这个符号是需要保留的。我们在开发iOS的过程中，常常会遇到有时候会报警告<code>xxx unused</code>，在某些优化的情况下，编译器甚至都不报警告，直接将我们进行了剔除，<b>这样在编译后(预处理、编译、汇编)生成的目标文件里就<span style="color:red">不</span>存在我们这个符号。</b></p>
<p>继续看这行，又出现了我们新的不熟悉的<code>__attribute__((section (FBTweakSegmentName &quot;,&quot; FBTweakSectionName)))</code></p>
<pre><code>__attribute__((used)) __attribute__((section (FBTweakSegmentName <span class="string">","</span> FBTweakSectionName))) <span class="keyword">static</span> fb_tweak_entry entry = \
       { &amp;category__, &amp;collection__, &amp;name__, (<span class="keyword">void</span> *)&amp;default__, (<span class="keyword">void</span> *)&amp;possible__, &amp;encoding__ };
</code></pre><p>我们知道，iOS里面函数代码一般存在于<code>__TEXT</code>段，数据部分一般存在于<code>__DATA</code>段。但是在每个段中，都存在着许多不同作用的节（section）。比如存储常量字符串的<code>__cfstring</code>等等。</p>
<p>因此，编译器提供了我们一种<code>__attribute__((section(&quot;xxx段，xxx节&quot;)</code>的方式让我们讲一个指定的数据储存到我们需要的节当中。</p>
<p><b style="color:red">上述基础知识很容易理解，但是我在实际读代码理解整个运行机制的时候，还是有点懵逼。</b></p>
<h3 id="令人困惑的指针和数据">令人困惑的指针和数据</h3><p>我们将上章节中的代码简单具象一下：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">NSString</span> *haha = <span class="string">@"Mingyi"</span>;
_attribute__((section (<span class="string">"__DATA, MinyiSpecific"</span>))) <span class="keyword">static</span> <span class="built_in">NSString</span> ** entry = &amp;haha;
</code></pre><p>我们看到，我们将<code>&amp;haha</code>所代表这个数据存入了<code>__DATA</code> Segment的<code>MinyiSpecific</code>Section中。</p>
<p>但是，<code>&amp;haha</code>的类型是一个<code>NSString **</code>，即指向指针的指针。换句话说，这个指针的指针的背后的含义是<code>haha</code>这个变量本身的地址。我们知道，苹果的程序在加载的过程中都会ASLR地址随机化，那我们对一个地址进行存储，有啥用呢？</p>
<p><b style="color:red">上述的理解，有个最大的误区，就是从运行时来理解了地址，而不是从编译后的目标文件来理解程序，什么意思呢？</b> </p>
<p>在我们这里，因为声明了常量字符串@”Mingyi”，在编译(而非程序运行)后，它就存在于可执行文件的<code>cfstring</code>这个节中，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.02.43.png?raw=true" alt=""></p>
<p>这个数据格式的起始地址偏移为<code>00000001 00003068</code>。</p>
<p>而由于我们使用的是静态变量<code>haha</code>，在编译后，也会生成一个指向刚刚那个常量字符串地址的数据。这个数据存在于<code>__DATA，__data</code>中，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.07.50.png?raw=true" alt=""></p>
<p>而<code>00000001 00003DC0</code>就是在代码中<code>&amp;haha</code>的含义。</p>
<p>无论是<code>3068</code>抑或是<code>3DC0</code>，它们的含义都是一个地址偏移，在程序加载运行的过程中，都要进行地址<strong>REBASE</strong>，去获得真正正确地址空间中的数据。但是由于我们的</p>
<pre><code>_attribute__<span class="list">(<span class="list">(<span class="keyword">section</span> <span class="list">(<span class="string">"__DATA, MinyiSpecific"</span>)</span>)</span>)</span> static NSString ** entry = &amp;haha<span class="comment">;</span>
</code></pre><p>是一个编译期的行为，因此这行语句的行为表征的还是存储没有rebase之前的相对地址偏移，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.11.55.png?raw=true" alt=""></p>
<p>好，至此，我们才将整个数据存入的部分搞懂。</p>
<p><strong>注意，iOS是小端序，即数据的高位在低地址。</strong></p>
<h3 id="镜像数据加载">镜像数据加载</h3><p>说完了数据存储，我们再来看看怎么从编译后的执行文件的节中读取出文件，代码如下：</p>
<pre><code>  <span class="keyword">static</span> <span class="keyword">uint32_t</span> _tweaksLoaded = <span class="number">0</span>;
  <span class="keyword">if</span> (OSAtomicTestAndSetBarrier(<span class="number">1</span>, &amp;_tweaksLoaded)) {
    <span class="keyword">return</span>;
  }

<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
  <span class="keyword">typedef</span> <span class="keyword">uint64_t</span> fb_tweak_value;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> section_64 fb_tweak_section;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header_64 fb_tweak_header;
<span class="preprocessor">#<span class="keyword">define</span> fb_tweak_getsectbynamefromheader getsectbynamefromheader_64</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
  <span class="keyword">typedef</span> <span class="keyword">uint32_t</span> fb_tweak_value;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> section fb_tweak_section;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header fb_tweak_header;
<span class="preprocessor">#<span class="keyword">define</span> fb_tweak_getsectbynamefromheader getsectbynamefromheader</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>


  FBTweakStore *store = [FBTweakStore sharedInstance];

  <span class="comment">// 1. 注意点</span>
  <span class="keyword">uint32_t</span> image_count = _dyld_image_count();
  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> image_index = <span class="number">0</span>; image_index &lt; image_count; image_index++) {
    <span class="keyword">const</span> fb_tweak_header *mach_header = (<span class="keyword">const</span> fb_tweak_header *)_dyld_get_image_header(image_index);

    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;

    <span class="comment">// 2.注意点</span>
    fb_tweak_entry *data = (fb_tweak_entry *)getsectiondata(mach_header, FBTweakSegmentName, FBTweakSectionName, &amp;size);
    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) {
      <span class="keyword">continue</span>;
    }
    <span class="keyword">size_t</span> count = size / <span class="keyword">sizeof</span>(fb_tweak_entry);
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) {
      fb_tweak_entry *entry = &amp;data[i];
      FBTweakCategory *category = [store tweakCategoryWithName:*entry-&gt;category];
      <span class="keyword">if</span> (category == nil) {
        category = [[FBTweakCategory alloc] initWithName:*entry-&gt;category];
        [store addTweakCategory:category];
      }

      FBTweakCollection *collection = [category tweakCollectionWithName:*entry-&gt;collection];
      <span class="keyword">if</span> (collection == nil) {
        collection = [[FBTweakCollection alloc] initWithName:*entry-&gt;collection];
        [category addTweakCollection:collection];
      }

      NSString *identifier = _FBTweakIdentifier(entry);
      <span class="keyword">if</span> ([collection tweakWithIdentifier:identifier] == nil) {
        FBTweak *tweak = _FBTweakCreateWithEntry(identifier, entry);

        <span class="keyword">if</span> (tweak != nil) {
          [collection addTweak:tweak];
        }
      }
    }
  }
}
</code></pre><ul>
<li>注意点1:通过dyld获取当前程序加载时候的image个数。什么是image个数呢？你的可执行文件就是一个image。那为什么又会存在多个image呢？如果你平时使用的都是静态库，那么在编译连接完成后，静态库这个scope就不存在了，所有的符号都互相匹配完成。但是呢，苹果自身比如<code>UIKIt</code>之类的库又是动态库，因此，你的可执行文件中会存在多个image。</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%8811.50.09.png?raw=true" alt=""></p>
<ul>
<li>注意点2:读取macho文件中对应的段和节中我们自己储存的数据。</li>
</ul>
<h3 id="修改同步映射">修改同步映射</h3><p>我们之前看到，在利用<code>FBTweakBind</code>可以将某个对象的属性和操作进行映射，同步修改。这里的机制看起来很复杂，其实非常简单，就是简单的利用了KVO。</p>
<p><code>FBTweak</code>就是想要修改的属性，其包含了多个<code>Observer</code>。在<code>FBTweak</code>的<code>currentValue</code>更改后，会利用观察者模式对每个<code>Observer</code>发送属性更新通知。而<code>FBTweak</code>的属性值改变则是和UI界面，利用KVO进行联动修改。</p>
<p>这里就没什么过于复杂的技术含量了，具体看下<code>FBTweak</code>和<code>_FBTweakColorViewController</code>代码就行。</p>
<h3 id="其余知识点:">其余知识点:</h3><ul>
<li><p><code>objc_precise_lifetime</code>的作用  </p>
<pre><code>__attribute__<span class="list">(<span class="list">(<span class="keyword">objc_precise_lifetime</span>)</span>)</span> id strongObject = _object<span class="comment">;</span>
</code></pre></li>
</ul>
<p>这行代码的作用就是确保ARC不会进行特殊的优化，提前将一些本来认为在Scope最后才释放的对象提前释放了。</p>
<ul>
<li><p><code>_Generic</code>是一个编译时的<a href="http://en.cppreference.com/w/c/language/generic" target="_blank" rel="external">泛型选择</a>，他能根据变量的类型兼容来输出不同的结果，比如：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> cbrt(X) _Generic((X), \</span>
          <span class="keyword">long</span> <span class="keyword">double</span>: cbrtl, \
              <span class="keyword">default</span>: cbrt,  \
<span class="comment">/*for clang*/</span> <span class="keyword">const</span> <span class="keyword">float</span>: cbrtf, \
                <span class="keyword">float</span>: cbrtf  \
)(X)

<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)
</span>{
    <span class="keyword">long</span> <span class="keyword">double</span> x = <span class="number">8.0</span>;
    <span class="keyword">const</span> <span class="keyword">float</span> y = <span class="number">3.375</span>;
    printf(<span class="string">"cbrt(8.0) = %Lg\n"</span>, cbrt(x)); <span class="comment">// selects the default cbrt</span>
    printf(<span class="string">"cbrtf(3.375) = %f\n"</span>, cbrt(y)); <span class="comment">// gcc: converts const float to float,</span>
                                            <span class="comment">// then selects cbrtf</span>
                                            <span class="comment">// clang: selects cbrtf for const float</span>
}
</code></pre></li>
</ul>
<p>上述代码就根据编译器的类型声明，选择不同的函数进行执行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发的过程中，我们进场要做一些类似于参数调整之类的琐碎问题。如果每次都通过<code>CMD + R</code>来编译运行查看效果，浪费的时间真是得不偿失。因此，在看到了<code>FBTweak</code>这个项目以后，就感觉比较有意思，让我们来对这个项目一探究竟。]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM64下Indirect Result Location摸索]]></title>
    <link href="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/"/>
    <id>http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/</id>
    <published>2017-04-22T19:00:36.000Z</published>
    <updated>2017-04-22T19:18:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ARM64下Indirect_Result_Location摸索">ARM64下Indirect Result Location摸索</h3><p>之前学习汇编的时候，大概了解了一些ARM64下寄存器的用途，比如<code>x0 - x7</code>作为函数传递使用。同时，<code>x0</code>也可以作为函数返回值时候的寄存器。</p>
<p>但是，今天在研究一些跟返回结构体相关的时候，发现返回值并不是放在<code>X0</code>寄存器中。上网搜索了一下资料，发现在<strong>ARM64下，当一个<code>Callee</code>函数返回的内容大于16bytes的时候，该内容会被存到一个内存地址当中，然后这个内存地址的值会存入寄存器<code>x8</code>。后续<code>Caller</code>函数在使用该返回值的时候，会从<code>X8</code>寄存器中取出内存地址，并从内存地址取出内容的值</strong></p>
<p>是不是有点绕，还是让我们来看个例子吧。</p>
<h3 id="原理">原理</h3><p>首先我根据<strong>大于16 bytes</strong>的要求定义了如下结构体：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">int64_t</span> i;
    <span class="keyword">int64_t</span> j;
    <span class="keyword">int64_t</span> k;
} MYStruct;
</code></pre><p>在ARM64下，该结构体默认按<code>4 bytes</code>对齐，每个<code>int64</code>占用<code>8 bytes</code>，因此结构体大小<code>24 bytes</code></p>
<p>我们定义如下函数，用于返回一个该结构体：</p>
<pre><code>- (MYStruct)testIndirectResultLocation:(int64_t)i1 second:(int64_t)i2 th:(int64_t)i3
{
    MYStruct s<span class="comment">;</span>
    s.i = i1<span class="comment">;</span>
    s.j = i2<span class="comment">;</span>
    s.k = i3<span class="comment">;</span>
    return s<span class="comment">;</span>
}
</code></pre><p>这个函数很简单，传入三个值。然后构造个局部变量<code>MYStruct s</code>，将其对应的成员变量按照刚刚的传入参数赋值，最后返回该结构体。</p>
<p>该函数调用<strong>在未优化的前提下</strong>的汇编结果如下：</p>
<pre><code>IndirectResultLocation`-[ViewController testIndirectResultLocation:second:th:]:
    <span class="comment">// 预留空间</span>
    &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>

    <span class="comment">// 存参</span>
    &lt;+<span class="number">4</span>&gt;:  str    x0, [sp, <span class="preprocessor">#<span class="number">0x38</span>]</span>
    &lt;+<span class="number">8</span>&gt;:  str    x1, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    &lt;+<span class="number">12</span>&gt;: str    x2, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">16</span>&gt;: str    x3, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">20</span>&gt;: str    x4, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>

    <span class="comment">// 赋值</span>
-&gt;  &lt;+<span class="number">24</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">28</span>&gt;: str    x0, [sp]
    &lt;+<span class="number">32</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">36</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">40</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>
    &lt;+<span class="number">44</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 将结构体存到x8寄存器的值代表的地址去</span>
    &lt;+<span class="number">48</span>&gt;: ldr    x0, [sp]
    &lt;+<span class="number">52</span>&gt;: str    x0, [x8]
    &lt;+<span class="number">56</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">60</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">64</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    &lt;+<span class="number">68</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 释放空间</span>
    &lt;+<span class="number">72</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>
    &lt;+<span class="number">76</span>&gt;: ret    
</code></pre><p>第一行：SP即<code>Stack Pointer</code>，向下减<code>0x40（64 bytes）</code>的大小，预先分配出函数需要用的栈空间。为什么要预留这么多的大小呢？首先按照<strong>Objective-C的函数调用规定，前两个参数必须是<code>self</code>和<code>selector</code>，也即会使用到寄存器<code>X0</code>和<code>X1</code>。然后该函数有三个形参，使用了<code>X2-X4</code>的寄存器</strong>。<br>上述这五个，大小占用了<strong>self(8 bytes) + selector(8 bytes) + 三个参数(24 bytes) = 40 bytes</strong>。那么还有<code>24 bytes</code>去干嘛了呢？</p>
<p>别忘了，我们在函数中可以声明了一个局部变量<code>MYStruct s</code>，该结构体大小是24 bytes。而在函数调用中使用到的变量，基本上都在栈区中开辟对应的空间进行暂存。</p>
<p>后续第二行到第六行非常简单易懂，就是把上述5个参数存到实际的栈区中去使用。按照这个存法以后，内存布局如下（注意高地址在上，低地址在下，ARM下的栈是向下增长）：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.48.35.png?raw=true" alt=""></p>
<p>将参数都存入到栈以后，我们就要对结构体进行赋值了，这些操作在第七行到第十二行之间。<br>将<strong>1赋值给[SP]，2赋值给[SP + #0x8]，3赋值给[SP + #0x10]</strong>。如果不理解啥意思的话，可以看下我自己转化的伪代码：</p>
<pre><code><span class="keyword">void</span> *address = &amp;s;
*(<span class="keyword">int64_t</span> *)(address) = <span class="number">1</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">8</span>) = <span class="number">2</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">16</span>) = <span class="number">3</span>;
</code></pre><p>赋值完以后，我们可以通过内存分布看下数据是否正确：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.30.06.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.29.53.png?raw=true" alt=""></p>
<p>当赋值完成后，就要进行结构体的返回了。这里不是简单的<code>mov x0, sp</code>之类的操作，而是一串和<code>X8</code>寄存器相关操作。</p>
<p>其实原理差不多，转化成伪代码的话，基本上是这样：</p>
<pre><code>void <span class="keyword">*</span>toSaveAddress = [x8];
void <span class="keyword">*</span>valueNowAddress = [sp];

<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress) = <span class="keyword">*</span>valueNowAddress;
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 8) = <span class="keyword">*</span>(valueNowAddress + 8);
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 16) = <span class="keyword">*</span>(valueNowAddress + 16);
</code></pre><p>操作完成后，释放空间即可。</p>
<h3 id="补充">补充</h3><p>其实ARM64在汇编层面实现的这么复杂， 我们在编程层面只要按照如下方式理解即可：</p>
<pre><code><span class="function">some_struct <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s = foo(<span class="number">1</span>, <span class="number">2</span>);
</code></pre><p>会被编译成：</p>
<pre><code><span class="function">some_struct* <span class="title">foo</span><span class="params">(some_struct* ret_val, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s; 
foo(&amp;s, <span class="number">1</span>, <span class="number">2</span>);
</code></pre><h3 id="后续">后续</h3><p>从本文中我们不难看出，ARM64针对不同大小的返回值都有着对应的<strong>Calling Convention</strong>。下次我准备来摸索下，处于<code>8 bytes - 16 bytes</code>之间的返回值究竟是怎么处理的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ARM64下Indirect_Result_Location摸索">ARM64下Indirect Result Location摸索</h3><p>之前学习汇编的时候，大概了解了一些ARM64下寄存器的用途，比如<code>x0 - x7</code>作为函数传递]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速计算两组数据源的变化的方法 - Doppelganger 源码剖析]]></title>
    <link href="http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/"/>
    <id>http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/</id>
    <published>2017-04-17T17:15:40.000Z</published>
    <updated>2017-04-17T17:24:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Doppelganger_源码剖析">Doppelganger 源码剖析</h3><p>性能优化系列一：如何快速的计算UITableView的数据量变换。</p>
<p>今天要介绍的是一个比较精简但是很实用的库：Doppelganger。平时我们经常会和<code>UITableView</code>或者<code>UICollectionView</code>打交道，所以数据源（dataSource）及其变化就非常重要。</p>
<p>如何高效的求解两次数据源之间的删除、增加以及移动（交换位置）就成为了一个可以显著加速的地方。</p>
<blockquote>
<p>备注：这里指的是将一定量的数据计算放在客户端来进行，而不是通过多次发送网络请求获取数据然后整体重新刷新。有人会问，什么情况下会有这样的需求呢？比如，你有个用户选项，可以支持按照倒序或者正序的方式进行布局，那这个时候，你直接在本地进行计算并展示差量布局计算，就要比从网络请求多次拉取整体重新刷新的效果赞很多。</p>
</blockquote>
<p>本文提到的<code>Doppelganger</code>其实就是一种对于上述需求的封装，提供了及其简化的数据源更新机制。抛开其性能不谈，我们先来看看其实现。</p>
<h4 id="数据结构">数据结构</h4><p>从需求不难看出，我们的数据结构需要支持如下潜在数据记录：</p>
<ul>
<li>改动类型：增加、删除、移动</li>
<li>改动索引：增加的话，是插入到哪行、删除的话是删除哪行、移动的话是从哪行移动到哪行。</li>
</ul>
<p>基于此，数据结构的定义就很显而易见了：</p>
<pre><code><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WMLArrayDiffType) {
    WMLArrayDiffTypeMove,
    WMLArrayDiffTypeInsert,
    WMLArrayDiffTypeDelete
};

<span class="class"><span class="keyword">@interface</span> <span class="title">WMLArrayDiff</span> : <span class="title">NSObject</span></span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) WMLArrayDiffType type;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> previousIndex;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> currentIndex;

<span class="keyword">@end</span>
</code></pre><p>其中，有些字段在某些类型下可以为空。</p>
<h4 id="计算变动">计算变动</h4><p>我们先简化下我们的模型，我们就是两个数组A和B，里面各自一堆不重复的数字，分别代表之前的数据源和现在的数据源。现在我们需要求得这两个数组之前提到的三种变化。</p>
<p><strong>首先是删除的计算，非常简单，只要计算在A中不在B中就可以：</strong></p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>然后是增加的计算，同样简单，只要计算在B中不在A中的：</strong></p>
<pre><code>NSSet *insertedObjects = ({
    NSMutableSet *<span class="keyword">set</span> = [currentSet mutableCopy];
    [<span class="keyword">set</span> minusSet:previousSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>最后就是计算那些即在A中又在B中的改变，对于这种计算，我们要得到在A中的原索引和现在的新索引。</strong></p>
<pre><code>- (<span class="type">NSArray</span> *)_moveDiffsWithDeletedObjects:(<span class="type">NSSet</span> *)deletedObjects insertedObjects:(<span class="type">NSSet</span> *)insertedObjects {    
    // <span class="type">TODO</span>: <span class="type">Improve</span> on O(n^<span class="number">2</span>)
    __block <span class="type">NSInteger</span> delta = <span class="number">0</span>;
    <span class="type">NSMutableArray</span> *<span class="literal">result</span> = [<span class="type">NSMutableArray</span> <span class="type">array</span>];
    [self.previousArray enumerateObjectsUsingBlock:^(id leftObj, <span class="type">NSUInteger</span> leftIdx, <span class="type">BOOL</span> *stop) {
        <span class="keyword">if</span> ([deletedObjects containsObject:leftObj]) {
            delta++;
            <span class="keyword">return</span>; 
        }
        <span class="type">NSUInteger</span> localDelta = delta;
        <span class="keyword">for</span> (<span class="type">NSUInteger</span> rightIdx = <span class="number">0</span>; rightIdx &lt; self.currentArray.count; ++rightIdx) {
            id rightObj = self.currentArray[rightIdx];
            <span class="keyword">if</span> ([insertedObjects containsObject:rightObj]) {
                localDelta--;
                <span class="keyword">continue</span>;
            }

            <span class="keyword">if</span> (![rightObj isEqual:leftObj]) {
                <span class="keyword">continue</span>;
            }

             //  注意点：          
            <span class="type">NSInteger</span> adjustedRightIdx = rightIdx + localDelta;
            // 首先如果前后索引一致，没有变化的区别，没有必要做diff变化
            // 或者如果你前面删除了一条，自身索引是<span class="number">1</span>，然后这边是<span class="number">0</span>，那也没必要做move变化。
            <span class="keyword">if</span> (leftIdx != rightIdx &amp;&amp; adjustedRightIdx != leftIdx) {
                [<span class="literal">result</span> addObject:[<span class="type">WMLArrayDiff</span> arrayDiffForMoveFromIndex:leftIdx toIndex:rightIdx]];
            }
            <span class="keyword">return</span>;
        }
    }];
    <span class="keyword">return</span> [<span class="literal">result</span> copy];
}
</code></pre><p>上述代码一开始我看了也是懵逼了，我觉得直接二重遍历计算同样数在不同两组数据源中的索引区别不就行了？在读了代码一遍以后确定了，作者的思路是这样的：</p>
<ol>
<li><p>如果在旧数组中和新数组中的数据源一样，那就不更新了，也即<code>leftIdx != rightIdx</code>的判断。</p>
</li>
<li><p>如果在旧数组中，索引为1，但是之前的0索引位置的数据删除了；然后这个索引为1的数据在新数据中位置为索引0，那么也不需要改了，因为之前计算删除变化的时候已经做了这个相同的效果。</p>
</li>
</ol>
<h4 id="时间复杂度">时间复杂度</h4><p>虽然不知道苹果内部的数据结构代码实现是如何的，但是我们可以进行数据模拟，同时也可以看看<a href="http://devstreaming.apple.com/videos/wwdc/2013/224xcx5x1y1yx8ra5jbmfyhf/224/224.pdf" target="_blank" rel="external">苹果WWDC的文章</a> 来进行时间复杂度估算。</p>
<p>而从上面实现的计算变动源代码来看，整个库的实现时间复杂度还是有所欠缺的，到达了O(mn) + O(n) ≈ O(mn)的级别，因此我们可以进行一些优化。</p>
<blockquote>
<p>备注：O(mn)就是二重循环遍历的问题。其中m是数据源A的数据个数，n是数据源b的数据个数。简单来看就是O(n^2)级别的运算耗时。</p>
</blockquote>
<p>怎么优化呢，答案很简单，就是利用动态规划思想来求解最小编辑距离。</p>
<p>我们举个简单的例子，还是没有重复数组的数组，<code>A = [1, 3, 5, 6, 8]</code>以及<code>B = [1, 5, 6, 9, 2]</code>。</p>
<p>怎么样最小变化才能从A变成B呢？</p>
<p>我们列一个二维的矩阵先，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-25%20%E4%B8%8A%E5%8D%881.22.02.png?raw=true" alt=""></p>
<blockquote>
<p>备注：蓝色为原数据，绿色为新数据，黄色的为最小变化的开销。</p>
</blockquote>
<p>不难看出，这个算法的时间复杂度就是填满整张表的O(mn)。</p>
<p>看到这，有人会问，你的Big(O) 复杂度都是O(mn)啊，这你优化在什么地方啊。</p>
<p>从时间复杂度分析上看，最大数值都是O(mn)没错，但是在大数量的情况下，还是会有比较大的区别。</p>
<p>究竟原因在于作者的算法做了很多重复性的劳动，而利用动态规划的特征可以合理的储存状态，避免重复性的劳动。</p>
<h4 id="一些细节">一些细节</h4><p>在查看源码的时候，查看过一个代码，</p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p>这里非常有意思，利用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" target="_blank" rel="external">Statements and Declarations in Expressions</a>，具体不多说了，非常巧妙，大开眼界。</p>
<blockquote>
<p>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct</p>
</blockquote>
<p>啥意思呢？就是说这种符合表达式的最后一句必须是一个用分号结尾的表达式，并且这个表达式必须有返回值。而这个返回值就作为整个符号表达式的返回值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Doppelganger_源码剖析">Doppelganger 源码剖析</h3><p>性能优化系列一：如何快速的计算UITableView的数据量变换。</p>
<p>今天要介绍的是一个比较精简但是很实用的库：Doppelganger。平时我们经常会和<code]]>
    </summary>
    
      <category term="Performance" scheme="http://satanwoo.github.io/tags/Performance/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS疑难问题排查之深入探究dispatch_group crash]]></title>
    <link href="http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/"/>
    <id>http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/</id>
    <published>2017-01-07T13:44:39.000Z</published>
    <updated>2017-01-07T14:08:40.000Z</updated>
    <content type="html"><![CDATA[<h3 id="起因">起因</h3><p>昨天其他部门的同事突然反馈一起相对来说比较严重的Crash问题（占比达到了yyyy左右，并且从Crash堆栈上可以发现很多情况下是一启动就Crash了）。去掉隐私数据大致堆栈如下：</p>
<pre><code>Thread <span class="number">0</span> Crashed:
<span class="number">0</span>   libdispatch.dylib               <span class="number">0x000000018953e828</span> _dispatch_group_leave :<span class="number">76</span> (in libdispatch.dylib)
<span class="number">1</span>   libdispatch.dylib               <span class="number">0x000000018954b084</span> __dispatch_barrier_sync_f_slow_invoke :<span class="number">320</span> (in libdispatch.dylib)
<span class="number">2</span>   libdispatch.dylib               <span class="number">0x000000018953a1bc</span> __dispatch_client_callout :<span class="number">16</span> (in libdispatch.dylib)
<span class="number">3</span>   libdispatch.dylib               <span class="number">0x000000018953ed68</span> __dispatch_main_queue_callback_4CF :<span class="number">1000</span> (in libdispatch.dylib)
<span class="number">4</span>   CoreFoundation                  <span class="number">0x000000018a65e810</span> ___CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ :<span class="number">12</span> (in CoreFoundation)
<span class="number">5</span>   CoreFoundation                  <span class="number">0x000000018a65c3fc</span> ___CFRunLoopRun :<span class="number">1660</span> (in CoreFoundation)
<span class="number">6</span>   CoreFoundation                  <span class="number">0x000000018a58a2b8</span> _CFRunLoopRunSpecific :<span class="number">444</span> (in CoreFoundation)
<span class="number">7</span>   GraphicsServices                <span class="number">0x000000018c03e198</span> _GSEventRunModal :<span class="number">180</span> (in GraphicsServices)
<span class="number">8</span>   UIKit                           <span class="number">0x00000001905d17fc</span> -[UIApplication _run] :<span class="number">684</span> (in UIKit)
<span class="number">9</span>   UIKit                           <span class="number">0x00000001905cc534</span> _UIApplicationMain :<span class="number">208</span> (in UIKit)
<span class="number">10</span>  xxxiPhone                       <span class="number">0x0000000100041a98</span> main main.m:<span class="number">26</span> (in xxxiPhone)
<span class="number">11</span>  libdyld.dylib                   <span class="number">0x000000018956d5b8</span> _start :<span class="number">4</span> (in libdyld.dylib)
</code></pre><p>一看到这种堆栈，头就大了，除了<strong>Thread 0 的第10行是和程序本身二进制相关的</strong>堆栈，其余的调用栈全部是系统库里面的，并且唯一一行程序本身二进制的代码还是一个完全没作用的<code>main</code>函数。</p>
<p>好吧，只能重新找找其余的线索。从堆栈上来反推当时的场景应该是如下场景：</p>
<pre><code>启动 -&gt; main函数 -&gt; main_queue 执行 -&gt; dispatch_group_leave -&gt; <span class="constant">Crash</span>
</code></pre><p>于是，我们的线索就从最后的<code>_dispatch_group_leave</code>来进行。  </p>
<p>首先先来最简单的方法：下符号断点：<code>dispatch_group_leave</code>。</p>
<p>当然事情没有这么简单，尝试重复多次也没有断到我们想要的符号断点上，于是这条路暂时考虑放弃（结合Crash率也可以发现这并非必现的Crash场景）。</p>
<p>这条路不通，我们先尝试全局搜索<code>dispatch_group_leave</code>，结果发现有如下几条线索：</p>
<ul>
<li>外部开源库</li>
<li>自身工程代码</li>
</ul>
<p>结合Crash出现的版本以及以上上述各库最后升级时间来判断，我们基本确定出在问题出现在自身工程中的代码里，如下：</p>
<pre><code>dispatch_group_t serviceGroup = dispatch_group_create();
dispatch_group_notify(serviceGroup, dispatch_get_main_queue(), ^{
    <span class="built_in">NSLog</span>(<span class="string">@"ttttttt:%@"</span>,t);
});

<span class="comment">// t 是一个包含一堆字符串的数组 </span>
[t enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) {
    dispatch_group_enter(serviceGroup);
    SDWebImageCompletionWithFinishedBlock completion =
    ^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
        dispatch_group_leave(serviceGroup);
        <span class="built_in">NSLog</span>(<span class="string">@"idx:%zd"</span>,idx);
    };
    [[SDWebImageManager sharedManager] downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:t[idx]]
                                                    options:SDWebImageLowPriority
                                                   progress:<span class="literal">nil</span>
                                                  completed:completion];
}];
</code></pre><p>这段代码逻辑非常简单吧：给你一个数组，里面是一堆图片地址。你使用多线程进行并发下载，直到所有图片都下载完成（可以失败）进行回调，其中图片下载使用的是<code>SDWebImage</code>。</p>
<p>这段代码里面的的确确出现了可疑的<code>dispatch_group_leave</code>，但是这段代码太常见了。和同事认认真真检查了许久，同时也和天猫、手淘中使用<code>dispatch_group_t</code>的地方进行了对比，没发现任何问题。</p>
<p>好吧，问题一下子陷入了僵局，只好上终极调试大法：<strong>汇编分析法</strong>。</p>
<p>通过文章开头的堆栈我们查找<code>libdispatch.dylib</code>中对应的Crash位置，然后通过汇编解析查看相关指令，结果如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/hopper.png?raw=true" alt=""></p>
<p>从上图看出，指令挂掉的原因是因为执行了<code>brk</code> （brk可以理解为跳转指令特殊的一种，一旦执行，就会进入某种Exception模式，导致Crash）。</p>
<p>为什么执行<code>dispatch_group_leave</code>会挂？从上述图中汇编不难发现，<code>dispatch_group_leave</code>具有两条分支：比较x9寄存器和0之间的关系，如果是less equal，就跳转到0x180502808(即会crash的逻辑分支)；反之则正确执行ret返回。</p>
<p>那么x9寄存器是什么？我们继续往上看指令<code>ldxr x9, [x10]</code>，x9中的值是以x10寄存器中的内容作为地址，取64位放入x9寄存器中。继续，那么x10中的内存是什么？x10中的内容是指令<code>add x10, x0, #0x30</code>。也就是x10 = x0 + 48(0x30的10进制表示)。那么，函数调用的时候x0是self，也即是一个类或者结构体的首地址。所以这两句指令加起来的含义就是<strong><b style="color:red">取结构体地址偏移48位置的某个成员变量的值。</b></strong></p>
<p>除此之外，汇编解析还完整保留了Crash的字符串提示： <strong>“BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()”</strong></p>
<p>结合这两点，我们查看<code>libdispatch</code>的源码，代码如下：</p>
<pre><code><span class="function"><span class="keyword">void</span>
<span class="title">dispatch_group_leave</span>(<span class="params">dispatch_group_t dg</span>)
</span>{
    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;
    dispatch_atomic_release_barrier();
    <span class="keyword">long</span> <span class="keyword">value</span> = dispatch_atomic_inc2o(dsema, dsema_value);
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);
    }
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == dsema-&gt;dsema_orig)) {
        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);
    }
}
</code></pre><p><em>注：苹果开发的libdispatch源码经过了各种变形修改，不是真正运行的代码，仅供参考。</em></p>
<p>果不其然，这段代码完整复现了我们之前汇编分析的结果：如果<code>dg</code>信号量中的字段<code>dsema_value</code>原子性自加一后等于LONGMIN，就会<strong>CRASH</strong>。为什么会Crash呢？</p>
<p>我们需要关注下LONG_MIN这个数字，<code>LONG_MIN = -LONG_MAX - 1</code>。理解起来很简单，就是可以表征的(该类型合法范围)最大数和最小数。</p>
<p>搜索下LONGMAX，我们发现在<code>dispatch_group_create</code>里面发现了它的踪影：</p>
<pre><code><span class="keyword">dispatch_group_t</span>
dispatch_group_create(<span class="keyword">void</span>)
{
    <span class="keyword">dispatch_group_t</span> dg = _dispatch_alloc(DISPATCH_VTABLE(group),
            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_semaphore_s));
    _dispatch_semaphore_init(LONG_MAX, dg);
    <span class="keyword">return</span> dg;
}
</code></pre><p>好了， 这下豁然开朗。这两段代码的结合告诉了我们一个事实：当<code>dq</code>这个信号量加一导致<strong><b style="color:red">溢出</b></strong>后，<code>dispatch_group_leave</code>就会Crash。</p>
<p>最简单的复现代码如下：</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad 
{
    [<span class="keyword">super</span> viewDidLoad];
    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();
    dispatch_group_leave(<span class="keyword">group</span>);
    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span>
}
</code></pre><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/symbol.png?raw=true" alt=""></p>
<p>当然，上述代码相当直白简单，我们一般都不会犯这样低级的错误。</p>
<h3 id="代码究竟出错在哪？">代码究竟出错在哪？</h3><p>了解了<code>dispatch_group_leave</code>的出错原因后，我们再回到我们刚刚认为没问题的代码，一定是哪个地方我们欠考虑了。</p>
<p>上述代码执行流程还是非常简单的，我们用模型简述一遍：</p>
<p><strong>遍历数组，对每个URL进行<code>dispatch_group_enter</code>，然后将其丢入一个下载block交由SDWebImage进行并发下载，下载回调（无论失败或者成功）后执行<code>dispatch_group_leave</code>。</strong></p>
<p>我们举个简单的例子，假设我们有一个包含5个URL的数组：</p>
<ol>
<li>遍历的时候，对信号量<code>dq</code> enter了5次，简单理解信号量减去5次。</li>
<li>SDWebImage下载回调的时候，对信号量<code>dq</code> leave了5次，于是信号量增加了5次。</li>
<li>执行完毕，整个group执行完成。</li>
</ol>
<p><strong><b style="color:red">但是，由于SDWebImage的下载是异步且无法保证时间的，如果在整个group没有执行完毕期间，上述函数整体又被执行到了，会怎么样？</b></strong></p>
<p>我们再用上述的例子来走遍流程。</p>
<ol>
<li>第一次遍历，我们创建了信号量<code>dq1</code>，enter了5次，dq1 现在 = -5。</li>
<li>SDWebImage的下载回调捕捉了<code>dq1</code>，准备留待回调后加回来，我们将这次遍历生成的下载回调block统称为b10, b12, b13, b14, b15。</li>
<li><strong>但是，在第一次SDWebImage下载回调还没执行的时候，第二次函数遍历来了。</strong></li>
<li>第二次遍历，我们创建了信号量<code>dq2</code>，enter了5次，dq2 现在 = -5。</li>
<li>创建第二次遍历对应的回调block，称为b20，b21, b22, b23, b24。</li>
</ol>
<p>通过查阅<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m" target="_blank" rel="external">SDWebImageDownloader.m</a>源码我们发现：</p>
<pre><code><span class="function_or_atom">dispatch_barrier_sync</span>(<span class="function_or_atom">self</span>.<span class="function_or_atom">barrierQueue</span>, ^{
    <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">operation</span> = <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>];
    <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">operation</span>) {
    <span class="function_or_atom">operation</span> = <span class="function_or_atom">createCallback</span>();

    // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意这行<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
    <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] = <span class="function_or_atom">operation</span>;

    __weak <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">woperation</span> = <span class="function_or_atom">operation</span>;
    <span class="function_or_atom">operation</span>.<span class="function_or_atom">completionBlock</span> = ^{
      <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">soperation</span> = <span class="function_or_atom">woperation</span>;
      <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">soperation</span>) <span class="function_or_atom">return</span>;
      <span class="function_or_atom">if</span> (<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] == <span class="function_or_atom">soperation</span>) {
          [<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span> <span class="function_or_atom">removeObjectForKey:url</span>];
      };
    };
}
</code></pre><p>SDWebImage的下载器会<strong>根据URL做下载任务对应NSOperation映射，也即之前创建的下载回调Block。</strong></p>
<p>好，就是这行导致Crash的发生。为什么呢？</p>
<p>我们设想下，假设在第二次遍历中包含了第一次遍历中的图片URL，比如b20对应的图片URL和b10对应的图片URL一样，那么在SDWebImage的处理回调里，b20就会替换掉b10。<b style="color:red">于是，在第一次遍历创建的5个下载任务回调中，b10回调的时候实际已经执行的是b20，也就是<code>dq2 + 1</code>；而在后续第二次遍历执行下载任务回调的时候，又分别执行了b20-b24的5个任务，导致<code>dq2 + 5</code>。这从导致<code>dq2</code>实际上leave的次数比enter的次数多了1 (6比5)，导致了dq2信号量的数值溢出，从而进入了Crash分支。</b></p>
<h3 id="最后">最后</h3><p>看起来很简单、清晰易懂的代码，没想到也会造成巨大的问题。所以，写代码一定要谨慎谨慎再谨慎。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="起因">起因</h3><p>昨天其他部门的同事突然反馈一起相对来说比较严重的Crash问题（占比达到了yyyy左右，并且从Crash堆栈上可以发现很多情况下是一启动就Crash了）。去掉隐私数据大致堆栈如下：</p>
<pre><code>Thread <span]]>
    </summary>
    
      <category term="Reverse Engineering" scheme="http://satanwoo.github.io/tags/Reverse-Engineering/"/>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSONRPCKit源码解析]]></title>
    <link href="http://satanwoo.github.io/2017/01/07/JSONRPCKit/"/>
    <id>http://satanwoo.github.io/2017/01/07/JSONRPCKit/</id>
    <published>2017-01-07T13:40:51.000Z</published>
    <updated>2017-01-07T13:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司参与开源项目<code>BeeHive</code>的开发（第一版的代码是由前辈们写的，已经开源在了GitHub上的Alibaba项目里）。在参与开发的过程中，我一直在思考一个问题：基于Protocol的服务调用真的是最合理的方式吗？这种方式从某种方式来说还是一种强依赖（至少需要引入相对应的整个Protocol的头文件），能否有更通用的方式来进行呢？而且，从目前的实现进度来看，也无法做到对方法级的解耦。</p>
<h3 id="C/S架构">C/S架构</h3><p>在传统的开发框架下，我们一般调用HTTP/HTTPS的请求的方式都是一个API接口，配合一些参数外加GET/POST的调用方式来获取远程服务器的响应返回。如：</p>
<pre><code><span class="collection">[self.manager request:@<span class="string">"api.com"</span> withParams:@<span class="collection">{@<span class="string">"name"</span>:<span class="string">"satanwoo"</span>}</span> withCompletionBlock:^<span class="list">(<span class="keyword">id</span> responseObject)</span><span class="collection">{
    NSLog<span class="list">(@<span class="string">"return response is %@"</span>, responseObject)</span><span class="comment">;</span>
)]</span><span class="comment">;</span></span>
</code></pre><h3 id="JSONRPCKit">JSONRPCKit</h3><p>JSONRPCKit是一套基于JSON RPC 2.0协议的远程服务调用框架。这套框架基于JSON格式（NULL，Boolean，String，Number，Array，Object）来传递请求以及接受返回的响应，是一套应用层之上的协议。</p>
<p>什么意思呢？  </p>
<ol>
<li>所有的客户端请求首先都必须构造成JSON格式  </li>
<li>请求中必须带有JSON RPC 2.0协议要求的字段作为标示符。  </li>
<li>服务端在处理客户端请求的时候，就从协议指定的字段去取调用的方法名、参数、版本号等等。</li>
<li>服务端将请求的结果也封装成复合JSON RPC要求的形式，通过JSON格式传回给客户端。</li>
<li>客户端根据指定的字段解析返回的结果。</li>
</ol>
<p>如果还有不懂的，我们可以看看这篇<a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html#3" target="_blank" rel="external">文章</a>。</p>
<p>所以，JSONRPCKit就是一套封装了该协议的框架，它主要包含如下几个类：</p>
<ul>
<li><code>RequestType</code> 代表着当前的请求</li>
<li><code>BatchType</code>   代表着一个批次（即里面可以一次性包含多个请求，减少调用开销）</li>
<li><code>BatchElementType</code> 将业务请求转换成批次请求的数据结构</li>
<li><code>BatchFactory</code> 构造批次请求的地方</li>
<li><code>JSONRPCError</code>  JSONRPC出错的原因</li>
<li><code>Id</code> 代表着一次（或者一批次）请求的识别符，网络回调要和客户端请求进行ID匹配，否则谁知道哪个请求需要哪个响应。</li>
</ul>
<h4 id="RequestType">RequestType</h4><p>RequestType就是一个符合JSONRPCKit定义的数据结构，包含里几个主要的字段：</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">RequestType</span> </span>{
    <span class="comment">/// If `Response == Void`, request is treated as a notification.</span>
    associatedtype <span class="type">Response</span>

    <span class="keyword">var</span> method: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> parameters: <span class="type">AnyObject</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> extendedFields: [<span class="type">String</span>: <span class="type">AnyObject</span>]? { <span class="keyword">get</span> }
    <span class="keyword">var</span> isNotification: <span class="type">Bool</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromResultObject</span><span class="params">(resultObject: AnyObject)</span></span> throws -&gt; <span class="type">Response</span>
}
</code></pre><ol>
<li><code>method</code> 远程调用的方法名</li>
<li><code>parameters</code> 调用该方法需要传入的参数，顺序需要严格按照方法的入餐，<strong>从左至右</strong>。</li>
<li><code>extendFields</code> 这个在协议中并没有定义，可以理解为自身业务需要，扩展字段。</li>
<li><code>isNotification</code> 在JSON RPC协议中规定，当请求或者相应不带有识别ID的时候，意味着这是一个全局通知，可以没有对应的解析结果。</li>
</ol>
<p>此外，还有一个<code>associatedType Response</code>可以定义响应的类型，用作校验。</p>
<h4 id="BatchElementType">BatchElementType</h4><p>大家都知道，网络调用是有其延迟性和资源消耗的，每次都去建立连接（采用TCP长链接或者HTTP keep alive除外）进行资源传输是非常不划算的话，<strong>尤其是当你的数据payload非常小，在整个传输数据占比非常小的情况下就极其的蛋疼</strong>。因此，JSON RPC 协议定义了一种可以批量传输的方式：就是一批请求包在一次传输；服务端处理好了以后，同样也在一次性将数据响应返回。</p>
<p>有人会问，那一次性批处理的响应怎么和请求对应呢？<br>这就是我们之前提到的<code>ID</code>字段的作用了，这是一个全局唯一性的识别符，请求时的id在服务端处理完后，会同样放在数据中进行返回。</p>
<p>好了，我们来看一下这个数据结构的设计：</p>
<pre><code><span class="comment">// 协议定义</span>
public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchElementType</span> </span>{
    associatedtype <span class="type">Request</span>: <span class="type">RequestType</span>

    <span class="keyword">var</span> request: <span class="type">Request</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> version: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> id: <span class="type">Id</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> body: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>
    <span class="func"><span class="keyword">func</span> <span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>

    <span class="func"><span class="keyword">func</span> <span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
    <span class="func"><span class="keyword">func</span> <span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
}

<span class="comment">// 具体实现</span>
public <span class="class"><span class="keyword">struct</span> <span class="title">BatchElement</span>&lt;<span class="title">Request</span>: <span class="title">RequestType</span>&gt;: <span class="title">BatchElementType</span> </span>{
    public <span class="keyword">let</span> request: <span class="type">Request</span>
    public <span class="keyword">let</span> version: <span class="type">String</span>
    public <span class="keyword">let</span> id: <span class="type">Id</span>?
    public <span class="keyword">let</span> body: <span class="type">AnyObject</span>

    public <span class="keyword">init</span>(request: <span class="type">Request</span>, version: <span class="type">String</span>, id: <span class="type">Id</span>) {
        <span class="keyword">let</span> id: <span class="type">Id</span>? = request.isNotification ? <span class="literal">nil</span> : id
        <span class="keyword">var</span> body: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [
            <span class="string">"jsonrpc"</span>: version,
            <span class="string">"method"</span>: request.method,
        ]

        <span class="keyword">if</span> <span class="keyword">let</span> id = id {
            body[<span class="string">"id"</span>] = id.value
        }

        <span class="keyword">if</span> <span class="keyword">let</span> parameters = request.parameters {
            body[<span class="string">"params"</span>] = parameters
        }

        request.extendedFields?.forEach { key, value <span class="keyword">in</span>
            body[key] = value
        }

        <span class="keyword">self</span>.request = request
        <span class="keyword">self</span>.version = version
        <span class="keyword">self</span>.id = id
        <span class="keyword">self</span>.body = body
    }
}
</code></pre><p>从代码中不难看出，<code>BatchElement</code>是对之前的<code>Request</code>的进一步封装，将所有<code>Request</code>的字段塞到了一个<code>body</code>中（我们可以理解为HTTP Body），这个<code>body</code>是真正用于传输的，其余字段都是用于校验的，总共需要进行如下校验：</p>
<ol>
<li>查看JSON RPC协议是不是2.0。</li>
<li>响应数据的id和请求的id是不是能匹配。</li>
</ol>
<p>为了处理这些默认逻辑，BatchElement基于Protocol Extension提供了默认的实现，具体如下：</p>
<pre><code>func <span class="function"><span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; Request<span class="class">.Response</span>
func <span class="function"><span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; Request<span class="class">.Response</span>

func <span class="function"><span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
func <span class="function"><span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
</code></pre><p>从命名中不难看出，上述4个API分成两组，分别对应单个请求和批处理的。出于篇幅考虑，我们仅以单个批次进行分析。</p>
<pre><code><span class="function"><span class="keyword">public</span> func <span class="title">resultFromObject</span>(<span class="params"><span class="keyword">object</span>: AnyObject</span>) -&gt; Result&lt;Request.Response, JSONRPCError&gt; </span>{
    <span class="keyword">let</span> receivedVersion = <span class="keyword">object</span>[<span class="string">"jsonrpc"</span>] <span class="keyword">as</span>? String
    <span class="comment">// 校验协议版本</span>
    guard version == receivedVersion <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.UnsupportedVersion(receivedVersion))
    }

     <span class="comment">// 校验标识符ID</span>
    guard id == <span class="keyword">object</span>[<span class="string">"id"</span>].flatMap(Id.init) <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.ResponseNotFound(requestId: id, <span class="keyword">object</span>: <span class="keyword">object</span>))
    }


    <span class="keyword">let</span> resultObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"result"</span>]
    <span class="keyword">let</span> errorObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"error"</span>]

      <span class="comment">// 根据错误或者结果进行解析</span>
    <span class="keyword">switch</span> (resultObject, errorObject) {
    <span class="keyword">case</span> (nil, <span class="keyword">let</span> errorObject?):
        <span class="keyword">return</span> .Failure(JSONRPCError(errorObject: errorObject))

    <span class="keyword">case</span> (<span class="keyword">let</span> resultObject?, nil):
        <span class="keyword">do</span> {
            <span class="comment">// 请求还要再单独校验一次</span>
            <span class="keyword">return</span> .Success(<span class="keyword">try</span> request.responseFromResultObject(resultObject))
        } <span class="keyword">catch</span> {
            <span class="keyword">return</span> .Failure(.ResultObjectParseError(error))
        }

    <span class="keyword">default</span>:
        <span class="keyword">return</span> .Failure(.MissingBothResultAndError(<span class="keyword">object</span>))
    }
}
</code></pre><p>根据JSON RPC的协议规定，数据在成功处理后，必须将响应结果放在<code>result</code>字段里；而如果有出错的时候，就必须放在<code>error</code>字段中。并且必须包含<code>error code</code>和<code>error message</code>。</p>
<p>所以，上述代码利用Swift强大的Pattern Match机制，进行对应的解析。<strong>有一点需要注意的是，即使是服务端成功返回了数据，但是该数据可能和我们请求需求的数据类型不一致等等，仍然有可能出错。</strong></p>
<h4 id="BatchType">BatchType</h4><p><code>BatchType</code>顾名思义，就是批次对应的数据结构。简单理解就是包着一堆<code>BatchElement</code>，没啥可以特别讲述的。</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchType</span> </span>{
    associatedtype <span class="type">Responses</span>
    associatedtype <span class="type">Results</span>

    <span class="keyword">var</span> requestObject: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responsesFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Responses</span>
    <span class="func"><span class="keyword">func</span> <span class="title">resultsFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Results</span>

    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">responsesFromResults</span><span class="params">(results: Results)</span></span> throws -&gt; <span class="type">Responses</span>
}
</code></pre><h4 id="BatchFactory">BatchFactory</h4><p>通过上面的讲述不难看出，我们要使用JSON RPC 需要有三步骤：</p>
<ol>
<li>构造一个符合JSON RPC 2.0协议的请求</li>
<li>将其转换成批处理元素</li>
<li>将批处理元素合并，构造成一个批次。</li>
</ol>
<p>这样的步骤虽然不困难，但是每次都这么干，估计使用者要吐血。所以<code>BatchFactory</code>的目的是提供简单的工厂方法。我们以构造包含1-2个请求的批处理为例：</p>
<pre><code><span class="keyword">public</span> func create&lt;<span class="string">Request:</span> RequestType&gt;(<span class="string">request:</span> Request) -&gt; Batch&lt;Request&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement = BatchElement(<span class="string">request:</span> request, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch(<span class="string">batchElement:</span> batchElement)
   }

   <span class="keyword">public</span> func create&lt;<span class="string">Request1:</span> RequestType, <span class="string">Request2:</span> RequestType&gt;(<span class="string">request1:</span> Request1, _ <span class="string">request2:</span> Request2) -&gt; Batch2&lt;Request1, Request2&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement1 = BatchElement(<span class="string">request:</span> request1, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       let batchElement2 = BatchElement(<span class="string">request:</span> request2, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch2(<span class="string">batchElement1:</span> batchElement1, <span class="string">batchElement2:</span> batchElement2)
   }
</code></pre><p>看了代码，简单吧。什么高深的都没干，就是用信号量构造了互斥区域，为什么要这么做？<strong>是为了确保<code>idGenerator</code>生成的标识符是连续的，并且是唯一的。</strong></p>
<h4 id="其他">其他</h4><p>借这里正好复习下<code>dispatch_semaphore</code>相关知识。</p>
<p><code>dispatch_semaphore</code>对应的就是信号量，当有多个线程想要访问一个需要并发保护的资源的时候，信号量可以帮助我们协调并发数。</p>
<p>我们用互斥变量（即信号量为1）来举例：<br>    xxx = dispatch_semaphore_create(1);</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) {</span>
    dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">yyy</span>, <span class="number">0</span>)</span>, ^{
        dispatch_semaphore_wait<span class="list">(<span class="keyword">xxx</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
        [self doSomething]<span class="comment">;</span>
        dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
    })</span><span class="comment">;    </span>
}<span class="comment">;</span></span>
</code></pre><p>就可以保证任意时候，只有一个线程中可以访问到资源了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司参与开源项目<code>BeeHive</code>的开发（第一版的代码是由前辈们写的，已经开源在了GitHub上的Alibaba项目里）。在参与开发的过程中，我一直在思考一个问题：基于Protocol的服务调用真的是最合理的方式吗？这种方式从某种方式来说还是一种强]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈一种解决多线程野指针的新思路]]></title>
    <link href="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/"/>
    <id>http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/</id>
    <published>2016-10-22T18:43:25.000Z</published>
    <updated>2016-10-23T12:05:48.000Z</updated>
    <content type="html"><![CDATA[<p>无论是xx还是xx，对于整个App的稳定性要求都非常之高。因此，那些前辈大牛们为了解决一些常见的问题，比如空指针、数组越界等等，开发了xxxxxx这样的底层SDK，用于解决问题。</p>
<p>但是随着业务逐渐的复杂化以及愈发严格的性能要求，xxApp绝大多数的Crash开始往野指针方面靠拢。这些野指针的问题，除了一些<strong>iOS7上delegate是assign声明导致的历史遗留问题以外，绝大多数都是多线程的赋值导致的野指针问题。</strong></p>
<p><span style="color:red">而这些多线程的野指针问题，至今仍未有一个比较好的统一解决方案。因此，今天就想稍微聊下我自身研究的一个方案。</span></p>
<h3 id="什么是多线程的野指针问题">什么是多线程的野指针问题</h3><p>之前在《浅谈多线程编程误区》一文中，曾经举过如下这样的<strong>多线程setter</strong>例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>如果这个<code>self.data</code>是个<code>nonatomic</code>的属性的话，就会造成在多次释放导致的野指针问题。（具体可以见《浅谈多线程编程误区》的原理解释）。</p>
<p>从原理解释中不难发现，本质上会产生野指针的场景是由于我们没有对临界区进行保护。导致赋值替换的操作不是原子性的。</p>
<p>有些人会说，例子中你刻意构建了一万个线程才会导致Crash。而我们平时就用用几个线程，不会有问题的。<br><strong>理论上一万个线程只不过是把两个线程中可能出现问题的概率放大了而已。在一万个线程中会出现的多线程野指针问题在两个线程中一定也会发生。</strong></p>
<h3 id="传统业界方案：赋值加锁">传统业界方案：赋值加锁</h3><p>既然原子性是导致野指针的罪魁祸首，那么我们只要在对应可能产生冲突的临界区内加锁就好了，比如：</p>
<pre><code>[<span class="operator"><span class="keyword">lock</span> <span class="keyword">lock</span>];</span>
self.data = [[NSMutableData alloc] init];
[<span class="operator"><span class="keyword">lock</span> <span class="keyword">unlock</span>]</span>
</code></pre><p>按照这样的做法，同一时间不管有多少线程试图对<code>self.data</code>进行赋值，最终都只有一个线程能够抢到锁对其赋值。</p>
<p>但是这样的做法从安全性角度来说是解决了原子赋值的问题。但是这样的做法却对开发要求比较严格，因为<strong>任意非基础类型的对象(Int, Bool)</strong>都有可能产生多线程赋值的野指针，所以开发需要牢记自身的属性变量究竟有哪些会在多线程场景中被使用到。</p>
<p><b style="color:red">而且，这样的方案还有一个非常大的不确定性！</b></p>
<p>当你开发了一个底层SDK，对外暴露了一些公共的<strong>readwrite</strong>的Property。别人对你的property赋值的时候，你怎么确定他们一定会做到线程安全？</p>
<h3 id="我的方案：runtime追踪对象初始化的GCD_Queue">我的方案：runtime追踪对象初始化的GCD Queue</h3><p>我们都知道，在<code>Objective-C</code>中，对于一个<code>property</code>的赋值最终都会转化成对于<code>ivar</code>的setter方法。所以，如果我们能确保<code>setter</code>方法的线程安全性，就能确保多线程赋值不会产生野指针。</p>
<p>好，按照这个思路进行操作的话，我们大致需要如下几个步骤：</p>
<ol>
<li>获取第一次setter调用的时机及对应的线程。</li>
<li>将这个线程记录下来。</li>
<li>后续调用setter的时候，判断当前setter调用的线程是不是我们之前记录的线程，如果是，直接赋值。如果不是，派发到对应的线程进行调用。</li>
<li>获取所有的setter，重复实现上述步骤。</li>
</ol>
<p>看起来思路很简单，具体实现起来却有一定的难度，容我由浅入深慢慢道来：</p>
<h4 id="1-_获取第一次赋值的线程并记录">1. 获取第一次赋值的线程并记录</h4><p>由于我们不能通过成员变量就记录每个ivar对应的setter的初始化线程(这样setter的个数就无限增长了)，因此本质上我们只有通过局部静态变量的方式来作为存储。同时由于我们只需要在初次执行时进行记录，所以很理所当然就想到了<code>dispatch_once</code>。</p>
<p>具体代码如下：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> initQueue;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueKey;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueContext;

<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{

    <span class="comment">// 1. 主队列</span>
    <span class="keyword">if</span> ([<span class="built_in">UIApplication</span> isMainQueue]) {
        initQueue = dispatch_get_main_queue();
        initQueueKey = [<span class="built_in">UIApplication</span> mainQueueKey];
        initQueueContext = [<span class="built_in">UIApplication</span> mainQueueContext];
    } <span class="keyword">else</span> {
        <span class="comment">// 2. 非主队列</span>
        <span class="keyword">const</span> <span class="keyword">char</span> *label = [<span class="built_in">NSStringFromSelector</span>(_cmd) UTF8String];
        initQueueKey = &amp;initQueueKey;
        initQueueContext = &amp;initQueueContext;
        initQueue = dispatch_queue_create(label, <span class="literal">nil</span>);
        dispatch_queue_set_specific(initQueue, initQueueKey, initQueueContext, <span class="literal">nil</span>);
    }
});
</code></pre><p>从代码中不难发现，由于主队列是全局共用的，所以如果这次setter的赋值是在主队列进行的，那么就直接复用主队列即可；而如果当前的队列我们自身都不确定的话，那么就干脆<strong>开辟一个串行的队列</strong>用语这个setter的后续赋值，并将其记录下来。</p>
<p><strong>细心的读者可能会发现，我们标题里写的是线程，但是在代码中记录的却是GCD的队列（Queue）。而且，我们判断的是主队列而不是主线程。这是为什么呢？</strong></p>
<p>嘿嘿，容我卖个关子，文章最后会有详细的阐述。</p>
<h4 id="2-_判断后续赋值是否是记录的线程">2. 判断后续赋值是否是记录的线程</h4><p>由于我们之前记录的是队列，所以我们是无法直接使用诸如如下代码的方式进行是否是同一个线程的判断  </p>
<pre><code><span class="string">[NSThread currentThread]</span> == xxxThread
</code></pre><p>在iOS7之前，苹果提供了<code>dispatch_get_current_queue()</code>用于获取当前正在执行的队列，如果有这个方法，我们就可以很容易判断这个队列和我们记录的队列是否是同一个了。但是很不幸的是，该方法已经被从GCD的Public API中移除了，一时间研究陷入了僵局。</p>
<p>不过好在<code>libdispatch</code>是开源的，经过一段时间的摸索，我发现了这个方法<code>dispatch_get_specific</code>，其自身实现如下：</p>
<pre><code><span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span> *
<span class="title">dispatch_get_specific</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span>
</span>{
    <span class="keyword">if</span> (slowpath(!key)) {
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }
    <span class="keyword">void</span> *ctxt = <span class="literal">NULL</span>;
    <span class="comment">// 1. 获取当前线程的执行队列</span>
    <span class="keyword">dispatch_queue_t</span> dq = _dispatch_queue_get_current();

    <span class="keyword">while</span> (slowpath(dq)) {
        <span class="comment">// 2. 如果进行过标记</span>
        <span class="keyword">if</span> (slowpath(dq-&gt;dq_specific_q)) {
            ctxt = (<span class="keyword">void</span> *)key;
            dispatch_sync_f(dq-&gt;dq_specific_q, &amp;ctxt,
                    _dispatch_queue_get_specific);
            <span class="keyword">if</span> (ctxt) <span class="keyword">break</span>;
        }
        <span class="comment">// 3. 向上传递至target Queue</span>
        dq = dq-&gt;do_targetq;
    }
    <span class="keyword">return</span> ctxt;
}
</code></pre><p>通过上述代码不难理解，系统会自动获取当前线程正在执行的队列的。如果进行该队列进行过标记，就根据我们传入的key去获取key对应的value(ctxt)。如果查询到了，就返回。否则按照目标队列层层上查，直至root_queue也没找到为止。（关于libdispatch的具体原理，我下周还会专门写篇细细分析的文章）。</p>
<p>通过这个方法，我们可以在直接记录初始化队列的时候对其进行特殊的标定：</p>
<pre><code>dispatch_queue_set_specific<span class="list">(<span class="keyword">initQueue</span>, initQueueKey, initQueueContext, <span class="literal">nil</span>)</span><span class="comment">;</span>
</code></pre><p>随后在后续setter执行的时候通过如下代码进行判断并进行相应的直接赋值或者队列重新派发：</p>
<pre><code><span class="comment">// 如果是当前队列</span>
<span class="keyword">if</span> (dispatch_get_specific(initQueueKey) == initQueueContext) {
    _threadSafeArray = threadSafeArray;
} <span class="keyword">else</span> {
     <span class="comment">// 不是当前队列</span>
    <span class="built_in">dispatch_sync</span>(initQueue, ^{
        _threadSafeArray = threadSafeArray;
    });
}
</code></pre><h4 id="3-_遍历所有的setter，重复上述过程">3. 遍历所有的setter，重复上述过程</h4><p>由于我们的目的是减轻其他开发的负担，所以不得不借助了runtime的Method Swizzling技术。但是传统的Method Swizzling技术是将函数实现两两交换。如果按照这个思路，我们就需要为每一个setter编写一个对应的<code>hook_setter</code>，这工作量无疑太巨大了。</p>
<p>所以，在这里我们需要的一个中心重定向的过程：即，将所有的setter都转移到一个hook_proxy中。代码如下：</p>
<pre><code>- (<span class="function_or_atom">void</span>)<span class="function_or_atom">hookAllPropertiesSetter</span>
{
    <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">outCount</span>;
    <span class="function_or_atom">objc_property_t</span> *<span class="function_or_atom">properties</span> = <span class="function_or_atom">class_copyPropertyList</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], &amp;<span class="function_or_atom">outCount</span>);

    <span class="variable">NSMutableArray</span> *<span class="function_or_atom">readWriteProperties</span> = [[<span class="variable">NSMutableArray</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCapacity:outCount</span>];
    <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">i</span> = <span class="number">0</span>; <span class="function_or_atom">i</span> &lt; <span class="function_or_atom">outCount</span>; <span class="function_or_atom">i</span>++) {
        <span class="function_or_atom">objc_property_t</span> <span class="function_or_atom">property</span> = <span class="function_or_atom">properties</span>[<span class="function_or_atom">i</span>];
        <span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> = [[<span class="variable">NSString</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCString:property_getName</span>(<span class="function_or_atom">property</span>) <span class="function_or_atom">encoding</span>:<span class="variable">NSUTF8StringEncoding</span>];

        <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">attrCount</span>;
        <span class="function_or_atom">objc_property_attribute_t</span> *<span class="function_or_atom">attrs</span> = <span class="function_or_atom">property_copyAttributeList</span>(<span class="function_or_atom">property</span>, &amp;<span class="function_or_atom">attrCount</span>);

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">BOOL</span> <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">NO</span>;
        <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">j</span> = <span class="number">0</span>; <span class="function_or_atom">j</span> &lt; <span class="function_or_atom">attrCount</span>; <span class="function_or_atom">j</span>++) {
            <span class="function_or_atom">if</span> (<span class="function_or_atom">attrs</span>[<span class="function_or_atom">j</span>].<span class="function_or_atom">name</span>[<span class="number">0</span>] == <span class="string">'R'</span>) {
                <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">YES</span>;
                <span class="function_or_atom">break</span>;
            }
        }
        <span class="function_or_atom">free</span>(<span class="function_or_atom">attrs</span>);

        <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">isReadOnlyProperty</span>) {
            [<span class="function_or_atom">readWriteProperties</span> <span class="function_or_atom">addObject:propertyName</span>];
        }
    }
    <span class="function_or_atom">free</span>(<span class="function_or_atom">properties</span>);

    <span class="function_or_atom">for</span> (<span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> <span class="function_or_atom">in</span> <span class="function_or_atom">readWriteProperties</span>) {

        <span class="variable">NSString</span> *<span class="function_or_atom">setterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"set%@%@:"</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringToIndex</span>:<span class="number">1</span>].<span class="function_or_atom">uppercaseString</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringFromIndex</span>:<span class="number">1</span>]];

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">NSString</span> *<span class="function_or_atom">hookSetterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"hook_set%@:"</span>, <span class="function_or_atom">propertyName</span>];

        <span class="variable">SEL</span> <span class="function_or_atom">originSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">setterName</span>);
        <span class="variable">SEL</span> <span class="function_or_atom">newSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">hookSetterName</span>);

        <span class="function_or_atom">swizzleMethod</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], <span class="function_or_atom">originSetter</span>, <span class="function_or_atom">newSetter</span>);
    }
}
</code></pre><p>在这里有两点需要注意的地方：</p>
<ol>
<li><strong>readonly</strong>的property是不具备setter功能的，所以将其过滤。</li>
<li>将每个setter，比如<code>setThreadSafeArray</code>都<strong>swizzle</strong>成了<code>hook__setThreadSafeArray</code>。即为每一个setter都定制了一个对应的hook_setter。</li>
</ol>
<p>哎，有人会问，你刚刚不才说为每一个setter编写对应的hook_setter是费时费力的吗？怎么自己打自己脸啊？</p>
<p>别急，容我慢慢道来。</p>
<p>在Method Swizzling的时候，我们需要调用<code>class_getInstanceMethod</code>来进行对应方法名的函数查找。整个过程简述如下：</p>
<pre><code><span class="keyword">method</span> cache list -&gt; <span class="keyword">method</span> list -&gt; 动态方法决议 -&gt; 方法转交 (forward <span class="type">Invocation</span>)
</code></pre><p>其中，在动态方法决议这步，如果我们添加了之前的没找到的方法，那么整个查找过程又会重新开始一遍。</p>
<p><strong><span style="color:red">由于那些hook_setter是压根不会存在于method list中的，所以在查找这些函数的时候，一定会走到动态决议这一步。</span></strong></p>
<p>基于此，我实现了如下的动态决议函数：</p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *selName = NSStringFromSelector(sel);

    <span class="keyword">if</span> ([selName hasPrefix:@<span class="string">"hook_"</span>]) {
        <span class="function"><span class="keyword">Method</span> <span class="title">proxyMethod</span> =</span> class_getInstanceMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">hook_proxy</span>:));</span>
        class_addMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], <span class="title">sel</span>, <span class="title">method_getImplementation</span>(<span class="title">proxyMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">proxyMethod</span>));</span>
        <span class="keyword">return</span> YES;
    }

    <span class="keyword">return</span> [<span class="variable">super</span> resolveInstanceMethod:sel];
}
</code></pre><p>从代码中很容易发现，如果是之前那么hook_setter的函数名，我就讲这些方法的<strong>函数实现</strong>全部重定向到函数<code>hook__proxy</code>上。</p>
<h4 id="4-_寻找上下文">4. 寻找上下文</h4><p>在传统的Method Swizzling技术中，由于我们是两两交换，因此我们不需要上下文这一个步骤，直接调用hook_setter就可以重新返回对应的原setter方法。</p>
<p>可是在本文的实现中，由于我们将所有的setter都重定向到了<code>hook__proxy</code>中，所以我们需要在<code>hook_proxy</code>中寻找究竟是给哪个property赋值。</p>
<p><strong><span style="color:red">如果对Method Swizzling的理解只停留在表面，是很难想到后续步骤的。</span></strong></p>
<p>Method Swizzling的原理是只是交换IMP，即函数实现。而我们在Objective-C的函数调用统统是通过objc_msgSend结合函数的Selector(可以简单理解为函数名)来找到真正的函数实现。</p>
<p><strong>因此，swizzle后的Selector没变，变的是IMP。</strong></p>
<p>有了这个理解，我们就可以在hook_proxy使用<b style="color:red">__cmd</b>这个隐藏变量，它会指引我们究竟是哪个Setter当前正在被调用，具体代码如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">hook_proxy:</span>(NSObject *)proxyObject
{
    <span class="comment">// 只是实现被换了，但是selector还是没变</span>
    NSString *originSelector = NSStringFromSelector(_cmd);
    NSString *propertyName = [[originSelector <span class="string">stringByTrimmingCharactersInSet:</span>[NSCharacterSet <span class="string">characterSetWithCharactersInString:</span>@<span class="string">":"</span>]] <span class="string">stringByReplacingOccurrencesOfString:</span>@<span class="string">"set"</span> <span class="string">withString:</span>@<span class="string">""</span>];
    <span class="keyword">if</span> (propertyName.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;

    NSString *ivarName = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"_%@%@"</span>, [propertyName <span class="string">substringToIndex:</span><span class="number">1</span>].lowercaseString, [propertyName <span class="string">substringFromIndex:</span><span class="number">1</span>]];

    <span class="comment">//NSLog(@"hook_proxy is %@ for property %@", proxyObject, propertyName);</span>

    重复之前步骤即可。
}
</code></pre><h4 id="5-_其他拓展">5. 其他拓展</h4><p><strong>本文中只是探索了下没有重载setter的那些ivar，因此只需要简单对ivar进行赋值即可。</strong><br>如果你碰到了大量自定义setter的ivar，那么也一样很简单，你只需要维护一个ivar 到对应自定义的setter的imp映射，在hook_proxy将<code>setValue:ForKey:</code>替换成直接的IMP调用即可。</p>
<h3 id="一些额外细节">一些额外细节</h3><ul>
<li><ol>
<li>线程和GCD Queue并不是一一对应的关系。</li>
</ol>
</li>
</ul>
<p>前面提到了，我们要记录的是队列而不是线程。相信很多人可能一开始都不能理解，那么我用如下这样的代码进行解释：</p>
<pre><code><span class="tag">if</span> ([NSThread isMainThread]) {
    <span class="attr_selector">[self doSomeThing]</span>;
} <span class="tag">else</span> {
    <span class="tag">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="attr_selector">[self doSomething]</span>;
    });
}
</code></pre><p>上述代码想必大家非常熟悉，就是全包在主线程执行一些操作，比如UI操作等等。但是事实上，这里有个误区：</p>
<p><strong>主队列一定在主线程执行，而主线程不一定只执行主队列。</strong></p>
<p><b style="color:red">换句话说：上述代码的if 和 else是不等价的。</b> </p>
<p>有时候，主线程有可能会被调度到执行其他队列（其他线程亦是如此），比如如下代码：</p>
<pre><code><span class="comment">// 在主线程创建</span>
dispatch\_queue\_t dq = dispatch\_queue\_create(<span class="string">'com.mingyi.dashuaibi'</span>, <span class="keyword">NULL</span>);
dispatch_sync(dq, ^{
    NSLog(@<span class="string">"current thread is %@"</span>, [NSThread currentThread]);
});
</code></pre><p>具体效果，大家可以自己尝试下，看看Log输出的结果是不是主线程。</p>
<ul>
<li><ol>
<li>为什么不能直接将所有的setter直接hook到hook_proxy，非要通过动态决议来进行。</li>
</ol>
</li>
</ul>
<p>我们举个简单的例子，假设我们有两个property，分别叫A和B。那么在执行下述代码的时候：</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 2; i++) {</span>
     SEL originSetter = NSSelectorFromString<span class="list">(<span class="keyword">setterName</span>)</span><span class="comment">;</span>
     SEL newSetter = NSSelectorFromString<span class="list">(<span class="keyword">hook_proxy</span>)</span><span class="comment">;</span>
     swizzleMethod<span class="list">([self class], originSetter, newSetter)</span><span class="comment">;</span>
}</span>
</code></pre><p>第一次交换的时候，Setter A的 IMP和 hook_proxy的 IMP进行了交换，这一步没问题。<br>第二次交换的时候，Setter B的 IMP和 hook_proxy的 IMP进行了交换，而此时hook_proxy的IMP已经指向了Setter A的IMP，因此导致的结果就是交换错乱了，调用setter B实质上是调用了setter A。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>无论是xx还是xx，对于整个App的稳定性要求都非常之高。因此，那些前辈大牛们为了解决一些常见的问题，比如空指针、数组越界等等，开发了xxxxxx这样的底层SDK，用于解决问题。</p>
<p>但是随着业务逐渐的复杂化以及愈发严格的性能要求，xxApp绝大多数的Crash开]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈iOS的多Window处理]]></title>
    <link href="http://satanwoo.github.io/2016/09/17/uiwindow-iOS/"/>
    <id>http://satanwoo.github.io/2016/09/17/uiwindow-iOS/</id>
    <published>2016-09-17T14:51:46.000Z</published>
    <updated>2016-09-17T14:53:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>想必做iOS的人都知道，我们的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个<code>UIWindow</code>，也就是AppDelegate在<code>applicationDidFinishLaunching</code>里面创建出来的。</p>
<p>但是即使我们什么都不做，在我们的APP里面也会有其他的<code>UIWindow</code>:</p>
<ol>
<li>键盘对应的UITextEffectWindow</li>
<li>状态栏对应的UIStatusBarWindow</li>
</ol>
<p>只不过上述两种<code>UIWindow</code>我们一般不太容易去操作罢了，因此很多问题都无形被掩盖住了。所以接下来我们就说说如果在多个UIWindow状态下存在的一些问题吧。</p>
<p>那么在什么情况下会导致我们想要创建多<code>UIWindow</code>的状态呢？我总结了一下，包括但不限于：</p>
<ol>
<li>全局性的自定义HUD，Alert效果（SCAlert）等等。</li>
<li>需要展示的界面需要盖住UIStatusBar。</li>
</ol>
<p>其中，第一种方案其实不一定需要创建一个新的<code>UIWindow</code>实例，我们也可以将这些自定义的全局性界面添加到AppDelegate的window上。但是这样就会产生一个问题，由于在<strong>iOS8之前</strong>，UIWindow的bounds是不会随着旋转而改变的，拿到的永远是处于<strong>Portrait</strong>模式下的坐标系坐标。因此，<b>对于直接添加在UIWindow上的视图，我们需要自己根据  <code>UIApplicationDidChangeStatusBarOrientationNotification</code>来进行转换处理。</b></p>
<p>苹果这篇<a href="https://developer.apple.com/library/content/qa/qa1688/_index.html" target="_blank" rel="external">Q&amp;A</a>讲述了比较具体的原因：<b style="color:red">UIWindow并不会处理rotation事件，而是UIWindow的rootViewController去处理。</b></p>
<p>而对于第二种问题，添加一个盖在UIStatusBar上的界面，就必须依赖我们自己创建一个新的UIWindow，究其原因在于UIStatusBar本身并不属于我们App内可控的一个控件，而是一个系统级创建出来的产物。<br>因此，<strong>我们必须创建一个WindowLevel大于UIWindowStatusBar的新Window盖在上面才行。</strong></p>
<p>有人会问：咦，奇怪了，为什么你在自己App内添加一个WindowLevel大于statusbar的就可以了呢？你只是在你自身应用内添加了一个UIView（UIWindow的子类），竟然能影响系统级的控件？</p>
<p><b style="color:red">是的，不知道大家有没有了解过<code>CALayer</code>这层有个属性叫zIndex。通过操纵这个属性，我们可以调整视图渲染的前后关系。即使有的UIView在构建<span style="color:black">层级树</span>的时候被后加的UIView所遮盖，但是在构建<span style="color:black">渲染树</span>的时候，zIndex越高的视图就会越处于视觉前方进行渲染。 而渲染树构建完成之后，并不是在我们的App内部进行渲染，而是通过IPC通信，统一交由一个第三方进程<span style="color:black">Render Server</span>进行渲染。而在我们这里处理盖住StatusBar的多Window的情形也是基于这个原理进行。</b></p>
<h3 id="横屏及旋转">横屏及旋转</h3><p>现在绝大多数的iPhone应用都是竖屏应用，即只支持<strong>Portrait</strong>模式。但是随着视频、直播的风口到来，在新闻、购物等等APP内都会插入视频播放这一特性，而视频播放需要的全屏播放特性势必要用到横屏，也就意味着会牵扯到旋转。</p>
<p>横屏旋转分为两种，一种是强制性的，一种是随着设备进行旋转的。什么意思呢？<br>大家还记得手机上有旋转锁这一个开关吧，你将旋转锁开启的时候，手机就保持在锁定对应的模式下，无法自动根据你旋转设备而旋转。在这种模式下，如果你需要更改APP界面对应的UIInterfaceOrientation，就必须要么在对应的<strong>viewcontroller</strong>里面提供实现如下的方法：</p>
<pre><code>- (<span class="built_in">NSUInteger</span>)supportedInterfaceOrientations
{
    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>; <span class="comment">// 表示支持水平右方向</span>
}

- (<span class="built_in">BOOL</span>)shouldAutorotate
{
    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>这样，当你展现到这个页面的时候，就会触发系统检查一下当前页面应该所处的Orientation，从而达到正确的显示效果。</p>
<p><strong>但需要注意的是，如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</strong></p>
<p>PS: <strong><i>其实这个道理和<code>hideBottomBarWhenPushed</code>是一个道理。很多人用了这个属性，发现隐藏Tabbar的时机经常错乱了</i></strong>，这个就在于没有仔细阅读文档，需要在整个导航栈里面的topmostViewController提供正确的属性设置才行。</p>
<blockquote>
<p>The value of this property on the topmost view controller determines whether the toolbar is visible. If the value of this property is true, the toolbar is hidden. If the value of this property is false, the bar is visible</p>
</blockquote>
<p>或者你可以将你需要横屏的ViewController通过present的形势展现出来（有人觉得会狠突兀，那你自己实现专场动画过渡就可以了）。<strong>不过呢，这种实现方式会有一个超级大坑，待会我们细细说。</strong></p>
<p>上面这种就是强制性的。</p>
<p>而自动旋转的就是打开旋转锁，让界面随着<strong>设备的旋转而进行旋转</strong>，这种旋转是物理特性的，非强制性的。</p>
<p>Q: 那么这两种旋转的区别在哪？<br>A: <strong>UIInterfaceOrientation（UIStatusBar的所处方向）和UIDeviceOrientation</strong>是否一致。</p>
<p>Q: 那么有什么问题呢？<br>A: 在iOS8之后，UIScreen的bounds是随着物理设备的旋转而更改的。如果你需要获取iOS8之前的bounds效果，需要使用<strong>nativeBounds</strong>。但是要记得，nativeBounds是像素级别的，你需要换算到对应的point单位来，所以关系是：</p>
<pre><code>bounds<span class="list">( <span class="keyword">&lt;</span> iOS8.<span class="number">0</span>)</span> = nativeBounds / nativeScale<span class="comment">;</span>
</code></pre><p>大家可以参考苹果的<a href="https://developer.apple.com/reference/uikit/uiscreen/1617838-bounds" target="_blank" rel="external">文档</a>来更确切的掌握一下。</p>
<h3 id="坑">坑</h3><p>上面的内容我们曾经提及在采用多<code>UIWindow</code>时候的几个大坑，如果你现在有自定义的界面，想要添加到除了<code>delegate window</code>之外的window，可能会遇到如下几个问题。</p>
<h4 id="直接将自定义的视图作为Subview添加到UIWindow上">直接将自定义的视图作为Subview添加到UIWindow上</h4><p>从理论上来说UIWindow继承于UIView，这种直接用法在认知上没有任何的问题。但是如果涉及的应用牵扯到横屏模式而且又要支持iOS7的话（我相信现在没有哪个产品还需要支持iOS6）吧，那么针对iOS7需要单独处理横屏的坐标系转换。我们摘录一段著名的开源库<strong>MBProgressHUD</strong>的代码作为示例：</p>
<pre><code><span class="preprocessor">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="title">&lt; 80000
    // Only needed pre iOS 8 when added to a window
    BOOL iOS8OrLater = kCFCoreFoundationVersionNumber &gt;</span>= kCFCoreFoundationVersionNumber_iOS_8_0;</span>
    <span class="keyword">if</span> (iOS8OrLater || ![<span class="keyword">self</span><span class="variable">.superview</span> isKindOfClass:[<span class="built_in">UIWindow</span> class]]) <span class="keyword">return</span>;

    <span class="comment">// Make extension friendly. Will not get called on extensions (iOS 8+) due to the above check.</span>
    <span class="comment">// This just ensures we don't get a warning about extension-unsafe API.</span>
    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
    <span class="keyword">if</span> (!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) <span class="keyword">return</span>;

    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="built_in">UIInterfaceOrientation</span> orientation = application<span class="variable">.statusBarOrientation</span>;
    <span class="built_in">CGFloat</span> radians = <span class="number">0</span>;

    <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsLandscape</span>(orientation)) {
        radians = orientation == <span class="built_in">UIInterfaceOrientationLandscapeLeft</span> ? -(<span class="built_in">CGFloat</span>)M_PI_2 : (<span class="built_in">CGFloat</span>)M_PI_2;
        <span class="comment">// Window coordinates differ!</span>
        <span class="keyword">self</span><span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);
    } <span class="keyword">else</span> {
        radians = orientation == <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> ? (<span class="built_in">CGFloat</span>)M_PI : <span class="number">0.</span>f;
    }

        <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(radians);
<span class="preprocessor">#endif</span>
</code></pre><h4 id="通过rootViewController的view添加子视图">通过rootViewController的view添加子视图</h4><p>这种方式就是通过将<code>window.rootViewController = vc</code>，然后我们所有的子视图都添加到<code>vc.view</code>。</p>
<p>这种使用的好处是我们无需去考虑版本兼容的问题，通过vc.view拿到的坐标系对于我们来说都是和<strong>UIInterfaceOrientation</strong>正确转换过的。</p>
<p>在iOS7之前，坐标系的转换是系统通过设置<code>vc.transform</code>更改；而在iOS8之后，vc和window的旋转会根据<strong>UIDeviceOrientation</strong>和viewcontroller自身<code>supportedInterfaceOrientations</code>进行<strong>交集</strong>的操作。</p>
<p>总之，<strong>需要支持横屏的自定义界面，全部放在viewcontroller.view上来做，是准没错的。</strong></p>
<p>而且，在iOS9以后，苹果推荐每个<code>UIWindow</code>都必须有一个rootViewController。否则<span style="color:red">在启动过程使用了不包含rootViewController的UIWindow中会导致必现的crash</span>。</p>
<h4 id="presentViewController的大坑">presentViewController的大坑</h4><p>我们前面提过，如果想要让viewcontroller单独横屏有两种方式。</p>
<blockquote>
<ol>
<li><p>如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</p>
</li>
<li><p>或者你可以将你需要横屏的ViewController通过present的形势展现出来</p>
</li>
</ol>
</blockquote>
<p>第二种方案在实现过程中，会产生一个非常隐晦的大坑，容我慢慢道来。<br>首先我们需要了解下整体响应旋转变化的事件流程，简单来说如下：</p>
<pre><code><span class="constant">UIScreen </span>-&gt; <span class="constant">UIWindow </span>-&gt; <span class="constant">UIViewController </span>-&gt; <span class="constant">ChildViewControllers </span>-&gt; <span class="constant">View </span>-&gt; <span class="constant">Subviews</span>
</code></pre><p>其中，UIWindow对应的处理方法是：<code>supportedInterfaceOrientationsForWindow</code>；而UIViewController对应的处理方法是<code>supportedInterfaceOrientations</code>。</p>
<p>也就是说，当系统通过这个流程向我们请求界面的UIInterfaceOrientation的时候，我们必须确保我们能够提供正确的返回参数。</p>
<p>而这个流程在使用<code>presentViewController</code>弹出<strong>modalViewController</strong>会产生一些问题：即当你想从<strong>modalViewController</strong> 返回（dismiss）原先的界面的时候，你会发现虽然原先界面强制设置了portrait模式，但是如果<strong>设备锁关闭且设备仍然处于水平状态</strong>，那么此时的UIInterfaceOrientation，仍然是不准确的。</p>
<p>其原因在于：当你想要dismiss的时候，系统的确发起了一次新的请求流程。但是此时，modalViewController正处于dismissing的状态中，请求到的<code>supportedInterfaceOrientations</code>还是针对modalViewController的。所以，如果你的modalViewController是横屏模式，那么返回后的效果就是横屏模式，除非你人为的旋转一下设备，让其回到竖直方向。</p>
<p>Q: 那么这种问题有没有解决办法呢？<br>A: 你可以在<code>supportedInterfaceOrientations</code>里面判断下当前的viewcontroller是不是处于<strong>isBeingDismissed</strong>，如果是的话，取其<strong>presentingViewController</strong>的<code>supportedInterfaceOrientations</code>作为返回值。</p>
<p>Q: 有些同学会问，我们怎么从来没遇到过这个问题？<br>A: 那是因为你们使用的<code>UIWindow</code> 99%的可能都是默认的<code>delegate window</code>，对于这个window，所有的旋转事件都自动帮你校准了，因此无需担忧。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li><a href="https://jkyin.me/uiwindow/" target="_blank" rel="external">UIWindow in iOS</a></li>
<li><a href="http://stackoverflow.com/questions/8598315/after-rotation-uiview-coordinates-are-swapped-but-uiwindows-are-not" target="_blank" rel="external">After rotation UIView coordinates are swapped but UIWindow’s are not?</a></li>
<li><a href="http://chun.tips/blog/2014/10/23/xiang-jie-uicoordinatespacehe-uiscreenzai-ios-8shang-de-zuo-biao-wen-ti/" target="_blank" rel="external">详解UICoordinateSpace和UIScreen在iOS 8上的坐标问题</a></li>
<li><a href="http://stackoverflow.com/questions/25391564/ios-7-dismiss-modal-view-controller-and-force-portrait-orientation" target="_blank" rel="external">iOS 7+ Dismiss Modal View Controller and Force Portrait Orientation</a></li>
<li><a href="http://swiftiostutorials.com/ios-orientations-landscape-orientation-one-view-controller/" target="_blank" rel="external">iOS Orientations: Landscape orientation for only one View Controller</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><p>想必做iOS的人都知道，我们的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个<code>UIWindow</code>，也就是AppDelegate在<code>applicationD]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Immutable来谈谈对于线程安全的理解误区]]></title>
    <link href="http://satanwoo.github.io/2016/07/10/immutable-thread/"/>
    <id>http://satanwoo.github.io/2016/07/10/immutable-thread/</id>
    <published>2016-07-10T09:03:47.000Z</published>
    <updated>2016-07-10T09:08:26.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线程安全中真正起到的作用。</p>
<p>所以今天就以这篇文章来谈谈我所理解的线程安全。</p>
<p>首先就允许我从Immutable来开始整篇话题吧。</p>
<h3 id="Swift中的Immutable">Swift中的Immutable</h3><p>用过Swift的人都知道，Swift相较于Objective-C有一个比较明显的改动就是将结构体（Struct）和类型（Class）进行了分离。从某种方面来说，Swift将值类型和引用类型进行了明显的区分。为什么要这么做？</p>
<ol>
<li>避免了引用类型在被作为参数传递后被他人持有后修改，从而引发比较难以排查的问题。</li>
<li>在某些程度上提供了一定的线程安全（因为多线程本身的问题很大程序上出在<strong>写修改</strong>的不确定性）。而Immutable 数据的好处在于一旦创建结束就无法修改，因此相当于任一一个线程在使用它的过程中仅仅是使用了读的功能。</li>
</ol>
<p>看到这，很多人开始欢呼了（嘲讽下WWDC那些“托”一般的粉丝，哈哈），觉得线程安全的问题迎刃而解了。</p>
<p>但事实上，我想说的是<strong>使用Immutable不直接等同于线程安全</strong>，不然在使用NSArray，NSDictionary等等Immutable对象之后，为啥还会有那么多奇怪的bug出现？</p>
<h3 id="指针与对象">指针与对象</h3><p>有些朋友会问，Immutable都将一个对象变为不可变的“固态”了，为什么还是不安全呢，在各个线程间传递的只是一份只读文件啊。</p>
<p>是的，对于一个Immutable的对象来说，它自身是不可变了。但是在我们的程序里，我们总是需要有“东西”去指向我们的对象的吧，那这个“东西”是什么？<strong>指向对象的指针</strong>。</p>
<p>指针想必大家都不会陌生。对于指针来说，其实它本质也是一种对象，我们更改指针的指向的时候，实质上就是对于指针的一种赋值。所以想象这样一种场景，当你用一个指针指向一个Immutable对象的时候，在多线程更改的时候，你觉得你的指针修改是线程安全的吗？这也就是为什么有些人碰到一些跟<strong>NSArray</strong>这种Immutable对象的在多线程出现奇怪bug的时候会显得一脸懵逼。</p>
<p>举例：  </p>
<pre><code><span class="comment">// Thread A 其中immutableArrayA count 7</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayA;

<span class="comment">// Thread B 其中immutableArrayB count 4</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayB 

<span class="comment">// main Thread</span>
<span class="preprocessor">[</span><span class="built_in">self</span><span class="built_in">.</span>xxx objectAtIndex:<span class="number">5</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述这个代码片段，绝对是存在线程的安全的隐患的。</p>
<h3 id="锁">锁</h3><p>既然想到了多线程对于指针（或者对象）的修改，我们很理所当然的就会想到用锁。在现如今iOS博客泛滥的年代，大家都知道NSLock, OSSpinLock之类的可以用于短暂的Critical Section竞态的锁保护。</p>
<p>所以对于一些多线程中需要使用共享数据源并支持修改操作的时候，比如NSMutableArray添加一些object的时候，我们可以写出如下代码：</p>
<pre><code>OSSpinLock(&amp;_lock)<span class="comment">;</span>
[self.array addObject:@"hahah"]<span class="comment">;</span>
OSSpinUnlock(&amp;_lock)<span class="comment">;</span>
</code></pre><p>乍一看，这个没问题了，这个就是最基本的写保护锁。如果有多个代码同时尝试添加进入<code>self.array</code>，是会通过锁抢占的方式一个一个的方式的添加。</p>
<p>但是，这个东西有啥卵用吗？原子锁只能解决Race Condition的问题，但是它并不能解决任何你代码中需要有时序保证的逻辑。</p>
<p>比如如下这段代码：</p>
<pre><code>if (<span class="literal">self</span>.xxx) {
    [<span class="literal">self</span>.dict <span class="built_in">set</span>Object:@<span class="string">"ah"</span> <span class="keyword">for</span>Key:<span class="literal">self</span>.xxx];
}
</code></pre><p>大家第一眼看到这样的代码，是不是会认为是正确的？因为在设置key的时候已经提前进行了<code>self.xxx</code>为<strong>非nil</strong>的判断，只有非nil得情况下才会执行后续的指令。<strong>但是，如上代码只有在单线程的前提下才是正确的。</strong></p>
<p>假设我们将上述代码目前执行的线程为<code>Thread A</code>，当我们执行完<code>if (self.xxx)</code>的语句之后，此时CPU将执行权切换给了<code>Thread B</code>，而这个时候Thread B中调用了一句<strong><em><code>self.xxx = nil</code></em></strong>。<div style="color:red"><b>嘿嘿，后果如何，想必我不用多说了吧。</b></div></p>
<p>那对于这种问题，我们有没有比较好的解决方案呢？答案是存在的，就是使用<strong>局部变量</strong>。<br>针对上述代码，我们进行如下修改：</p>
<pre><code>__strong id <span class="function"><span class="keyword">val</span> =</span> self.xxx;
<span class="keyword">if</span> (<span class="function"><span class="keyword">val</span>) {</span>
    [self.dict setObject:@<span class="string">"ah"</span> forKey:<span class="function"><span class="keyword">val</span>];</span>
}
</code></pre><p>这样，无论多少线程尝试对<code>self.xxx</code>进行修改，本质上的<code>val</code>都会保持现有的状态，符合非nil的判断。</p>
<h3 id="Objective-C的Property_Setter多线程并发bug">Objective-C的Property Setter多线程并发bug</h3><p>最后我们回到经常使用的Objective-C来谈谈现实生活中经常出现的问题。相信各位对于Property的Setter概念都不陌生，<code>self.xxx = @&quot;kks&quot;</code>其实就是调用了<code>xxx</code>的setter方法。而Setter方法本质上就是如下这样一段代码逻辑：</p>
<pre><code>- (void)setXxx:(NSString *)newXXX {
      if (newXXX != _xxx) {
          [newXXX retain]<span class="comment">;</span>
          [_xxx release]<span class="comment">;</span>
          _userName = newXXX<span class="comment">;</span>
      }
}
</code></pre><p>比如<strong>Thread A 和 B</strong>同时对<code>self.xxx</code>进行了赋值，当两者都越过了<code>if (newXXX != _xxx)</code>的判断的时候，就会产生<code>[_xxx release]</code>执行了两次，造成过度释放的crash危险。</p>
<p>有人说，呵呵，你这是MRC时代的写法，我用了ARC，没问题了吧。</p>
<p>ok，那让我们来看看ARC时代是怎么处理的，对于ARC中不复写Setter的属性（我相信是绝大多数情况），Objective-C的<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm" target="_blank" rel="external">底层源码</a>是这么处理的。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, 
  ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) 
{
    <span class="keyword">id</span> oldValue;
    <span class="comment">// 计算结构体中的偏移量</span>
    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);

    <span class="keyword">if</span> (<span class="keyword">copy</span>) {
        newValue = [newValue copyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> {
        <span class="comment">// 某些程度的优化</span>
        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;
        newValue = objc_retain(newValue);
    }

    <span class="comment">// 危险区</span>
    <span class="keyword">if</span> (!atomic) {
         <span class="comment">// 第一步</span>
        oldValue = *slot;

        <span class="comment">// 第二步</span>
        *slot = newValue;
    } <span class="keyword">else</span> {
        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
        _spin_lock(slotlock);
        oldValue = *slot;
        *slot = newValue;        
        _spin_unlock(slotlock);
    }

    objc_release(oldValue);
}
</code></pre><p>由于我们一般声明的对象都是<strong>nonatomic</strong>，所以逻辑会走到上述注释<strong>危险区</strong>处。还是设想一下多线程对一个属性同时设置的情况，我们首先在线程A处获取到了执行第一步代码后的<strong>oldValue</strong>，然后此时线程切换到了B，B也获得了第一步后的oldValue，所以此时就有两处持有oldValue。然后无论是线程A或者线程B执行到最后都会执行<strong>objc_release(oldValue);</strong>。</p>
<div style="color:red"><b>于是，重复释放的场景就出现了，crash在向你招手哦！</b></div>

<p>如果不相信的话，可以尝试如下这个小例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>相信你很容易就能看到如下错误log：<strong>error for object: pointer being freed was not allocated</strong>。</p>
<h3 id="结语">结语</h3><p>说了这么多，本质上线程安全是个一直存在并且相对来说是个比较困难的问题，没有绝对的银弹。用了Immutable不代表可以完全抛弃锁，用了锁也不代表高枕无忧了。希望这篇文章能够帮助大家更深入的思考下相关的问题，不要见到线程安全相关的问题就直接回答加锁、使用Immutable数据之类的。</p>
<p><strong>当然，其实Stick To GCD (dispatch_barrier)是最好的解决方案。</strong></p>
<p>本文写于头昏脑涨之中，写错之处请大神多多指出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线]]>
    </summary>
    
      <category term="iOS" scheme="http://satanwoo.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
