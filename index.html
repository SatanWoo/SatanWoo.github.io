<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SatanWoo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="SatanWoo">
<meta property="og:url" content="http://satanwoo.github.io/index.html">
<meta property="og:site_name" content="SatanWoo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SatanWoo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="SatanWoo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SatanWoo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/sitemap.xml">map</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://satanwoo.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TrampolineHookOpenSource" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/TrampolineHookOpenSource/" class="article-date">
  <time datetime="2020-04-25T16:28:53.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/TrampolineHookOpenSource/">基于桥的全量方法 Hook 方案（3）- 开源 TrampolineHook</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本来以为是双休日，结果五一调休本周末只休一天，懵逼。不过还算完成了承诺，赶了出来。</p>
</blockquote>
<p>开源地址：<a href="https://github.com/SatanWoo/TrampolineHook" target="_blank" rel="external">https://github.com/SatanWoo/TrampolineHook</a>  </p>
<h3 id="TrampolineHook_是什么">TrampolineHook 是什么</h3><p>之前<b style="color:red">中国90后 iOS 第一人杨萧玉</b>在看到我<a href="http://satanwoo.github.io/2020/04/22/NewBridgeHook/">《基于桥的全量方法 Hook 方案（2） - 全新升级》</a> 后就问我这个和直接用 <code>method_exchangeImplementation</code> 之类的 <code>runtime</code> 方法交换 <code>IMP</code> 性能对比咋样？</p>
<p>所以这篇文章开头先占用大家宝贵的两分钟，简要说明下。</p>
<p><code>TrampolineHook</code> 本质上不是用来 <code>Swizzling</code> 的框架，取 <code>Hook</code> 这个名字只是为了读起来顺口。<b style="color:red">它实际上是一个中心重定向框架。</b> 换句话说，你可以认为它是为了通过<strong>一个函数替换/拦截所有你想要函数的框架。</strong></p>
<p>其实这个中心重定向的思想并不新潮，很多人（包括我自己）在内就曾经利用重载 <code>objc_msgForward</code> 干过这样的事。</p>
<p>但是这个方式我在之前的文章里也提到过对应的缺点，比如：</p>
<ul>
<li>性能慢</li>
<li>不能替换/拦截同一个继承链上的多个类。</li>
</ul>
<p>所以可以认为 <code>TrampolineHook</code> 是一个让你<strong>不用关注底层架构Calling Convention（因为涉及到汇编），不用关心上下文信息保存、恢复，不用担心引入传统 Swizzle 方案在大型项目中有奇奇怪怪 Crash 问题的中心重定向框架。</strong></p>
<h3 id="TrampolineHook_技术原理">TrampolineHook 技术原理</h3><p>整个技术原理其实可以分为三部分：</p>
<ul>
<li><p><code>vm_remap</code> 技术。</p>
</li>
<li><p>流程设计。</p>
</li>
<li><p>汇编实现。</p>
</li>
</ul>
<h4 id="vm_remap_的价值">vm_remap 的价值</h4><p>通俗意义上，我们访问的内存都是按照页来组织。而在程序加载后分配的页之中，会对应有不同的权限，比如代码占用的页，就是可读且可执行，但是一般不具备可写的权限；而存放数据的页呢，就对应是可读且可写，但不能拥有可执行权限。</p>
<p><strong>在绝大多数情况下</strong>，当我们编写完一个程序运行的时候，动态分配的页都是用来做数据保存、访问的，不太会有涉及执行权限。</p>
<p>而要做到可以将动态分配出来的内存页具备可执行权限，就需要利用 <code>vm_remap</code>。 它的定义是这样的：</p>
<p>On Darwin, vm_remap() provides support for mapping an existing code page at new address, while retaining the existing page protections; using vm_remap(), we can create multiple copies of existing, executable code, placed at arbitrary addresses. </p>
<p>从定义中我们可以知道两点信息：</p>
<ul>
<li><p><code>vm_remap</code> 可以让内存页具备被 map 的页的特性，如果是可执行页被 map，那新创建的页自然而然页具备了这个权限。</p>
</li>
<li><p><code>vm_remap</code> 也不是肆无忌惮的创建任何可执行的页，通俗理解，它只是一个 copy 映射。</p>
</li>
</ul>
<p><img src="https://landonf.org/static/blog/code/objc/blockimp_vm_remap.png" alt=""></p>
<p><img src="https://landonf.org/static/blog/code/objc/blockimp_vm_remap_data.png" alt=""></p>
<p>因此，我们可以通过在编写代码的过程中，<b style="color:red">精心构造、预留在程序二进制的代码页</b>，在运行时不断<strong>“复制映射”</strong>，来完成特殊的使命。</p>
<p>在我们的定义中，我们是构造了<b style="color:red">连续的两个页</b>。</p>
<h4 id="流程设计">流程设计</h4><p>要构造特殊的程序二进制代码，首先还是要梳理我们的目的，<b style="color:red">我们的诉求是所有的函数都能先进入我们的一个中心重定向函数，执行自定义的操作，然后返回原函数，同时这个调用栈不能乱。</b></p>
<ul>
<li>把一个我们要替换的原方法 IMP A 取出来，保存起来。</li>
<li>给这个原方法塞一个动态分配的可执行地址 B。</li>
<li>当执行这个原方法的时候，会跳转到 可执行地址 B。</li>
<li>这个 B 经过一段简短的运算操作，可以获取到原先保存的 IMP A。</li>
<li>在跳转回 IMP A 之前，统一拦截函数先做些事情，比如检查是不是主线程调用之类的。</li>
</ul>
<p><b style="color:red">【注意】：在整个过程中，我们要保证参数寄存器、返回地址等不能错乱。</b></p>
<h4 id="汇编实现">汇编实现</h4><p>既然 <code>vm_remap</code> 是按页的维度来映射，我们要构造的代码自然而然要<b style="color:red">页对齐</b>。<strong>在 arm64 中，一页是 0x4000，也就是 16KB</strong>，所以首先就是 <code>.align 14</code> 来确保。</p>
<p>然后上一下最关键部分的代码，感兴趣的还是去 <a href="https://github.com/SatanWoo/TrampolineHook" target="_blank" rel="external">Github</a> 上阅读完整的代码吧。</p>
<pre><code><span class="label">_th_entry</span>:

// 不要小看这五行汇编
<span class="keyword">nop
</span><span class="keyword">nop
</span><span class="keyword">nop
</span><span class="keyword">nop
</span><span class="keyword">nop
</span>
<span class="keyword">sub </span>x12, <span class="literal">lr</span>,   <span class="number">#0x8</span>
<span class="keyword">sub </span>x12, x12,  <span class="number">#0x4000</span>
<span class="keyword">mov </span><span class="literal">lr</span>,  x13

<span class="keyword">ldr </span>x10, [x12]

<span class="label">stp</span> <span class="literal">q0</span>,  <span class="literal">q1</span>,   [<span class="literal">sp</span>, #-<span class="number">32</span>]!
<span class="label">stp</span> <span class="literal">q2</span>,  <span class="literal">q3</span>,   [<span class="literal">sp</span>, #-<span class="number">32</span>]!
<span class="label">stp</span> <span class="literal">q4</span>,  <span class="literal">q5</span>,   [<span class="literal">sp</span>, #-<span class="number">32</span>]!
<span class="label">stp</span> <span class="literal">q6</span>,  <span class="literal">q7</span>,   [<span class="literal">sp</span>, #-<span class="number">32</span>]!

<span class="label">stp</span> <span class="literal">lr</span>,  x10,  [<span class="literal">sp</span>, #-<span class="number">16</span>]!
<span class="label">stp</span> x0,  x1,   [<span class="literal">sp</span>, #-<span class="number">16</span>]!
<span class="label">stp</span> x2,  x3,   [<span class="literal">sp</span>, #-<span class="number">16</span>]!
<span class="label">stp</span> x4,  x5,   [<span class="literal">sp</span>, #-<span class="number">16</span>]!
<span class="label">stp</span> x6,  x7,   [<span class="literal">sp</span>, #-<span class="number">16</span>]!
<span class="keyword">str </span>x8,        [<span class="literal">sp</span>, #-<span class="number">16</span>]!

// 加载自定义的拦截器，并跳转过去。
<span class="keyword">ldr </span>x8,  interceptor
<span class="keyword">blr </span>x8

<span class="keyword">ldr </span>x8,        [<span class="literal">sp</span>], <span class="number">#16</span>
<span class="label">ldp</span> x6,  x7,   [<span class="literal">sp</span>], <span class="number">#16</span>
<span class="label">ldp</span> x4,  x5,   [<span class="literal">sp</span>], <span class="number">#16</span>
<span class="label">ldp</span> x2,  x3,   [<span class="literal">sp</span>], <span class="number">#16</span>
<span class="label">ldp</span> x0,  x1,   [<span class="literal">sp</span>], <span class="number">#16</span>
<span class="label">ldp</span> <span class="literal">lr</span>,  x10,  [<span class="literal">sp</span>], <span class="number">#16</span>

<span class="label">ldp</span> <span class="literal">q6</span>,  <span class="literal">q7</span>,   [<span class="literal">sp</span>], <span class="number">#32</span>
<span class="label">ldp</span> <span class="literal">q4</span>,  <span class="literal">q5</span>,   [<span class="literal">sp</span>], <span class="number">#32</span>
<span class="label">ldp</span> <span class="literal">q2</span>,  <span class="literal">q3</span>,   [<span class="literal">sp</span>], <span class="number">#32</span>
<span class="label">ldp</span> <span class="literal">q0</span>,  <span class="literal">q1</span>,   [<span class="literal">sp</span>], <span class="number">#32</span>

<span class="keyword">br </span> x10

<span class="label">.rept</span> <span class="number">2032</span>
<span class="keyword">mov </span>x13, <span class="literal">lr</span>
<span class="keyword">bl </span>_th_entry<span class="comment">;</span>
<span class="label">.endr</span>
</code></pre><p>整段汇编可以分为几个部分：</p>
<ul>
<li><p>设计一大堆的动态可执行地址，即：</p>
<pre><code><span class="label">.rept</span> <span class="number">2032</span>
<span class="keyword">mov </span>x13, <span class="literal">lr</span>
<span class="keyword">bl </span>_th_entry<span class="comment">;</span>
<span class="label">.endr</span>
</code></pre><p>这里最早我的实现是复制粘贴一大堆重复性代码，<b style="color:red">在 HookZZ 作者的指导下，我优化成了上述这样。</b></p>
</li>
<li><p>执行统一的运行过程，通过偏移计算等方式获取保留的原始 IMP。</p>
</li>
<li><p>要注意特定的寄存器用处，<code>x8-x18</code>是临时寄存器，里面的值在函数调用后可能被修改，这些寄存器为caller-saved。<b style="color:red">所以在我们自身函数可以用，但是要在调用别的函数之前保存好。</b></p>
</li>
<li><p>要特别注意对 LR 寄存器的处理，没处理好，调用栈就回不去了。</p>
</li>
<li><p>保存对应的参数、浮点参数等寄存器，避免上下文被我们自己的处理函数破坏。</p>
</li>
<li><p><code>b / bl</code> 的跳转范围非常有限，由于我们是动态地址分配，不能保证拦截函数的范围偏移，所以要采用 <code>blr</code> 的方式。</p>
</li>
</ul>
<h3 id="TrampolineHook_用处">TrampolineHook 用处</h3><p>和传统的 <code>Swizzle</code> 需要提供对应的替换后的函数实现不同，中心化重定向思想可以帮助你实现很多有意思的事情：</p>
<ul>
<li><p>比如网上很常见的 <code>hook objc_msgSend</code>，可以帮你查看任意被 Hook 二进制中的函数耗时和调用链路。</p>
</li>
<li><p>比如 <code>Bang</code> / <code>AnyMethodLog</code> 这样的重定向 Log 日志框架等等。</p>
</li>
</ul>
<p><b style="color:red">苹果著名的 <code>MainThreadChecker</code> 也用了类似的技术。由于我才疏学浅，只是大致完成了对其实现的逆向，通过 <code>TrampolineHook</code> 进行了重写。</b> 因为效果还不错，所以也开源了出来，地址是：<a href="https://github.com/SatanWoo/TrampolineHook/tree/master/Example/MainThreadChecker" target="_blank" rel="external">https://github.com/SatanWoo/TrampolineHook/tree/master/Example/MainThreadChecker</a></p>
<p>这次在重写 <code>MainThreadChecker</code> 的过程中，我也对比了下和 2017 年苹果实现的差异。在整体流程上没有比较大的差异，但是还是有一些细节可以分享分享：</p>
<ul>
<li>iOS 10 的时候对应的二进制是 <code>UIKit</code>，到了 iOS 12/13 成了 <code>UIKitCore</code>，所以原先获取二进制的逻辑失效了，为了避免后续版本的变更干扰，我采用了苹果自身的守候，通过 <code>class_getImageName([UIResponder class])</code> 来保证获取的就是我们理解上的 <code>UIKit</code> 动态库。</li>
</ul>
<p>当然 <code>TrampolineHook</code> 的作用不止于此，争取过段时间把我的一些想法做完善再和大家交流。</p>
<h3 id="后续思考">后续思考</h3><p>如果有朋友对 arm64 的汇编比较熟悉，同时对函数调用也比较了解的话，会很快的发现我上述提供的汇编代码存在一个漏洞（虽然这个漏洞绝大多数人用不到），感兴趣的朋友可以微信交流下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2020/04/26/TrampolineHookOpenSource/" data-id="ck9fy2gfc001j2ni1ef74x1sg" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2020/04/26/TrampolineHookOpenSource/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Assembly-Language/">Assembly Language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-NewBridgeHook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/NewBridgeHook/" class="article-date">
  <time datetime="2020-04-21T16:12:51.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/NewBridgeHook/">基于桥的全量方法 Hook 方案（2） - 全新升级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果读过我的博客的人可能知道，我在 <b style="color:red">2017</b> 年曾经研究过<b style="color:red">当时苹果出的一个新玩意 MainThread Checker</b>，并以此为基础推导了一个基于桥的全量 Hook 方案，<a href="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/">基于桥的全量方法Hook方案 - 探究苹果主线程检查实现
</a> 。当时简单写了下 ARM64 的方案代码，并放在了 Github 上，不过已废弃。</p>
<p>当时觉得自己研究的还算深入，基于汇编写（其实是复制粘贴）了一大堆的桥，可以<b style="color:red">针对性</b> Hook 一个或多个二进制，比如 UIKit 的逻辑，觉得挺屌的。</p>
<p>但是使用中发现了<b style="color:red">两个巨大的问题：</b></p>
<ul>
<li>性能问题。由于我是运行时的方案，没法对二进制产物进行修改（比如编译插桩），因此如果要能达到对二进制所有方法<b style="color:red">中心重定向的效果</b>，借助了 forwarding 的流程（不是objc_msgForward）。但是这个方案懂的人肯定明白，性能巨慢。</li>
</ul>
<blockquote>
<p>不能上线的方案其实价值都不大。</p>
</blockquote>
<ul>
<li>Crash 问题。尽管我通过汇编的方式解决了中心重定向 Hook 方案上对一条继承链重复 Hook 会死循环的 Crash 问题(如果你不理解，可以回到我文章开头所提及的文章了解原因或者查看 Aspects 库中对应的 issue)， <b style="color:red">但是却出乎意料的引入了系统库新的 Crash，这个我会开一篇新的文章来分析。</b></li>
</ul>
<p>因此，当时这个方案我就抛弃了，后续也因为我不怎么搞iOS，就没深入优化。</p>
<h4 id="新的方案">新的方案</h4><p>新的方案的起源灵感来自于我隔壁组的同事，<strong>手淘架构新生代小天王谢俊逸</strong>的启发。他说你用汇编写桥，照理性能不会慢啊，你为啥要走一次 forwarding 的逻辑？</p>
<p>我回顾了下代码，发现原先我为了保留所谓的<b style="color:red">层级上下文</b>，将类名和方法名构造成了一个唯一标示，然后将这个唯一标示和一个动态生成的函数地址相绑定。然后通过这个不存在的方法名触发 forwarding 流程，然后改写成正确的方法名，从而调用正确的被 HOOK 前的函数。</p>
<blockquote>
<p>看不懂的话等我周末整理下代码开源吧。</p>
</blockquote>
<p><b style="color:red">而整个流程，也是如下两个问题的罪魁祸首。</b></p>
<ul>
<li><p>改了方法名：SEL 的修改之前是为了解决中心重定向相同继承链上的 Hook Crash 问题，但是会导致意想不到的其他 Crash 问题。</p>
</li>
<li><p>性能巨慢：走 fowarding 流程绕了一大圈。</p>
</li>
</ul>
<p>要解决上述这些问题，汇编和桥依然是不可或缺的，但是如何把所有 UIKit 的方法都中心重定向同时又能绕开继承链问题呢还能不修改 SEL 的名称呢？</p>
<p>经过和<strong>谢俊逸</strong>的讨论，我们发现，我们把原先保存 <strong>拼接后 SEL 的逻辑，换成直接保存 HOOK 之前的 函数IMP，然后通过汇编直接跳过去执行 IMP 不就完事了？</strong></p>
<p><b style="color:red">思路非常 Nice ！ 开工</b>  </p>
<h4 id="动手过程">动手过程</h4><p>想法有了，因为涉及到汇编，需要非常复杂的操作流程，简单抛砖引玉一下。</p>
<pre><code>_template_page:
sub x12, lr, <span class="preprocessor">#<span class="number">0x8</span></span>
sub x12, x12, <span class="preprocessor">#<span class="number">0x4000</span> <span class="comment">// 获取对应数据页的便宜</span></span>
mov lr, x13   <span class="comment">// 获取返回原始调用处</span>

<span class="comment">// x8-x18 临时寄存器，里面的值在函数调用后可能被修改，这些寄存器为caller-saved，可以用</span>
ldr x10, [x12] <span class="comment">// originIMP</span>

stp lr, x10, [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>
stp x0, x1,  [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>
stp x2, x3,  [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>
stp x4, x5,  [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>
stp x6, x7,  [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>
str x8,      [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span>

<span class="comment">// 我不用浮点数寄存器，所以我不保存，你们用你们要保存</span>
<span class="comment">// 这行是伪代码，意思意思。实际上这个代码是会Crash的。</span>
bl _WZQMainThreadChecker

ldr x8,      [sp], <span class="preprocessor">#<span class="number">16</span></span>
ldp x6, x7,  [sp], <span class="preprocessor">#<span class="number">16</span></span>
ldp x4, x5,  [sp], <span class="preprocessor">#<span class="number">16</span></span>
ldp x2, x3,  [sp], <span class="preprocessor">#<span class="number">16</span></span>
ldp x0, x1,  [sp], <span class="preprocessor">#<span class="number">16</span></span>
ldp lr, x10, [sp], <span class="preprocessor">#<span class="number">16</span></span>

br x10   <span class="comment">// 执行原函数</span>

mov x13, lr
bl _template_page;

<span class="comment">//// 下面是重复性的一堆代码。</span>
</code></pre><p>主体上是这么写，但是需要考虑的太多了，今天周二，来不及整完博客了，吹吹逼睡觉。</p>
<p>还有很多东西实现了但是文章中没写，周末再写吧，水一篇博客。</p>
<ul>
<li><p>要考虑对齐问题？</p>
</li>
<li><p>为什么可以这么设计桥？</p>
</li>
<li><p>如何保存重要的上下文、寄存器信息等？</p>
</li>
</ul>
<h4 id="结尾">结尾</h4><p>代码写完后我和同事放在手淘里跑了泡，美滋滋，嘻嘻。不崩，还挺顺畅，哈哈，吊打原先的实现。</p>
<p>当然，鉴于本人汇编仅较初级的掌握 ARM64，因此 x86_64 或者 ARM64e（不知道有没有差别） 上的方案近期慢慢等我搞出来吧。</p>
<p>ARM64 上的代码等我周末慢慢整理下开源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2020/04/22/NewBridgeHook/" data-id="ck9fy2gh6002r2ni121ymzaqu" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2020/04/22/NewBridgeHook/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Assembly/">Assembly</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Selective-Search" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/07/Selective-Search/" class="article-date">
  <time datetime="2020-04-06T16:36:44.000Z" itemprop="datePublished">2020-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/07/Selective-Search/">目标检测之 Selective Search</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><br>最近因为工作上的事，搞了一点非常基础目标检测相关的东西。正好在学习之余梳理了下之前自己认知错误的一些地方，记录一下。<br></p>
<h3 id="起因">起因</h3><p><br>之前对于目标检测的了解停留于深度学习部分，比如 Fast-RCNN / Faster-RCNN / Yolo 等等，对于候选框域搜索算法主要还是对于 RPN 的认知。<br><br><br>但是这次在工作中了解到了 Selective Search 的概念，没想到在小样本训练的过程中精度也不错，性能还很好，哈哈。因此决定深入研究下。Selective Search 从大类上也可以属于 Region Proposal 的思想，但是主要的思想却是来源于传统的图像处理。<br><br><br>相关的论文发表于 IJCV 2013 《Selective Search for Object Detection》，大家可自行阅读获取更多细节。<br></p>
<blockquote>
<p>主要还是学习目的，业界主流的还是采用 Faster-RCNN 的做法。</p>
</blockquote>
<h3 id="Selective_Search">Selective Search</h3><p><br>目标检测问题相对来说比图像分类复杂点，因为一般情况下要同时检测出多个子物体的位置（及可能需要的分类目的）。最原始的做法就是对于一张图像的每个可能位置都进行搜索，但是这里会产生一个两个互相增加复杂度的问题？<br></p>
<ul>
<li>我们要识别的物体在哪？我们要识别的物体大小是多少？长宽比要不要考虑？</li>
</ul>
<p><br><strong>简单来说，假设知道一个待识别的物体左上角顶点处于（x, y），那么长和宽分别设置多少呢？设置小了，可能没有办法得到正确要识别的物体；设置大了，可能又把要分开区分的两个或多个物体合在了一起。</strong><br><br><br>因此，这种传统的做法产生的搜索空间基本可以认为是无穷尽的。<br><br><br><strong>那么自然而然地，我们的优化的想法肯定是减少搜索空间的大小！怎么做呢？</strong><br><br><br>答案说难也不难，就是<strong>只找哪些可能是物体的区域。从区域这个维度进行搜索，而不是全图像的像素级查询。</strong><br></p>
<blockquote>
<p>全图搜索绝大多数的搜索像素包含区域是不包含物体的，实质上是浪费，可以通过如下两张图进行直观对比。</p>
</blockquote>
<p><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/520564/1586190762414-d187819a-a5f8-467c-ac0e-b6f4fdb0facd.jpeg#align=left&amp;display=inline&amp;height=416&amp;originHeight=416&amp;originWidth=813&amp;size=0&amp;status=done&amp;style=none&amp;width=813" alt=""><br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/520564/1586190762646-b0f5a4d4-ea6d-4223-a427-3dcab2360020.jpeg#align=left&amp;display=inline&amp;height=389&amp;originHeight=389&amp;originWidth=794&amp;size=0&amp;status=done&amp;style=none&amp;width=794" alt=""><br><br><br>基于此，作者首先利用图像分割的想法，来获取可能是物体的区域；<strong>当然，这种层次的分割肯定不准<br><br><br>进一步地，考虑掉物体之间诸如包含等关系，通过</strong>合并<strong>的方式来构建</strong>层次化**的潜在物体区域。<br><br><br>所以整篇论文的核心就可以归纳为如下的数学公式：<br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/520564/1586190762438-1360cd20-f297-4977-8835-07cd1d7ac43b.png#align=left&amp;display=inline&amp;height=389&amp;originHeight=389&amp;originWidth=452&amp;size=0&amp;status=done&amp;style=none&amp;width=452" alt=""><br></p>
<ul>
<li>通过图像分割算法得到初始区域集合 R = {r1, ….. rn}，这个很容易理解吧，就是图像分割。</li>
<li>设定一个相似集合 S，初始为<strong>空</strong>。</li>
<li>对于初始区域集合<strong>相邻</strong>中的每一对(ri, rj)，计算<strong>相似度（下文会说如何计算相似度）</strong>，得到 s(ri, rj)，将其加入之前的相似集合 S 中。</li>
<li>当 S 不为空的时候，从 S 中获取相似度最大的一对 s(ri, rj)，将这两个 ri, rj 区域合并，称为 rt。</li>
<li>把所有和 ri, rj 相关的<strong>相似度对</strong>都从 S 中移除掉。（ri, rj 已经不存在了，变身为 rt）</li>
<li>把新得到的 rt，在分别和其邻区域的 rx 们，计算相似度对，存入 S 中。</li>
<li>把 rt 加入到区域集合 R 中。</li>
<li>重复步骤，知道合并到最后只有一个区域了（即 S 为空）。</li>
</ul>
<p><br>这个时候，R 集合中的所有区域，就是通过 Selective Search 得到的候选框区域。<br><br><br><strong>值得注意的是，这种计算方式得到的 R，本身就包含了多层次的关系。</strong><br></p>
<p><a name="3a2cccf8"></a></p>
<h4 id="如何合并">如何合并</h4><p><br>前面我们提到了，我们初始的待定区域是基于图像分割得到的一批候选集，但是这些候选集的质量还比较“糙”，粒度也不一定对，需要合并甚至多次合并来处理一下。<strong>因此，如何合并也是一个相对值得思考的问题。</strong><br><strong><br></strong><img src="https://cdn.nlark.com/yuque/0/2020/png/520564/1586190829238-e23f2c94-b271-499f-9cc7-230e005a8d94.png#align=left&amp;display=inline&amp;height=522&amp;name=%E6%88%AA%E5%B1%8F2020-04-07%E4%B8%8A%E5%8D%8812.33.29.png&amp;originHeight=522&amp;originWidth=1656&amp;size=1153243&amp;status=done&amp;style=none&amp;width=1656" alt="截屏2020-04-07上午12.33.29.png"><strong><br></strong></p>
<blockquote>
<p>上两张图不难看出，初始化的图像分割对于目标检测来说是不能直接使用的。</p>
</blockquote>
<p><br><strong>其实这篇文章，作者也坦诚道：图片的样式千变万化，某些图片里面可行的方案到了另外一些图片中就不适用了。</strong> 因此，作者采用了多种方案混合的合并方法。<br></p>
<ul>
<li>比如，背景色大块区域和前景色不同的主体可以很明显区分。</li>
<li>比如，材质 / 纹理等也可以比较明显区分出待检测的物体。</li>
<li>比如，形状和大小也可以做为检测手段区分待检测物体。</li>
</ul>
<p><br>有了这些可以参考的思路，作者设计了<strong>四合一的合并公式。</strong><br></p>
<ul>
<li>颜色相似度</li>
<li>纹理相似度，这里使用了 SIFT 算法。</li>
<li>小区域合并优先级度。这里解释下，作者为了避免出现“大鱼吃小鱼”的现象，即一块区域不断膨胀，吞并周围区域，所以采用了尽量将小区域先分别合并，始终保持大小类似的方式。</li>
<li>距离。如果区域ri包含在rj内，毫无疑问应该立刻合并，另一方面，如果ri很难与rj相接，不应该合并在一块。这里定义区域的合适度距离主要是为了衡量两个区域是否更加“吻合”，其指标是合并后的区域的Bounding Box（能够框住区域的最小矩形BBij）越小，其吻合度越高。</li>
</ul>
<p><a name="72f1243d"></a></p>
<h3 id="Selective_Search_代码理解">Selective Search 代码理解</h3><p><br>读顶尖学术会议论文的好处就是一般对应的代码都会开源，即使论文读的云里雾里，但是只要能大致理解思路，配合源代码深入分析，总是能懂。<br><br><br>这篇论文对应的代码开源在<a href="https://github.com/AlpacaDB/selectivesearch" target="_blank" rel="external">Selective Search</a>，代码总计也就 <strong>300+</strong> 行（当然有些非核心代码直接依赖了库），很容易理解。<br></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">def selective_search(</span><br><span class="line">        im_orig, scale=1.0, sigma=0.8, min_size=50):</span><br><span class="line">    '''Selective Search</span><br><span class="line">    </span><br><span class="line"> 	 assert im_orig.shape[2] == 3, "3ch image is expected"</span><br><span class="line"></span><br><span class="line">    # <span class="operator"><span class="keyword">load</span> image <span class="keyword">and</span> <span class="keyword">get</span> smallest regions</span><br><span class="line">    # region label <span class="keyword">is</span> <span class="keyword">stored</span> <span class="keyword">in</span> the <span class="number">4</span>th <span class="keyword">value</span> <span class="keyword">of</span> <span class="keyword">each</span> pixel [r,<span class="keyword">g</span>,b,(region)]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   【<span class="number">1</span>】图像分割</span><br><span class="line">    img = _generate_segments(im_orig, scale, sigma, min_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	【<span class="number">2</span>】获取对象总大小</span><br><span class="line">    imsize = img.shape[<span class="number">0</span>] * img.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">   【<span class="number">3</span>】获取初始集合</span><br><span class="line">    R = _extract_regions(img)</span><br><span class="line"></span><br><span class="line">    # <span class="keyword">extract</span> neighbouring information</span><br><span class="line">    </span><br><span class="line">   【<span class="number">4</span>】计算相邻的区域</span><br><span class="line">    neighbours = _extract_neighbours(R)</span><br><span class="line"></span><br><span class="line">   【<span class="number">5</span>】计算初始化的相邻区域相似度</span><br><span class="line">    S = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (ai, ar), (bi, br) <span class="keyword">in</span> neighbours:</span><br><span class="line">        S[(ai, bi)] = _calc_sim(ar, br, imsize)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	【<span class="number">6</span>】就是之前我们说的搜索过程</span><br><span class="line">    # hierarchal <span class="keyword">search</span></span><br><span class="line">    <span class="keyword">while</span> S != &#123;&#125;:</span><br><span class="line"></span><br><span class="line">        # <span class="keyword">get</span> highest similarity</span><br><span class="line">        <span class="keyword">i</span>, j = sorted(S.items(), <span class="keyword">key</span>=lambda <span class="keyword">i</span>: <span class="keyword">i</span>[<span class="number">1</span>])[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        # <span class="keyword">merge</span> <span class="keyword">corresponding</span> regions</span><br><span class="line">        <span class="keyword">t</span> = <span class="keyword">max</span>(R.<span class="keyword">keys</span>()) + <span class="number">1.0</span></span><br><span class="line">        R[<span class="keyword">t</span>] = _merge_regions(R[<span class="keyword">i</span>], R[j])</span><br><span class="line"></span><br><span class="line">        # mark similarities <span class="keyword">for</span> regions <span class="keyword">to</span> be removed</span><br><span class="line">        key_to_delete = []</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">k</span>, v <span class="keyword">in</span> <span class="keyword">list</span>(S.items()):</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">i</span> <span class="keyword">in</span> <span class="keyword">k</span>) <span class="keyword">or</span> (j <span class="keyword">in</span> <span class="keyword">k</span>):</span><br><span class="line">                key_to_delete.append(<span class="keyword">k</span>)</span><br><span class="line"></span><br><span class="line">        # remove <span class="keyword">old</span> similarities <span class="keyword">of</span> related regions</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">k</span> <span class="keyword">in</span> key_to_delete:</span><br><span class="line">            del S[<span class="keyword">k</span>]</span><br><span class="line"></span><br><span class="line">        # calculate similarity <span class="keyword">set</span> <span class="keyword">with</span> the <span class="keyword">new</span> region</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">k</span> <span class="keyword">in</span> [a <span class="keyword">for</span> a <span class="keyword">in</span> key_to_delete <span class="keyword">if</span> a != (<span class="keyword">i</span>, j)]:</span><br><span class="line">            <span class="keyword">n</span> = <span class="keyword">k</span>[<span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">k</span>[<span class="number">0</span>] <span class="keyword">in</span> (<span class="keyword">i</span>, j) <span class="keyword">else</span> <span class="keyword">k</span>[<span class="number">0</span>]</span><br><span class="line">            S[(<span class="keyword">t</span>, <span class="keyword">n</span>)] = _calc_sim(R[<span class="keyword">t</span>], R[<span class="keyword">n</span>], imsize)</span><br><span class="line"></span><br><span class="line">    regions = []</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">k</span>, r <span class="keyword">in</span> <span class="keyword">list</span>(R.items()):</span><br><span class="line">        regions.append(&#123;</span><br><span class="line">            <span class="string">'rect'</span>: (</span><br><span class="line">                r[<span class="string">'min_x'</span>], r[<span class="string">'min_y'</span>],</span><br><span class="line">                r[<span class="string">'max_x'</span>] - r[<span class="string">'min_x'</span>], r[<span class="string">'max_y'</span>] - r[<span class="string">'min_y'</span>]),</span><br><span class="line">            <span class="string">'size'</span>: r[<span class="string">'size'</span>],</span><br><span class="line">            <span class="string">'labels'</span>: r[<span class="string">'labels'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, regions</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一步，通过经典的图像分割算法获取分割的块。这一步留到后续研究 felzenszwalb 算法再说吧，<strong>暂时我也不会。</strong></li>
<li>其实第一步已经得到对应的区域了，但是在算法实现上只是做了一个个标记，所以还需要处理下，变成我们需要的 R 集合。这步里面已经做好了大量的计算处理，后续直接按照论文<strong>层级化</strong>调用就行。</li>
<li>计算相邻的区域，对应产生初始的 S 集合。</li>
<li>对相邻的区域计算最大相似度，然后合并。</li>
<li>后面就重复我上问的内容了。</li>
</ul>
<p><br>大致内容就这样，当然细节还有不少值得研究的，可以继续深入，后续再读读。<br><br><br>最后，作者这 Python 写的真是溜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2020/04/07/Selective-Search/" data-id="ck9fy2gg200222ni1h0hxx94u" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2020/04/07/Selective-Search/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-MNN-Visual" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/06/MNN-Visual/" class="article-date">
  <time datetime="2020-02-06T15:10:21.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/06/MNN-Visual/">实现 MNN 模型的可视化工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>Netron</code> 是一个支持 <code>Tensorflow</code> ，<code>PyTorch</code> ，<code>MXNet</code> ，<code>NCNN</code> ， <code>PaddlePaddle</code> 等深度模型格式的可视化框架。去年国庆前的时候我稍微研究了下相关的代码，<b style="color:red">重点关注其将其是如何设计出一套兼容不同模型格式表征，用来归一化展现不同的深度学习框架模型。</b></p>
<p>研究完成后，我利用如下两个 <code>Commit</code> 作为 <code>Pull Request</code> 提交给了作者，用以支持 <code>MNN</code> 的模型可视化。</p>
<ul>
<li><p><a href="https://github.com/lutzroeder/netron/pull/340" target="_blank" rel="external">Visualization support for MNN models #340</a></p>
</li>
<li><p><a href="https://github.com/lutzroeder/netron/pull/345" target="_blank" rel="external">Fix loading .mnn model failed when there is no extraTensorDescribe existed.</a></p>
</li>
</ul>
<p>从中也不难看出我扎实的英语表述能力（我果然是个国际化人才）。</p>
<p>这篇文章会从<strong>架构设计、标准定义、巧用JS解析</strong>等几个方面来阐述</p>
<h3 id="架构设计">架构设计</h3><p>整体上，按照我个人的理解，<code>Netron</code> 的架构可以简要展现如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4292627-565192345c3f5484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最基础的应用部分及运行环境，是 <code>Electron</code> 这个跨平台框架直接呈现的。<br>当然，一些诸如基础zip/gzip用于解压等等的库我们也统一归类到支撑里。</p>
<p>然后是一套经典的 <code>MVC</code> 的结构，<code>app.js</code> 作为整体的 controller ，负责整个应用的功能逻辑，如导出图片、菜单管理、保存加载等等。<b style="color:red">这一层我们需要的做事非常少，只要将 <code>MNN</code> 支持的模型后缀 <code>.mnn</code> 注册进去即可</b>。 然后是是对应的 <code>view.js</code>，这块实际上还是一层 <code>controller</code>，类比我们常说的子控制器，专门用于处理主视图的逻辑，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4292627-6539f5107f03904e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><b style="color:red">从这块开始，我们就要注意了，因为这里开始通过工厂方法对应的根据读取文件类型的不同，托管给了不同的自定义 <code>xxx.js</code> 来处理后续步骤</b>。 比如<code>.mar</code>，<code>model</code>，<code>prototxt</code> 等格式的模型会首先托管给 <code>mxnet.js</code>来处理。<strong>如果存在重名，则按照先后顺序依次尝试。</strong></p>
<pre><code>view.ModelFactoryService = <span class="keyword">class</span> {
    <span class="constructor"><span class="keyword">constructor</span>(host) </span>{
        <span class="keyword">this</span>._host = host;
        <span class="keyword">this</span>._extensions = [];
        <span class="keyword">this</span>.register(<span class="string">'./onnx'</span>, [ <span class="string">'.onnx'</span>, <span class="string">'.pb'</span>, <span class="string">'.pbtxt'</span>, <span class="string">'.prototxt'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./mxnet'</span>, [ <span class="string">'.mar'</span>, <span class="string">'.model'</span>, <span class="string">'.json'</span>, <span class="string">'.params'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./keras'</span>, [ <span class="string">'.h5'</span>, <span class="string">'.hd5'</span>, <span class="string">'.hdf5'</span>, <span class="string">'.keras'</span>, <span class="string">'.json'</span>, <span class="string">'.model'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./coreml'</span>, [ <span class="string">'.mlmodel'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./caffe'</span>, [ <span class="string">'.caffemodel'</span>, <span class="string">'.pbtxt'</span>, <span class="string">'.prototxt'</span>, <span class="string">'.pt'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./caffe2'</span>, [ <span class="string">'.pb'</span>, <span class="string">'.pbtxt'</span>, <span class="string">'.prototxt'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./pytorch'</span>, [ <span class="string">'.pt'</span>, <span class="string">'.pth'</span>, <span class="string">'.pkl'</span>, <span class="string">'.h5'</span>, <span class="string">'.t7'</span>, <span class="string">'.model'</span>, <span class="string">'.dms'</span>, <span class="string">'.pth.tar'</span>, <span class="string">'.ckpt'</span>, <span class="string">'.bin'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./torch'</span>, [ <span class="string">'.t7'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./torchscript'</span>, [ <span class="string">'.pt'</span>, <span class="string">'.pth'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./mnn'</span>, [<span class="string">'.mnn'</span>, <span class="string">'.tflite'</span>]);
        <span class="keyword">this</span>.register(<span class="string">'./tflite'</span>, [ <span class="string">'.tflite'</span>, <span class="string">'.lite'</span>, <span class="string">'.tfl'</span>, <span class="string">'.bin'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./tf'</span>, [ <span class="string">'.pb'</span>, <span class="string">'.meta'</span>, <span class="string">'.pbtxt'</span>, <span class="string">'.prototxt'</span>, <span class="string">'.json'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./sklearn'</span>, [ <span class="string">'.pkl'</span>, <span class="string">'.joblib'</span>, <span class="string">'.model'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./cntk'</span>, [ <span class="string">'.model'</span>, <span class="string">'.cntk'</span>, <span class="string">'.cmf'</span>, <span class="string">'.dnn'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./openvino'</span>, [ <span class="string">'.xml'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./darknet'</span>, [ <span class="string">'.cfg'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./paddle'</span>, [ <span class="string">'.paddle'</span>, <span class="string">'__model__'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./ncnn'</span>, [ <span class="string">'.param'</span>, <span class="string">'.bin'</span>, <span class="string">'.cfg.ncnn'</span>, <span class="string">'.weights.ncnn'</span>]);
        <span class="keyword">this</span>.register(<span class="string">'./dl4j'</span>, [ <span class="string">'.zip'</span> ]);
        <span class="keyword">this</span>.register(<span class="string">'./mlnet'</span>, [ <span class="string">'.zip'</span>]);

    }
</code></pre><p>在这上层是一层标准定义层，用于抹平不同模型之间的表达方式，用归一化的逻辑来进行处理，<strong>至于怎么把自己的模型表征映射成归一化的逻辑，就需要编写对应 <code>xxx.js</code> 来自行处理，后文会以 <code>MNN</code> 来进行举例。</strong></p>
<p>最上层就是对应各个深度框架自行的逻辑处理了。其中包含了数据格式及对应解析（如 <code>flatbuffer</code>）、内容校验、构图等等，后文也会用 <code>MNN</code> 举例说明。</p>
<h3 id="标准定义">标准定义</h3><p>这一环是一个很不起眼但是却非常重要的环节。 每种深度模型框架都有其自定义的模块结构和模块构成，一般都以 <code>Flatbuffer Schema</code> 的形式构成。（当然也有例外）以<code>MNN</code> 为例，其对应的模型结构大致如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9525982-b558276df2e23ddc.png" alt=""></p>
<blockquote>
<p>上图引用自<a href="https://www.jianshu.com/p/8eb153c12a4b" target="_blank" rel="external">FlatBuffers，MNN模型存储结构基础 —- 无法解读MNN模型文件的秘密</a></p>
</blockquote>
<p>同理， <code>TFLite</code> 的模型也可见 <code>TFLite.schema</code>，不再赘述。</p>
<p>从定义中不难看出，<code>TFLite</code> 有 <code>model</code>，<code>graph</code> ，<code>SubGraph</code> 等；而 <code>MNN</code> 对应的就是<code>Net</code>；再往下一层 <code>TFLite</code> 有 <code>Operator</code> 和 <code>Options</code>；而 <code>MNN</code> 有 <code>OP</code> 和<code>OPParameter</code>；至于 <code>NCNN</code> 则是 <code>Layer</code>。</p>
<p><b style="color:red">如果是从整个架构角度去兼容不同的框架，必然会有着大量的 <code>messy code</code>。因此作者定义了一套标准表征，让不同的深度模型自己去解析，然后附着自身的逻辑到这同一套表征上。</b></p>
<ul>
<li><code>Model</code> ，表示模型的静态表示。</li>
<li><code>Graph</code> ，表示模型的计算图表示。</li>
<li><code>Node</code> ，一个操作对应一个节点。</li>
<li><code>Tensor</code> ，输入输出数据。</li>
<li><code>Parameter</code> ，对应的属性。</li>
<li><code>Argument</code> ，对应的属性值。</li>
</ul>
<blockquote>
<p>上述 <code>Parameter</code> 和 <code>Argument</code>可以简单认为一一对应吧，都认为是属性值即可。</p>
</blockquote>
<p>一图胜千言，下图比较好的展现了<strong>术语和对应的表征：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4292627-ecec7a02f7c33ae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样不同的框架模型只要在自己对应的 <code>xxx.js</code> 中，把<strong>图，<code>OP</code> 层</strong>对应的数据填充至对应的地方即可。</p>
<p>这里依然以 <code>MNN</code> 举例：</p>
<ul>
<li>我们不存在 <code>subgraph</code> 的概念，直接把 <code>Model</code> 和 <code>Graph</code> 等价于一个 <code>net</code>即可。</li>
<li>从 <code>net</code> 中取出 <code>oplist</code> ，对应创建成 <code>Node</code>。</li>
<li>从 <code>oplist</code> 中每个 <code>op</code> ，取出对应的 <code>tensorIndex</code>，根据 <code>net</code> 的 <code>tensorName</code> 和<code>tensorIndex</code> 来创建对应的 <code>tensor</code> 。</li>
<li>从 <code>op</code> 中根据 <code>opparameter</code> 的种类，从 <code>op.main</code> 中取出不同的数据来填入 <code>paramter / argument</code>，<strong>这块是解析的大头，如果没想好方式，就会非常浪费时间</strong>，下文重点说。</li>
</ul>
<h3 id="数据格式">数据格式</h3><p>诸如 <code>MNN</code> ，<code>TFlite</code> 都选用了 <code>Flatbuffer</code> 来进行数据的保存，而官方的 <code>flatc</code> 程序支持直接根据定义的 <code>schema</code> 文件生成对应的 <code>generated.js</code>，命令如下：</p>
<pre><code>.<span class="regexp">/flatc -s ~/y</span>ourPathTo<span class="regexp">/MNN/</span>schema<span class="regexp">/default/</span>Type.fbs
</code></pre><p>这个我看了下很多的同学的在处理多 <code>Schema</code> 定义的时候是对应的一个个生成 <code>generated.js</code>，这样维护成本比较大，既然我们的已经使用了 <code>include</code> 机制，我们直接在生成过程中合并即可，如下所示：</p>
<pre><code>.<span class="regexp">/flatc --js -I ~/y</span>ourPathTo<span class="regexp">/MNN/</span>schema<span class="regexp">/default/</span> ~<span class="regexp">/yourPathTo/M</span>NN<span class="regexp">/schema/</span><span class="keyword">default</span><span class="regexp">/MNN.fbs --gen-all</span>
</code></pre><p>这里有两个参数注意下：</p>
<ul>
<li><code>-I</code>，表示 <code>include</code> 从哪个路径进行搜索。</li>
<li><code>--gen-all</code>，表示自动对生成的所有文件合并。</li>
</ul>
<p>生成代码大致如下：</p>
<pre><code><span class="comment">/**
 * <span class="doctag">@param</span> {number} i
 * <span class="doctag">@param</span> {flatbuffers.ByteBuffer} bb
 * <span class="doctag">@returns</span> {MNN.Blob}
 */</span>
MNN.Blob.prototype.__init = <span class="function"><span class="keyword">function</span><span class="params">(i, bb)</span> </span>{
  this.bb_pos = i;
  this.bb = bb;
  <span class="keyword">return</span> this;
};
<span class="comment">/**
 * <span class="doctag">@param</span> {flatbuffers.ByteBuffer} bb
 * <span class="doctag">@param</span> {MNN.Blob=} obj
 * <span class="doctag">@returns</span> {MNN.Blob}
 */</span>
MNN.Blob.getRootAsBlob = <span class="function"><span class="keyword">function</span><span class="params">(bb, obj)</span> </span>{
  <span class="keyword">return</span> (obj || <span class="keyword">new</span> MNN.Blob).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};
<span class="comment">/**
 * <span class="doctag">@param</span> {flatbuffers.ByteBuffer} bb
 * <span class="doctag">@param</span> {MNN.Blob=} obj
 * <span class="doctag">@returns</span> {MNN.Blob}
 */</span>
MNN.Blob.getSizePrefixedRootAsBlob = <span class="function"><span class="keyword">function</span><span class="params">(bb, obj)</span> </span>{
  <span class="keyword">return</span> (obj || <span class="keyword">new</span> MNN.Blob).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};
</code></pre><p>具体关于 <code>FlatBuffer</code> 的细节，可以阅读我之前的文章，不再赘述。</p>
<h3 id="避免冗余解析流程">避免冗余解析流程</h3><p>上文提到 <strong>根据 OpParameter </strong>来获取 <code>main</code> 中的数据，然后依次填入 <code>parameter / argument</code> 是比较耗费精力的步骤。我们所有的 <code>OpParameter</code> 类型有 <b style="color:red">74</b>种（还在不断更新）</p>
<pre><code>MNN.OpParameter = {
  NONE: <span class="number">0</span>,
  QuantizedAdd: <span class="number">1</span>,
  ArgMax: <span class="number">2</span>,
  AsString: <span class="number">3</span>,
  Axis: <span class="number">4</span>,
  BatchNorm: <span class="number">5</span>,
  BinaryOp: <span class="number">6</span>,
  Blob: <span class="number">7</span>,
  CastParam: <span class="number">8</span>,
  Convolution2D: <span class="number">9</span>,
  Crop: <span class="number">10</span>,
  CropAndResize: <span class="number">11</span>,
  Dequantize: <span class="number">12</span>,
  DetectionOutput: <span class="number">13</span>,
  Eltwise: <span class="number">14</span>,
  ExpandDims: <span class="number">15</span>,
  Fill: <span class="number">16</span>,
  Flatten: <span class="number">17</span>,
  Gather: <span class="number">18</span>,
  GatherV2: <span class="number">19</span>,
  InnerProduct: <span class="number">20</span>,
  Input: <span class="number">21</span>,
  Interp: <span class="number">22</span>,
  LRN: <span class="number">23</span>,
  LSTM: <span class="number">24</span>,
  MatMul: <span class="number">25</span>,
  NonMaxSuppressionV2: <span class="number">26</span>,
  Normalize: <span class="number">27</span>,
  PackParam: <span class="number">28</span>,
  Permute: <span class="number">29</span>,
  Plugin: <span class="number">30</span>,
  Pool: <span class="number">31</span>,
  PRelu: <span class="number">32</span>,
  PriorBox: <span class="number">33</span>,
  Proposal: <span class="number">34</span>,
  QuantizedAvgPool: <span class="number">35</span>,
  QuantizedBiasAdd: <span class="number">36</span>,
  QuantizedConcat: <span class="number">37</span>,
  QuantizedLogistic: <span class="number">38</span>,
  QuantizedMatMul: <span class="number">39</span>,
  QuantizedMaxPool: <span class="number">40</span>,
  QuantizedRelu: <span class="number">41</span>,
  QuantizedRelu6: <span class="number">42</span>,
  QuantizedReshape: <span class="number">43</span>,
  QuantizedSoftmax: <span class="number">44</span>,
  QuantizeMaxMin: <span class="number">45</span>,
  QuantizeV2: <span class="number">46</span>,
  Range: <span class="number">47</span>,
  Rank: <span class="number">48</span>,
  ReduceJoin: <span class="number">49</span>,
  ReductionParam: <span class="number">50</span>,
  Relu: <span class="number">51</span>,
  Relu6: <span class="number">52</span>,
  RequantizationRange: <span class="number">53</span>,
  Requantize: <span class="number">54</span>,
  Reshape: <span class="number">55</span>,
  Resize: <span class="number">56</span>,
  RoiPooling: <span class="number">57</span>,
  Scale: <span class="number">58</span>,
  Selu: <span class="number">59</span>,
  Size: <span class="number">60</span>,
  Slice: <span class="number">61</span>,
  SliceTf: <span class="number">62</span>,
  SpaceBatch: <span class="number">63</span>,
  SqueezeParam: <span class="number">64</span>,
  StridedSliceParam: <span class="number">65</span>,
  TensorConvertInfo: <span class="number">66</span>,
  TfQuantizedConv2D: <span class="number">67</span>,
  TopKV2: <span class="number">68</span>,
  Transpose: <span class="number">69</span>,
  UnaryOp: <span class="number">70</span>,
  MomentsParam: <span class="number">71</span>,
  RNNParam: <span class="number">72</span>,
  BatchMatMulParam: <span class="number">73</span>,
  QuantizedFloatParam: <span class="number">74</span>
};
</code></pre><p><strong>以 <code>Convolution2D</code> 举例，它又有几个对应的参数：<code>weight</code> ，<code>bias</code> ，<code>quanParameter</code> ，<code>symmetricQuan</code> ，<code>padX</code> ，<code>padY</code> ，<code>kernelX</code> ，<code>kernelY</code> 等等，需要解析。</strong></p>
<p>一开始我采用了人肉的解析方式，代码就成了 <code>if else</code> 加上一大堆解析代码：</p>
<pre><code>mnn_private.Convolution2DAttrBuilder = <span class="keyword">class</span> {
constructor() {}

buildAttributes(metadata, parameter) {
    <span class="comment">//var common = parameter.common();</span>
    var attributes = [];
    var common = parameter.common();
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"padX"</span>, common.padX(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"padY"</span>, common.padY(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"kernelX"</span>, common.kernelX(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"kernelY"</span>, common.kernelY(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"strideX"</span>, common.strideX(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"strideY"</span>, common.strideY(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"dilateX"</span>, common.dilateX(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"dilateY"</span>, common.dilateY(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"padMode"</span>, mnn.schema.PadModeName[common.dilateY()], <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"group"</span>, common.<span class="keyword">group</span>(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"outputCount"</span>, common.outputCount(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"inputCount"</span>, common.inputCount(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"relu"</span>, common.relu(), <span class="keyword">true</span>));
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"relu6"</span>, common.relu6(), <span class="keyword">true</span>));
    <span class="comment">//var quanParameter = parameter.quanParameter();</span>
    var weights = [];
    <span class="keyword">for</span> (var w = <span class="number">0</span>; w &lt; parameter.weightLength(); w++) {
        weights.<span class="keyword">push</span>(parameter.weight(w));
    }
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"weights"</span>, weights, <span class="keyword">true</span>));
    var bias = [];
    <span class="keyword">for</span> (var b = <span class="number">0</span>; b &lt; parameter.biasLength(); b++) {
        bias.<span class="keyword">push</span>(parameter.bias(b));
    }
    attributes.<span class="keyword">push</span>(<span class="keyword">new</span> mnn.Attribute(metadata, <span class="string">"bias"</span>, bias, <span class="keyword">true</span>));

    <span class="keyword">return</span> attributes;
}

get hasMain() {
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p><strong>这样的代码如果写完74个 <code>OpParameter</code> ，可维护性和后续的扩展也不够。</strong></p>
<p><b style="color:red">我们要巧用 <code>JavaScript</code>的 <code>Reflect</code> 能力以及<strong>属性等于与字符串值属性的特性</strong></b></p>
<pre><code>_buildAttributes(metadata, op, net, args) {
        <span class="keyword">var</span> opParameter = op.mainType();    
        <span class="keyword">var</span> opParameterName = mnn.schema.OpParameterName[opParameter];

        <span class="comment">// 获取对应的类型</span>
        <span class="keyword">var</span> mainConstructor = mnn.schema[opParameterName];
        <span class="keyword">var</span> opParameterObject = <span class="keyword">null</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> mainConstructor === <span class="string">'function'</span>) {
            <span class="keyword">var</span> mainTemplate = Reflect.construct(mainConstructor, []);
            opParameterObject = op.main(mainTemplate);
        }
        <span class="keyword">this</span>._recursivelyBuildAttributes(metadata, net, opParameterObject, <span class="keyword">this</span>._attributes);
    }
    _recursivelyBuildAttributes(metadata, net, opParameterObject, attributeHolders) {
        <span class="keyword">if</span> (!opParameterObject) <span class="keyword">return</span>;
        <span class="keyword">var</span> attributeName;
        <span class="keyword">var</span> attributeNames = [];
        <span class="keyword">var</span> attributeNamesMap = {};
        <span class="keyword">for</span> (attributeName of Object.keys(Object.getPrototypeOf(opParameterObject))) {
            <span class="keyword">if</span> (attributeName != <span class="string">'__init'</span>) {
                attributeNames.push(attributeName);
            }
            attributeNamesMap[attributeName] = <span class="keyword">true</span>;
        }
        <span class="keyword">var</span> attributeArrayNamesMap = {}; 
        <span class="keyword">for</span> (attributeName of Object.keys(attributeNamesMap)) {
            <span class="keyword">if</span> (attributeNamesMap[attributeName + <span class="string">'Length'</span>]) {                    attributeArrayNamesMap[attributeName] = <span class="keyword">true</span>;
                attributeNames = attributeNames.filter((item) =&gt; item != (attributeName + <span class="string">'Array'</span>) &amp;&amp; item != (attributeName + <span class="string">'Length'</span>));
            }
        }
        <span class="keyword">for</span> (attributeName of attributeNames) {
            <span class="keyword">if</span> (opParameterObject[attributeName] &amp;&amp; <span class="keyword">typeof</span> opParameterObject[attributeName] == <span class="string">'function'</span>) {
                <span class="keyword">var</span> <span class="keyword">value</span> = <span class="keyword">null</span>;
                <span class="keyword">if</span> (attributeArrayNamesMap[attributeName]) {
                    <span class="keyword">var</span> array = [];
                    <span class="keyword">var</span> length = opParameterObject[attributeName + <span class="string">'Length'</span>]();
                    <span class="comment">//var a = opParameterObject[attributeName + 'Array']();</span>
                    <span class="keyword">for</span> (<span class="keyword">var</span> l = <span class="number">0</span>; l &lt; length; l++) {
                        array.push(opParameterObject[attributeName + <span class="string">'Length'</span>](l));
                    }
                    <span class="keyword">value</span> = array;
                }
                <span class="keyword">else</span> {
                    <span class="keyword">value</span> = opParameterObject[attributeName]();
                    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">value</span> === <span class="string">'object'</span>) {
                        <span class="keyword">this</span>._recursivelyBuildAttributes(metadata, net, <span class="keyword">value</span>, attributeHolders);   
                        <span class="keyword">value</span> = <span class="keyword">null</span>;
                    }
                }
                <span class="keyword">if</span> (<span class="keyword">value</span>) {
                    <span class="keyword">var</span> attribute = <span class="keyword">new</span> mnn.Attribute(metadata, attributeName, <span class="keyword">value</span>);
                    attributeHolders.push(attribute);
                }                
            }
        }
    }
</code></pre><p><b style="color:red">区区50多行代码就可以完成所有 <code>OpParamater</code> 及其对应的属性解析。</b></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2020/02/06/MNN-Visual/" data-id="ck9fy2ghi00322ni1yhsjr7z6" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2020/02/06/MNN-Visual/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-SIMD-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/01/SIMD-1/" class="article-date">
  <time datetime="2019-12-01T15:39:48.000Z" itemprop="datePublished">2019-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/01/SIMD-1/">了解 SIMD 指令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="了解_SIMD_指令">了解 SIMD 指令</h2><p>SIMD 是一种常见的利用单指令完成多数据量处理的计算方式。本文作为 SIMD 文章的引子，先来了解简单的 SIMD 使用和概念。</p>
<h4 id="SIMD_的含义">SIMD 的含义</h4><p>SIMD 的全称是 Single Instruction Multiple Data。简要来说，就是通过一条指令完成多条数据处理的行为。我们知道，虽然程序是由一条条机器指令组成，但是实际上执行一条机器码包含了多个过程，包含取指令、分析指令到执行等，如下图所示（暂时先忽略流水线并行）</p>
<p><img src="http://file.elecfans.com/web1/M00/47/5F/pIYBAFqkjYeAONeZAAApUrptLBI051.jpg" alt=""></p>
<p>而在这其中，每一个阶段，都会消耗一个或多个机器周期。如果我们认为，取指令和分析指令（译码）可以近似的认为是一个机器周期内完成，<b style="color:red">那么不同的指令，在执行阶段耗费的机器周期则大不相同。</b></p>
<p>举个例子，可能加法指令的执行阶段需要两个机器周期；而乘法可能需要5-6个机器周期。那么，当我们无法缩短指令的执行周期缩短的时候，利用 SIMD 技术，则可以在相同的执行周期内完成更多的数据处理，这样也同等的提升了单位时间内的数据吞吐，提高了计算性能。</p>
<p>在 Intel 的手册上，提供了包含 MMX, SSE, AVX 等系列的并行指令，面向不同长度的数据并行，比如：</p>
<ul>
<li>MMX 并行计算 64bit 的数据。</li>
<li>SSE 并行计算 128bit 的数据。</li>
<li>AVX 并行计算 256bit 的数据。</li>
<li>AVX512 并行计算 512bit 的数据。</li>
</ul>
<p>更多详细的使用可以参考：</p>
<p><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" target="_blank" rel="external">Intel 手册</a></p>
<h3 id="SIMD_的使用方式">SIMD 的使用方式</h3><p>由于绝大多数的人对 SIMD 还不甚了解，因此本文基于大家比较熟悉的环境 Xcode + x86/64 架构来完成。</p>
<blockquote>
<p>主要是我懒，不想再翻 ARM 的手册了。</p>
</blockquote>
<p>这里我们以一个简单的 256bit (32 byte) 加法改写成 SIMD 的形式来验证：</p>
<p>原始版本：</p>
<pre><code>double input1[k] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
double input2[k] = {<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>};
double <span class="literal">result</span>[k] = {<span class="number">0</span>};

<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) {
    <span class="literal">result</span>[i] = input1[i] + input2[i];
}
</code></pre><p>SIMD 版本：</p>
<pre><code><span class="keyword">const</span> <span class="type">int</span> k = <span class="number">4</span>;
double input1[k] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
double input2[k] = {<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>};
double <span class="literal">result</span>[k] = {<span class="number">0</span>};

__m256d a = _mm256_load_pd(input1);
__m256d b = _mm256_load_pd(input2);

__m256d c = _mm256_add_pd(a, b);
_mm256_store_pd(<span class="literal">result</span>, c);
</code></pre><p>原始版本比较好懂，我们主要来深入看下 SIMD 中代码的意思：</p>
<ul>
<li><p><code>_mm256_load_pd</code> 就是从内存中读取一个地址，这个地址返回为 <code>__m256d</code> 的向量（256bit）。其中， <code>__mm256d</code>的定义为下：</p>
<pre><code>typedef double __m256d __attribute__<span class="list">(<span class="list">(<span class="keyword">__vector_size__</span><span class="list">(<span class="number">32</span>)</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>  这个含义的意思就是 <code>__m256d</code> 的长度是 32 byte（256bit），而这个 32 byte 是按照 4 个 double 元素构成的。</p>
</li>
<li><p><code>_mm256_add_pd</code> 就是对两个 256bit 的向量元素进行直接相加。</p>
</li>
<li><p><code>_mm256_store_pd</code> 就是 <code>_mm256_load_pd</code>的逆运算，不再赘述。</p>
</li>
</ul>
<p><b style="color:red">注意：如果提示需要 AVX 支持的话，请在 Xcode 对应的代码文件处添加 Compiler Flag: <code>-mavx</code></b></p>
<h3 id="用_SIMD_实现求和加法">用 SIMD 实现求和加法</h3><p>既然说了 SIMD 的本质还是为了提升单位时间内的计算吞吐量，我们还是用一个简单的例子，<strong>加法求和</strong>来实践一下：</p>
<p>常规的代码如下：</p>
<pre><code>double <span class="type">CommonAdd</span>(double *data, <span class="type">int</span> count)
{
    double <span class="literal">result</span> = <span class="number">0</span>;

    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; count; i++) {
        <span class="literal">result</span> += data[i];
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>SIMD 的代码如下：</p>
<pre><code><span class="keyword">double</span> AVXAdd(<span class="keyword">double</span> *data, <span class="keyword">int</span> <span class="keyword">count</span>)
{
    <span class="keyword">int</span> offset = <span class="number">0</span>;

    __m256d v1;
    __m256d <span class="keyword">sum</span> = _mm256_setzero_pd();

    <span class="keyword">double</span> ret = <span class="number">0</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>/<span class="number">4</span>; i++) {
        v1 = _mm256_load_pd(data + offset);
        <span class="keyword">sum</span> = _mm256_add_pd(<span class="keyword">sum</span>, v1);
        offset += <span class="number">4</span>;
    }

    <span class="keyword">sum</span> = _mm256_hadd_pd(<span class="keyword">sum</span>, <span class="keyword">sum</span>); <span class="comment">// 水平求和</span>

    ret += <span class="keyword">sum</span>[<span class="number">0</span>];
    ret += <span class="keyword">sum</span>[<span class="number">2</span>];

    <span class="keyword">return</span> ret;
}
</code></pre><p>测试代码如下：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{

    <span class="keyword">struct</span>  timeval   start;
    <span class="keyword">struct</span>  timeval   end;


    <span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">512</span> * <span class="number">512</span>;

    <span class="keyword">const</span> <span class="keyword">int</span> loop = <span class="number">1</span>;

    <span class="keyword">double</span> input1[k];

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) {
        input1[i] = i;
    }

    gettimeofday(&amp;start, <span class="literal">nullptr</span>);

    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loop; j++) {
        CommonAdd(input1, k);
    }

    gettimeofday(&amp;end, <span class="literal">nullptr</span>);

    <span class="built_in">printf</span>(<span class="string">"tv_sec:%ld\n"</span>,end.tv_sec - start.tv_sec);
    <span class="built_in">printf</span>(<span class="string">"tv_usec:%d\n"</span>, end.tv_usec - start.tv_usec);

    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" ======================= "</span> &lt;&lt; <span class="built_in">std</span>::endl;

    gettimeofday(&amp;start, <span class="literal">nullptr</span>);

    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loop; j++) {
        AVXAdd(input1, k);
    }

    gettimeofday(&amp;end, <span class="literal">nullptr</span>);

    <span class="built_in">printf</span>(<span class="string">"tv_sec:%ld\n"</span>,end.tv_sec - start.tv_sec);
    <span class="built_in">printf</span>(<span class="string">"tv_usec:%d\n"</span>, end.tv_usec - start.tv_usec);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>这里，我们选择了图像处理里面比较常见的 512 * 512 大小来做验证，在我的 2015款 MacBookPro 上可以得到大致如下两个性能耗时：</p>
<ul>
<li>常规方法 【774 us】</li>
<li>SIMD   【560 us】</li>
</ul>
<p>别小看这一点的性能差距，对于大运算量的端侧深度学习可就有很显著的差距了。</p>
<h3 id="后记">后记</h3><p>本文只是仅仅介绍了最常规的 SIMD 使用方式。但是在实际设计的过程中，不可能像我们这么简单的去应用。随之而来的，你会发现伴随着许多不同的坑，包含不规范的应用导致<b style="color:red">性能的下降</b>和<b style="color:red">崩溃问题</b>。这些都会留在后面我们去解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/12/01/SIMD-1/" data-id="ck9fy2gg500252ni1xmhrhwhn" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/12/01/SIMD-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/汇编/">汇编</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-MNN1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/27/MNN1/" class="article-date">
  <time datetime="2019-10-26T17:23:39.000Z" itemprop="datePublished">2019-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/27/MNN1/">浅谈移动工程师跨界机器学习之路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="题记">题记</h3><p>相信从事移动开发的朋友们肯定看到过一个表情包：“iOS 开发没人要啦”。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnn_1.jpeg?raw=true" alt="15706761042966.jpg"></p>
<p>虽说是搞笑之图，却也反映了移动开发领域的部分焦虑感。网上甚至有文章贴出<strong>“难上加难”</strong>的数据，称：“相比于 2017 年，2018 年 Android 程序员人均面邀数<b style="color:red">减少40%</b>，iOS 程序员<b style="color:red">降幅更高达57%</b>，即<strong>平均每个移动端程序员在找工作时收到的面邀数比去年减少一半</strong>。”</p>
<p>撇开玩笑之言，移动开发人员的焦虑感来自何处？我从自身角度及与他人沟通，大致归纳出如下几点：</p>
<ul>
<li>跨平台框架、如 Flutter 对 Native 研发模式的冲击。</li>
<li>业界关注重点从移动时代向人工智能等领域转移。</li>
<li>对自身掌握技术壁垒的担忧。</li>
</ul>
<p>细细品味这三点，我想<strong>开发者在面临业界趋势转移，担忧自身竞争力不足才是焦虑产生的内在根本</strong>。我曾和几个国内知名的 iOS 开发者闲聊，他们表示：都 <strong>9102 </strong>年了，<strong>从大量公开的文章来看，大家还是局限于研究 Runtime，Runloop，block 源码分析等一些比较缺少创新的知识点，让人感受行业的停滞不前。</strong></p>
<p>当然，也有不少开发者在积极拥抱新技术。身边的许多朋友也在了解机器学习，自学相关课程等。但是其中大部分都反馈：学完了基础知识，不知道如何应用；也不知道这些东西能对自己日常工作带来怎样的帮助。<strong>最终的结果就演变成了学了就忘，无法产生实质价值</strong>。</p>
<p>那是不是事情就此陷入了僵局呢？抱着怀疑及学习的态度，我在2018年中旬加入了<strong>手淘-端智能组</strong>，参与了一款名叫 <strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a></strong> 的深度推理引擎的研发工作。这一年多的开发过程，让我对加深了对机器学习 / 深度学习的理解。<strong>但更重要的是，这一年多的亲身经历，让我对过去的观点产生了颠覆式的看法。</strong></p>
<p>在这里，<b style="color:red">我并不想探讨如何学习机器学习，因为这样的文章数量已经浩瀚如海；相反地，我希望通过这篇文章，阐述在开发推理引擎 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a> 的过程中，我的思考与收获；希望给许多曾和我一样迷茫的移动开发者，一些亲历的感受和信心。</b></p>
<blockquote>
<p>节约篇幅直接贴出 MNN 的 Github 地址：<a href="https://github.com/alibaba/MNN" target="_blank" rel="external">https://github.com/alibaba/MNN</a></p>
</blockquote>
<p><a name="098e61e1"></a></p>
<h3 id="定义清晰的跨界目标">定义清晰的跨界目标</h3><p>相信有不少同学都曾和我一样，在了解机器学习的初期被诸多的公式推导所吓退，担心这是一个充斥着算法、数学、理论证明的技术领域。</p>
<p>这个观点没错，如果你想要设计出经典的 MobileNet、ResNet 这样的深度神经网络或者是对 Yolo 这样的结构进行复杂度优化，如 Yolo V3 等，你势必要对数学证明、算法优化等方面有较深刻的理解，<strong>从这个角度看，说一句很残酷的话：移动工程师跨界的机会不大。</strong></p>
<p>但是机器学习是不是只有算法？<strong>这个观点是偏颇的，机器学习本质上是一个工程开发、算法优化与实际应用结合的领域。</strong></p>
<p>用 深度学习领域的知名大牛 <strong>贾扬青 </strong>的观点来看：<strong>AI 是一个系统工程，90%的工作在算法之外</strong>。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnn_3.jpeg?raw=true" alt="IMG_2784.JPG"></p>
<p>换句话说，<strong>机器学习还包含系统工程这个范畴</strong>。往小了说，模型可视化工具、转换工具；往大了讲，学术界探索机器学习的编译优化系统，比如陈天奇提出的 TVM 等等，这都是机器学习的一部分。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnn_2.png?raw=true" alt=""></p>
<blockquote>
<p>上图是 MNN 官方在 Netron 上维护的可视化框架，我们应该是国内第一个主动支持可视化能力的深度学习推理引擎。</p>
</blockquote>
<p>因此，对于我们移动开发者来说，我们<strong>更适合从系统工程的角度，通过实际编程解决问题，去探索机器学习</strong>。</p>
<blockquote>
<p>备注：这个观点并不是我自己想象出来。大家可以看看机器学习泰斗级人物 Jeff Dean 和李飞飞等人在2017年发表的机器学习系统白皮书。<a href="https://arxiv.org/abs/1904.03257" target="_blank" rel="external">SysML: The New Frontier of Machine Learning Systems</a></p>
</blockquote>
<h3 id="系统工程角度的机器学习价值">系统工程角度的机器学习价值</h3><p>如同大家学习编程时听过的那样，算法和数据结构是核心能力，一通百通。<strong>那么从系统工程的角度来看，无论是机器学习抑或是移动开发，存在诸多共通点是可以相互借鉴</strong>。限于篇幅，我仅仅列举几点能够切实帮助我自身日常开发的：</p>
<h4 id="数据自描述协议">数据自描述协议</h4><p>曾有人戏言“移动开发就是 UITableView + JSON”。虽然是句玩笑话，但也能看出数据传输在移动开发中的重要性。从个人经验来看，绝大多数的移动端数据传输协议基本都采用了 JSON（可能部分公司设计了自己的数据协议）。但是 JSON 存在几个缺点（不考虑优化的前提）：</p>
<ul>
<li>不内存友好，相对会带来性能瓶颈。</li>
<li>需要人为的解析流程。</li>
<li>不具备很好的类型解释性。</li>
</ul>
<p>为了解决类似的问题，一些新的数据协议，如 <strong>FlatBuffer </strong>也渐渐进入大家的视线之中。<strong>尽管之前就对其有所耳闻，但是真的深入了解还是要追溯到开发推理引擎的过程中</strong>。在设计机器学习模型存储结构中，大名鼎鼎的 TFLite，<a href="https://github.com/alibaba/MNN" target="_blank" rel="external"><strong>MNN</strong></a><strong> </strong>等框架都采用了 <strong>FlatBuffer</strong>，这是一种具备 <code>Access to serialized data without parsing/unpacking</code> 的存储结构。它不仅减少了模型的存储大小、提升了性能，也对模型结构扩展、解析自描述起到了巨大的帮助。</p>
<p>尤其是协议自解析方面，真是令我大开眼界。简单来说，你只要按照 <strong>FlatBuffer Schema 要求的方式定义你的数据结构，剩下的编码 / 解析的过程都自动化完成。</strong></p>
<p>这里以 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external"><strong>MNN</strong></a> 框架中的 <strong>FlatBuffer</strong> 的使用举例，比如整个神经网络的拓扑架构定义如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">table</span> <span class="tag">Net</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">bizCode</span>:<span class="value"> string</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">extraTensorDescribe</span>:<span class="value"> [TensorDescribe]</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">gpulibrary</span>:<span class="value"> GpuLibrary</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">oplists</span>:<span class="value"> [Op]</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">outputName</span>:<span class="value"> [string]</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">preferForwardType</span>:<span class="value"> ForwardType = CPU</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">sourceType</span>:<span class="value"> NetSource = CAFFE</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">tensorName</span>:<span class="value"> [string]</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">tensorNumber</span>:<span class="value"> int = <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>整体 MNN 中 Schema 的设计可以参考：<a href="https://github.com/alibaba/MNN/tree/master/schema/default" target="_blank" rel="external">https://github.com/alibaba/MNN/tree/master/schema/default</a></p>
</blockquote>
<p>然后我们通过一行简单的命令（这里仅作演示举例）就可以自动生成 JavaScript 的对应代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flatc -s -I ~/MNN/schema/default ~/MNN/schema/default/MNN.fbs</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * @constructor&#10; */&#10;MNN.Net = function() &#123;&#10;  /**&#10;   * @type &#123;flatbuffers.ByteBuffer&#125;&#10;   */&#10;  this.bb = null;&#10;&#10;  /**&#10;   * @type &#123;number&#125;&#10;   */&#10;  this.bb_pos = 0;&#10;&#125;;&#10;&#10;/**&#10; * @param &#123;number&#125; i&#10; * @param &#123;flatbuffers.ByteBuffer&#125; bb&#10; * @returns &#123;MNN.Net&#125;&#10; */&#10;MNN.Net.prototype.__init = function(i, bb) &#123;&#10;  this.bb_pos = i;&#10;  this.bb = bb;&#10;  return this;&#10;&#125;;&#10;&#10;/**&#10; * @param &#123;flatbuffers.ByteBuffer&#125; bb&#10; * @param &#123;MNN.Net=&#125; obj&#10; * @returns &#123;MNN.Net&#125;&#10; */&#10;MNN.Net.getRootAsNet = function(bb, obj) &#123;&#10;  return (obj || new MNN.Net).__init(bb.readInt32(bb.position()) + bb.position(), bb);&#10;&#125;;&#10;&#10;/**&#10; * @param &#123;flatbuffers.ByteBuffer&#125; bb&#10; * @param &#123;MNN.Net=&#125; obj&#10; * @returns &#123;MNN.Net&#125;&#10; */&#10;MNN.Net.getSizePrefixedRootAsNet = function(bb, obj) &#123;&#10;  return (obj || new MNN.Net).__init(bb.readInt32(bb.position()) + bb.position(), bb);&#10;&#125;;&#10;&#10;/**&#10; * @param &#123;number&#125; index&#10; * @param &#123;MNN.TensorDescribe=&#125; obj&#10; * @returns &#123;MNN.TensorDescribe&#125;&#10; */&#10;MNN.Net.prototype.extraTensorDescribe = function(index, obj) &#123;&#10;  var offset = this.bb.__offset(this.bb_pos, 6);&#10;  return offset ? (obj || new MNN.TensorDescribe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;&#10;&#125;;&#10;&#10;/**&#10; * @returns &#123;number&#125;&#10; */&#10;MNN.Net.prototype.extraTensorDescribeLength = function() &#123;&#10;  var offset = this.bb.__offset(this.bb_pos, 6);&#10;  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;&#10;&#125;;&#10;&#10;/**&#10; * @param &#123;number&#125; index&#10; * @param &#123;MNN.Op=&#125; obj&#10; * @returns &#123;MNN.Op&#125;&#10; */&#10;MNN.Net.prototype.oplists = function(index, obj) &#123;&#10;  var offset = this.bb.__offset(this.bb_pos, 10);&#10;  return offset ? (obj || new MNN.Op).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>而用户在代码中使用这个拓扑结构，只要简单调用入口函数 <strong>getRootAsNet ，剩下来的一切都自动化完成。而当你要修改结构定义的时候，仅仅需要修改对应的 Schema 文件，重新生成对应的解析文件，无需人工逐字段手工修改。</strong></p>
<blockquote>
<p>限于篇幅有限，这里不过多展开对 <strong>FlatBuffer</strong> 的介绍，感兴趣的读者可以阅读 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external"><strong>MNN</strong></a> 用户自发写的博客《<a href="https://www.jianshu.com/p/8eb153c12a4b" target="_blank" rel="external">FlatBuffers，MNN模型存储结构基础 —- 无法解读MNN模型文件的秘密</a>》。</p>
</blockquote>
<p><b style="color:red">那这样的协议能不能应用于移动开发中并起到正向的作用呢？</b>答案是肯定的，有兴趣的朋友可以阅读 Facebook 的相关文章。</p>
<h4 id="汇编知识的深度掌握">汇编知识的深度掌握</h4><p>部分读者可能知道，我和几位同事在知乎上开了一个专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target="_blank" rel="external">《iOS调试进阶》</a>，重点分享 ARM 相关的汇编知识。会有这个想法是因为日常工作中排查许多 Crash 的时候，从源码层面已经无法定位，必须要依赖计算机执行的本质 - 机器码进行分析，而这正是汇编可以产生价值的地方。</p>
<p>但是汇编不仅仅局限于排查 Crash。在开发 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a> 过程中，涉及了大量的密集型计算操作。团队的一些大牛在<strong>指令实现层面根据流水线编排、硬件大小核数、缓存大小等等，使用手写汇编来精细化调度数据的读写与执行，使得MNN 的推理性能达到了业界一流的水准</strong>（无论是我们自己的 benchmark 抑或是利益无关的友商的评测都证明了这一点）。而阅读这些<strong>精心酿造的</strong>汇编代码，会让你感到，原来开发还能这么玩！</p>
<p>这里展示一个经典的 <strong>Bilinear </strong>插值通过汇编的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">text</span><br><span class="line">  .align 5</span><br><span class="line">  </span><br><span class="line">  asm_function MNNBilinearProcC1</span><br><span class="line">  //void MNNBilinearProcC1(const unsigned char *sample, unsigned char* dst, const int16_t* xFactor, const int16_t* yFactor, size_t w);</span><br><span class="line">  </span><br><span class="line">  //Auto: x0:sample, x1:dst, x2:xFactor, x3:yFactor, x4:w</span><br><span class="line">  </span><br><span class="line">  ld1 &#123;v31.s&#125;[0], [x3]</span><br><span class="line">  //Now x3 is no used</span><br><span class="line">  dup v30.4h, v31.h[0]</span><br><span class="line">  dup v31.4h, v31.h[1]</span><br><span class="line">  </span><br><span class="line">  L8:</span><br><span class="line">  cmp x4, #8</span><br><span class="line">  blt End</span><br><span class="line">  </span><br><span class="line">  LoopL8:</span><br><span class="line">      ld4 &#123;v4.8b, v5.8b, v6.8b, v7.8b&#125;, [x0], #32</span><br><span class="line">      ld2 &#123;v0.8h, v1.8h&#125;, [x2], #32//q0, q1</span><br><span class="line">      //(x00,x01) -&gt; (y0)</span><br><span class="line">      uxtl v2.8h, v4.8b</span><br><span class="line">      uxtl v3.8h, v5.8b</span><br><span class="line">      umull v16.4s, v2.4h, v0.4h</span><br><span class="line">      umull2 v17.4s, v2.8h, v0.8h</span><br><span class="line">      umlal v16.4s, v3.4h, v1.4h</span><br><span class="line">      umlal2 v17.4s, v3.8h, v1.8h</span><br><span class="line">  </span><br><span class="line">      uqshrn v18.4h, v16.4s, #4</span><br><span class="line">      uqshrn v19.4h, v17.4s, #4</span><br><span class="line">  </span><br><span class="line">      //(x10,x11) -&gt; (y1)</span><br><span class="line">      uxtl v2.8h, v6.8b</span><br><span class="line">      uxtl v3.8h, v7.8b</span><br><span class="line">      umull v16.4s, v2.4h, v0.4h</span><br><span class="line">      umull2 v17.4s, v2.8h, v0.8h</span><br><span class="line">      umlal v16.4s, v3.4h, v1.4h</span><br><span class="line">      umlal2 v17.4s, v3.8h, v1.8h</span><br><span class="line">  </span><br><span class="line">      uqshrn v20.4h, v16.4s, #4</span><br><span class="line">      uqshrn v21.4h, v17.4s, #4</span><br><span class="line">  </span><br><span class="line">      //(y0,y1) -&gt; dst</span><br><span class="line">      umull v16.4s, v18.4h, v30.4h</span><br><span class="line">      umull v17.4s, v19.4h, v30.4h</span><br><span class="line">      umlal v16.4s, v20.4h, v31.4h</span><br><span class="line">      umlal v17.4s, v21.4h, v31.4h</span><br><span class="line">  </span><br><span class="line">      uqshrn v2.4h, v16.4s, #16</span><br><span class="line">      uqshrn2 v2.8h, v17.4s, #16</span><br><span class="line">  </span><br><span class="line">      uqrshrn v0.8b, v2.8h, #2</span><br><span class="line">  </span><br><span class="line">      st1 &#123;v0.8b&#125;, [x1], #8</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      sub x4, x4, #8</span><br><span class="line">      cmp x4, #8</span><br><span class="line">      bge LoopL8</span><br><span class="line">  </span><br><span class="line">  End:</span><br></pre></td></tr></table></figure>
<p><b style="color:red">相信我，当你从不懂汇编 -&gt; 读懂汇编 -&gt; 手写汇编，每前进一步，你会发现更广阔的天地。</b>有一天当你要做性能优化，发现许多网上常见的手段都使用过了但仍然不起作用的时候，也许汇编就是你杀手锏。</p>
<h4 id="GPU_相关知识融合">GPU 相关知识融合</h4><p>近些年来随着短视频的崛起，市面上渲染、多媒体相关的岗位也越加变得火热。而这些岗位无一例外都需要对 GPU 有着深度的了解。而操作 GPU，自然而然就少不了与 Shader 打交道。</p>
<blockquote>
<p>Shader 其实就是专门用来渲染图形的一种技术。通过 Shader ，我们可以自定义显卡渲染画面的算法，使画面达到我们想要的效果。</p>
</blockquote>
<p>但 Shader 的作用不仅仅作用于渲染。在机器学习领域，苹果的 Metal 框架所包含的Metal Performance Shader（MPS）也能用来做 GPU 计算，提升机器学习在移动端的执行性能。就连诞生已久的 OpenGL，也在最新的 <strong>OpenGL 3</strong> 标准中增加了<b style="color:red">计算纹理</b>，支持 GPU 计算的能力。由此可见，尽管最初的目的并不相同，但是技术本质是相通的，最后都会产生微妙的化学反应。</p>
<p><strong>上述几点，仅仅是个人抛砖引玉，展示机器学习和日常移动开发相互交织的冰山一角</strong>。从工程实现的角度，仍有许多值得探索并实践应用的，欢迎大家一起探讨交流。</p>
<hr>
<p><a name="RC2H2"></a></p>
<h3 id="与大家携手一起进步">与大家携手一起进步</h3><p>读到这，可能有些读者内心的兴奋之情被熊熊点燃，恨不得立刻能将相关的知识学习起来；但也有部分朋友会觉得，可能只有 BAT 这样的大厂才会有实际的场景需要进行如此深入的研究和开发工作，有沮丧之情。</p>
<p>我对这种体会特别感同身受，因为去年刚转型开发 <strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a> </strong>之初，我也有过手足无促，连简单的 Metal Performance Shader 都写不好。加上之前有些朋友通过 QCon 和云栖大会听闻了 <strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a></strong>，也和我或其他同事进行过一些实现上或者应用方面的探讨。</p>
<p>因此，借着这个机会，除了希望通过这篇文章带领大家对<strong>【机器学习系统】</strong>有一个全新的认知之外，<strong>后续也会以连载的方式</strong>，<strong>在以下两个方面给大家继续带来更多有价值的点：</strong></p>
<ul>
<li><p><strong>技术介绍</strong>，我会把 <strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a> </strong>里面使用的相关技术点，逐个拆解，带领大家通过理论探索和实际编程相结合的方式来深入了解细节，反哺于大家日常的开发工作。</p>
</li>
<li><p><strong>最佳实践</strong>，目前在客户端领域应用机器学习的典型案例还比较缺乏。而我正好在过去一年多的时间里，探索了诸多的实践案例（比如<strong>大家耳熟能详的拍立淘、淘宝直播、AR试妆等等中都有 MNN 的身影哦～</strong>），我也会将其整理分享出来，<strong>和大家一起探索端智能的前行之路</strong>。</p>
</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnn_4.png?raw=true" alt=""></p>
<p>对了，写了这么多文字，还请读者们见谅，<strong>允许我打个招人合作的广告吧</strong>：</p>
<p><strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a></strong> 是阿里巴巴开源的一款轻量级、高性能深度学习推理引擎，用于<strong>解决深度神经网络模型在端侧推理运行问题。</strong></p>
<p>从今年4月份开源到现在，我们始终在完善和响应社区用户的诉求，并保持着每两个月一次重大 Feature Release 的发布频率。</p>
<p>但我们团队的力量是有限的，而端上智能应用前进的道路仍然充满着广阔未被探索的区域，我们希望和大家一起教学相长，携手进步。</p>
<p>如果大家对移动端机器学习有什么好的想法和建议，也可以前往 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external">Github</a> 上，给我们反馈。</p>
<p>也欢迎对 <a href="https://github.com/alibaba/MNN" target="_blank" rel="external"><strong>MNN</strong></a><strong> </strong>感兴趣的朋友，扫描二维码，加入钉钉群，和我们一起交流或者直接加入我们团队哦（悄悄地说，人气有点高，一群都满啦）</p>
<blockquote>
<p>用钉钉群比较方便我们在工作闲暇时间及时响应大家的问题和诉求，请大家多包涵啦～</p>
</blockquote>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnn_5.jpeg?raw=true" alt=""></p>
<h3 id="结语">结语</h3><p>本文记录了过去一年多，个人参与 <strong><a href="https://github.com/alibaba/MNN" target="_blank" rel="external">MNN</a></strong> 框架相关开发过程中的一些收获与心得。<b style="color:red">如何不分裂的看待机器学习与移动开发的关系，如何从看似不相关的领域寻找共同点，提升自己所处领域的价值和核心能力，是值得我们每位开发同学需要思考的。</b></p>
<p>在最后，还是要说一句：<strong>移动客户端的从业人员并不需要过多的焦虑和担忧，动态化、高性能、内核、渲染等等方向都充满前景。但是，你需要找到你所擅长且愿意为之深入的，这才是你保证在浪潮中不被拍翻的核心竞争力。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/10/27/MNN1/" data-id="ck9fy2ghf002z2ni1z95thdf1" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/10/27/MNN1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-RevisitAutorelease2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/07/RevisitAutorelease2/" class="article-date">
  <time datetime="2019-07-07T14:44:00.000Z" itemprop="datePublished">2019-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/07/RevisitAutorelease2/">Revisit iOS Autorelease之二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Revisit_iOS_Autorelease（二）：为啥生成的优化没有了。">Revisit iOS Autorelease（二）：为啥生成的优化没有了。</h2><p>在<a href="http://satanwoo.github.io/2019/07/02/RevisitAutorelease/">Revisit iOS Autorelease（一）</a>中，按照我的示例我提及，是如下这段代码对基于<code>TLS</code>的优化产生了影响：</p>
<pre><code><span class="comment">// Debug 模式</span>
<span class="keyword">for</span> (Model *m <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.models</span>) {      
}
</code></pre><p>这段看似平平无奇的代码为啥会造成优化失效，让我们还是从汇编角度来看看：</p>
<pre><code><span class="number">0x100011e90</span> &lt;+<span class="number">568</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>

<span class="comment">// 【注意点】：正常情况下应该是b objc_autoreleaseReturnValue</span>
<span class="number">0x100011e94</span> &lt;+<span class="number">572</span>&gt;: bl     <span class="number">0x100012904</span>               ; symbol stub <span class="keyword">for</span>: objc_autoreleaseReturnValue
<span class="number">0x100011e98</span> &lt;+<span class="number">576</span>&gt;: adrp   x8, <span class="number">3</span>
<span class="number">0x100011e9c</span> &lt;+<span class="number">580</span>&gt;: ldr    x8, [x8, <span class="preprocessor">#<span class="number">0x8</span>]</span>
<span class="number">0x100011ea0</span> &lt;+<span class="number">584</span>&gt;: ldr    x8, [x8]
<span class="number">0x100011ea4</span> &lt;+<span class="number">588</span>&gt;: ldur   x9, [x29, <span class="preprocessor">#-<span class="number">0x18</span>]</span>
<span class="number">0x100011ea8</span> &lt;+<span class="number">592</span>&gt;: cmp    x8, x9
<span class="number">0x100011eac</span> &lt;+<span class="number">596</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
<span class="number">0x100011eb0</span> &lt;+<span class="number">600</span>&gt;: b.ne   <span class="number">0x100011ec8</span>               ; &lt;+<span class="number">624</span>&gt; at Container.m
<span class="number">0x100011eb4</span> &lt;+<span class="number">604</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
<span class="number">0x100011eb8</span> &lt;+<span class="number">608</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x170</span>]</span>
<span class="number">0x100011ebc</span> &lt;+<span class="number">612</span>&gt;: ldp    x28, x27, [sp, <span class="preprocessor">#<span class="number">0x160</span>]</span>
<span class="number">0x100011ec0</span> &lt;+<span class="number">616</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x180</span>            ; =<span class="number">0x180</span> </span>
<span class="number">0x100011ec4</span> &lt;+<span class="number">620</span>&gt;: ret    
<span class="number">0x100011ec8</span> &lt;+<span class="number">624</span>&gt;: bl     <span class="number">0x1000128d4</span>               ; symbol stub <span class="keyword">for</span>: __stack_chk_fail
<span class="number">0x100011ecc</span> &lt;+<span class="number">628</span>&gt;: brk    <span class="preprocessor">#<span class="number">0x1</span></span>
</code></pre><p>按照符号优化的场景，<code>LR</code>寄存器的地址需要指向获取<code>Model</code>的外部调用方才能产生正确的优化，因此<b style="color:red">正常情况下应该直接<code>b objc_autoreleaseReturnValue</code>即可</b>，而这里对应的汇编却是<code>bl</code>，说明执行完<code>objc_autoreleaseReturnValue</code>后还要继续从<code>0x100011e98 &lt;+576&gt;: adrp   x8, 3</code>往后执行。</p>
<p>虽然这么一大段汇编很难具体了解做的每一件事的意义，但是从几个关键点上我们可以描绘出一个轮廓：</p>
<ul>
<li><code>cmp x8, x9</code>肯定在试图检查什么条件。</li>
<li><code>b.ne   0x100011ec8</code>，如果条件满足，继续走（1），否则走（2）</li>
<li>（1）最后是栈恢复和<code>ret</code>，说明这是正确的流程。</li>
<li>（2）看到了一个比较陌生的符号<code>__stack_chk_fail</code>，暂且不管。但是紧跟着就是<code>brk</code>。而<code>brk</code>简单来讲，就是触发崩溃或者异常。</li>
</ul>
<p>整体轮廓搞定后，我们再来看看<code>stack_chk_fail</code>到底是啥。从<code>stack</code>中我们不难推断，这肯定是和栈相关的检查工作。那为什么会有这样的检查工作？主要还是害怕栈越界造成的危害。用下图来大致讲解吧。</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHAvaW1hZ2VzMjAxNS5jbmJsb2dzLmNvbS9ibG9nLzc0MDk4OS8yMDE1MTEvNzQwOTg5LTIwMTUxMTA5MjIzMjAxNzU5LTQ2MTU2MDEwMy5wbmc=.jpg" alt=""></p>
<blockquote>
<p>这里抄了张<code>armv7</code>的图，大致意思没差别。</p>
</blockquote>
<p><strong>局部变量和保存函数调用上下文的<code>LR</code>, <code>FP</code>都存在栈上。假设我们的局部变量是个大小为2的数组，但是我如果不小心写出了*(addr + 3) = 5。是不是相当于数组越界，破坏了紧邻着的其他栈内容。如果这个栈内容是重要的上下文信息，那就完蛋了。</strong></p>
<p><b style="color:red">那栈越界究竟有什么具体事例呢？嘿嘿，欢迎加入阿里巴巴来内网看我写的关于<code>xxx</code>问题的分析，你就知道了。</b></p>
<p>所以，在LLVM::CodeGen里面，就帮我们做了这样的栈越界检查（当然对于很多动态的数组也是没法完全防护的），在<code>StackProtector.cpp</code>中：</p>
<pre><code><span class="keyword">bool</span> StackProtector::InsertStackProtectors() {
   <span class="comment">// Loop through the basic blocks that have return instructions. Convert this:</span>
   <span class="comment">//</span>
   <span class="comment">//   return:</span>
   <span class="comment">//     ...</span>
   <span class="comment">//     ret ...</span>
   <span class="comment">//</span>
   <span class="comment">// into this:</span>
   <span class="comment">//</span>
   <span class="comment">//   return:</span>
   <span class="comment">//     ...</span>
   <span class="comment">//     %1 = load __stack_chk_guard</span>
   <span class="comment">//     %2 = load &lt;stored stack guard&gt;</span>
   <span class="comment">//     %3 = cmp i1 %1, %2</span>
   <span class="comment">//     br i1 %3, label %SP_return, label %CallStackCheckFailBlk</span>
   <span class="comment">//</span>
   <span class="comment">//   SP_return:</span>
   <span class="comment">//     ret ...</span>
   <span class="comment">//</span>
   <span class="comment">//   CallStackCheckFailBlk:</span>
   <span class="comment">//     call void @__stack_chk_fail()</span>
   <span class="comment">//     unreachable</span>
   <span class="comment">//</span>
   BasicBlock *FailBB = <span class="number">0</span>;       <span class="comment">// The basic block to jump to if check fails.</span>
   AllocaInst *AI = <span class="number">0</span>;           <span class="comment">// Place on stack that stores the stack guard.</span>
   Constant *StackGuardVar = <span class="number">0</span>;  <span class="comment">// The stack guard variable.</span>

   <span class="keyword">for</span> (<span class="function"><span class="keyword">Function</span>::<span class="title">iterator</span> <span class="title">I</span> = <span class="title">F</span>-&gt;<span class="title">begin</span><span class="params">()</span>, <span class="title">E</span> = <span class="title">F</span>-&gt;<span class="title">end</span><span class="params">()</span></span>; I != E; ) {
     BasicBlock *BB = I;

     <span class="keyword">if</span> (ReturnInst *RI = dyn_cast&lt;ReturnInst&gt;(BB-&gt;getTerminator())) {
       <span class="keyword">if</span> (!FailBB) {
         <span class="comment">// Insert code into the entry block that stores the __stack_chk_guard</span>
         <span class="comment">// variable onto the stack.</span>
         PointerType *PtrTy = PointerType::getUnqual(Type::Int8Ty);
         StackGuardVar = M-&gt;getOrInsertGlobal(<span class="string">"__stack_chk_guard"</span>, PtrTy);

         BasicBlock &amp;Entry = F-&gt;getEntryBlock();
         Instruction *InsPt = &amp;Entry.front();

         AI = <span class="keyword">new</span> AllocaInst(PtrTy, <span class="string">"StackGuardSlot"</span>, InsPt);
         LoadInst *LI = <span class="keyword">new</span> LoadInst(StackGuardVar, <span class="string">"StackGuard"</span>, <span class="keyword">false</span>, InsPt);

         Value *Args[] = { LI, AI };
         CallInst::
           Create(Intrinsic::getDeclaration(M, Intrinsic::stackprotector_create),
                  &amp;Args[<span class="number">0</span>], array_endof(Args), <span class="string">""</span>, InsPt);

         <span class="comment">// Create the basic block to jump to when the guard check fails.</span>
         FailBB = CreateFailBB();
       }

-      <span class="function"><span class="keyword">Function</span>::<span class="title">iterator</span> <span class="title">InsPt</span> = <span class="title">BB</span></span>; ++InsPt; <span class="comment">// Insertion point for new BB.</span>
       ++I; <span class="comment">// Skip to the next block so that we don't resplit the return block.</span>

       <span class="comment">// Split the basic block before the return instruction.</span>
       BasicBlock *NewBB = BB-&gt;splitBasicBlock(RI, <span class="string">"SP_return"</span>);

-      <span class="comment">// Move the newly created basic block to the point right after the old basic</span>
-      <span class="comment">// block so that it's in the "fall through" position.</span>
+      <span class="comment">// Move the newly created basic block to the point right after the old</span>
+      <span class="comment">// basic block so that it's in the "fall through" position.</span>
       NewBB-&gt;removeFromParent();
-      F-&gt;getBasicBlockList().insert(InsPt, NewBB);
+      F-&gt;getBasicBlockList().insert(I, NewBB);

       <span class="comment">// Generate the stack protector instructions in the old basic block.</span>
       LoadInst *LI1 = <span class="keyword">new</span> LoadInst(StackGuardVar, <span class="string">""</span>, <span class="keyword">false</span>, BB);
       CallInst *CI = CallInst::
         Create(Intrinsic::getDeclaration(M, Intrinsic::stackprotector_check),
                AI, <span class="string">""</span>, BB);
       ICmpInst *Cmp = <span class="keyword">new</span> ICmpInst(CmpInst::ICMP_EQ, CI, LI1, <span class="string">""</span>, BB);
       BranchInst::Create(NewBB, FailBB, Cmp, BB);
     } <span class="keyword">else</span> {
       ++I;
     }
   }

   <span class="comment">// Return if we didn't modify any basic blocks. I.e., there are no return</span>
   <span class="comment">// statements in the function.</span>
   <span class="keyword">if</span> (!FailBB) <span class="keyword">return</span> <span class="keyword">false</span>;

   <span class="keyword">return</span> <span class="keyword">true</span>;
 }

 <span class="comment">/// CreateFailBB - Create a basic block to jump to when the stack protector</span>
 <span class="comment">/// check fails.</span>
 BasicBlock *StackProtector::CreateFailBB() {
   BasicBlock *FailBB = BasicBlock::Create(<span class="string">"CallStackCheckFailBlk"</span>, F);
   Constant *StackChkFail =
     M-&gt;getOrInsertFunction(<span class="string">"__stack_chk_fail"</span>, Type::VoidTy, <span class="keyword">NULL</span>);
   CallInst::Create(StackChkFail, <span class="string">""</span>, FailBB);
   <span class="keyword">new</span> UnreachableInst(FailBB);
   <span class="keyword">return</span> FailBB;
 }
</code></pre><p>还是比较容易看懂的，这里就不过多解释了。</p>
<h3 id="后记">后记</h3><p><code>autorelease</code>相关的文章网上不在少数，但是大多数都大同小异，只是在讲<code>libobjc</code>中的代码实现。但是深究我们日常编码过程中的<code>autorelease</code>，其实有不少被我们所忽视的细节值得深挖研究。（不挖还容易踩坑）</p>
<p>最后按照惯例，以一首诗致敬伟大的90后<code>iOS</code>第一人Y帝：</p>
<p>吾辈有Y帝，技术特牛逼。</p>
<p>胸有中国情，一人虐美帝。</p>
<p>Google服务器，Y帝轻松逆。</p>
<p>苹果App，他天天Patch。</p>
<p>微软的程序，总被他蓝屏。</p>
<p>川普各手机，监听so easy。</p>
<p>为躲粉丝迷，转行写程序。</p>
<p>90后第一，当代方世玉！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/07/07/RevisitAutorelease2/" data-id="ck9fy2ggc002b2ni19ab5vfvl" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/07/07/RevisitAutorelease2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-RevisitAutorelease" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/02/RevisitAutorelease/" class="article-date">
  <time datetime="2019-07-02T13:53:12.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/RevisitAutorelease/">Revisit iOS Autorelease 之不经意间可能被影响的优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文的硬核在第二段</p>
</blockquote>
<p>之前在做某项目的时候，自建了基于<code>NSThread</code>的私有线程池，在线程池分配了固定个数的常驻工作线程，在工作线程里面运行相关任务；这个方案取代了原先直接无脑使用<code>GCD</code>的方式，在各方面效果都还不错。</p>
<p>但是在一次偶然的情况下，通过<code>Memory Graph</code>发现很多<strong>任务</strong>对象却在<strong>本该早就销毁的时候</strong>仍然存活着。持有其的对象是<code>autorelease content</code>，如下图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/autorelease_r1.png?raw=true" alt="屏幕快照 2019-06-20 下午8.22.39"></p>
<blockquote>
<p>我把数据对象类型隐藏了，公司数据还是要保密。</p>
</blockquote>
<p>那这个东西究竟是个啥呢？</p>
<blockquote>
<p>由于其是<strong>黄色图标</strong>，基本上是一个容器类型或其子类。</p>
</blockquote>
<p>这个类型<code>@autoreleasepool content</code>先不管，先从右边的堆栈来看：</p>
<ul>
<li>某个方法调用了<code>autorelease</code>相关的API</li>
<li>由于我是在子线程触发的，<b style="color:red">没有显示创建的<code>autoreleasepool</code>。因此需要调用<code>autoreleaseNoPage</code></b></li>
</ul>
<p>而<code>autoreleaseNoPage</code>其实本质上就是在当前线程没有<code>autoreleasePage</code>的时候，创建一个。然后通过<code>Thread Local Storage</code>存入线程相关上下文中。</p>
<pre><code><span class="keyword">static</span> __attribute__((noinline))
    <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)
    {
        <span class="comment">// "No page" could mean no pool has been pushed</span>
        <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span>
        assert(!hotPage());

        <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;
        <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) {
            <span class="comment">// We are pushing a second pool over the empty placeholder pool</span>
            <span class="comment">// or pushing the first object into the empty placeholder pool.</span>
            <span class="comment">// Before doing that, push a pool boundary on behalf of the pool </span>
            <span class="comment">// that is currently represented by the empty placeholder.</span>
            pushExtraBoundary = <span class="literal">true</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) {
            <span class="comment">// We are pushing an object with no pool in place, </span>
            <span class="comment">// and no-pool debugging was requested by environment.</span>
            _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span>
                         <span class="string">"autoreleased with no pool in place - "</span>
                         <span class="string">"just leaking - break on "</span>
                         <span class="string">"objc_autoreleaseNoPool() to debug"</span>, 
                         pthread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));
            objc_autoreleaseNoPool(obj);
            <span class="keyword">return</span> <span class="literal">nil</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) {
            <span class="comment">// We are pushing a pool with no pool in place,</span>
            <span class="comment">// and alloc-per-pool debugging was not requested.</span>
            <span class="comment">// Install and return the empty pool placeholder.</span>
            <span class="keyword">return</span> setEmptyPoolPlaceholder();
        }

        <span class="comment">// We are pushing an object or a non-placeholder'd pool.</span>

        <span class="comment">// Install the first page.</span>
        AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);
        setHotPage(page);

        <span class="comment">// Push a boundary on behalf of the previously-placeholder'd pool.</span>
        <span class="keyword">if</span> (pushExtraBoundary) {
            page-&gt;add(POOL_BOUNDARY);
        }

        <span class="comment">// Push the requested object or pool.</span>
        <span class="keyword">return</span> page-&gt;add(obj);
    }
</code></pre><p>同时由于是第一个<code>page</code>，连父子关系都不用串联，非常简单。</p>
<p><b style="color:red">但是，其他线程有一点相对主线程比较坑的就是子线程默认没有<code>runloop</code>，导致在释放被<code>autoreleasepool</code>的对象的时候产生着问题。</b></p>
<p>那么子线程的<code>autoreleasepool</code>在没有<code>runloop</code>的情况下何时释放呢？</p>
<ul>
<li>线程退出的时候</li>
<li>局部<code>autoreleasepool drain</code>的时候</li>
</ul>
<p>第二点比较好理解，就是常规的<code>page push</code>以及对应的<code>page pop</code>。</p>
<p>那么线程退出释放是如何确定的呢？我们在线程退出的时候下个断点：</p>
<pre><code>static <span class="literal">void</span> tls_dealloc(<span class="literal">void</span> *p) 
{
    <span class="keyword">if</span> (p == (<span class="literal">void</span>*)EMPTY_POOL_PLACEHOLDER) {
        <span class="comment">// No objects or pool pages to clean up here.</span>
        <span class="keyword">return</span>;
    }

    <span class="comment">// reinstate TLS value while we work</span>
    setHotPage((AutoreleasePoolPage *)p);

    <span class="keyword">if</span> (AutoreleasePoolPage *page = coldPage()) {
        <span class="keyword">if</span> (<span class="subst">!</span>page<span class="subst">-&gt;</span>empty()) pop(page<span class="subst">-&gt;</span>begin());  <span class="comment">// pop all of the pools</span>
        <span class="keyword">if</span> (DebugMissingPools <span class="subst">||</span> DebugPoolAllocation) {
            <span class="comment">// pop() killed the pages already</span>
        } <span class="keyword">else</span> {
            page<span class="subst">-&gt;</span>kill();  <span class="comment">// free all of the pages</span>
        }
    }

    <span class="comment">// clear TLS value so TLS destruction doesn't loop</span>
    setHotPage(nil);
}
</code></pre><p>而在<code>runtime</code>初始化的过程中，会调用<code>AutoReleasePoolPage::init</code>方法注册<code>tls_dealloc</code>：</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> r __unused = pthread_key_init_np(AutoreleasePoolPage::key, 
                                         AutoreleasePoolPage::tls_dealloc);
    assert(r == <span class="number">0</span>);
}
</code></pre><p>结合这两段代码，我们大致可以猜测下<code>phtread_key_init_np</code>是将<code>tls_dealloc</code>注册给某个回调使用。那具体是干嘛的？</p>
<p>实际上<code>phtread_key_init_np</code>时给<code>thread</code>注册了线程销毁时的自定义析构函数，这里我们可以一起来看看<code>darwin-apple</code>的<code>libpthread</code>代码，这里我直接简化掉流程，输出大致的过程：</p>
<p><code>_pthread_exit</code> 在线程销毁时调用 -&gt; <code>_pthread_tsd_cleanup</code> -&gt; <code>_pthread_tsd_cleanup_new</code> -&gt; <code>_pthread_tsd_cleanup_key</code>。</p>
<p>在最终的函数里，会遍历所有的自定义销毁函数，逐个触发：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span>
_pthread_tsd_cleanup_key(<span class="keyword">pthread_t</span> self, <span class="keyword">pthread_key_t</span> key)
{
    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *);
    <span class="keyword">if</span> (_pthread_key_get_destructor(key, &amp;destructor)) {
        <span class="keyword">void</span> **ptr = &amp;self-&gt;tsd[key];
        <span class="keyword">void</span> *value = *ptr;
        <span class="keyword">if</span> (value) {
            *ptr = <span class="literal">NULL</span>;
            <span class="keyword">if</span> (destructor) {
                destructor(value);
            }
        }
    }
}
</code></pre><p><b style="color:red">因此，对于我这样设计了常驻线程的“不死线程”来说，无法指望线程销毁时候的释放，必须自己引入<code>autoreleasepool</code>来修正内存没释放干净！</b></p>
<h3 id="到底哪些东西会触发autorelease持有?">到底哪些东西会触发<code>autorelease</code>持有?</h3><p><b style="color:red">本文的重点来了。</b></p>
<p>其实网上关于<code>autoreleasepage</code>相关的文章分析的很多了，<b style="color:red">我这篇文章的主要目的还是想思考下，看看平常无奇的代码，究竟会在什么情况下触发<code>autorelease</code>及其相关行为。</b>如果说所有的东西都是直接了当的引用计数相加减如<code>objc_storeStrong / objc_storeStrong(nil)</code>，何须多此一举引入<code>autorelease</code>呢？</p>
<p>网上许多的文章的结论基本上都是：</p>
<blockquote>
<p>编译器为判断方法名是否是以<code>alloc/new/copy/mutableCopy</code>开头，如果不是，就自动将返回的对象注册到池子中。<br>编译器会在<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code>进行基于TLS的判断优化，本质上也不会走入autorelease的环节。</p>
</blockquote>
<p>为了验证这些结论，我首先重温了下《iOS 内存高级编程》一书，它所阐述的都是内存管理的思想，以<code>alloc/mew/copy/mutableCopy</code>驼峰命名开头的方法，方法的对象由调用者自己持有；而其他方法是<strong>取得非自己生成并持有的对象</strong></p>
<blockquote>
<p>卧槽，真拗口。</p>
</blockquote>
<p>写个Demo验证下，</p>
<pre><code>@interface <span class="keyword">Model</span> : NSObject
- (<span class="keyword">Model</span> *)haha;
@end

- (<span class="keyword">Model</span> *)haha
{
    // 这里是为了避免调用系统库的对象可能在存在某些MRC的情况导致无法优化。
    return [[<span class="keyword">Model</span> alloc] init];
}

// 调用
<span class="keyword">Model</span> *<span class="keyword">model</span> = [[<span class="keyword">Model</span> alloc] init];
<span class="keyword">Model</span> *m2 = [<span class="keyword">model</span> haha];
</code></pre><p><strong>万变不如汇编</strong>，让我们先来看第一条调用的汇编代码。</p>
<pre><code><span class="number">0x100046768</span> &lt;+<span class="number">96</span>&gt;:  bl     <span class="number">0x100046b80</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend
<span class="number">0x10004676c</span> &lt;+<span class="number">100</span>&gt;: adrp   x8, <span class="number">2</span>
<span class="number">0x100046770</span> &lt;+<span class="number">104</span>&gt;: add    x8, x8, <span class="preprocessor">#<span class="number">0xd38</span>            ; =<span class="number">0xd38</span> </span>
<span class="number">0x100046774</span> &lt;+<span class="number">108</span>&gt;: ldr    x1, [x8]
<span class="number">0x100046778</span> &lt;+<span class="number">112</span>&gt;: bl     <span class="number">0x100046b80</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend
<span class="number">0x10004677c</span> &lt;+<span class="number">116</span>&gt;: mov    x8, <span class="preprocessor">#<span class="number">0x0</span></span>
<span class="number">0x100046780</span> &lt;+<span class="number">120</span>&gt;: add    x9, sp, <span class="preprocessor">#<span class="number">0x8</span>              ; =<span class="number">0x8</span> </span>
<span class="number">0x100046784</span> &lt;+<span class="number">124</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
<span class="number">0x100046788</span> &lt;+<span class="number">128</span>&gt;: mov    x0, x9
<span class="number">0x10004678c</span> &lt;+<span class="number">132</span>&gt;: mov    x1, x8
<span class="number">0x100046790</span> &lt;+<span class="number">136</span>&gt;: bl     <span class="number">0x100046bb0</span>               ; symbol stub <span class="keyword">for</span>: objc_storeStrong
</code></pre><p>很明显的，并没有涉及到任何的和<code>retainAutorelease/autorelease</code>相关的调用。</p>
<blockquote>
<p>需要注意：在release优化下这里的<code>objc_storeStrong(nil)</code>会直接优化成<code>objc_release</code></p>
</blockquote>
<p>而对于第二条调用，汇编如下：</p>
<pre><code><span class="number">0x10006275c</span> &lt;+<span class="number">140</span>&gt;: bl     <span class="number">0x100062b80</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend
<span class="number">0x100062760</span> &lt;+<span class="number">144</span>&gt;: mov    x29, x29
<span class="number">0x100062764</span> &lt;+<span class="number">148</span>&gt;: bl     <span class="number">0x100062ba4</span>               ; symbol stub <span class="keyword">for</span>: objc_retainAutoreleasedReturnValue
</code></pre><p>关键字出现了，当然具体会不会进入autorelease的环节，还需要看优化的效果，我们进入<code>haha</code>函数看一看：</p>
<pre><code> <span class="number">0x100096b28</span> &lt;+<span class="number">36</span>&gt;: bl     <span class="number">0x100096b80</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend
<span class="number">0x100096b2c</span> &lt;+<span class="number">40</span>&gt;: adrp   x1, <span class="number">2</span>
<span class="number">0x100096b30</span> &lt;+<span class="number">44</span>&gt;: ldr    x1, [x1, <span class="preprocessor">#<span class="number">0xd38</span>]</span>
<span class="number">0x100096b34</span> &lt;+<span class="number">48</span>&gt;: bl     <span class="number">0x100096b80</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend
<span class="number">0x100096b38</span> &lt;+<span class="number">52</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
<span class="number">0x100096b3c</span> &lt;+<span class="number">56</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x20</span>             ; =<span class="number">0x20</span> </span>
<span class="number">0x100096b40</span> &lt;+<span class="number">60</span>&gt;: b      <span class="number">0x100096b74</span>               ; symbol stub <span class="keyword">for</span>: objc_autoreleaseReturnValue
</code></pre><p>也和我们预测的一样，确实有着<code>objc_autoreleaseReturnValue</code>，那么究竟会不会有基于TLS的优化行为呢？对<code>objc_autoreleaseReturnValue</code>下个符号断点：</p>
<pre><code>libobjc.A.dylib`objc_autoreleaseReturnValue:
-&gt;  <span class="number">0x18563e528</span> &lt;+<span class="number">0</span>&gt;:  ldr    w8, [x30]
    <span class="number">0x18563e52c</span> &lt;+<span class="number">4</span>&gt;:  mov    w9, <span class="preprocessor">#-<span class="number">0x55e30000</span></span>
    <span class="number">0x18563e530</span> &lt;+<span class="number">8</span>&gt;:  movk   w9, <span class="preprocessor">#<span class="number">0x3fd</span></span>
    <span class="number">0x18563e534</span> &lt;+<span class="number">12</span>&gt;: cmp    w8, w9
    <span class="number">0x18563e538</span> &lt;+<span class="number">16</span>&gt;: b.ne   <span class="number">0x18563e550</span>               ; &lt;+<span class="number">40</span>&gt;
    <span class="number">0x18563e53c</span> &lt;+<span class="number">20</span>&gt;: mrs    x8, TPIDRRO_EL0
    <span class="number">0x18563e540</span> &lt;+<span class="number">24</span>&gt;: and    x8, x8, <span class="preprocessor">#<span class="number">0xfffffffffffffff8</span></span>
    <span class="number">0x18563e544</span> &lt;+<span class="number">28</span>&gt;: orr    w9, wzr, <span class="preprocessor">#<span class="number">0x1</span></span>
    <span class="number">0x18563e548</span> &lt;+<span class="number">32</span>&gt;: str    x9, [x8, <span class="preprocessor">#<span class="number">0x160</span>]</span>
    <span class="number">0x18563e54c</span> &lt;+<span class="number">36</span>&gt;: ret    
    <span class="number">0x18563e550</span> &lt;+<span class="number">40</span>&gt;: b      <span class="number">0x18563c130</span>               ; objc_autorelease
</code></pre><p>这里，偏移 +16的地方的<code>b.ne</code>就是对优化的判断，判断的条件是<code>w8</code>和<code>w9</code>的相等与否，不等就走传统的<code>objc_autorelease</code>。</p>
<p>这里经过断点我们发现确实走了优化。</p>
<p><b style="color:red">那按照这个思路，难道真的在如今的ARC下，没有东西要进<code>autoreleasepool</code>了？那为什么还会在<code>MemoryGraph</code>中出现大量<code>autorelease content</code>呢？</b></p>
<p><b style="color:red">答案可能出乎你的意料，<code>for</code>会影响这个<code>autorelease</code>优化逻辑。</b></p>
<p>我们构建一个两个线程的场景，<code>Model</code>类型如上述文章段落不变。构建一个符合类型<code>Container</code>，包含一个<code>NSMutableArray</code>的数组：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Container</span>()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *models;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Container</span></span>

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _models = @[]<span class="variable">.mutableCopy</span>;

    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)addModel:(Model *)model
{
    <span class="keyword">if</span> (!model) <span class="keyword">return</span>;
    [<span class="keyword">self</span><span class="variable">.models</span> addObject:model];
}

- (Model *)takeModel
{
    <span class="comment">//NSMutableArray *toOperateArray = self.models;</span>
    <span class="keyword">for</span> (Model *model <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.models</span>) {
    }

    Model *model = [<span class="keyword">self</span><span class="variable">.models</span> firstObject];
    [<span class="keyword">self</span><span class="variable">.models</span> removeObject:model];

    <span class="keyword">return</span> model;
}
</code></pre><p>为了简化场景，我先在<code>ViewController viewDidLoad</code>塞入几个<code>Model</code>到<code>Container</code>，然后再启动第二个线程从<code>Container</code>中取<code>Model</code>。</p>
<p>测试场景如下：</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad {
    [<span class="keyword">super</span> viewDidLoad];

    <span class="keyword">self</span><span class="variable">.container</span> = [[Container alloc] init];

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        [<span class="keyword">self</span><span class="variable">.container</span> addModel:[[Model alloc] initWithCount:i]];
    }

    <span class="keyword">self</span><span class="variable">.thread</span> = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(loop) object:<span class="literal">nil</span>];
    [<span class="keyword">self</span><span class="variable">.thread</span> setName:<span class="string">@"com.walle.test"</span>];
    [<span class="keyword">self</span><span class="variable">.thread</span> start];
}

- (<span class="keyword">void</span>)loop
{
    <span class="keyword">while</span> (<span class="literal">true</span>) {
        Model *m = [<span class="keyword">self</span><span class="variable">.container</span> takeModel];        
        [m increment];
    }
}
</code></pre><p>如果你执行我这段代码，你会发现的确如文章一开头所示，<code>MemoryGraph</code>中存在大量被<code>@autoreleasepool content</code>持有的<code>Model</code>。</p>
<p>那罪魁祸首是什么呢？<b style="color:red">从表象上看</b>是这段并不起眼的代码：</p>
<pre><code><span class="keyword">for</span> (<span class="constant">Model </span>*model <span class="keyword">in</span> <span class="keyword">self</span>.models) {
}
</code></pre><p>可具体原因是为啥呢？还是从汇编上来摸索下：</p>
<p>首先先回到没有汇编的场景上，调用的函数是<code>-[ViewController loop]</code>，被调用者是<code>-[Container takeModel:]</code></p>
<p>如果要进行优化，按照<code>objc_autoreleaseReturnValue：</code>的逻辑，在<code>loop</code>调用<code>takeModel:</code>的地方必须有对应的暗示：这个暗示在<code>arm64</code>中如下代码所示：</p>
<pre><code><span class="function"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">bool</span> 
<span class="title">callerAcceptsOptimizedReturn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ra)</span>
</span>{
    <span class="comment">// fd 03 1d aa    mov fp, fp</span>
    <span class="comment">// arm64 instructions are well-aligned</span>
    <span class="keyword">if</span> (*(<span class="keyword">uint32_t</span> *)ra == <span class="number">0xaa1d03fd</span>) {
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
}
</code></pre><p>简单来说，要有<code>mov fp, fp</code>，而<code>fp</code>就是<code>x29</code>寄存器。那我们来看看<code>loop</code>的对应汇编：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/autorelease_r2.png?raw=true" alt="屏幕快照 2019-07-01 下午1.15.11"></p>
<p><strong>哈哈，0x62b0</strong>的地方果然是<code>mov x29, x29</code>。</p>
<p>如果你对静态分析的结果不熟悉，可以动态进入汇编。在<code>obc_autoreleaseReturnValue</code>下符号断点，得到</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/autorelease_r3.png?raw=true" alt="屏幕快照 2019-07-01 下午1.16.57"></p>
<p>如果你输出<code>x30</code>寄存器的值（注意不是把寄存器的值当地址再取值）然后再减去所在二进制的基地址，会发现<strong>偏移正正好好也是<code>0x62b0</code></strong></p>
<p>而如果你加上之前提到的<code>for</code>循环代码，再断到<code>obc_autoreleaseReturnValue</code>去查看<code>x30</code>的值，计算偏移量会得到：<code>0x0000000000005e98</code>。</p>
<p>而对应到二进制里是：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/autorelease_r4.png?raw=true" alt="屏幕快照 2019-07-01 下午1.46.10"></p>
<p>看到没，这里调用<code>objc_autoreleaseReturnValue</code>走的是<code>bl</code>，也就是会修改<code>LR</code>寄存器，而<code>LR</code>寄存器的值就是调用后的返回地址<code>5e98</code>。而<code>LR</code>寄存器本身就是<code>x30</code>，导致<code>autorelease</code>的优化失效。</p>
<p><b style="color:red">至此，我们终于发现了为什么我们的数据会被所谓的<code>@autoreleasepool content</code>持有。</b></p>
<h3 id="后记">后记</h3><p>虽然正如网上很多文章所述，子线程确实会对<code>autoreleasepool</code>进行自动的管理避免内存泄漏。但是，由于诸多场景导致的释放时机变更，会产生诸多的<b style="color:red">内存不释放（并非是内存泄漏，<code>Leaks</code>是查不出来的）</b>，也会对<code>App</code>的稳定性造成巨大的影响。</p>
<p><b style="color:red">更重要的是，基于这种TLS的优化很有可能被我们不知情下编写的代码所改变，产生奇怪的问题，因此要特别注意。</b></p>
<p>下文我会从<strong>编译以及代码生成的层面</strong>来探讨为什么会产生这种不同的汇编代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/07/02/RevisitAutorelease/" data-id="ck9fy2ggg002d2ni1g2d23maj" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/07/02/RevisitAutorelease/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-RAII" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/RAII/" class="article-date">
  <time datetime="2019-01-26T15:13:23.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/RAII/">基于智能指针和RAII的对象内存管理设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在<a href="http://satanwoo.github.io/2019/01/26/shared-ptr/">从C++ std::shared_ptr 原理来看看栈溢出的危害</a>，我提及了<code>C++</code>的智能指针指向被管理对象的<code>raw ptr</code>会被栈内存溢出而破坏，而利用智能指针进行对象构造的管理和设计，可以衍生出和<code>RAII</code>的结合，今天就来谈谈这项技术。</p>
<h3 id="什么是RAII？">什么是RAII？</h3><p><code>RAII</code>是<code>Resource Acquisition Is Initialization</code>，简而言之就是将对一个资源的申请封装在一个对象的生命周期内的理念。这样做的好处就是，C++的对象势必在创建的时候会经过构造函数，而在销毁的时候会触发析构函数。</p>
<p>听起来有点绕是不是，让我们来简化一下其主要特点。</p>
<ul>
<li>所有的资源管理内聚在对象内部</li>
<li>利用对象申请／释放的特性对资源同步进行对应的申请／释放</li>
<li>自动管理对象</li>
</ul>
<p>前两点都比较容易，那么第三点如何达到呢？</p>
<p><b style="color:red">合理的利用局部变量。</b></p>
<p>绝大多数语言，比如<code>C++</code>，都居于块级作用域。当在创建的变量离开其所在的块级时候，就会触发释放。而这就可以达到我们所说的自动管理对象。</p>
<blockquote>
<p>这其实就是压栈／出栈的高级语言表现。</p>
</blockquote>
<p>而在<code>C++</code>领域，有一个比较经典的利用<code>RAII</code>特性的设计就是<strong>ScopeLock</strong>。</p>
<pre><code><span class="title">template</span>&lt;<span class="keyword">class</span> <span class="type">LockType</span>&gt;
<span class="class">
<span class="keyword">class</span> <span class="type">My_scope_lock</span>
{

   public:

   <span class="type">My_scope_lock</span><span class="container">(<span class="type">LockType</span>&amp; <span class="title">_lock</span>)</span>:m_lock<span class="container">(<span class="title">_lock</span>)</span>

   {

         m_lock.occupy<span class="container">()</span>;

    }

   ~<span class="type">My_scope_lock</span><span class="container">()</span>

   {

        m_lock.relase<span class="container">()</span>;

   }

   protected:

   <span class="type">LockType</span>    m_lock;
}</span>
</code></pre><p>在这里，<b style="color:red">锁被看成是一种资源，他需要lock/unlock的配对操作，不然就会引发问题。</b></p>
<p>而上述代码，将锁保留在对象的构造函数和西沟函数中。这样，当我们在某个函数中需要操作临界区域的时候，就可以简洁明了的使用局部变量来操作锁：</p>
<pre><code><span class="keyword">void</span> Data::Update()
{
     <span class="function">My_scope_lock <span class="title">l_lock</span><span class="params">(m_mutex_lock)</span></span>;
    <span class="comment">// do some operation</span>
}
</code></pre><h3 id="基于智能指针的RAII">基于智能指针的RAII</h3><p>上文我们用锁的例子来举例说明了<code>RAII</code>的设计理念，那什么又是基于智能指针的<code>RAII</code>呢？</p>
<p>我们都知道，在编程过程中，我们必须和内存打交道，而内存分为了两种类型：栈上内存和堆上内存。栈上内存不仅和线程相关，同时空间大小也相对堆内存来说非常小。因此，当我们在处理一些大规模数据（以及对象规模不确定）的时候，比如使用几百个对象的数据等等，一般都采用堆上动态分配内存。</p>
<p>但是堆上内存，在诸多的语言中，都需要手动管理，比如<code>C++</code>。而一般处理不当，比如（new []和delete搭配），或者遗忘了释放，那么就会产生内存泄漏等严重问题。</p>
<p>为此，我们参考上节的设计，准备构建一个可以在对象的构造／析构函数中成对正确释放内存的设计思路。</p>
<p>先假设一个需要在堆上频发操作的对象<code>Data</code></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>{
    <span class="comment">// 省略</span>
}
</code></pre><p>如果直接使用，一般情况下是这样的代码:</p>
<pre><code><span class="type">Data</span> *<span class="typedef"><span class="keyword">data</span> = new <span class="type">Data</span><span class="container">()</span>;</span>
<span class="title">delete</span> <span class="typedef"><span class="keyword">data</span>;</span>
</code></pre><p>需要频繁的确认对堆内存的正确使用。现在我们给他加一个包装对象，<code>DataHandle</code></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">DataHandle</span> </span>{
    <span class="keyword">private</span>:
        Data *m_data;
}

DataHandle::DataHandle():m_data(<span class="keyword">new</span> Data())
{}

DataHandle::~DataHandle()
{
    delete m_data;
    m_data = NULL;
}
</code></pre><p>这样，我们后续每次使用，就可以简化成  </p>
<pre><code><span class="collection">{
    DataHandle handle;
}</span>
</code></pre><p>但是，别忘记了，<code>C++</code>中海油拷贝构造和重载赋值等操作，一旦我们写出如下代码，就会引发<code>double free</code>的问题。</p>
<pre><code><span class="collection">{
    DataHandle handle1<span class="list">(<span class="keyword">handle</span>)</span><span class="comment">;</span>
    handle1 = handle;
}</span>
</code></pre><p>因此，我们需要对拷贝构造函数和重载赋值进行特别处理。这里有两种处理方式：</p>
<ul>
<li>对于拷贝／赋值，每次把内部指针<code>m_data</code>也拷贝<code>new</code>一次。</li>
<li>对于<code>m_data</code>进行合理的计数记录。</li>
</ul>
<p><strong>一般情况下，我们期望<code>DataHandle</code>的行为和<code>Data</code>是一致的。</strong> 因此我们想使用第二种方式。</p>
<p>这个时候，<code>C++</code>的<code>shared_ptr</code>就派上用场了。改写下<code>DataHanle</code></p>
<pre><code><span class="keyword">class</span> DataHandle{
    <span class="keyword">public</span>:
        DataHandle();
        DataHandle(<span class="keyword">const</span> DataHandle &amp;handle);
        DataHandle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DataHanlde &amp;handle);
    <span class="keyword">private</span>:
        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; m_dataS;
}
</code></pre><p>对于重载后的拷贝／复制函数，我们只要利用智能指针自身重载过的赋值操作赋，即可解决引用计数问题。</p>
<p><strong>最后要特别注意的是，下述两种情况的代码，是完全不相同的含义。</strong></p>
<pre><code><span class="comment">// 第一种情况</span>
Data *data = <span class="keyword">new</span> Data();

<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; s1 = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>(data);

<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; s2 = s1;

<span class="comment">// 第二种情况</span>

Data *data = <span class="keyword">new</span> Data();

<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; s1 = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>(data);

<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; s2 = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>(data);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/01/26/RAII/" data-id="ck9fy2ggx002k2ni16fvuuj6d" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/01/26/RAII/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-LD-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/LD-2/" class="article-date">
  <time datetime="2019-01-26T08:51:30.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/LD-2/">LD-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="了解苹果的LD">了解苹果的LD</h2><blockquote>
<p>其实文章关于传统<code>Section Based Linker</code>那块我还没怎么读懂，有兴趣的欢迎互相探讨。</p>
</blockquote>
<p>之前研究<code>Xcode 10</code>兼容<code>libstdc++</code>的时候，稍微把玩了下苹果的<code>LD</code>，借这个机会正好通读了下苹果的<code>LD</code>设计，本文做一下总结。</p>
<h3 id="Atom_&amp;_FixUp">Atom &amp; FixUp</h3><p>苹果的<code>LD</code>，核心理念就是基于<code>Atom</code>和<code>FixUp</code>，拿着两个术语是啥意思呢？</p>
<ul>
<li><code>Atom</code>就是一块代码（函数）或者数据（全局变量）之类的，每个<code>Atom</code>都有一些属性，比如名称、作用域、内容类型、字节对齐之类的。</li>
<li><code>Fixup</code>可以理解为一个包含种类、便宜、辅助加数以及目标<code>Atom</code>的数据结构。</li>
</ul>
<p>有点抽象对吧？概要来说，苹果<code>LD</code>通过<code>Atom</code>和<code>FixUP</code>构建一张图，图中的节点都是<code>Atom</code>，连接<code>Atom</code>的则是<code>FixUP</code>。</p>
<p><strong>通过构建这样一张图，苹果就可以在链接期间进行一系列的优化，比如死代码剔除，怎么做呢？比如一段代码也会被抽象成<code>Atom</code>，如果没有<code>FixUP</code>连接的<code>Atom</code>就可以进行剔除</strong></p>
<p>举一个简单的小例子<code>main.c</code>：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>会被抽象出如下行为：</p>
<p><img src="https://opensource.apple.com/source/ld64/ld64-253.3/doc/design/hello.png" alt=""></p>
<p>单独编译这个<code>.c</code>文件生成的<code>.o</code>会包含两个<code>atom</code>，一个是<code>main</code>函数，另外一个是<code>C</code>字符串<code>&quot;hello world&quot;</code></p>
<blockquote>
<p>printf 本质上也会一个<code>atom</code>，但是在这个编译单元内他还没加入图中。</p>
</blockquote>
<p>而<code>fixup</code>也存在两个，一个是去调用不知道在哪的函数<code>printf</code>的调用<code>fixup</code>，一个是去加载字符串的<code>fixup</code>。</p>
<h3 id="链接过程">链接过程</h3><ul>
<li><p>链接过程的第一步就是要处理输入文件，构建一张初始图。</p>
<ul>
<li>如果输入文件是<code>.o</code>，那么所有的<code>atom</code>都会被加入到初始图当中。</li>
<li>如果输入文件是静态库(静态库基本上就是一组<code>.o</code>文件包含一个目录)，初始状态下这里面的<code>atom</code>都默认<b style="color:red">不会加入到里面</b>，当<code>LD</code>不断初始图中有没被决议的<code>fixup</code>，如果fixup对应的目标<code>atom</code>在这个静态库里面的话，就会把找到的<code>atom</code>的加入到图内。</li>
<li>动态库其实在链接期间不会添加任何的<code>atom</code>，同静态库一样，如果有没被决议的<code>fixup</code>对应的<code>atom</code>在动态库内找到（比如<code>tbd</code>声明的那些），就就提供一个代理，<b style="color:red">这个代理标记了这个符号来自哪个动态库</b></li>
</ul>
</li>
</ul>
<blockquote>
<p>本质上来说，链接期间动态库的作用就是参与标记一下。</p>
</blockquote>
<ul>
<li><p>考虑完符号决议，还要考虑符号合并之类的，比如根据字符串表的设计，来自不同文件的相同字符串，比如<code>&quot;haha&quot;</code>，不可能保留两份，需要合并。此外还有诸如<code>C</code>中的<code>tentative definitions</code>，<code>C++ Weak Symbol</code>等</p>
</li>
<li><p>处理<code>fixup</code>的时候，也需要分几种类型，见下图：</p>
</li>
</ul>
<p><img src="https://opensource.apple.com/source/ld64/ld64-253.3/doc/design/bindings.png" alt=""></p>
<h3 id="其他">其他</h3><p>虽然苹果的<code>LD</code>已经抽象成了<code>Atom-FixUP</code>的架构，但是它的可执行文件<code>Mach-O</code>还是传统的基于<code>section</code>的结构，这限制了<code>Atom-FixUP</code>的能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/01/26/LD-2/" data-id="ck9fy2gi0003i2ni1iun39cry" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/01/26/LD-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-shared-ptr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/shared-ptr/" class="article-date">
  <time datetime="2019-01-26T08:48:20.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/shared-ptr/">从C++ std::shared_ptr 原理来看看栈溢出的危害</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="C++_std::shared_ptr_实现原理">C++ std::shared_ptr 实现原理</h2><p>上周五排查了一个由于<code>XXX模块</code>操作疏忽导致栈越界引发的<code>我的模块</code>的智能指针Crash问题，因此稍微研究了一下，以作参考：</p>
<blockquote>
<p>shared_ptr共享被管理对象，同一时刻可以有多个shared_ptr拥有对象的所有权，当最后一个shared_ptr对象销毁时，被管理对象自动销毁</p>
</blockquote>
<h3 id="shared_ptr_实现">shared_ptr 实现</h3><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/share_ptr.png?raw=true" alt=""></p>
<p>简单来说，<code>shared_ptr</code>实现包含了两部分，</p>
<ul>
<li>一个指向堆上创建的对象的裸指针，<code>raw_ptr</code></li>
<li><strong>一个指向内部隐藏的、共享的管理对象。<code>share_count_object</code></strong></li>
</ul>
<p>第一部分没什么好说的，第二部分是需要关注的重点：</p>
<ul>
<li><code>use_count</code>，当前这个堆上对象被多少对象引用了，简单来说就是引用计数。</li>
<li><code>weak_count</code>，这个管理对象被多少个智能指针共享了，简单来说就是<code>管理对象</code>的引用计数。</li>
</ul>
<p><b style="color:red">不同指针创建的对同一个堆上对象的智能管理，并不共享管理对象，因此存在<code>double free</code>的可能性</b></p>
<p><code>_shared_ptr</code>直接包含的裸指针，即<code>raw prt</code>，是为了实现一般指针的-&gt;,*等操作，通过<code>__shared_count object</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</p>
<p>换句话说，<code>__shared_count object</code>内部的<code>use_count</code>主要用来标记<strong>被管理对象</strong>的生命周期，<code>weak_count</code>主要用来标记<strong>管理对象</strong>的生命周期。</p>
<blockquote>
<p>注意区分管理和被管理。</p>
</blockquote>
<h3 id="问题原因">问题原因</h3><p>了解了原理，可以看出<code>std::share_ptr</code>本身的<code>raw ptr</code>指向了堆上通过<code>new</code>创建的对象。但是其自身这个<code>raw ptr</code>却会如果在不当操作上，被修改，比如栈越界操作，就会被破坏，导致产生对非法对象的访问：</p>
<pre><code><span class="keyword">int</span> i = <span class="number">5</span>;
NSLog(@<span class="string">"i address is %p"</span>, &amp;i);

XXX::XX df = XXX::XX::buildDataFrame();
NSLog(@<span class="string">"sp0 address is %p"</span>, &amp;df);

<span class="keyword">int</span> a[<span class="number">1</span>] = {<span class="number">1</span>};

NSLog(@<span class="string">"k address is %p"</span>, a);

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    a[i] = i;
}

NSLog(@<span class="string">"haha"</span>);
</code></pre><p>上述这段代码就会引发问题，这里<code>XXX::XX</code>的具体内部设计使用了经典的<code>RAII</code>，下文再表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/01/26/shared-ptr/" data-id="ck9fy2gdg00092ni1ybtcry27" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/01/26/shared-ptr/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/01/Synchronized/" class="article-date">
  <time datetime="2019-01-01T15:50:00.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/01/Synchronized/">抛开性能，谈谈不该用@Synchronized的原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于<code>Objective-C</code>中的<code>@Synchronized</code>，想必从事<code>iOS</code>开发相关工作的同学都不陌生，可以说这是一种最简单的加锁的方式了。</p>
<p>网上关于锁对比的文章也不在少数，太多说集中在用法概述以及性能对比。而<code>@Synchronized</code>在不少文章中常常因其<b>性能</b>而被建议不要使用。</p>
<p>本质上来说，在客户端场景下，高密度使用锁的场景是相对较少（比如<code>IM</code>数据库除外）；同时，抛开使用场景单独通过比如<code>for</code>循环测试锁的性能，也是比较蛋疼的，不合适的用法、过大的锁范围以及竞态条件，都会导致比较条件的欠考虑性。</p>
<p><b style="color:red">因此，今天我想谈谈一个不应该使用<code>@Synchronized</code>的本质原因：它是一个和上下文强相关的锁，会导致锁失效。</b></p>
<h3 id="一个简单的事例">一个简单的事例</h3><p>考虑一个场景：</p>
<p>我们后台静默更新一下数据，一旦有了新数据，就整体替换掉现在呈现的数据，这在列表页配合远程数据的时候非常常见。</p>
<p>为了放大多线程<b>可能出错的场景</b>，我放大到<b>5000</b>个线程，构造如下代码：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *testArray;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>

- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];

    <span class="keyword">self</span><span class="variable">.testArray</span> = @[]<span class="variable">.mutableCopy</span>;

    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) {
        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
            [<span class="keyword">self</span> testThreadArray];
        });
    }
}

- (<span class="keyword">void</span>)testThreadArray
{
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.testArray</span>) {
        <span class="keyword">self</span><span class="variable">.testArray</span> = @[]<span class="variable">.mutableCopy</span>;
    }
}
</code></pre><p>可以看出，为了避免多个线程同时更新临界资源<code>testArray</code>，我们使用 <code>@synchronized (self.testArray)</code> 进行了资源保护。</p>
<blockquote>
<p>备注：为什么需要保护这里的赋值操作，可以阅读我的<a href="http://satanwoo.github.io/2016/07/10/immutable-thread/">从Immutable来谈谈对于线程安全的理解误区
</a></p>
</blockquote>
<p>看起来一切都很Ok，但是当你实际运行代码，还是会出现野指针Crash。如下图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/synchronized-1.png?raw=true" alt="屏幕快照 2018-12-27 下午2.02.28.png"></p>
<blockquote>
<p>这里用<code>@Synchronized(self)</code>是可以成功锁住的，但是这会陷入到锁的范围太大的场景中去，不再此文探讨的范围内。</p>
</blockquote>
<h3 id="Crash的根因">Crash的根因</h3><p><code>@Synchronized</code>会变成一对基于<code>try-catch</code>的<code>objc_sync_enter</code>和<code>objc_sync_exit</code>的代码，想必都不陌生了，许多网上文章都有，不再赘述，可以参考<code>clang</code>的代码：</p>
<blockquote>
<p><a href="https://clang.llvm.org/doxygen/RewriteObjC_8cpp_source.html" target="_blank" rel="external">https://clang.llvm.org/doxygen/RewriteObjC_8cpp_source.html</a></p>
</blockquote>
<pre><code><span class="comment">/// RewriteObjCSynchronizedStmt -</span>
 <span class="comment">/// This routine rewrites @synchronized(expr) stmt;</span>
 <span class="comment">/// into:</span>
 <span class="comment">/// objc_sync_enter(expr);</span>
 <span class="comment">/// @try stmt @finally { objc_sync_exit(expr); }</span>
 <span class="comment">///</span>
 Stmt *RewriteObjC::RewriteObjCSynchronizedStmt(ObjCAtSynchronizedStmt *S) {
   <span class="comment">// Get the start location and compute the semi location.</span>
   SourceLocation startLoc = S-&gt;getBeginLoc();
   <span class="keyword">const</span> <span class="keyword">char</span> *startBuf = SM-&gt;getCharacterData(startLoc);

   assert((*startBuf == <span class="string">'@'</span>) &amp;&amp; <span class="string">"bogus @synchronized location"</span>);

   std::string buf;
   buf = <span class="string">"objc_sync_enter((id)"</span>;
   <span class="keyword">const</span> <span class="keyword">char</span> *lparenBuf = startBuf;
   <span class="keyword">while</span> (*lparenBuf != <span class="string">'('</span>) lparenBuf++;
   ReplaceText(startLoc, lparenBuf-startBuf+<span class="number">1</span>, buf);
   <span class="comment">// We can't use S-&gt;getSynchExpr()-&gt;getEndLoc() to find the end location, since</span>
   <span class="comment">// the sync expression is typically a message expression that's already</span>
   <span class="comment">// been rewritten! (which implies the SourceLocation's are invalid).</span>
   SourceLocation endLoc = S-&gt;getSynchBody()-&gt;getBeginLoc();
   <span class="keyword">const</span> <span class="keyword">char</span> *endBuf = SM-&gt;getCharacterData(endLoc);
   <span class="keyword">while</span> (*endBuf != <span class="string">')'</span>) endBuf--;
   SourceLocation rparenLoc = startLoc.getLocWithOffset(endBuf-startBuf);
   buf = <span class="string">");\n"</span>;
   <span class="comment">// declare a new scope with two variables, _stack and _rethrow.</span>
   buf += <span class="string">"/* @try scope begin */ \n{ struct _objc_exception_data {\n"</span>;
   buf += <span class="string">"int buf[18/*32-bit i386*/];\n"</span>;
   buf += <span class="string">"char *pointers[4];} _stack;\n"</span>;
   buf += <span class="string">"id volatile _rethrow = 0;\n"</span>;
   buf += <span class="string">"objc_exception_try_enter(&amp;_stack);\n"</span>;
   buf += <span class="string">"if (!_setjmp(_stack.buf)) /* @try block continue */\n"</span>;
   ReplaceText(rparenLoc, <span class="number">1</span>, buf);
   startLoc = S-&gt;getSynchBody()-&gt;getEndLoc();
   startBuf = SM-&gt;getCharacterData(startLoc);

   assert((*startBuf == <span class="string">'}'</span>) &amp;&amp; <span class="string">"bogus @synchronized block"</span>);
   SourceLocation lastCurlyLoc = startLoc;
   buf = <span class="string">"}\nelse {\n"</span>;
   buf += <span class="string">"  _rethrow = objc_exception_extract(&amp;_stack);\n"</span>;
   buf += <span class="string">"}\n"</span>;
   buf += <span class="string">"{ /* implicit finally clause */\n"</span>;
   buf += <span class="string">"  if (!_rethrow) objc_exception_try_exit(&amp;_stack);\n"</span>;

   std::string syncBuf;
   syncBuf += <span class="string">" objc_sync_exit("</span>;

   Expr *syncExpr = S-&gt;getSynchExpr();
   CastKind CK = syncExpr-&gt;getType()-&gt;isObjCObjectPointerType()
                   ? CK_BitCast :
                 syncExpr-&gt;getType()-&gt;isBlockPointerType()
                   ? CK_BlockPointerToObjCPointerCast
                   : CK_CPointerToObjCPointerCast;
   syncExpr = NoTypeInfoCStyleCastExpr(Context, Context-&gt;getObjCIdType(),
                                       CK, syncExpr);
   std::string syncExprBufS;
   llvm::raw_string_ostream syncExprBuf(syncExprBufS);
   assert(syncExpr != nullptr &amp;&amp; <span class="string">"Expected non-null Expr"</span>);
   syncExpr-&gt;printPretty(syncExprBuf, nullptr, PrintingPolicy(LangOpts));
   syncBuf += syncExprBuf.<span class="keyword">str</span>();
   syncBuf += <span class="string">");"</span>;

   buf += syncBuf;
   buf += <span class="string">"\n  if (_rethrow) objc_exception_throw(_rethrow);\n"</span>;
   buf += <span class="string">"}\n"</span>;
   buf += <span class="string">"}"</span>;

   ReplaceText(lastCurlyLoc, <span class="number">1</span>, buf);

   <span class="keyword">bool</span> hasReturns = <span class="keyword">false</span>;
   HasReturnStmts(S-&gt;getSynchBody(), hasReturns);
   <span class="keyword">if</span> (hasReturns)
     RewriteSyncReturnStmts(S-&gt;getSynchBody(), syncBuf);

   <span class="keyword">return</span> nullptr;
 }
</code></pre><blockquote>
<p>卧槽，原来<code>clang</code>的rewrite部分也写的这么挫逼啊。</p>
</blockquote>
<p>我们就从<code>objc_sync_enter</code>来继续挖掘：</p>
<pre><code><span class="title">if</span> (obj) {
    <span class="type">SyncData</span>* <span class="typedef"><span class="keyword">data</span> = id2data<span class="container">(<span class="title">obj</span>, <span class="type">ACQUIRE</span>)</span>;</span>
    assert(<span class="typedef"><span class="keyword">data</span>);</span>
    <span class="typedef"><span class="keyword">data</span>-&gt;mutex.lock<span class="container">()</span>;</span>
}
</code></pre><p>关键其实就是在于从<code>obj</code>转换到<code>SyncData</code>，然后通过<code>SyncData</code>中的<code>mutex</code>来进行临界区的锁。</p>
<p>有两个部分需要分析一下，首先<code>SyncData</code>结构体定义如下：</p>
<pre><code><span class="function"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>{
    <span class="keyword">struct</span> SyncData* nextData;
    DisguisedPtr&lt;objc_object&gt; object;
    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span>
    <span class="keyword">recursive_mutex_t</span> mutex;
} SyncData;
</code></pre><ul>
<li><code>mutex</code>，一把递归锁，这也是为什么我们可以在<code>@Synchronized</code>里面嵌套<code>@Synchronized</code>的原因。</li>
<li><code>DisguisedPtr</code>，还记得我们以前<b>写安全气垫的时候给一些释放的内存地址填充<code>0x55</code>用于拦截<code>use after free</code>的场景</b>？这里<code>DisguisedPtr</code>其实就是对裸对象指针<code>objc_object</code>的一层包装改写。</li>
</ul>
<p>继续回到<code>id2data</code>函数往下研究，可以发现一段比较有意思的函数：</p>
<pre><code><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;
</code></pre><p>我们具体就关注<code>[]</code>对应的操作即可：</p>
<pre><code><span class="keyword">class</span> StripedMap {
<span class="preprocessor">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span>
    <span class="keyword">enum</span> { StripeCount = <span class="number">8</span> };
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="keyword">enum</span> { StripeCount = <span class="number">64</span> };
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">struct</span> PaddedT {
        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;
    };

    PaddedT <span class="built_in">array</span>[StripeCount];

    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>{
        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);
        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;
    }

 <span class="keyword">public</span>:
    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) { 
        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; 
    }
    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> { 
        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; 
    }
</code></pre><p>抽丝剥茧，这里其实就是一个简单的<code>Hash</code>算法，然后将传入的对象地址，通过<code>indexForPointer</code>映射到不同的<code>SyncList</code>上。而<code>SyncList</code>是一个维护<code>SyncData</code>的链表，每个<code>SyncList</code>都单独维护操作自己的<code>lock</code>。</p>
<blockquote>
<p><code>indexForPointer</code>公式：<code>((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount</code>，其中<code>StripeCount</code>是个数。</p>
</blockquote>
<p>这样做的好处就是创建了一个所谓的散列锁，可以有效的降低不同的对象操作指尖的相互影响性。当然，从本质上看，<code>iOS</code>上就<b style="color:red">8个散列锁，这也是影响大规模使用@Synchronized会影响性能的原因之一。</b></p>
<p>接着往下走，我们直接<b>关注没有命中<code>Thread Local Storage</code>的场景</b>。</p>
<pre><code><span class="comment">#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span>
spinlock_t *lockp = &amp;<span class="type">LOCK_FOR_OBJ</span>(<span class="keyword">object</span>);

// 通过对对象地址hash，算法对应<span class="type">SyncList</span>的锁

lockp-&gt;lock();

{
    <span class="type">SyncData</span>* p;
    <span class="type">SyncData</span>* firstUnused = <span class="type">NULL</span>;
    <span class="keyword">for</span> (p = *listp; p != <span class="type">NULL</span>; p = p-&gt;nextData) {
        <span class="keyword">if</span> ( p-&gt;<span class="keyword">object</span> == <span class="keyword">object</span> ) {
            <span class="literal">result</span> = p;
            // atomic because may collide <span class="keyword">with</span> concurrent <span class="type">RELEASE</span>
            <span class="type">OSAtomicIncrement32Barrier</span>(&amp;<span class="literal">result</span>-&gt;threadCount);
            goto done;
        }
        <span class="keyword">if</span> ( (firstUnused == <span class="type">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )
            firstUnused = p;
    }

    // no <span class="type">SyncData</span> currently associated <span class="keyword">with</span> <span class="keyword">object</span>
    <span class="keyword">if</span> ( (why == <span class="type">RELEASE</span>) || (why == <span class="type">CHECK</span>) )
        goto done;

    // an unused one was found, use it
    // 关注点<span class="number">1</span> ！！！！！！！！！！！！
    <span class="keyword">if</span> ( firstUnused != <span class="type">NULL</span> ) {
        <span class="literal">result</span> = firstUnused;
        <span class="literal">result</span>-&gt;<span class="keyword">object</span> = (objc_object *)<span class="keyword">object</span>;
        <span class="literal">result</span>-&gt;threadCount = <span class="number">1</span>;
        goto done;
    }
}

// <span class="type">Allocate</span> a new <span class="type">SyncData</span> <span class="keyword">and</span> add to list.
// <span class="type">XXX</span> allocating memory <span class="keyword">with</span> a global lock held <span class="keyword">is</span> bad practice,
// might be worth releasing the lock, allocating, <span class="keyword">and</span> searching again.
// <span class="type">But</span> since we never free these guys we won't be stuck <span class="keyword">in</span> allocation very often.

// 关注点<span class="number">2</span> ！！！！！！！！！！！！
posix_memalign((<span class="type">void</span> **)&amp;<span class="literal">result</span>, alignof(<span class="type">SyncData</span>), sizeof(<span class="type">SyncData</span>));
<span class="literal">result</span>-&gt;<span class="keyword">object</span> = (objc_object *)<span class="keyword">object</span>;
<span class="literal">result</span>-&gt;threadCount = <span class="number">1</span>;
new (&amp;<span class="literal">result</span>-&gt;mutex) recursive_mutex_t(fork_unsafe_lock);
<span class="literal">result</span>-&gt;nextData = *listp;
*listp = <span class="literal">result</span>;

 done:
lockp-&gt;unlock();
<span class="keyword">if</span> (<span class="literal">result</span>) {
    // <span class="type">Only</span> new <span class="type">ACQUIRE</span> should get here.
    // <span class="type">All</span> <span class="type">RELEASE</span> <span class="keyword">and</span> <span class="type">CHECK</span> <span class="keyword">and</span> recursive <span class="type">ACQUIRE</span> are 
    // handled by the per-thread caches above.
    <span class="keyword">if</span> (why == <span class="type">RELEASE</span>) {
        // <span class="type">Probably</span> some thread <span class="keyword">is</span> incorrectly exiting 
        // <span class="keyword">while</span> the <span class="keyword">object</span> <span class="keyword">is</span> held by another thread.
        <span class="keyword">return</span> <span class="keyword">nil</span>;
    }
    <span class="keyword">if</span> (why != <span class="type">ACQUIRE</span>) _objc_fatal(<span class="string">"id2data is buggy"</span>);
    <span class="keyword">if</span> (<span class="literal">result</span>-&gt;<span class="keyword">object</span> != <span class="keyword">object</span>) _objc_fatal(<span class="string">"id2data is buggy"</span>);

      // 关注点<span class="number">3</span>
<span class="comment">#if SUPPORT_DIRECT_THREAD_KEYS</span>
    <span class="keyword">if</span> (!fastCacheOccupied) {
        // <span class="type">Save</span> <span class="keyword">in</span> fast thread cache
        tls_set_direct(<span class="type">SYNC_DATA_DIRECT_KEY</span>, <span class="literal">result</span>);
        tls_set_direct(<span class="type">SYNC_COUNT_DIRECT_KEY</span>, (<span class="type">void</span>*)<span class="number">1</span>);
    } <span class="keyword">else</span> 
<span class="comment">#endif</span>
    {
        // <span class="type">Save</span> <span class="keyword">in</span> thread cache
        <span class="keyword">if</span> (!cache) cache = fetch_cache(<span class="type">YES</span>);
        cache-&gt;list[cache-&gt;used].data = <span class="literal">result</span>;
        cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;
        cache-&gt;used++;
    }
}

<span class="keyword">return</span> <span class="literal">result</span>;
</code></pre><ul>
<li><ol>
<li>通过散列，计算这个对象应该落入的<code>SyncList</code>，由于需要操作<code>SyncList</code>，用其对应的锁进行加锁。</li>
</ol>
</li>
<li><ol>
<li>关注点1和2，其实本质干的是一件事，就是找出一个可以被使用的<code>SyncData</code>，如果没有就创建一个，设定好对应的成员变量，然后返回。</li>
</ol>
</li>
<li><ol>
<li>关注点3，就是做完了以后，利用一下<code>Thread Local Storage</code>，存一下，这块不关注无伤大雅。</li>
</ol>
</li>
</ul>
<p>Ok，到现在我们分析完成<code>@Synchronized</code>的实现原理后，我们可以回过头再来看看为什么对象被更改后会产生Crash了。</p>
<p><b style="color:red">其实一言以蔽之，就是<code>@Synchronized</code>锁不住对象赋值变化的场景。</b></p>
<p>回到我们上一小节<code>Crash</code>的问题：</p>
<p>考虑三个线程的场景，分别定义为线程A，线程B，线程C，初始的时候在线程A，<code>self.testArray</code>的初始值为<code>arr0</code>（实质上操作的是<code>arr0</code>地址，下文简述为<code>arr0</code>），我们来理下时间线：</p>
<ul>
<li>线程A获取<code>self.testArray</code>的值，为<code>arr0</code>。</li>
<li>线程B获取<code>self.testArray</code>的值，也为<code>arr0</code>。</li>
<li>线程A，B由于对象地址一致，产生竞争，A获取到了对应的锁，我们称之为<code>lock0</code>。</li>
<li>线程A在锁的保护下，执行<code>self.testArray = @[].mutableCopy</code>。<code>self.testArray</code>指向了<code>arr1</code>。</li>
<li>线程A<b>unlock</b>。</li>
<li>此时线程C开始尝试获取<code>self.testArray</code>，获取到了<code>arr1</code>。</li>
<li>这个时候线程B由于线程A释放锁了，线程B继续，线程B使用之前获取的<code>arr0</code>进行获取锁的操作。</li>
<li>这个时候线程C也尝试进行锁操作，由于线程C是<code>arr1</code>，所以使用的是<code>arr1</code>对应的锁操作。</li>
<li><b style="color:red">由于<code>arr0</code>和<code>arr1</code>对应的锁不是一个（当然理论上可能散列计算为同一个），所以这两个线程都进入了临界区</b></li>
<li>线程B和线程C都执行<code>self.testArray = @[].mutableCopy</code>。</li>
<li><p><code>Setter</code>的赋值并不是<code>atomic</code>的，实质上会转换成如下这样的代码：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, 
  ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) 
{
    <span class="keyword">id</span> oldValue;
    <span class="comment">// 计算结构体中的偏移量</span>
    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);

    <span class="keyword">if</span> (<span class="keyword">copy</span>) {
        newValue = [newValue copyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> {
        <span class="comment">// 某些程度的优化</span>
        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;
        newValue = objc_retain(newValue);
    }

    <span class="comment">// 危险区</span>
    <span class="keyword">if</span> (!atomic) {
         <span class="comment">// 第一步</span>
        oldValue = *slot;

        <span class="comment">// 第二步</span>
        *slot = newValue;
    } <span class="keyword">else</span> {
        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
        _spin_lock(slotlock);
        oldValue = *slot;
        *slot = newValue;        
        _spin_unlock(slotlock);
    }

    objc_release(oldValue);
}
</code></pre></li>
<li><p>在<b style="color:red">上述危险区的第二步，<code>_testArray</code>在线程B和线程C分别指向了新地址<code>addr2</code>和<code>addr3</code></b>，<b>但是获取到的<code>oldValue</code>可能都是<code>arr1</code></b></p>
</li>
<li>通过<code>objc_release</code>对<code>oldValue</code>，也就是<code>arr1</code>进行了两次释放，妥妥的<code>double free</code>过度释放场景，导致崩溃。</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/synchronized-2.png?raw=true" alt="屏幕快照 2018-12-28 上午11.05.22.png"></p>
<blockquote>
<p>备注：多线程的场景在于不确定性，可能在其中任何一个指令处挂掉。</p>
</blockquote>
<h3 id="结语">结语</h3><p>所以，从本质上来说，<code>@Synchronized</code>的确是最不应该推荐给用户使用的一种锁机制，但是其根本原因并<b style="color:red">不一定是</b>性能差距，<code>Hash</code>离散设计的优雅的话，一样能保证性能。但是其内在<b style="color:red">锁和对象上下文相关的联系会导致锁失效的场景</b>，一旦有对象发生变化（被赋值），导致潜在的锁不住多线程的场景，我们也应该去了解学习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2019/01/01/Synchronized/" data-id="ck9fy2gfk001p2ni1hd8qewao" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2019/01/01/Synchronized/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-LD-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/22/LD-1/" class="article-date">
  <time datetime="2018-12-22T15:20:59.000Z" itemprop="datePublished">2018-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/22/LD-1/">通过Xcode 10链接libstdc++来深入分析tbd文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相信玩<code>iOS</code>开发的同学对<code>tbd</code>这个格式的文件已经不再陌生了。最近<code>Xcode 10</code>升级的时候，你会发现很多原先用<code>libstdc++</code>的库在新的<code>Xcode</code>已经没有链接通过。而临时的解决方案也比较简单，网上也很多这样的文章，简而言之就是从<code>Xcode 9</code>中拷贝对应的<code>libstdc++.tbd</code>文件给新的<code>Xcode 10</code>来使用。</p>
<p>Ok，解决方案是有了，我们需要更深入的理解下：为什么<strong>拷贝tbd文件，就能够成功解决链接问题?</strong></p>
<h3 id="tbd格式解析">tbd格式解析</h3><p><code>tbd</code>全称是<code>text-based stub libraries</code>，本质上就是一个<strong>YAML</strong>描述的文本文件。</p>
<p>他的作用是用于记录<b style="color:red">动态库的一些信息</b>，包括导出的符号、动态库的架构信息、动态库的依赖信息。</p>
<p>为什么需要包含这些信息呢？</p>
<ul>
<li>动态库的架构信息是了确保运行的程序在运行的平台加载正确的库。比如你不能在运行<code>ARM</code>指令集的<code>iOS</code>设备上加载<code>x86</code>格式的库。</li>
</ul>
<blockquote>
<p>后续我们会举一个手动修改<code>tbd</code>中<code>install-name</code>字段的小例子来让运行在模拟器的时候加载<code>ARM64</code>架构的动态库</p>
</blockquote>
<ul>
<li>导出的符号。写过程序的人都知道，我们肯定会依赖别人提供的一些函数方法。一般业界都会把这些函数或者方法封装成库的形势。</li>
</ul>
<p>那库就分为静态库和动态库两种。相信网上关于这两者的讨论和阐述已经很多了，再次不再赘述。唯一需要提及的一点是，动态库是在程序运行（启动依赖或者按需加载）时候加载进程序的地址空间的，那么我们在静态期的时候，是如何得知动态库提供了哪些能力呢？<b style="color:red">而这就是<code>tbd</code>格式提供的导出符号表的加载，它会指导链接器在链接过程中，将需要决议的符号先做个标记，标记是来自哪个动态库。</b></p>
<p>这里举个小例子吧。<br>在程序构建的过程中，比如我们开发一个iOS应用，毋庸置疑的会用到<code>UIKit</code>这个动态库。而为了使我们的程序能够构建成功，这里分为了两个步骤：</p>
<ul>
<li><p>通过引入头文件，<code>import &lt;UIKit/UIKit.h&gt;</code>，我们知道了<code>UIKit</code>里面的函数、变量声明。有声明，就能通过编译器的检查。</p>
</li>
<li><p>我们在代码里面使用了<code>UIKit</code>的函数，其本质是一种符号，因此需要链接器来决议这个符号来自哪？要是所有地方都找到，就会报类似<code>undefined symbol</code>之类的错误（想必大家已经很熟悉了）。</p>
</li>
</ul>
<h4 id="为什么要改造成tbd格式">为什么要改造成tbd格式</h4><p><code>tbd</code>格式实际上是从<code>Xcode 7</code>时代引入的。</p>
<p><b style="color:red">用于取代在真机开发过程中直接使用传统的<code>dylib</code></b></p>
<p><b style="color:red">用于取代在真机开发过程中直接使用传统的<code>dylib</code></b></p>
<p><b style="color:red">用于取代在真机开发过程中直接使用传统的<code>dylib</code></b></p>
<p>我们都知道一个库在没有<code>strip</code>诸如调试信息、非导出符号的情况下是非常大的。但是由于在开发过程中，调试等过程是必不可少的，我们来对比下传统直接包含<code>dylib</code>的时候大小，我们以<code>CoreImage.framework</code>来举例：</p>
<ul>
<li>首先看下模拟器上的传统架构大小：</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/ld-1-dylib.png?raw=true" alt=""></p>
<ul>
<li>再看下对应的真机上的伪<code>framework</code>(包含<code>tbd</code>)的大小</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/ld-1-tbd.png?raw=true" alt=""></p>
<p>差距很明显了吧，对于真机来说，由于动态库都是在设备上，在<code>Xcode</code>上使用基于<code>tbd</code>格式的伪<code>framework</code>可以大大减少<code>Xcode</code>的大小。</p>
<blockquote>
<p>题外话：网上有人说模拟器上还是使用<code>dylib</code>，的确没错。但是模拟器现在也桥了一层<code>tbd</code>格式，真正的<code>dylib</code>是在这个路径下：<code>iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents</code></p>
</blockquote>
<p>此外，虽然从<code>Xcode 7</code>时代到现在，一直都是<code>tbd</code>的说法，但是它也是经历了一些演变了，目前已经发展了<code>v3</code>格式的版本。</p>
<h3 id="为什么拷贝tbd文件能解决Xcode_10上的问题">为什么拷贝tbd文件能解决Xcode 10上的问题</h3><p>网上很多人都研究过<code>dyld</code>的代码，与之对应还有一种<code>ld</code>，就是平时我们在构建程序过程中，链接过程中出错的根因：</p>
<p><img src="https://img-blog.csdn.net/20180918212007937?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NjgzOTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>既然我们通过拷贝<code>tbd</code>的方式能解决链接不过的问题，那我们就要知道<code>ld</code>是如何运用<code>tbd</code>文件的。</p>
<p>既然报错事<code>library not found</code>，我们扒一下<code>linker</code>的源码即可：</p>
<pre><code><span class="type">Options</span>::<span class="type">FileInfo</span> <span class="type">Options</span>::findLibrary(<span class="keyword">const</span> <span class="type">char</span>* rootName, <span class="type">bool</span> dylibsOnly) <span class="keyword">const</span>
{
    <span class="type">FileInfo</span> <span class="literal">result</span>;
    <span class="keyword">const</span> <span class="type">int</span> rootNameLen = strlen(rootName);
    // <span class="keyword">if</span> rootName ends <span class="keyword">in</span> .o there <span class="keyword">is</span> no .a vs .dylib choice
    <span class="keyword">if</span> ( (rootNameLen &gt; <span class="number">3</span>) &amp;&amp; (strcmp(&amp;rootName[rootNameLen-<span class="number">2</span>], <span class="string">".o"</span>) == <span class="number">0</span>) ) {
        <span class="keyword">for</span> (std::vector&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::const_iterator it = fLibrarySearchPaths.begin();
             it != fLibrarySearchPaths.<span class="keyword">end</span>();
             it++) {
            <span class="keyword">const</span> <span class="type">char</span>* dir = *it;
            <span class="keyword">if</span> ( checkForFile(<span class="string">"%s/%s"</span>, dir, rootName, <span class="literal">result</span>) )
                <span class="keyword">return</span> <span class="literal">result</span>;
        }
    }
    <span class="keyword">else</span> {
        <span class="type">bool</span> lookForDylibs = <span class="literal">false</span>;
        switch ( fOutputKind ) {
            <span class="keyword">case</span> <span class="type">Options</span>::kDynamicExecutable:
            <span class="keyword">case</span> <span class="type">Options</span>::kDynamicLibrary:
            <span class="keyword">case</span> <span class="type">Options</span>::kDynamicBundle:
            <span class="keyword">case</span> <span class="type">Options</span>::kObjectFile:  // &lt;rdar://problem/<span class="number">15914513</span>&gt; 
                lookForDylibs = <span class="literal">true</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="type">Options</span>::kStaticExecutable:
            <span class="keyword">case</span> <span class="type">Options</span>::kDyld:
            <span class="keyword">case</span> <span class="type">Options</span>::kPreload:
            <span class="keyword">case</span> <span class="type">Options</span>::kKextBundle:
                lookForDylibs = <span class="literal">false</span>;
                <span class="keyword">break</span>;
        }
        switch ( fLibrarySearchMode ) {
        <span class="keyword">case</span> kSearchAllDirsForDylibsThenAllDirsForArchives:
                // first look <span class="keyword">in</span> all directories <span class="keyword">for</span> just <span class="keyword">for</span> dylibs
                <span class="keyword">if</span> ( lookForDylibs ) {
                    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::const_iterator it = fLibrarySearchPaths.begin();
                         it != fLibrarySearchPaths.<span class="keyword">end</span>();
                         it++) {
                        <span class="keyword">const</span> <span class="type">char</span>* dir = *it;
                        <span class="type">auto</span> path = std::<span class="type">string</span>(dir) + <span class="string">"/lib"</span> + rootName + <span class="string">".dylib"</span>;
                        <span class="keyword">if</span> ( findFile(path, {<span class="string">".tbd"</span>}, <span class="literal">result</span>) )
                            <span class="keyword">return</span> <span class="literal">result</span>;
                    }
                    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::const_iterator it = fLibrarySearchPaths.begin();
                         it != fLibrarySearchPaths.<span class="keyword">end</span>();
                         it++) {
                        <span class="keyword">const</span> <span class="type">char</span>* dir = *it;
                        <span class="keyword">if</span> ( checkForFile(<span class="string">"%s/lib%s.so"</span>, dir, rootName, <span class="literal">result</span>) )
                            <span class="keyword">return</span> <span class="literal">result</span>;
                    }
                }
                // next look <span class="keyword">in</span> all directories <span class="keyword">for</span> just <span class="keyword">for</span> archives
                <span class="keyword">if</span> ( !dylibsOnly ) {
                    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::const_iterator it = fLibrarySearchPaths.begin();
                         it != fLibrarySearchPaths.<span class="keyword">end</span>();
                         it++) {
                        <span class="keyword">const</span> <span class="type">char</span>* dir = *it;
                        <span class="keyword">if</span> ( checkForFile(<span class="string">"%s/lib%s.a"</span>, dir, rootName, <span class="literal">result</span>) )
                            <span class="keyword">return</span> <span class="literal">result</span>;
                    }
                }
                <span class="keyword">break</span>;

            <span class="keyword">case</span> kSearchDylibAndArchiveInEachDir:
                // look <span class="keyword">in</span> each directory <span class="keyword">for</span> just <span class="keyword">for</span> a dylib then <span class="keyword">for</span> an archive
                <span class="keyword">for</span> (std::vector&lt;<span class="keyword">const</span> <span class="type">char</span>*&gt;::const_iterator it = fLibrarySearchPaths.begin();
                     it != fLibrarySearchPaths.<span class="keyword">end</span>();
                     it++) {
                    <span class="keyword">const</span> <span class="type">char</span>* dir = *it;
                    <span class="type">auto</span> path = std::<span class="type">string</span>(dir) + <span class="string">"/lib"</span> + rootName + <span class="string">".dylib"</span>;
                    <span class="keyword">if</span> ( lookForDylibs &amp;&amp; findFile(path, {<span class="string">".tbd"</span>}, <span class="literal">result</span>) )
                        <span class="keyword">return</span> <span class="literal">result</span>;
                    <span class="keyword">if</span> ( lookForDylibs &amp;&amp; checkForFile(<span class="string">"%s/lib%s.so"</span>, dir, rootName, <span class="literal">result</span>) )
                        <span class="keyword">return</span> <span class="literal">result</span>;
                    <span class="keyword">if</span> ( !dylibsOnly &amp;&amp; checkForFile(<span class="string">"%s/lib%s.a"</span>, dir, rootName, <span class="literal">result</span>) )
                        <span class="keyword">return</span> <span class="literal">result</span>;
                }
                <span class="keyword">break</span>;
        }
    }
    throwf(<span class="string">"library not found for -l%s"</span>, rootName);
}
</code></pre><ul>
<li><p><code>throwf(&quot;library not found for -l%s&quot;, rootName);</code> 这里我们就找到了错误发生的原因，我们再往上溯源，找到<code>linker</code>处理编译单元的入口：</p>
</li>
<li><p><code>InputFiles::addOtherLinkerOptions</code>里面存在如下代码：</p>
<pre><code>CStringSet newLibraries = <span class="built_in">std</span>::move(state.unprocessedLinkerOptionLibraries);
    state.unprocessedLinkerOptionLibraries.clear();
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* libName : newLibraries) {
        <span class="keyword">if</span> ( state.linkerOptionLibraries.count(libName) )
            <span class="keyword">continue</span>;
        <span class="keyword">try</span> {
            Options::FileInfo info = _options.findLibrary(libName);
            <span class="keyword">if</span> ( ! <span class="keyword">this</span>-&gt;libraryAlreadyLoaded(info.path) ) {
                _linkerOptionOrdinal = _linkerOptionOrdinal.nextLinkerOptionOrdinal();
                info.ordinal = _linkerOptionOrdinal;
                 <span class="comment">//&lt;rdar://problem/17787306&gt; -force_load_swift_libs</span>
                info.options.fForceLoad = _options.forceLoadSwiftLibs() &amp;&amp; (<span class="built_in">strncmp</span>(libName, <span class="string">"swift"</span>, <span class="number">5</span>) == <span class="number">0</span>);
                ld::File* reader = <span class="keyword">this</span>-&gt;makeFile(info, <span class="literal">true</span>);
                ld::dylib::File* dylibReader = <span class="keyword">dynamic_cast</span>&lt;ld::dylib::File*&gt;(reader);
                ld::archive::File* archiveReader = <span class="keyword">dynamic_cast</span>&lt;ld::archive::File*&gt;(reader);
                <span class="keyword">if</span> ( dylibReader != <span class="literal">NULL</span> ) {
                    dylibReader-&gt;forEachAtom(handler);
                    dylibReader-&gt;setImplicitlyLinked();
                    dylibReader-&gt;setSpeculativelyLoaded();
                    <span class="keyword">this</span>-&gt;addDylib(dylibReader, info);
                }
                <span class="keyword">else</span> <span class="keyword">if</span> ( archiveReader != <span class="literal">NULL</span> ) {
                    _searchLibraries.push_back(LibraryInfo(archiveReader));
                    _options.addDependency(Options::depArchive, archiveReader-&gt;path());
                    <span class="comment">//&lt;rdar://problem/17787306&gt; -force_load_swift_libs</span>
                    <span class="keyword">if</span> (info.options.fForceLoad) {
                        archiveReader-&gt;forEachAtom(handler);
                    }
                }
                <span class="keyword">else</span> {
                    throwf(<span class="string">"linker option dylib at %s is not a dylib"</span>, info.path);
                 }
             }
         }
        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) {
            <span class="comment">// &lt;rdar://problem/40829444&gt; only warn about missing auto-linked library if some missing symbol error happens later</span>
            state.missingLinkerOptionLibraries.insert(libName);
        }
        state.linkerOptionLibraries.insert(libName);
    }
</code></pre></li>
</ul>
<p><strong>而上述这些需要查询的<code>library</code>是从哪里来的呢？</strong> </p>
<ul>
<li><p>我们以<code>xcconfig</code>举例来看：</p>
<pre><code>OTHER_LDFLAGS = $(inherited) -ObjC <span class="operator">-l</span><span class="string">"stdc++"</span>
</code></pre></li>
</ul>
<p>在链接过程中就需要处理这样的<code>stdc++</code> <strong>Library</strong>，而查询的方式就是在特定目录结构中搜索是否有对应的库文件或者<code>tbd</code>文件。</p>
<h3 id="后记">后记</h3><p>使用<code>tbd</code>当然不止减少<code>Xcode</code>体积大小这一个好处，嘿嘿，你们自己摸索下吧～</p>
<p>而且，基于这种思路，能玩出许多类似文体两开花，中美合拍美猴王的玩法，加油吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/12/22/LD-1/" data-id="ck9fy2gi2003k2ni1vdp0gc17" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/12/22/LD-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-JSDebugger-INTRO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/06/JSDebugger-INTRO/" class="article-date">
  <time datetime="2018-10-05T17:32:55.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/06/JSDebugger-INTRO/">谈谈JSDebugger</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="务虚乱弹">务虚乱弹</h3><blockquote>
<p>JSDebugger开源地址：<a href="https://github.com/SatanWoo/JSDebugger" target="_blank" rel="external">https://github.com/SatanWoo/JSDebugger</a>  </p>
</blockquote>
<p>这是一篇谈谈设计<code>JSDebugger</code>的总体设想，不会过于深究具体实现细节，后续会单独探讨一些涉及实现方面的过程。</p>
<p>读过我之前博客的朋友可能会记得我3-4月份的时候写过一篇<a href="http://satanwoo.github.io/2018/04/01/jsengine/">动手制作一个简易的iOS动态执行器</a>，效果如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/jstester.gif?raw=true" alt=""></p>
<p>虽然这个效果还起来还不错（有许多人问这个东西咋实现的，挺炫酷的），但是其实只是个原型而已，从设想构思到编码实现没有超过一天的时间。当时在博文里面承诺发代码，想想实现的完善度还不够，就准备完善后再继续搞搞。不过后来由于我转到其他组不继续钻研<code>iOS</code>，这事也就不了了之。</p>
<p><strong><span style="color:red">那为什么现在又重新开搞呢？</span></strong>，三点原因吧：</p>
<ol>
<li>有朋友在群里问我之前提过的<code>Mach-o</code>包瘦身方案怎么也没发文章？</li>
<li>看到同事查非Crash产生的Bug的过程还是比较累。</li>
</ol>
<p>好，来说说前两个原因：</p>
<ul>
<li>第一点，有些文章为什么后续不发，主要原因还是很多产出和收获都是工作中和同事一起探讨研究出来的，发出来一是泄漏了公司的数据（职业操守还是很重要的），二是相当于霸占了一些别人的工作成果。比如说我之前写的内存等等，对外发的一般都是只和开源代码相关的同时删减了大部分略微关键的部分，所以导致有些读者读起来断断续续云里雾里。</li>
</ul>
<blockquote>
<p>完整版的很多文章或者一些没对外的技术研究，我都发在了公司的内网里，欢迎加入阿里巴巴。</p>
</blockquote>
<ul>
<li>第二点，我之前有段时间负责手淘的稳定性，除了有堆栈的Crash问题外，更多是用户反馈的使用异常以及毫无头绪的奇怪现象。针对这种问题，我相信各家(甚至开源方案)一般都有自己的监控体系，比如日志啊、埋点等等。但是怎么说呢，从我的感受来看，都是使用起来偏繁琐，而且<strong><span style="color:blue">还依赖对应的开发把错误信息等现场保留写入到日志内。</span></strong>我想要的就是一个能像我在自己手机上调试应用一样调试用户手机的能力（前提是用户授权同意），因此我就想做了一个这样的工具。结合自己以前玩逆向的些许经历，<code>Cycript</code>就提供了类似的能力，因此就利用业余时间做了一个<strong>JSDebugger</strong>。</li>
</ul>
<p><strong><span style="color:red">说了这么多原因，其实还是我太懒了。</span></strong></p>
<h3 id="JSDebugger">JSDebugger</h3><p>言归正传，回到<strong>JSDebugger</strong>本身，基于之前的代码，这次主要做了完整性的代码重构重写以及功能完善上。</p>
<ul>
<li>类方法调用</li>
<li>实例方法调用</li>
<li>Setter &amp; Getter的调用</li>
<li>可变参数的函数调用</li>
<li>C Pointer的使用</li>
<li>基础类型的使用</li>
<li>对象和类的使用</li>
<li>结构体的使用（目前支持<code>CGSize</code>, <code>CGRect</code>, <code>CGPoint</code>，正在开发自定义注册接口）</li>
<li>插件化的扩展功能。</li>
</ul>
<p>同时，为了更好的测试所写的<code>JavaScript</code>代码，开发了玩具级别的<code>Playground</code>功能，每次实时修改文件后保存即可自动触发<code>Reload</code>。</p>
<p>很多细节此文不表，但是有些功能上的实现还是比较用心的，比如支持了各种类型、个数的可变参数的函数调用，比如目前支持了<code>choose</code>和<code>introspect</code>的能力，二者配合可以对任意对象实时查询其当前所有的属性值。</p>
<p>而且，我对<code>JavaScriptCore</code>的使用可能和常规大家所属性的<code>iOS JavaScriptCore</code>有所区别，利用更低层的设计思路，经过我实测：</p>
<p>更低层的设计桥接思路在<code>iOS</code>上同比基于<code>Objective-C</code>的使用方式可以节省<strong>50%</strong>的时间；同比在<code>Android</code>上使用开源的<code>JavaScriptCore</code>是<strong>50分之一左右</strong>的时间。</p>
<blockquote>
<p>当然Android上比较主流的JS引擎室v8咯</p>
</blockquote>
<p>具体快原因可以阅读<a href="http://satanwoo.github.io/2018/04/01/jsengine/">动手制作一个简易的iOS动态执行器</a>中涉及的<code>JavaScriptCore</code>上层源码分析以及阅读我的<strong>JSDebugger</strong>源码。</p>
<p>目前<strong>JSDebugger</strong>还在不断完善中，后续会把我更多的想法移植到里面，总体规划有几个关键点：</p>
<ul>
<li><p>实现一个交互式的编辑器（或者命令行），能够让大家写<code>Objective-C</code>的代码自动转换成<strong>JSDebugger</strong>的JS语法。以我目前的技术水准，还做不到<code>Cycript</code>那种牛逼的<code>Objective-C</code>和<code>JavaScript</code>的混合语法模式。</p>
</li>
<li><p>实现远程图形化<code>Debug</code>能力。目前<strong>JSDebugger</strong>可以调试数据，但是如果能像<code>Reveal</code>一样把操作界面和数据结合起来就会更有效的定位问题。</p>
</li>
</ul>
<p>欢迎有想法的朋友一起来参与完善这个项目，开源地址如下：</p>
<p><strong><a href="https://github.com/SatanWoo/JSDebugger" target="_blank" rel="external">https://github.com/SatanWoo/JSDebugger</a></strong></p>
<p><strong><span style="color:red"><a href="https://github.com/SatanWoo/JSDebugger" target="_blank" rel="external">https://github.com/SatanWoo/JSDebugger</a></span></strong></p>
<p><strong><a href="https://github.com/SatanWoo/JSDebugger" target="_blank" rel="external">https://github.com/SatanWoo/JSDebugger</a></strong></p>
<p>当然，要是发现了任何的Bug或者使用上的疑惑、抑或是可以改进的点，也可以私聊我或者开<code>issue</code>。</p>
<h3 id="最后">最后</h3><p>实现<strong>JSDebugger</strong>的过程，还是站在两个杰出的项目肩膀上：</p>
<ul>
<li>Cycript</li>
<li>JSPatch</li>
</ul>
<p>我的思路是来自于<code>Cycript</code>，诸如结构体等许多方面的实现细节是参考了<code>JSPatch</code>。在这里对这几个项目的作者和代码贡献者表示感谢！</p>
<p>此外，很多的技术方案是和<strong>HookZZ</strong>大神交流（主要是他教我）中学习而来，在这也特别感谢。也感谢头条的谢大佬的代码贡献以及寒神的<code>Code Style</code>整理。</p>
<p>当然，<strong>JSDebugger</strong>在实现上还是有很多自己思考的部分，感兴趣的读者可以自行前往<a href="https://github.com/SatanWoo/JSDebugger" target="_blank" rel="external">JSDebugger的Github开源地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/10/06/JSDebugger-INTRO/" data-id="ck9fy2gii003t2ni14aj0v4qy" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/10/06/JSDebugger-INTRO/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-MNIST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/MNIST/" class="article-date">
  <time datetime="2018-05-08T17:04:49.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/MNIST/">C++实现一个识别MNIST数字的卷积神经网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新的一个财年加入了新的组，从事机器学习相关的工作。由于之前做的一直是iOS（略微底层）方面的事情，初来乍到，对很多东西不熟悉，在超级大神ZB的建议下，用C++实现一个多层前馈神经网络，来识别MNIST数据中的各种手写图片。</p>
<h3 id="素材寻找">素材寻找</h3><ul>
<li>感谢这位不知名的大佬提供的MNIST数据集，可以直接下载<a href="https://pan.baidu.com/s/1pLMV4Kz" target="_blank" rel="external">纯图片数据集</a></li>
<li>搜索下载已经调整好的<code>weight</code>和<code>bias</code>模型。（下文会介绍）</li>
</ul>
<h3 id="实现过程">实现过程</h3><p>关于实现多层前馈神经网络，网络上的答案数不胜数，但是大多数都是参考Tensorflow或者Caffe（PyTorch）去实现，我觉得这样很不好。因为学习一门新技术，虽然快速完成项目看出效果很重要，但是对个人来说，弄懂黑盒背后的故事非常重要。因此我决定不依赖任何的库来完全裸写。</p>
<blockquote>
<p>当然，对于我来说，实现的完整度和正确性是第一位的，我并没有过多的关注性能。</p>
</blockquote>
<p>虽然在深度学习高度发展的今天，类似于<code>AlexNet</code>这样的网络模型能够近乎完美的识别手写数据集。但是作为这个领域的入门级选手，我还是想追溯起源，从头开始做起。因此，在一番学习和搜索后，我选定了<code>LeNet-5</code>模型进行编写。选择它的原因主要有如下几点：</p>
<ul>
<li>它自身是一个多层的前馈网络模型。</li>
<li>麻雀虽小，五脏俱全。包含了卷积层、全联接层、放缩、灰度以及池化层。同时还引入了<code>ReLu</code>，<code>Softmax</code>等激活函数。</li>
<li><b style="color:red">实现简单，哈哈哈哈哈</b></li>
</ul>
<h3 id="LeNet-5">LeNet-5</h3><p><code>LeNet-5</code>整体是个非常简单的过程，包含如下步骤：</p>
<ol>
<li>接受一个RGBA的图像。这个很简单，直接在RGBA的颜色空间下读取即可。</li>
<li>放缩到<strong>28 * 28</strong>（保留所有的feature）的大小，采用的是<code>bilinear</code>插值方法。</li>
<li>灰度化，公式如下：<code>r / 255.0 * 0.299 + g / 255.0 * 0.587 + b /255.0 * 0.114</code>。</li>
<li>取反，即<code>255.0 - 灰度化的结果</code></li>
<li><strong>5 * 5</strong>大小的卷积，加<code>Relu</code>，进行第一次卷积操作。（这里为了保证卷积后尺寸一致，添加了Padding）</li>
<li>最大池化层降采样。</li>
<li><strong>5 * 5</strong>大小的进行第二次卷积，加<code>ReLu</code>，进行第一次卷积操作。（这里为了保证卷积后尺寸一致，添加了Padding）</li>
<li>最大池化层降采样。</li>
<li>全链接计算 + <code>ReLu</code></li>
<li>全链接输出10个<code>featureMap</code></li>
<li><code>Softmax</code>计算并去除最大的值，即为检测的数字结果。</li>
</ol>
<p><b style="color:red">整体实现上没什么需要特别注意的，如果对这里的名次不懂，可以上网自行查询对应的解释。不过这里有一点很不好，浪费了大量的时间在调试我定义的张量的格式和网上找到的<code>weight</code>模型的格式。</b></p>
<p>什么意思呢？我大致用如下的图解释下我自身设计的张量是如何存储的。</p>
<p>理论上来讲，张量有三个维度，<code>width</code>, <code>height</code>, <code>featureChannels</code>。我在设计我的张量存储上按照的<code>data[height][row][featureChannels]</code>的方式，然后全部拍成了一维。如图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnist1.png?raw=true" alt=""></p>
<blockquote>
<p>之所以想这么做，主要是瞄了眼<code>TensorFlow</code>也是类似的设计，然后印象中CUDA也是按照这样维度进行存储，貌似可以有效做并行计算拆分。（这个不确定）</p>
</blockquote>
<p>然后为什么卡了很久呢？主要是<code>weights</code>和<code>bias</code>的模型文件是个按照自定义协议二进制流的文件（非结构化的数据）。</p>
<p>这模型由于是我网上找的，一开始没注意模型的自定义协议和我设计的张量直接的区别。我直接按照我的张亮顺序进行了相乘，得到了十分错误的结果。</p>
<p>当然，<code>bias</code>模型没什么好说的，就是按照<code>outputFeatureMap</code>定义的纯一维数组，不会出错。</p>
<p>后来发现这个模型是基于苹果的<code>MPS</code>设计的模型，它的模型是这样的数据结构<code>weights[outputChannels][height][width][inputChannel/group]</code>。第一维在计算的时候需要和我做个映射，所以这里没搞清楚模型格式，查了比较久。</p>
<p><b style="color:red">当然，我在加载权重和bias这块还是做了点小油画。用了<code>mmap</code>，避免一次性直接搞进来太大的数据，反正看起来<code>weight</code>和<code>bias</code>这块并不需要一次性的读取，而且只读的<code>mmap</code>还能合理利用iOS设备上的clean memory回收机制。</b></p>
<h3 id="框架设计">框架设计</h3><ul>
<li><p>网络模型拓扑结构，<code>MinstGraph</code>。这里偷懒了，因为<code>LeNet-5</code>也没啥复杂的拓扑结构，不用考虑多个节点连接，直接线性跑下去就好。</p>
</li>
<li><p>支持任意多维度的张量，类似<code>Tensorflow</code>里面的<code>Tensor</code>，这里对应了<code>MinstImage</code>。</p>
</li>
<li>各种Layer，如<code>MaxPoolingLayer</code>，<code>ConvolutionLayer</code>, <code>FullConnectionLayer</code>等等。</li>
<li>各种激活函数，如<code>Relu</code>，<code>Softmax</code>等等。</li>
<li>一些辅助函数之类的。</li>
</ul>
<p>代码下周发吧。</p>
<h3 id="效果">效果</h3><p>准确度一开始不怎么高，检查了很多遍代码，确实发现了一些问题，比如数据精度问题。</p>
<p>一开始从图像的角度理解，认为用<code>unsigned char</code>存储一个数据点就够了，毕竟图像像素点(RGB空间下)的取值范围就是<strong>0-255</strong>。</p>
<p>后来发现在计算卷积、全链接层的时候会产生很多小数，用<code>unsigned char</code>存储精度全部丢失了。因此修改成了现在的<code>float</code>设计。对效果提升还是比较明显的。</p>
<p>后来专门跑了下苹果基于Metal实现的卷积神经网络，由于上述我自身实现的<strong>所有Layer和激活函数</strong>在苹果的框架中都有内置，因此把网络模型搭起来跑就完了（除非苹果自己实现有错）。然后对比我的每一层输入输出和对应的<code>MPSImage</code>输入输出。</p>
<p>不过这里有一点要注意，<code>MPSImage</code>的数据格式是<strong>NHWC</strong>，这里的N是把C按照4对齐后分成的不同batch。如下图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnist2.png?raw=true" alt=""></p>
<p>假设是一个<code>2 * 1 * 5</code>(w <em> h </em> c)的数据，会先把前4层排完，再进行第五层的排列，按4对齐后多出来的三个层补0。</p>
<p>我的代码里面<code>MinstImage</code>提供了一个<code>print</code>方法就是专门做输出对比的。嗯，对比了我的实现和用苹果框架的下输入输出，结果是一致的。(除了iOS10上不支持<code>bilinear</code>插值)</p>
<p>最终效果如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mnist3.png?raw=true" alt=""></p>
<p><b style="color:red">备注：</b></p>
<blockquote>
<p>如果直接用我开头提到的MNIST数据集，由于每张图都是<strong>28 * 28</strong>的灰度图，因此不需要resize + grayscale，直接从取反开始计算就可以了。</p>
</blockquote>
<h3 id="后续规划">后续规划</h3><ol>
<li><p>做神经网络还是挺有意思，不过目前还是参考简单的模型结构实现，主要做<code>inference</code>。还没真正去研究训练模型这块。<strong>这块需要多深入研究算法，多读论文。</strong></p>
</li>
<li><p>目前并没有真正设计<code>Session</code>的概念。<strong>理论上一张图就是一个静态的拓扑结构的组合而已，不应该承担类似执行<code>run</code>的功能</strong>。后续业余时间还会继续实现完整这套逻辑，将静态结构和动态执行结构彻底分离。</p>
</li>
<li><p>后续有时间的话，可以尝试实现别的模型。同时支持从文件中读取已经建立好的模型，类似Caffee模型之类的</p>
</li>
<li><p>移植到GPU上。</p>
</li>
</ol>
<h3 id="最后">最后</h3><p>文章的最后，按照惯例还是向我的偶像致敬。机器学习发展到今天，已经成为了不可忽视的研究方向。对于我们这样的后生来说，站在大牛的肩膀上是我们的福气和基石。而像杨萧玉这样，能够一周时间内学完机器学习课程，发表博客造福大众，才是推动机器学习不断发展的中坚力量。相信在他的带领下，我们国家一定能够在2030年达到全球领先的AI技术水准。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/05/09/MNIST/" data-id="ck9fy2ghm00362ni1vuu5zfj5" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/05/09/MNIST/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-jsengine" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/01/jsengine/" class="article-date">
  <time datetime="2018-03-31T16:26:55.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/jsengine/">动手制作一个简易的iOS动态执行器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前听说滴滴的<code>DynamicCocoa</code>是基于JavaScriptCore搞得，一直期待看到他们的真正实现，不过可能后来由于公司机密，应该不能再开源了。</p>
<p>借着最近开始研究JavaScriptCore的契机，我决定利用这一两天所学的JavaScript知识，在业余时间做一个简单的iOS动态执行器玩具。</p>
<blockquote>
<p>题外话1：听说滴滴基于LLVM backend搞了一套中间语言解释器，不知道最后用了哪个？不过LLVM IR解释器的话，嘿嘿，还是有点意思的。</p>
<p>题外话2：我研究这个并不是想做iOS动态化，因为xxxxxxx。我只是纯粹想看看JavaScriptCore的一些实现而已。</p>
</blockquote>
<h3 id="效果">效果</h3><p>一张Gif图想必能最佳得展示我做的玩具，请各位大佬过目：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/jstester.gif?raw=true" alt=""></p>
<h3 id="前置知识点">前置知识点</h3><p>在实现我们的执行器前，我们还是要稍微要了解一下一些前置的知识点。</p>
<h4 id="JSWrapper_Object">JSWrapper Object</h4><p>大家都知道，Objective-C中的诸多类型在JavaScript的环境里是不能直接用的，需要通过JSValue进行一层包装，具体的类型转换如下图展示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/762048-c669c91024c9308b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>基本上图上的转换都很容易理解，唯一需要我们注意的是<code>Wrapper Object</code>。什么是<code>Wrapper Object</code>呢？</p>
<p>举个例子：</p>
<pre><code><span class="built_in">self</span><span class="built_in">.</span>context<span class="preprocessor">[</span>@<span class="string">"a"</span><span class="preprocessor">]</span><span class="markup"> = </span><span class="preprocessor">[</span>CustomObject <span class="literal">new</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述代码将我们一个自定义类型<code>CustomObject</code>的实例以变量名<code>a</code>的方式注入到了JavaScript的运行环境里。但是她是怎么知道我们的定义呢，又是如何知道我们是否能调用特定的方法？</p>
<p>从默认的角度看，JS运行环境只会把OC中<code>init</code>初始化方法以及类的继承关系给同步到JS环境中（如果有JSExport我们下文说），然后这个对象会包装给一个JSWrapperValue用于JS环境中使用。而当JS环境调用OC并且涉及到这个对象的时候，JavaScriptCore会自动将其解包还原成原始的OC对象类型。</p>
<pre><code>- <span class="list">(<span class="keyword">JSValue</span> <span class="variable">*)jsWrapperForObject:(id)object
{
    JSC::JSObject*</span> jsWrapper = m_cachedJSWrappers.get<span class="list">(<span class="keyword">object</span>)</span><span class="comment">;</span>
    if <span class="list">(<span class="keyword">jsWrapper</span>)</span>
        return [JSValue valueWithJSValueRef<span class="keyword">:toRef</span><span class="list">(<span class="keyword">jsWrapper</span>)</span> inContext<span class="keyword">:m_context</span>]<span class="comment">;</span>

     // 注意点!!!!!!!!!!!!!!!!!!
    JSValue <span class="variable">*wrapper;
    if (class_isMetaClass(object_getClass(object)))
        wrapper = [[self classInfoForClass:(Class)object] constructor];
    else {
        JSObjCClassInfo*</span> classInfo = [self classInfoForClass:[object class]]<span class="comment">;</span>
        wrapper = [classInfo wrapperForObject<span class="keyword">:object</span>]<span class="comment">;</span>
    }

    JSC:<span class="keyword">:ExecState*</span> exec = toJS<span class="list">([m_context JSGlobalContextRef])</span><span class="comment">;</span>
    jsWrapper = toJS<span class="list">(<span class="keyword">exec</span>, valueInternalValue<span class="list">(<span class="keyword">wrapper</span>)</span>)</span>.toObject<span class="list">(<span class="keyword">exec</span>)</span><span class="comment">;</span>
    m_cachedJSWrappers.set<span class="list">(<span class="keyword">object</span>, jsWrapper)</span><span class="comment">;</span>
    return wrapper<span class="comment">;</span>
}</span>
</code></pre><ul>
<li>整体分析下，就是基于一个缓存来判断是否对特定的对象或类型已经构建果<code>Wrapper Object</code>，没有的话就进行构建，构建过程如下：</li>
</ul>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSClassDefinition definition<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">definition = kJSClassDefinitionEmpty<span class="comment">;</span></span><br><span class="line">definition.className = className<span class="comment">;</span></span><br><span class="line">m_classRef = JSClassCreate(&amp;definition)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">[self allocateConstructorAndPrototypeWithSuperClassInfo:superClassInfo]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>没啥特别的，就是OC对象创建对应的JS对象，类型对类型。</li>
<li>OC类型的继承关系在JS里面通过设置Constructor和Prototype进行构建，其实就是简单的JavaScript原型链继承。</li>
</ul>
<h4 id="JSExport协议_&amp;_JSExportAs">JSExport协议 &amp; JSExportAs</h4><p><code>JSExport</code>协议本质上只是个<code>Protocol</code>标记，用于让JavaScriptCore加载那些打上这个特殊标记的类，用于特定方式的注册及初始化。</p>
<p>上文我们提过，默认情况下，JavaScriptCore会对象创建一个默认的<code>Wrapper Object</code>，但是这个对象除了简单继承关系外，也就一个按照特殊格式命令的<code>Constructor</code>而已：</p>
<p><code>[NSString stringWithFormat:@&quot;%sConstructor&quot;, className]</code></p>
<p>那如果我们需要将OC环境中的方法注入到JS环境中，就需要用到<code>JSExport</code>协议了，这个协议在运行时会按照如下逻辑进行处理，将方法和属性进行诸如注入：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">检查init方法簇的方法，并根据这么合法提供合理的</span><br><span class="line"></span><br><span class="line">__block <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">Protocol</span> *&gt; initTable;</span><br><span class="line">    <span class="type">Protocol</span> *exportProtocol = getJSExportProtocol();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Class</span> currentClass = cls; currentClass; currentClass = class_getSuperclass(currentClass)) &#123;</span><br><span class="line">        forEachProtocolImplementingProtocol(currentClass, exportProtocol, ^(<span class="type">Protocol</span> *protocol) &#123;</span><br><span class="line">            forEachMethodInProtocol(protocol, <span class="type">YES</span>, <span class="type">YES</span>, ^(<span class="type">SEL</span> selector, <span class="keyword">const</span> <span class="type">char</span>*) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="type">char</span>* name = sel_getName(selector);</span><br><span class="line">                <span class="keyword">if</span> (!isInitFamilyMethod(@(name)))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                initTable.<span class="type">set</span>(name, protocol);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Class</span> currentClass = cls; currentClass; currentClass = class_getSuperclass(currentClass)) &#123;</span><br><span class="line">        __block unsigned numberOfInitsFound = <span class="number">0</span>;</span><br><span class="line">        __block <span class="type">SEL</span> initMethod = <span class="number">0</span>;</span><br><span class="line">        __block <span class="type">Protocol</span> *initProtocol = <span class="number">0</span>;</span><br><span class="line">        __block <span class="keyword">const</span> <span class="type">char</span>* types = <span class="number">0</span>;</span><br><span class="line">        forEachMethodInClass(currentClass, ^(<span class="type">Method</span> <span class="keyword">method</span>) &#123;</span><br><span class="line">            <span class="type">SEL</span> selector = method_getName(<span class="keyword">method</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="type">char</span>* name = sel_getName(selector);</span><br><span class="line">            <span class="type">auto</span> iter = initTable.find(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iter == initTable.<span class="keyword">end</span>())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            numberOfInitsFound++;</span><br><span class="line">            initMethod = selector;</span><br><span class="line">            initProtocol = iter-&gt;value;</span><br><span class="line">            types = method_getTypeEncoding(<span class="keyword">method</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!numberOfInitsFound)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numberOfInitsFound &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">"ERROR: Class %@ exported more than one init family method via JSExport. Class %@ will not have a callable JavaScript constructor function."</span>, cls, cls);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">JSObjectRef</span> <span class="keyword">method</span> = objCCallbackFunctionForInit(context, cls, initProtocol, initMethod, types);</span><br><span class="line">        <span class="keyword">return</span> [<span class="type">JSValue</span> valueWithJSValueRef:<span class="keyword">method</span> inContext:context];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注入方法和属性</span><br><span class="line">Protocol *exportProtocol = getJSExportProtocol()<span class="comment">;</span></span><br><span class="line">forEachProtocolImplementingProtocol(m_class, exportProtocol, ^(Protocol *protocol)&#123;</span><br><span class="line">  copyPrototypeProperties(m_context, m_class, protocol, prototype)<span class="comment">;</span></span><br><span class="line">  copyMethodsToObject(m_context, m_class, protocol, NO, constructor)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>而至于<code>JSExportAs</code>，就是做了个简单的名称映射而已，毕竟JS函数传参和OC有很大的区别：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *createRenameMap(Protocol *protocol, <span class="built_in">BOOL</span> isInstanceMethod)
{
    <span class="built_in">NSMutableDictionary</span> *renameMap = [[<span class="built_in">NSMutableDictionary</span> alloc] init];

    forEachMethodInProtocol(protocol, <span class="literal">NO</span>, isInstanceMethod, ^(SEL sel, <span class="keyword">const</span> <span class="keyword">char</span>*){
        <span class="built_in">NSString</span> *rename = @(sel_getName(sel));
        <span class="built_in">NSRange</span> range = [rename rangeOfString:<span class="string">@"__JS_EXPORT_AS__"</span>];
        <span class="keyword">if</span> (range<span class="variable">.location</span> == <span class="built_in">NSNotFound</span>)
            <span class="keyword">return</span>;
        <span class="built_in">NSString</span> *selector = [rename substringToIndex:range<span class="variable">.location</span>];
        <span class="built_in">NSUInteger</span> begin = range<span class="variable">.location</span> + range<span class="variable">.length</span>;
        <span class="built_in">NSUInteger</span> length = [rename length] - begin - <span class="number">1</span>;
        <span class="built_in">NSString</span> *name = [rename substringWithRange:(<span class="built_in">NSRange</span>){ begin, length }];
        renameMap[selector] = name;
    });

    <span class="keyword">return</span> renameMap;
}
</code></pre><h3 id="实现过程">实现过程</h3><p><b style="color:red">说了那么多基础原理，下面让我们来看看具体实现流程：</b></p>
<h4 id="类、实例和方法">类、实例和方法</h4><p>在我看来，要实现一个动态化的执行环境，有三要素是必不可少的：</p>
<p><b style="color:red">类（包括元类）、实例对象以及方法。</b></p>
<p>基于我们上文对于<code>Wrapper Object</code>的分析，我们可以构建特殊类型的Wrapper Object对这三个元素进行包装，具体就不说了，还是建议大家自行思考，基本上类似我上文分析<code>JSWrapperObject</code>的步骤。</p>
<p>除了上述三要素，我们还需要定义一个全局变量，<code>WZGloablObject</code>（大家可以理解为浏览器的window对象），用于拦截顶层的属性访问。</p>
<p><b style="color:red">按照这个设计，大家可以自行思考下，如果是你做，你会如何继续下面的工作，文章下周随着代码一起发布吧。</b></p>
<h4 id="Choose_调试">Choose 调试</h4><p>搞过逆向用过<strong>Cycript</strong>的朋友都知道，<strong>Cycript</strong>在调试时候有个非常方便的调试功能：<code>Choose</code>。该功能可以快速的帮助我们根据类名在堆上的对象全部查询返回。</p>
<p>这么实用的功能必须提供，我基本上直接照搬了Cycript的实现。代码很清晰，基本能够自解释其逻辑。核心基本上就是遍历每个<code>malloc_zone</code>，然后根据获取的<code>vmaddress_range</code>判断获取到的<strong>数据</strong>其类型是不是我们要的。</p>
<pre><code>// 遍历zone
<span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i != size; ++i) {
    <span class="keyword">const</span> malloc_zone_t * zone = reinterpret_cast&lt;<span class="keyword">const</span> malloc_zone_t *&gt;(zones[i]);
    <span class="keyword">if</span> (zone == <span class="type">NULL</span> || zone-&gt;introspect == <span class="type">NULL</span>)
        <span class="keyword">continue</span>;
    zone-&gt;introspect-&gt;enumerator(mach_task_self(), &amp;choice, <span class="type">MALLOC_PTR_IN_USE_RANGE_TYPE</span>, zones[i], &amp;read_memory, &amp;choose_);
}

// 检查对象
<span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i &lt; count; ++i) {
   vm_range_t &amp;<span class="type">range</span> = ranges[i];
   <span class="type">void</span> * data = reinterpret_cast&lt;<span class="type">void</span> *&gt;(<span class="type">range</span>.address);
   size_t size = <span class="type">range</span>.size;

   <span class="keyword">if</span> (size &lt; sizeof(<span class="type">ObjectStruct</span>))
       <span class="keyword">continue</span>;

   uintptr_t * pointers = reinterpret_cast&lt;uintptr_t *&gt;(data);
<span class="comment">#ifdef __arm64__</span>
   <span class="type">Class</span> isa = (__bridge <span class="type">Class</span>)((<span class="type">void</span> *)(pointers[<span class="number">0</span>] &amp; <span class="number">0x1fffffff8</span>));
<span class="comment">#else</span>
   <span class="type">Class</span> isa = reinterpret_cast&lt;<span class="type">Class</span>&gt;(pointers[<span class="number">0</span>]);
<span class="comment">#endif</span>
   std::<span class="type">set</span>&lt;<span class="type">Class</span>&gt;::const_iterator <span class="literal">result</span>(choice-&gt;query_.find(isa));
   <span class="keyword">if</span> (<span class="literal">result</span> == choice-&gt;query_.<span class="keyword">end</span>())
       <span class="keyword">continue</span>;

   size_t needed = class_getInstanceSize(*<span class="literal">result</span>);
   size_t boundary = <span class="number">496</span>;
<span class="comment">#ifdef __LP64__</span>
   boundary *= <span class="number">2</span>;
<span class="comment">#endif</span>
   <span class="keyword">if</span> ((needed &lt;= boundary &amp;&amp; (needed + <span class="number">15</span>) / <span class="number">16</span> * <span class="number">16</span> != size) || (needed &gt; boundary &amp;&amp; (needed + <span class="number">511</span>) / <span class="number">512</span> * <span class="number">512</span> != size))
       <span class="keyword">continue</span>;
   choice-&gt;result_.insert((__bridge id)(data));
}
</code></pre><p><b style="color:red">不过这里一大堆的511、512的数字构成的公式，实话说我不是很懂，有了解的大佬麻烦告知我一下。</b></p>
<h4 id="类型转换">类型转换</h4><p>首先我们需要记住，JavaScript的基础类型如下：</p>
<pre><code>-<span class="ruby"> 字符串、
</span>-<span class="ruby"> 数字、
</span>-<span class="ruby"> 布尔、
</span>-<span class="ruby"> 数组、
</span>-<span class="ruby"> 对象、
</span>-<span class="ruby"> <span class="constant">Null</span>、
</span>-<span class="ruby"> <span class="constant">Undefined</span></span>
</code></pre><p>所以我们只要根据对应的进行转换就可以，如下所示：</p>
<ul>
<li>JS字符串 &lt;-&gt; NSString</li>
<li>数字 &lt;-&gt; NSNumber</li>
<li>数组 &lt;-&gt; NSArray</li>
<li>Null &lt;-&gt; NSNull</li>
<li>Undefined &lt;-&gt; Void (仅当返回值的时候处理，否则直接抛出异常)</li>
</ul>
<blockquote>
<p>题外话，JavaScript里面没有什么整数和浮点数类型区分一说，所以我们可以无脑将其通过double的方式构建<code>NSNumber</code></p>
</blockquote>
<p>最后再来说下对对象类型的处理：</p>
<p>在JavaScript，任何对象都可以简单理解为包含了属性（方法）的一个包装体，如下所示:</p>
<pre><code>var a = {x:<span class="number">10</span>, y:<span class="number">100</span>};
</code></pre><p>因此，我们在对类型进行转换的时候，要特别注意以下几点：</p>
<ul>
<li>这个对象是不是我们刚刚上文提过的<b style="color:red">类、实例、方法</b>，是的话在其进入到Objective-C执行上下文的之前从JSWrapperObject中取出来。</li>
<li>这个对象是不是特定类型的结构体，是的话我们将其转换成结构体，比如<code>CGRect</code>之类的，是的话需要特别转换</li>
<li>是不是可以直接转换成特定类型的对象，比如<code>Date &lt;-&gt; NSDate</code>的转换。</li>
<li>最后，将其可遍历的属性和对应的属性值，转换到<code>NSDictionary</code>之中。</li>
<li><strong>当然，别忘了，需要注意递归处理</strong>。</li>
</ul>
<h4 id="Calling_Convention">Calling Convention</h4><p>关于<code>Calling Convention</code>，本文就不再赘述，有兴趣的读者可以参考我和同事一起写的知乎专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target="_blank" rel="external">iOS调试进阶</a></p>
<p>简单来重新描述下就是：</p>
<p>一个函数的调用过程中，函数的参数既可以使用栈传递，也可以使用寄存器传递，参数压栈的顺序可以从左到右也可以从右到左，函数调用后参数从栈弹出这个工作可以由函数调用方完成，也可以由被调用方完成。如果函数的调用方和被调用方(函数本身)不遵循统一的约定，有这么多分歧这个函数调用就没法完成。这个双方必须遵守的统一约定就叫做调用惯例(Calling Convention)，调用惯例规定了参数的传递的顺序和方式，以及栈的维护方式。</p>
<p>由于业界已经有知名大佬写的<code>libffi</code>，所以我们不需要重复发明轮子，直接使用即可。如果真的要了解具体原理，也可以参考<a href="http://satanwoo.github.io/2017/06/29/Macho-2/">我的文章</a>，具体分析<code>objc_msgSend</code>的实现流程。</p>
<h3 id="其他">其他</h3><p>为了偷懒，我直接用JavaScript实现了这些的效果。其实理论上，如果我完整的实现编译前端，构建抽象语法树分析执行上下文，将Objective-C的代码转换成JavaScript，那么就能实现动态执行Objective-C代码了。(当然本质上还是障眼法)</p>
<blockquote>
<p>其实更快的方式，且不能保证完全正确的方式，就是调用一下<code>JSPatchConvertor</code>就好了，哈哈哈。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/04/01/jsengine/" data-id="ck9fy2gdz000m2ni15iml9nij" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/04/01/jsengine/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-iOS-iVar" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/04/iOS-iVar/" class="article-date">
  <time datetime="2018-02-04T15:14:33.000Z" itemprop="datePublished">2018-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/04/iOS-iVar/">谈谈ivar的直接访问</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>大水文一篇<br>大水文一篇<br>大水文一篇  </p>
</blockquote>
<h3 id="起因">起因</h3><p>最近对<code>Block</code>的一些实现细节又进行了一次复习，主要涉及的是捕捉变量的部分。有一个点我之前一直没太关注：对<code>ivar</code>变量的直接访问为啥会产生循环引用。</p>
<p>在我原先的理解中，之所以会产生循环引用，绝大多数场景都是由于<code>block</code>里面涉及了<strong>self</strong>关键字，比如<code>[self doSomething]</code>（同理，对于<code>property</code>的访问本质也是一堆方法），但是为啥对<code>ivar</code>的访问也会导致循环引用呢？</p>
<p>不是直接采用 <code>*(void *)address = xxx</code>这样的直接对编译好的静态地址赋值就好了？</p>
<blockquote>
<p>当时傻逼了，写完本文后想想就算编译成地址了，基地址从哪算还是要依赖<code>self</code>变量。</p>
</blockquote>
<h3 id="谈谈ivar的访问是啥形式">谈谈ivar的访问是啥形式</h3><p>还是回到runtime来看看吧，万变不离其宗，从<code>objc_class</code>结构体看起：</p>
<pre><code>struct objc<span class="number">_</span><span class="keyword">class</span> : objc<span class="number">_</span><span class="keyword">object</span> {
    <span class="comment">// Class ISA; // 8byte</span>
    Class superclass; <span class="comment">// 8byte</span>
    cache<span class="number">_</span>t cache;             <span class="comment">// formerly cache pointer and vtable // 4 + 4 + 8</span>
    <span class="keyword">class</span><span class="number">_</span>data<span class="number">_</span>bits<span class="number">_</span>t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span>

    <span class="keyword">class</span><span class="number">_</span>rw<span class="number">_</span>t *data() { 
        <span class="keyword">return</span> bits.data();
    }
</code></pre><p>主要的运行时数据都是<code>class_rw_t</code>表示，继续瞅瞅：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_rw_t</span> {
    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span>
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> version;

    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;
</code></pre><p>其中<code>class_ro_t</code>基本上是从二进制产物中读取的“副本”数据，我们看看：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;
</code></pre><p>看起来<code>ivar_list_t</code>就是存放<code>ivar</code>的列表，他的实现是一个模版类，看看具体结构表示：</p>
<pre><code><span class="title">struct</span> entsize_list_tt {
    <span class="title">uint32_t</span> entsizeAndFlags;
    <span class="title">uint32_t</span> count;
    <span class="title">Element</span> first;
</code></pre><p>具体对应<code>ivar</code>，替换掉模版就是：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">ivar_list_t</span> {
    <span class="keyword">uint32_t</span> entsizeAndFlags;
    <span class="keyword">uint32_t</span> count;
    <span class="keyword">ivar_t</span> first;
</code></pre><p>其中，<code>ivar_t</code>表征的就是我们每个<code>ivar</code>，</p>
<pre><code><span class="keyword">int32_t</span> *offset;
<span class="keyword">const</span> <span class="keyword">char</span> *name;
<span class="keyword">const</span> <span class="keyword">char</span> *type;
</code></pre><p>嗯，从这里开始<code>offset</code>是用一个<code>int32_t *</code>的指针来表示，就开始有意思了。<strong>这里我们先暂时忽略</strong></p>
<p>看起来，如果按照这种方式访问<code>ivar</code>，整个流程要经过好多次指针转移：</p>
<pre><code>class -&gt; class<span class="class">.rw_data</span> -&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span> -&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span><span class="class">.ivars</span> -&gt; 
-&gt; class<span class="class">.rw_data</span><span class="class">.ro_data</span><span class="class">.ivars</span><span class="class">.first</span>[n]
</code></pre><p>如果是这样，大量使用<code>ivar</code>肯定很耗时。那么，对于<code>ivar</code>的访问究竟是怎么玩的呢？</p>
<h3 id="全局变量">全局变量</h3><p>我们用如下这个非常简单的例子来瞅瞅：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^MyBlock)(<span class="keyword">void</span>);

<span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> haha;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlock block;

- (<span class="keyword">void</span>)inits;

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span>
- (<span class="keyword">void</span>)inits
{
    <span class="keyword">self</span><span class="variable">.block</span> = ^{
        _haha = <span class="number">5</span>;
    };
}
<span class="keyword">@end</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    MyObject *object = [MyObject new];
    [object inits];
}
</code></pre><p>重写一把，基本转化成如下的形式：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(*MyBlock)(<span class="keyword">void</span>);


<span class="preprocessor">#ifndef _REWRITER_typedef_MyObject</span>
<span class="preprocessor">#define _REWRITER_typedef_MyObject</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object MyObject;
<span class="keyword">typedef</span> <span class="keyword">struct</span> {} _objc_exc_MyObject;
<span class="preprocessor">#endif</span>

<span class="comment">// 注意点1!!!!!!!!!!!!!!!!!!!!</span>
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_haha;
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_block;
<span class="keyword">struct</span> MyObject_I<span class="built_in">MPL</span> {
    <span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;
    <span class="built_in">NSUInteger</span> _haha;
    MyBlock _block;
};

<span class="comment">// @property (nonatomic) NSUInteger haha;</span>
<span class="comment">// @property (nonatomic, copy) MyBlock block;</span>

<span class="comment">// - (void)inits;</span>

<span class="comment">/* @end */</span>


<span class="comment">// @implementation MyObject</span>

<span class="keyword">struct</span> __MyObject__inits_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __MyObject__inits_block_desc_0* Desc;
  MyObject *<span class="keyword">self</span>;

  <span class="comment">// 注意点2！！！！！！！！！！！！！！！</span>
  __MyObject__inits_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __MyObject__inits_block_desc_0 *desc, MyObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) {
    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;
    impl<span class="variable">.Flags</span> = flags;
    impl<span class="variable">.FuncPtr</span> = fp;
    Desc = desc;
  }
};

／／ 注意点<span class="number">3</span>！！！！！！！！！！！！
<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_func_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0 *__cself) {
  MyObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span>

        (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = <span class="number">5</span>;
    }
<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_copy_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*dst, <span class="keyword">struct</span> __MyObject__inits_block_impl_0*src) {_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}

<span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_dispose_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}

<span class="keyword">static</span> <span class="keyword">struct</span> __MyObject__inits_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*, <span class="keyword">struct</span> __MyObject__inits_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __MyObject__inits_block_impl_0*);
} __MyObject__inits_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __MyObject__inits_block_impl_0), __MyObject__inits_block_copy_0, __MyObject__inits_block_dispose_0};

<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_inits(MyObject * <span class="keyword">self</span>, SEL _cmd) {
    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, MyBlock))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"setBlock:"</span>), ((<span class="keyword">void</span> (*)())&amp;__MyObject__inits_block_impl_0((<span class="keyword">void</span> *)__MyObject__inits_block_func_0, &amp;__MyObject__inits_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>)));
}

<span class="keyword">static</span> <span class="built_in">NSUInteger</span> _I_MyObject_haha(MyObject * <span class="keyword">self</span>, SEL _cmd) { <span class="keyword">return</span> (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)); }
<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_setHaha_(MyObject * <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSUInteger</span> haha) { (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = haha; }

<span class="keyword">static</span> <span class="keyword">void</span>(* _I_MyObject_block(MyObject * <span class="keyword">self</span>, SEL _cmd) )(){ <span class="keyword">return</span> (*(MyBlock *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_block)); }
<span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> objc_setProperty (<span class="keyword">id</span>, SEL, <span class="keyword">long</span>, <span class="keyword">id</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>);

<span class="keyword">static</span> <span class="keyword">void</span> _I_MyObject_setBlock_(MyObject * <span class="keyword">self</span>, SEL _cmd, MyBlock block) { objc_setProperty (<span class="keyword">self</span>, _cmd, __OFFSETOFIVAR__(<span class="keyword">struct</span> MyObject, _block), (<span class="keyword">id</span>)block, <span class="number">0</span>, <span class="number">1</span>); }
<span class="comment">// @end</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    MyObject *object = ((MyObject *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"MyObject"</span>), sel_registerName(<span class="string">"new"</span>));
    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)object, sel_registerName(<span class="string">"inits"</span>));
}
</code></pre><p>一大堆东西，没啥特别的地方，我们只要关注几个地方：</p>
<ul>
<li><p>对于每个<code>ivar</code>，都有对应的全局变量</p>
<pre><code><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_haha;
<span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_MyObject$_block;
</code></pre></li>
<li><p>block_invoke对应的实现是通过对象自身作为基地址，全局变量作为偏移去对<code>haha</code>这个<code>ivar</code>进行赋值。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __MyObject__inits_block_func_0(<span class="keyword">struct</span> __MyObject__inits_block_impl_0 *__cself) {
  MyObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span>

        (*(<span class="built_in">NSUInteger</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_haha)) = <span class="number">5</span>;
    }
</code></pre></li>
<li><p>block的构造函数，确实捕捉了<code>self</code></p>
<pre><code>__MyObject__inits_block_impl_0(void *fp, <span class="keyword">struct</span> __MyObject__inits_block_desc_0 *desc, MyObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) {
    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
    <span class="keyword">impl</span>.Flags = flags;
    <span class="keyword">impl</span>.FuncPtr = fp;
    Desc = desc;
  }
</code></pre></li>
</ul>
<p>由于全局变量的地址是在编译期就确定了，所以这里也就不难解释<code>ivar_t</code>里面为什么要保存<code>int32_t *</code>，保存的就是对应的全局变量地址。而全局变量的值则是对应的动态偏移。</p>
<h3 id="结语">结语</h3><p>水完了，其实虽然runtime的结构体设计的比较绕，但是最后对于变量的访问和很多静态语言设计一样，也不会损失很多性能。</p>
<p><b style="color:red">从另外一个角度看，如果声明了巨多的<code>ivar</code>，看来也会对包大小产生不可忽视的影响。</b></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/02/04/iOS-iVar/" data-id="ck9fy2gec000u2ni198ll07vv" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/02/04/iOS-iVar/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-iOS-virtual" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/iOS-virtual/" class="article-date">
  <time datetime="2018-01-14T13:37:12.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/iOS-virtual/">XNU之四：iOS虚拟内存限制（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>XNU之二和之三两篇由于涉及的量过大，就不发了，当然本文我也删除了一定的内容，哈哈哈。</p>
<p><b style="color:red">欢迎加入我们<strong>手淘／天猫的架构组</strong>来内网阅读</b></p>
<p>提起iOS的内存管理，大多数人第一反应想到的都是引用计数、<code>ARC</code>、<code>AutoreleasePool</code>之类的词眼。但是事实上，这只是iOS内存管理的冰山一角，今天就让我们来探究水面之下的内存管理。</p>
<h3 id="虚拟内存的限制">虚拟内存的限制</h3><p>我之所以想研究这个议题，主要还是之前有个UC同事问了我一个问题：</p>
<blockquote>
<p>“现在绝大多数都是ARM64的设备，即64位寻址空间，而且iOS上的通过malloc申请的内存只是虚拟内存，还不是真正物理内存，为什么分配了两三G就会失败了。”</p>
</blockquote>
<p>按照他的想法，我在我的iPhone上测试了如下代码：</p>
<pre><code><span class="keyword">void</span> *buffer = <span class="built_in">malloc</span>(<span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>);
</code></pre><p>果不其然，报出了如下错误：</p>
<pre><code>malloc: <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> mach_vm_map(size=2097152000) failed (error code=3)
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> error: can't allocate region
</code></pre><p>次奥，我xxxxx分配一个<strong>2G<b style="color:red">虚拟</b>内存</strong>就懵逼？</p>
<p>还是赶紧翻翻看源码，由于我分配的是一个超大的内存，所以按照<code>nano_zone</code>和<code>scalable_zone</code>的设计理念，</p>
<ul>
<li>小于256byte的走<code>nano_zone</code>进行分配。</li>
<li>剩下的我记不得了</li>
</ul>
<p>赶紧翻翻<code>scalable_zone</code>看看源码，如下所示：</p>
<pre><code>void *    szone_malloc_should_clear<span class="list">(<span class="keyword">szone_t</span> <span class="variable">*szone, size_t size, boolean_t cleared_requested)
{
    void *</span>ptr<span class="comment">;</span>
    msize_t msize<span class="comment">;</span>

    if <span class="list">(<span class="keyword">size</span> &lt;= SMALL_THRESHOLD)</span> {
        // tiny size: &lt;1024 bytes <span class="list">(<span class="number">64</span>-bit)</span>, &lt;512 bytes <span class="list">(<span class="number">32</span>-bit)</span>
        // think tiny
        msize = TINY_MSIZE_FOR_BYTES<span class="list">(<span class="keyword">size</span> + TINY_QUANTUM - <span class="number">1</span>)</span><span class="comment">;</span>
        if <span class="list">(!msize)</span> {
            msize = <span class="number">1</span><span class="comment">;</span>
        }
        ptr = tiny_malloc_should_clear<span class="list">(<span class="keyword">szone</span>, msize, cleared_requested)</span><span class="comment">;</span>
    } else if <span class="list">(<span class="keyword">size</span> &lt;= szone-&gt;large_threshold)</span> {
        // small size: &lt;15k <span class="list">(<span class="keyword">&lt;1GB</span> machines)</span>, &lt;127k <span class="list">(<span class="keyword">&gt;1GB</span> machines)</span>
        // think small
        msize = SMALL_MSIZE_FOR_BYTES<span class="list">(<span class="keyword">size</span> + SMALL_QUANTUM - <span class="number">1</span>)</span><span class="comment">;</span>
        if <span class="list">(!msize)</span> {
            msize = <span class="number">1</span><span class="comment">;</span>
        }
        ptr = small_malloc_should_clear<span class="list">(<span class="keyword">szone</span>, msize, cleared_requested)</span><span class="comment">;</span>
    } else {
        // large: all other allocations
        size_t num_kernel_pages = round_page_quanta<span class="list">(<span class="keyword">size</span>)</span> &gt;&gt; vm_page_quanta_shift<span class="comment">;</span>
        if <span class="list">(<span class="keyword">num_kernel_pages</span> == <span class="number">0</span>)</span> { /* Overflowed <span class="variable">*/
            ptr = 0;
        } else {
            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);
        }
    }
#if DEBUG_MALLOC
    if (LOG(szone, ptr)) {
        malloc_printf("szone_malloc returned %p\n", ptr);
    }
#endif
    /*</span>
     <span class="variable">* If requested, scribble on allocated memory.
     *</span>/
    if <span class="list">(<span class="list">(<span class="keyword">szone-&gt;debug_flags</span> &amp; MALLOC_DO_SCRIBBLE)</span> <span class="keyword">&amp;&amp;</span> ptr <span class="keyword">&amp;&amp;</span> !cleared_requested <span class="keyword">&amp;&amp;</span> size)</span> {
        memset<span class="list">(<span class="keyword">ptr</span>, SCRIBBLE_BYTE, szone_size<span class="list">(<span class="keyword">szone</span>, ptr)</span>)</span><span class="comment">;</span>
    }

    return ptr<span class="comment">;</span>
}</span>
</code></pre><ul>
<li>小于1k的走<code>tiny_malloc</code></li>
<li>小于15k或者127k的走<code>small_malloc</code>（视具体不同的设备内存上限不同）</li>
<li>剩下的走<code>large_malloc</code>。</li>
</ul>
<p>OK，由于我们分配的非常大，我们可以确定我们的逻辑是落入<code>large_malloc</code>中。需要特别注意的是：<code>large_malloc</code>分配内存的基本单位是一页大小，而对于其他的几种分配方式，则不是必须按照页大小进行分配。</p>
<p>由于<code>large_malloc</code>这个函数本身并没有特殊需要注意的地方，我们直接关注其真正分配内存的地方，即<code>allocate_pages</code>，如下所示：</p>
<pre><code>vm_addr = vm_page_quanta_size;
kr = mach_vm_map(mach_task_self(), &amp;vm_addr, allocation_size, allocation_mask, alloc_flags, MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE,
            VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);
<span class="keyword">if</span> (kr) {
    szone_error(szone, <span class="number">0</span>, <span class="string">"can't allocate region"</span>, <span class="literal">NULL</span>, <span class="string">"*** mach_vm_map(size=%lu) failed (error code=%d)\n"</span>, size, kr);
    <span class="keyword">return</span> <span class="literal">NULL</span>;
}
addr = (<span class="keyword">uintptr_t</span>)vm_addr;
</code></pre><p>从上我们不难看出，如果分配失败，就是提示报错。而<code>mach_vm_map</code>则是整个内存的分配核心。</p>
<p>可能你一开始看到这个<code>mach_vm_map</code>会比较懵逼，可以先看下我下面这张图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/virtual.png?raw=true" alt="屏幕快照 2018-01-03 上午10.55.41.png"> </p>
<p>OK，是不是有冒出很多名词。没关系，你其实只要记住两点：<code>vm_map</code>代表就是一个进程运行时候涉及的虚拟内存，<code>pmap</code>代表的就是和具体硬件架构相关的物理内存。（这里我们暂时先不考虑<strong>submap</strong>这种情况）。</p>
<p>好，<code>vm_map</code>本身是进程（或者从Mach内核的角度看是task的地址分布图）。这个地址分布图维护着一个<strong><b style="color:red">双向列表</b></strong>，列表的每一项都是<code>vm_entry_t</code>，代表着虚拟地址上连续的一个范围。而<code>pmap</code>这个结构体代表了个硬件相关的内存转换：即利用<code>pmap</code>这个结构体来描述抽象的物理地址访问和使用。</p>
<h3 id="进程（任务）的创建">进程（任务）的创建</h3><p>在继续深入我们的话题之前，我们还需要具备一个额外的知识，就是iOS上的进程创建和加载执行Mach-O过程。</p>
<p>类UNIX系统本质上是没法无缘无故创建出一个全新的进程的，基本上必须要通过<code>fork</code>的形式来创建。(这块不太熟悉，有错请指正)。</p>
<p>在XNU的实现里，不论用户态调用<code>posix</code>相关API还是别的API，落入到内核里面都走的是<code>fork_create_child</code>函数来创建属于Mach内核的任务（task）。其实现如下：</p>
<pre><code>thread_t
fork_create_child(task_t parent_task, coalition_t *parent_coalitions, proc_t child_proc, <span class="type">int</span> inherit_memory, <span class="type">int</span> is64bit, <span class="type">int</span> in_exec)
{
    thread_t    child_thread = <span class="type">NULL</span>;
    task_t        child_task;
    kern_return_t    <span class="literal">result</span>;

    /* <span class="type">Create</span> a new task <span class="keyword">for</span> the child process */
    <span class="literal">result</span> = task_create_internal(parent_task,
                    parent_coalitions,
                    inherit_memory,
                    is64bit,
                    <span class="type">TF_LRETURNWAIT</span> | <span class="type">TF_LRETURNWAITER</span>,         /* <span class="type">All</span> created threads will wait <span class="keyword">in</span> task_wait_to_return */
                    in_exec ? <span class="type">TPF_EXEC_COPY</span> : <span class="type">TPF_NONE</span>,   /* <span class="type">Mark</span> the task exec copy <span class="keyword">if</span> <span class="keyword">in</span> execve */
                    &amp;child_task);

    <span class="keyword">if</span> (<span class="literal">result</span> != <span class="type">KERN_SUCCESS</span>) {
        printf(<span class="string">"%s: task_create_internal failed.  Code: %d\n"</span>,
            __func__, <span class="literal">result</span>);
        goto bad;
    }

    <span class="keyword">if</span> (!in_exec) {
        /*
         * <span class="type">Set</span> the child process task to the new task <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">in</span> exec,
         * will <span class="type">set</span> the task <span class="keyword">for</span> exec <span class="keyword">case</span> <span class="keyword">in</span> proc_exec_switch_task after image activation.
         */

         // 注意点：
        child_proc-&gt;task = child_task;
    }
</code></pre><ul>
<li>这个函数本身实现并没什么出彩的，我们唯一要注意的就是<strong>Mach内核里面没有进程的概念，只有任务</strong>，进程是属于BSD之上的抽象。它们之间的联系就是通过指针建立，<code>child_proc-&gt;task = child_task。</code></li>
</ul>
<p><code>fork</code>出来的进程更像是一个空壳，我们需要利用这个进程壳去执行可执行文件变成我们通常意义上理解的<code>程序进程</code>。</p>
<p>从XNU上来看，可执行的文件种类如下：</p>
<pre><code>{ <span class="built_in">exec</span>_mach_imgact,        <span class="string">"Mach-o Binary"</span> },
{ <span class="built_in">exec</span>_fat_imgact,        <span class="string">"Fat Binary"</span> },
{ <span class="built_in">exec</span>_shell_imgact,    <span class="string">"Interpreter Script"</span> }
</code></pre><p>这里咱们先只看最常用的<code>Mach-O</code>文件：</p>
<pre><code>exec_mach_imgact(struct image_params *imgp)
{
    ... 省略无数

    <span class="keyword">if</span> ((mach_header-&gt;magic == MH_CIGAM) ||
        (mach_header-&gt;magic == MH_CIGAM_64)) {
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;
        (mach_header-&gt;magic != MH_MAGIC_64)) {
        error = -<span class="number">1</span>;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> (mach_header-&gt;filetype != MH_EXECUTE) {
        error = -<span class="number">1</span>;
        <span class="keyword">goto</span> bad;
    }

    <span class="keyword">if</span> (imgp-&gt;ip_origcputype != <span class="number">0</span>) {
        <span class="comment">/* Fat header previously had an idea about this thin file */</span>
        <span class="keyword">if</span> (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||
            imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) {
            error = EBADARCH;
            <span class="keyword">goto</span> bad;
        }
    } <span class="keyword">else</span> {
        imgp-&gt;ip_origcputype = mach_header-&gt;cputype;
        imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;
    }

    task = current_task();
    thread = current_thread();
    uthread = get_bsdthread_info(thread);

    <span class="keyword">if</span> ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
        imgp-&gt;ip_flags |= IMGPF_IS_64BIT;

    <span class="comment">/* If posix_spawn binprefs exist, respect those prefs. */</span>
    psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;
    <span class="keyword">if</span> (psa != <span class="keyword">NULL</span> &amp;&amp; psa-&gt;psa_binprefs[<span class="number">0</span>] != <span class="number">0</span>) {
        <span class="keyword">int</span> pr = <span class="number">0</span>;
        <span class="keyword">for</span> (pr = <span class="number">0</span>; pr &lt; NBINPREFS; pr++) {
            cpu_type_t pref = psa-&gt;psa_binprefs[pr];
            <span class="keyword">if</span> (pref == <span class="number">0</span>) {
                <span class="comment">/* No suitable arch in the pref list */</span>
                error = EBADARCH;
                <span class="keyword">goto</span> bad;
            }

            <span class="keyword">if</span> (pref == CPU_TYPE_ANY) {
                <span class="comment">/* Jump to regular grading */</span>
                <span class="keyword">goto</span> grade;
            }

            <span class="keyword">if</span> (pref == imgp-&gt;ip_origcputype) {
                <span class="comment">/* We have a match! */</span>
                <span class="keyword">goto</span> grade;
            }
        }
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }
grade:
    <span class="keyword">if</span> (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) {
        error = EBADARCH;
        <span class="keyword">goto</span> bad;
    }

    <span class="comment">/* Copy in arguments/environment from the old process */</span>
    error = exec_extract_strings(imgp);
    <span class="keyword">if</span> (error)
        <span class="keyword">goto</span> bad;

    AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, 
        imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);
    AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,
        imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);

    <span class="comment">/* reset local idea of thread, uthread, task */</span>
    thread = imgp-&gt;ip_new_thread;
    uthread = get_bsdthread_info(thread);
    task = new_task = get_threadtask(thread);

    <span class="comment">// 注意点：</span>
    lret = load_machfile(imgp, mach_header, thread, &amp;map, &amp;load_result);

    ... 省略无数
</code></pre><p>整个代码都没啥用，就是做些检查，分配个进程壳，然后通过<code>load_machfile</code>加载真正的二进制文件。</p>
<pre><code>load_return_t
load_machfile(
    struct image_params    *imgp,
    struct mach_header    *header,
    thread_t         thread,
    vm_map_t         *mapp,
    load_result_t        *<span class="literal">result</span>
)
{
    ... 省略一大堆

    <span class="keyword">if</span> (macho_size &gt; file_size) {
        <span class="keyword">return</span>(<span class="type">LOAD_BADMACHO</span>);
    }

    <span class="literal">result</span>-&gt;is64bit = ((imgp-&gt;ip_flags &amp; <span class="type">IMGPF_IS_64BIT</span>) == <span class="type">IMGPF_IS_64BIT</span>);

    task_t ledger_task;
    <span class="keyword">if</span> (imgp-&gt;ip_new_thread) {
        ledger_task = get_threadtask(imgp-&gt;ip_new_thread);
    } <span class="keyword">else</span> {
        ledger_task = task;
    }

    // 注意点<span class="number">1</span>
    pmap = pmap_create(get_task_ledger(ledger_task),
               (vm_map_size_t) <span class="number">0</span>,
               <span class="literal">result</span>-&gt;is64bit);

    // 注意点<span class="number">2</span>
    map = vm_map_create(pmap,
            <span class="number">0</span>,
            vm_compute_max_offset(<span class="literal">result</span>-&gt;is64bit),
            <span class="type">TRUE</span>);

<span class="comment">#if defined(__arm64__)</span>
    // 注意点三
    <span class="keyword">if</span> (<span class="literal">result</span>-&gt;is64bit) {
        /* enforce <span class="number">16</span>KB alignment <span class="keyword">of</span> <span class="type">VM</span> map entries */
        vm_map_set_page_shift(map, <span class="type">SIXTEENK_PAGE_SHIFT</span>);
    } <span class="keyword">else</span> {
        vm_map_set_page_shift(map, page_shift_user32);
    }
</code></pre><ul>
<li>利用<code>pmap_create</code>创建硬件相关的物理内存抽象。</li>
<li>利用<code>vmap_create</code>创建虚拟内存的地址图。</li>
<li>ARM64下的页是16k一个虚拟页对应一个物理页。</li>
</ul>
<p>别的没啥关注，我们重点关注<code>vm_map_create</code><b style="color:red"><code>0</code>和<code>vm_compute_max_offset(result-&gt;is64bit)</code></b>。</p>
<p><b style="color:red">因为这个代表了这个任务分配的虚拟地址上下限！</b>这个函数的实现如下：</p>
<pre><code><span class="tag">vm_map_offset_t</span>
<span class="tag">vm_compute_max_offset</span>(boolean_t is64)
{
<span class="id">#if</span> <span class="tag">defined</span>(__arm__) || <span class="tag">defined</span>(__arm64__)
    <span class="tag">return</span> (<span class="function">pmap_max_offset</span>(is64, ARM_PMAP_MAX_OFFSET_DEVICE));
<span class="id">#else</span>
    <span class="tag">return</span> (is64 ? (vm_map_offset_t)<span class="attribute">MACH_VM_MAX_ADDRESS </span>: (vm_map_offset_t)VM_MAX_ADDRESS);
<span class="id">#endif</span>
}
</code></pre><p>继续往下看：</p>
<pre><code><span class="keyword">vm_map_offset_t</span> pmap_max_offset(
    <span class="keyword">boolean_t</span>    is64 __unused,
    <span class="keyword">unsigned</span> <span class="keyword">int</span>    option)
{
    <span class="keyword">vm_map_offset_t</span>    max_offset_ret = <span class="number">0</span>;

<span class="preprocessor">#<span class="keyword">if</span> defined(__arm64__)</span>
    assert (is64);
    <span class="keyword">vm_map_offset_t</span> min_max_offset = SHARED_REGION_BASE_ARM64 + SHARED_REGION_SIZE_ARM64 + <span class="number">0x20000000</span>; <span class="comment">// end of shared region + 512MB for various purposes</span>
    <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEFAULT) {
        max_offset_ret = arm64_pmap_max_offset_default;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MIN) {
        max_offset_ret = min_max_offset;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MAX) {
        max_offset_ret = MACH_VM_MAX_ADDRESS;
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEVICE) {
        <span class="keyword">if</span> (arm64_pmap_max_offset_default) {
            max_offset_ret = arm64_pmap_max_offset_default;
        } <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) {
            max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="comment">// Max offset is 12.375GB for devices with &gt; 3GB of memory</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) {
            max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="comment">// Max offset is 8.375GB for devices with &gt; 1GB and &lt;= 3GB of memory</span>
        } <span class="keyword">else</span> {
            max_offset_ret = min_max_offset;
        }
    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_JUMBO) {
        max_offset_ret = <span class="number">0x0000000518000000</span>ULL;     <span class="comment">// Max offset is 20.375GB for pmaps with special "jumbo" blessing</span>
    } <span class="keyword">else</span> {
        panic(<span class="string">"pmap_max_offset illegal option 0x%x\n"</span>, option);
    }

    assert(max_offset_ret &gt;= min_max_offset);
    <span class="keyword">return</span> max_offset_ret;
</code></pre><p>其实关键点就是这里的代码：</p>
<pre><code><span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) {
    max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="regexp">//</span> <span class="constant">Max</span> offset is <span class="number">12.375</span>GB <span class="keyword">for</span> devices <span class="keyword">with</span> &gt; <span class="number">3</span>GB <span class="keyword">of</span> memory
} <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) {
    max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="regexp">//</span> <span class="constant">Max</span> offset is <span class="number">8.375</span>GB <span class="keyword">for</span> devices <span class="keyword">with</span> &gt; <span class="number">1</span>GB and &lt;= <span class="number">3</span>GB <span class="keyword">of</span> memory
} <span class="keyword">else</span> {
    max_offset_ret = min_max_offset;
}
</code></pre><p><code>max_offset_ret</code>这个值就代表了我们任务对应的<code>vm_map_t</code>的最大地址范围，比如说这里是8.375GB。</p>
<h3 id="虚拟内存分配的限制">虚拟内存分配的限制</h3><p>好，在说了那么多前置知识后，我们言归正传，来谈谈为什么虚拟内存有限制。</p>
<p>之前我们提到了<code>large_malloc</code>会走入到最后的<code>vm_map_enter</code>，那么我们来看看<code>vm_map_enter</code>的实现：</p>
<pre><code>vm_map_enter(
    <span class="keyword">vm_map_t</span>        <span class="built_in">map</span>,
    <span class="keyword">vm_map_offset_t</span>        *address,    <span class="comment">/* IN/OUT */</span>
    <span class="keyword">vm_map_size_t</span>        size,
    <span class="keyword">vm_map_offset_t</span>        mask,
    <span class="keyword">int</span>            flags,
    <span class="keyword">vm_map_kernel_flags_t</span>    vmk_flags,
    <span class="keyword">vm_tag_t</span>        alias,
    <span class="keyword">vm_object_t</span>        object,
    <span class="keyword">vm_object_offset_t</span>    offset,
    <span class="keyword">boolean_t</span>        needs_copy,
    <span class="keyword">vm_prot_t</span>        cur_protection,
    <span class="keyword">vm_prot_t</span>        max_protection,
    <span class="keyword">vm_inherit_t</span>        inheritance)
{

<span class="preprocessor">#<span class="keyword">if</span> CONFIG_EMBEDDED</span>
    <span class="comment">// 注意点1:检查页的权限</span>
    <span class="keyword">if</span> (cur_protection &amp; VM_PROT_WRITE){
        <span class="keyword">if</span> ((cur_protection &amp; VM_PROT_EXECUTE) &amp;&amp; !entry_for_jit){
            <span class="built_in">printf</span>(<span class="string">"EMBEDDED: %s: curprot cannot be write+execute. "</span>
                   <span class="string">"turning off execute\n"</span>,
                   __FUNCTION__);
            cur_protection &amp;= ~VM_PROT_EXECUTE;
        }
    }
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>

    <span class="keyword">if</span> (resilient_codesign || resilient_media) {
        <span class="keyword">if</span> ((cur_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE)) ||
            (max_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE))) {
            <span class="keyword">return</span> KERN_PROTECTION_FAILURE;
        }
    }

    <span class="comment">// 1. 获取任务的可用的地址最小值和最大值</span>
    effective_min_offset = <span class="built_in">map</span>-&gt;min_offset;
    effective_max_offset = <span class="built_in">map</span>-&gt;max_offset;

    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;pmap == kernel_pmap) {
        user_alias = VM_KERN_MEMORY_NONE;
    } <span class="keyword">else</span> {
        user_alias = alias;
    }

<span class="preprocessor">#<span class="keyword">define</span>    RETURN(value)    { result = value; goto BailOut; }</span>

    assert(page_aligned(*address));
    assert(page_aligned(size));

    <span class="keyword">if</span> (!VM_MAP_PAGE_ALIGNED(size, VM_MAP_PAGE_MASK(<span class="built_in">map</span>))) {
        clear_map_aligned = TRUE;
    }

StartAgain: ;

    start = *address;

    <span class="keyword">if</span> (anywhere) {
        vm_map_lock(<span class="built_in">map</span>);
        map_locked = TRUE;

        <span class="keyword">if</span> (start &lt; effective_min_offset)
            start = effective_min_offset;
        <span class="keyword">if</span> (start &gt; effective_max_offset)
            RETURN(KERN_NO_SPACE);


        <span class="keyword">if</span>( FALSE ) {

        } <span class="keyword">else</span> {

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                hole_entry = (<span class="keyword">vm_map_entry_t</span>)<span class="built_in">map</span>-&gt;holes_list;

                <span class="keyword">if</span> (hole_entry == <span class="literal">NULL</span>) {
                    <span class="comment">/*
                     * No more space in the map?
                     */</span>
                    result = KERN_NO_SPACE;
                    <span class="keyword">goto</span> BailOut;
                } <span class="keyword">else</span> {

                    <span class="keyword">boolean_t</span> found_hole = FALSE;

                    <span class="keyword">do</span> {
                        <span class="keyword">if</span> (hole_entry-&gt;vme_start &gt;= start) {
                            start = hole_entry-&gt;vme_start;
                            found_hole = TRUE;
                            <span class="keyword">break</span>;
                        }

                        <span class="keyword">if</span> (hole_entry-&gt;vme_end &gt; start) {
                            found_hole = TRUE;
                            <span class="keyword">break</span>;
                        }
                        hole_entry = hole_entry-&gt;vme_next;

                    } <span class="keyword">while</span> (hole_entry != (<span class="keyword">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list);

                    <span class="keyword">if</span> (found_hole == FALSE) {
                        result = KERN_NO_SPACE;
                        <span class="keyword">goto</span> BailOut;
                    }

                    entry = hole_entry;

                    <span class="keyword">if</span> (start == <span class="number">0</span>)
                        start += PAGE_SIZE_64;
                }
            }
        }

        <span class="keyword">while</span> (TRUE) {
            <span class="keyword">vm_map_entry_t</span>    next;

            end = ((start + mask) &amp; ~mask);
            end = vm_map_round_page(end,
                        VM_MAP_PAGE_MASK(<span class="built_in">map</span>));

            <span class="keyword">if</span> (end &lt; start)
                RETURN(KERN_NO_SPACE);

            start = end;
            end += size;

            <span class="keyword">if</span> ((end &gt; effective_max_offset) || (end &lt; start)) {
                RETURN(KERN_NO_SPACE);
            }

            next = entry-&gt;vme_next;

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                <span class="keyword">if</span> (entry-&gt;vme_end &gt;= end)
                    <span class="keyword">break</span>;
            } <span class="keyword">else</span> {

                <span class="keyword">if</span> (next == vm_map_to_entry(<span class="built_in">map</span>))
                    <span class="keyword">break</span>;

                <span class="keyword">if</span> (next-&gt;vme_start &gt;= end)
                    <span class="keyword">break</span>;
            }

            entry = next;

            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
                <span class="keyword">if</span> (entry == (<span class="keyword">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list) {
                    result = KERN_NO_SPACE;
                    <span class="keyword">goto</span> BailOut;
                }
                start = entry-&gt;vme_start;
            } <span class="keyword">else</span> {
                start = entry-&gt;vme_end;
            }

            start = vm_map_round_page(start,
                          VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
        }

        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) {
            <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, entry-&gt;vme_start, &amp;entry)) {
                panic(<span class="string">"Found an existing entry (%p) instead of potential hole at address: 0x%llx.\n"</span>, entry, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)entry-&gt;vme_start);
            }
        }

        *address = start;
    } 
</code></pre><ul>
<li>注意点1：基本上就是检查页的权限啥的，iOS上不允许可写和可执行并存。</li>
<li>剩下的就是作各种前置检查</li>
</ul>
<p>老实说，我一开始看苹果这最新的XNU代码，我压根没读懂。这一堆<code>hole</code>啥的在干啥，后来我就往之前XNU版本翻了翻，果然好懂了很多：</p>
<pre><code>entry = <span class="built_in">map</span><span class="subst">-&gt;</span>first_free;

<span class="keyword">if</span> (entry == vm_map_to_entry(<span class="built_in">map</span>)) {
    entry = <span class="built_in">NULL</span>;
} <span class="keyword">else</span> {
       <span class="keyword">if</span> (entry<span class="subst">-&gt;</span>vme_next == vm_map_to_entry(<span class="built_in">map</span>)){
            entry = <span class="built_in">NULL</span>;
       } <span class="keyword">else</span> {
            <span class="keyword">if</span> (start &lt; (entry<span class="subst">-&gt;</span>vme_next)<span class="subst">-&gt;</span>vme_start ) {
                start = entry<span class="subst">-&gt;</span>vme_end;
                start = vm_map_round_page(start,
                              VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
            } <span class="keyword">else</span> {
                entry = <span class="built_in">NULL</span>;
            }
       }
}

<span class="keyword">if</span> (entry == <span class="built_in">NULL</span>) {
    vm_map_entry_t    tmp_entry;
    <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, start, <span class="subst">&amp;</span>tmp_entry)) {
        assert(<span class="subst">!</span>entry_for_jit);
        start = tmp_entry<span class="subst">-&gt;</span>vme_end;
        start = vm_map_round_page(start,
                      VM_MAP_PAGE_MASK(<span class="built_in">map</span>));
    }
    entry = tmp_entry;
}
</code></pre><ul>
<li><p>整个这段代码的意思是，就是要我们要找个一个比我们这个<code>start</code>地址大的<code>vm_entry_t</code>。(这句话比较绕口)，<b style="color:red">我们最终的目的是为了在两个已经存在<code>vm_entry_t</code>之间尝试插入一个能包含从<code>start</code>到<code>start + size</code>的新的<code>vm_entry_t</code></b></p>
</li>
<li><p>如果没找到的话，就尝试利用<code>vm_map_lookup_entry</code>找一个<code>preceding</code>我们地址的的<code>vm_entry_t</code>。</p>
</li>
</ul>
<p>好，现在我们找到了一个满足<code>start</code>其实地址条件的<code>vm_entry_t</code>了，剩下就是要满足分配大小<code>size</code>的需求了。</p>
<pre><code><span class="label">while</span> (TRUE) {
    register vm_map_entry_t    next<span class="comment">;</span>

    <span class="preprocessor">end</span> = ((start + mask) &amp; ~mask)<span class="comment">;</span>
    <span class="preprocessor">end</span> = vm_map_round_page(<span class="preprocessor">end</span>,
                VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>))<span class="comment">;</span>
    <span class="preprocessor">if</span> (<span class="preprocessor">end</span> &lt; start)
        RETURN(KERN_NO_SPACE)<span class="comment">;</span>

    start = <span class="preprocessor">end</span><span class="comment">;</span>
    <span class="preprocessor">end</span> += size<span class="comment">;</span>

    <span class="preprocessor">if</span> ((<span class="preprocessor">end</span> &gt; effective_max_offset) <span class="title">||</span> (<span class="preprocessor">end</span> &lt; start)) {
        RETURN(KERN_NO_SPACE)<span class="comment">;</span>
    }

    next = <span class="preprocessor">entry</span>-&gt;vme_next<span class="comment">;</span>

    // 如果是空的头
    <span class="preprocessor">if</span> (next == vm_map_to_entry(<span class="preprocessor">map</span>))
        <span class="keyword">break;
</span>
    // 如果下一个的start 
    <span class="preprocessor">if</span> (next-&gt;vme_start &gt;= <span class="preprocessor">end</span>)
        <span class="keyword">break;
</span>
    <span class="preprocessor">entry</span> = next<span class="comment">;</span>
    start = <span class="preprocessor">entry</span>-&gt;vme_end<span class="comment">;</span>
    start = vm_map_round_page(start,
                  VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>))<span class="comment">;</span>
}
*<span class="keyword">address </span>= start<span class="comment">;</span>
<span class="label">assert</span>(VM_MAP_PAGE_ALIGNED(*<span class="keyword">address,
</span>               VM_MAP_PAGE_MASK(<span class="preprocessor">map</span>)))<span class="comment">;</span>
</code></pre><p>这段代码相对来说就很简单了，我们判断<code>start + size</code>是不是可以正好插入在<code>vm_entry_t</code>代表的地址范围的空隙内，如果一直遍历到最后的任务地址上限都找不到，那就说明不存在我们需求的连续的虚拟内存空间用于作分配了。</p>
<h3 id="其他">其他</h3><p>除了本文说明的虚拟内存分配的连续性限制以外，虚拟内存作为堆内存分配的一种，在布局范围上也有限制。此文不表，且听下回分解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2018/01/14/iOS-virtual/" data-id="ck9fy2ge6000q2ni1xpfg4g1q" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2018/01/14/iOS-virtual/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XNU/">XNU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-KVO-Swizzle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/KVO-Swizzle/" class="article-date">
  <time datetime="2017-11-26T16:08:28.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/KVO-Swizzle/">一种基于KVO的页面加载，渲染耗时监控方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>打广告：有兴趣加入阿里巴巴手淘基础架构平台移动高可用团队的请微博联系我@盗版五子棋</p>
<p>和同事zb一起维护了一个ARM64的专栏<a href="https://zhuanlan.zhihu.com/c_142064221" target="_blank" rel="external">iOS调试进阶</a>，有兴趣的可以读读</p>
</blockquote>
<p>在介绍本文之前，请先允许我提出一个问题，如果你要无痕监控任意一个页面（UIViewController及其子类）的加载或者渲染时间，你会怎么做。</p>
<p>很多人都会想到说用AOP啊，利用<code>Method Swizzling</code>来进行方法替换从而获得方法调用耗时。<br>比如我们有一个<code>ViewController</code>，如果其实现了一个<code>viewDidLoad</code>方法进行睡眠<strong>5</strong>秒，如下所示：</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>

- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
    sleep(<span class="number">5</span>);
}

<span class="keyword">@end</span>
</code></pre><p>相信很多人的第一直觉会是如下AOP代码（我们省略Method Swizzling相关的代码）：</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">TestCase</span>)</span>

+ (<span class="keyword">void</span>)load
{
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
        wzq_swizzleMethod([<span class="built_in">UIViewController</span> class], <span class="keyword">@selector</span>(viewDidLoad), <span class="keyword">@selector</span>(wzq_viewDidLoad));
    });
}

- (<span class="keyword">void</span>)wzq_viewDidLoad
{
    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];
    [<span class="keyword">self</span> wzq_viewDidLoad];

    <span class="built_in">NSTimeInterval</span> duration = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:date];
    <span class="built_in">NSLog</span>(<span class="string">@"Page %@ cost %g in viewDidLoad"</span>, [<span class="keyword">self</span> class], duration); 
}

<span class="keyword">@end</span>
</code></pre><p>但是，如果你自己尝试了你会发现，你测算的时间压根不是<span style="color:red"><strong>5</strong></span>秒。</p>
<p>为什么呢？其原因在于我们<code>Method Swizzling</code>的时候，因为采用了对基类<code>UIViewController</code>进行替换，获取到的<code>viewDidLoad</code>对应的IMP是属于基类<code>UIViewController</code>的，而并不是<code>ViewController</code>自身覆写的，所以我们监控的其实从子类<code>ViewController</code>调用<code>[super viewDidLoad]</code>的时候调用基类IMP的耗时。</p>
<p>好，看到这，有人就想了对应的方法，把<code>-[ViewController viewDidLoad]</code>的IMP替换掉就行了。方法很多种，比如创建一个<code>ViewController</code>的<strong>Category</strong>进行替换。<strong>但是这种方法你好像没办法任意对某个页面进行替换。</strong></p>
<blockquote>
<p>有人说你可以runtime遍历所有类判断是不是<code>UIViewController</code>的子类，然后动态替换。理论是可行的，效率嘛，是比较低的。</p>
</blockquote>
<h3 id="方案">方案</h3><p>根据上述我们所知的缺陷，我们需要有一个兼顾动态性和性能的方案，能够直接获取到子类的IMP，这样才能达到我们对于页面加载渲染时间（<code>viewDidLoad</code>, <code>viewDidAppear</code>和<code>viewWillAppear</code>）监控的需求。</p>
<p>基于这个需求，我很快想到了<strong>基于KVO</strong>的方案（如果你对KVO不了解，可以参考<a href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/">我的文章：KVO在不同的二进制中多个符号并存的Crash问题</a>）。我们知道，在对于任意对象进行KVO监控的时候，iOS底层实际上帮你动态创建了一个隐蔽的类，同时帮了做了大量的<code>setter，getter</code>函数的override，并调用原来类对应函数实现，从而让你神不知鬼不觉的以为你还在用原来的类进行操作。</p>
<p>那我们该怎么做呢？</p>
<ol>
<li>对我们需要监听的类的实例进行KVO，随便监听一个不存在的KeyPath。我们压根不需要KVO的任何回调，我们只是需要它能帮我们<strong>创建子类</strong>而已。</li>
<li>对KVO创建出来的子类添加我们需要Swizzle的方法对应的SEL及其IMP。因为本质上KVO只是对setter和getter方法进行了<strong>override</strong>，<b style="color:red">如果我们不提供我们自己的实现，还是会调用到原来的类的IMP。</b></li>
<li>在实例销毁的时候，将KVO监听移除，不然会导致<b style="color:red">KVO still registering when deallocated这样的Crash。</b></li>
</ol>
<p>总体来说，我们需要做的就是三件事。</p>
<h4 id="1-_对实例进行KVO">1. 对实例进行KVO</h4><p>KVO方法只能在对象实例上进行操作，我们首先要获取到的就是<code>UIViewController</code>及其子类的实例。</p>
<p>遍历头文件，发现UIViewController的初始化方法比较少，归纳为如下三种：</p>
<pre><code>init
<span class="string">initWithCoder:</span>
<span class="string">initWithNibName:</span><span class="string">bundle:</span>
</code></pre><p>我们先Swizzle这几个方法：</p>
<pre><code> wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">initWithNibName</span><span class="keyword">:bundle</span>:)</span>, @selector<span class="list">(<span class="keyword">wzq_initWithNibName</span><span class="keyword">:bundle</span>:)</span>)</span><span class="comment">;</span>
wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">initWithCoder</span>:)</span>, @selector<span class="list">(<span class="keyword">wzq_initWithCoder</span>:)</span>)</span><span class="comment">;</span>
wzq_swizzleMethod<span class="list">([UIViewController class], @selector<span class="list">(<span class="keyword">init</span>)</span>, @selector<span class="list">(<span class="keyword">wzq_init</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>这几个方法调用的时候，实例对象对应的内存已经分配出来了，无非就是构造函数还没赋值，但是我们也能进行KVO了。KVO的代码如下所示：</p>
<pre><code>NSString *identifier = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"wzq_%@"</span>, [[NSProcessInfo processInfo] globallyUniqueString]];
[vc <span class="string">addObserver:</span>[NSObject <span class="keyword">new</span>] <span class="string">forKeyPath:</span>identifier <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
</code></pre><h4 id="2-_添加我们想要的方法">2. 添加我们想要的方法</h4><p>我们刚刚已经对页面实例进行了KVO操作，此时对于原先类别为<code>ViewController</code>的<code>vc</code>对象来说，内部其实已经变成<b style="color:red">NSKVONotifying_ViewController类型了。</b>。如果我们想对其所在的类型添加方法的话，不能直接用<code>[vc class]</code>，因为这个方法已经被内部override成了<code>ViewController</code>。我们需要使用<code>object_getClass</code>这个类进行真正的类型获取，如下所示：</p>
<pre><code> <span class="comment">// NSKVONotifying_ViewController</span>
Class kvoCls = <span class="keyword">object</span><span class="number">_</span>getClass(vc);
<span class="comment">// ViewController</span>
Class originCls = <span class="keyword">class</span><span class="number">_</span>getSuperclass(kvoCls);

<span class="comment">// 获取原来实现的encoding</span>
const char *originViewDidLoadEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewDidLoad)));
const char *originViewDidAppearEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewDidAppear:)));
const char *originViewWillAppearEncoding = method<span class="number">_</span>getTypeEncoding(<span class="keyword">class</span><span class="number">_</span>getInstanceMethod(originCls, <span class="annotation">@selector</span>(viewWillAppear:)));

<span class="comment">// 重点，添加方法。</span>
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewDidLoad), (IMP)wzq<span class="number">_</span>viewDidLoad, originViewDidLoadEncoding);
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewDidAppear:), (IMP)wzq<span class="number">_</span>viewDidAppear, originViewDidAppearEncoding);
<span class="keyword">class</span><span class="number">_</span>addMethod(kvoCls, <span class="annotation">@selector</span>(viewWillAppear:), (IMP)wzq<span class="number">_</span>viewWillAppear, originViewWillAppearEncoding);
</code></pre><p>上述代码非常通俗易懂，不再赘述，替换完的方法如下，我们以<code>wzq_viewDidLoad</code>举例：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> wzq_viewDidLoad(<span class="built_in">UIViewController</span> *kvo_self, SEL _sel)
{
    Class kvo_cls = object_getClass(kvo_self);
    Class origin_cls = class_getSuperclass(kvo_cls);

    <span class="comment">// 注意点</span>
    IMP origin_imp = method_getImplementation(class_getInstanceMethod(origin_cls, _sel));
    assert(origin_imp != <span class="literal">NULL</span>);

    <span class="keyword">void</span>(*func)(<span class="built_in">UIViewController</span> *, SEL) =  (<span class="keyword">void</span>(*)(<span class="built_in">UIViewController</span> *, SEL))origin_imp;

    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];

    func(kvo_self, _sel);

    <span class="built_in">NSTimeInterval</span> duration = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:date];
    <span class="built_in">NSLog</span>(<span class="string">@"Class %@ cost %g in viewDidLoad"</span>, [kvo_self class], duration);
}
</code></pre><p>重点关注下上述代码中的<b style="color:red">注意点</b>，之前我们在KVO生成的类中对应添加了原本没有的实现，因此<code>-[ViewController viewDidLoad]</code>会走到我们的<code>wzq_viewDidLoad</code>方法中，但是我们怎么才能调用到原来的<code>viewDidLoad</code>的呢？我们之前并没有保存对应的IMP呀。</p>
<p><b style="color:red">这里还是利用了KVO的特殊性：内部生成的NSKVONotifying_ViewController实际上是继承自ViewController的</b></p>
<p>因此，<code>Class origin_cls = class_getSuperclass(kvo_cls);</code>实际上获取到了<code>ViewController</code>类，我们从中取出对应的IMP，进行直接调用即可。</p>
<h4 id="3-_移除KVO">3. 移除KVO</h4><p>我们利用Associate Object去移除就好了。一个对象释放的时候会自动去清除其所在的<code>assoicate object</code>。</p>
<p>基于这个原理，我们可以实现如下代码：</p>
<p>我们构建一个桩，把所有无用的KVO监听都设置给这个桩，如下所示：</p>
<pre><code><span class="attr_selector">[vc addObserver:[WZQKVOObserverStub stub]</span> <span class="tag">forKeyPath</span><span class="pseudo">:identifier</span> <span class="tag">options</span><span class="pseudo">:NSKeyValueObservingOptionNew</span> <span class="tag">context</span><span class="pseudo">:nil</span>];
</code></pre><p>然后我们构建一个移除器，这个移除器弱引用保存了vc的实例和对应的keypath，如下：</p>
<pre><code>WZQKVORemover *remover = [WZQKVORemover new]<span class="comment">;</span>
remover.obj = vc<span class="comment">;</span>
remover.keyPath = identifier.copy<span class="comment">;</span>
</code></pre><p>然后我们把这个移除器利用<code>associate object</code>设置给对应的vc。</p>
<pre><code>objc_setAssociatedObject<span class="list">(<span class="keyword">vc</span>, <span class="keyword">&amp;wzq_associateRemoveKey</span>, remover, OBJC_ASSOCIATION_RETAIN)</span><span class="comment">;</span>
</code></pre><p>而在对应的移除器的<code>dealloc</code>方法里，我们把kvo监听给移除就可以了。</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span>
{
<span class="id">#ifdef</span> <span class="tag">DEBUG</span>
    <span class="tag">NSLog</span>(@<span class="string">"WZQKVORemover called"</span>);
<span class="id">#endif</span>
    <span class="tag">if</span> (_obj) {
        <span class="attr_selector">[_obj removeObserver:[WZQKVOObserverStub stub]</span> <span class="tag">forKeyPath</span><span class="pseudo">:_keyPath</span>];
    }
}
</code></pre><h3 id="额外">额外</h3><p>利用<code>associate object</code>移除KVO的正确性是有保障的，具体见runtime中<code>associate object</code>的源码：</p>
<pre><code><span class="type">void</span> objc_removeAssociatedObjects(id <span class="keyword">object</span>) 
{
    <span class="keyword">if</span> (<span class="keyword">object</span> &amp;&amp; <span class="keyword">object</span>-&gt;hasAssociatedObjects()) {
        _object_remove_assocations(<span class="keyword">object</span>);
    }
}

<span class="type">void</span> _object_remove_assocations(id <span class="keyword">object</span>) {
    vector&lt; <span class="type">ObjcAssociation</span>,<span class="type">ObjcAllocator</span>&lt;<span class="type">ObjcAssociation</span>&gt; &gt; elements;
    {
        <span class="type">AssociationsManager</span> manager;
        <span class="type">AssociationsHashMap</span> &amp;associations(manager.associations());
        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;
        disguised_ptr_t disguised_object = <span class="type">DISGUISE</span>(<span class="keyword">object</span>);
        <span class="type">AssociationsHashMap</span>::<span class="keyword">iterator</span> i = associations.find(disguised_object);
        <span class="keyword">if</span> (i != associations.<span class="keyword">end</span>()) {
            // copy all <span class="keyword">of</span> the associations that need to be removed.
            <span class="type">ObjectAssociationMap</span> *refs = i-&gt;second;
            <span class="keyword">for</span> (<span class="type">ObjectAssociationMap</span>::<span class="keyword">iterator</span> j = refs-&gt;begin(), <span class="keyword">end</span> = refs-&gt;<span class="keyword">end</span>(); j != <span class="keyword">end</span>; ++j) {
                elements.push_back(j-&gt;second);
            }
            // remove the secondary table.
            delete refs;
            associations.erase(i);
        }
    }
    // the calls to releaseValue() happen outside <span class="keyword">of</span> the lock.
    for_each(elements.begin(), elements.<span class="keyword">end</span>(), <span class="type">ReleaseValue</span>());
}
</code></pre><h3 id="代码">代码</h3><p>本文的工程代码托管在<a href="">Github</a>上，包含了测试用例（默认带干扰测试），还没来得及搞成cocoapods，等我有时间了搞一下。但是你直接拖拽源码使用是一点问题都没有。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/11/27/KVO-Swizzle/" data-id="ck9fy2gi5003m2ni1vj0njka7" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/11/27/KVO-Swizzle/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-load-twice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/02/load-twice/" class="article-date">
  <time datetime="2017-11-01T16:55:05.000Z" itemprop="datePublished">2017-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/02/load-twice/">注意系统库的坑之load函数调用多次</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>水文一篇</p>
</blockquote>
<p>今天在群友逆向企业微信的时候，发现了一个比较有意思的现象了，发现对于<code>NSObject</code>添加的<code>load</code>的方法执行了两次，导致原本意图的<code>Swizzle</code>出现了问题。</p>
<p>之前在个人的理解中，<code>load</code>和<code>initialize</code>函数有所不同，<code>load</code>是在加载二进制程序的时候，将这些二进制程序中的类中包含的<code>load</code>方法进行一一调用，调用过程中不会有调用父类的情况。而<code>initialize</code>则不同，是在类第一次使用的过程中进行调用，同时也会有过程中调用父类的情况。</p>
<p><strong>所以，今天一开始这个情况有点懵逼啊，来看看究竟是为啥。</strong></p>
<h2 id="准备工作（略）">准备工作（略）</h2><ol>
<li>PP助手上下载一个企业微信</li>
<li>重签名 -&gt; Build</li>
<li><p>写一个诸如下面这么简单的<code>NSObject Category</code>，并实现<code>+(void)Load</code>方法</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">injectLocation</span>)</span>
+ (<span class="keyword">void</span>)load
{
    <span class="built_in">NSLog</span>(<span class="string">@"我好弱"</span>);
}
<span class="keyword">@end</span>
</code></pre></li>
</ol>
<h2 id="排查过程">排查过程</h2><p>按照我们对<code>load</code>函数的理解，程序加载开始的时候，会通过<code>libobjc</code>的<code>call_load_methods</code>遍历逐一执行所有的<code>load</code>方法，如下图印证：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/load_twice_2.png?raw=true" alt=""></p>
<p>一开始当我在使用iOS 10.3.3的设备进行测试的时候，这就是唯一一次调用，没有二次重入的状况。</p>
<p>于是我按照群友的提示换了iOS 11的设备，果不其然，iOS 11的企业微信在登录过程中，会再次调用我这个分类的<code>load</code>方法，让我们一起来看看调用栈：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/load_twice_1.png?raw=true" alt=""></p>
<p>卧槽，又从<code>WebThread</code>这个类里面进行了调用了<code>load</code>，匪夷所思啊。</p>
<p>lldb调试下，结果如下：</p>
<pre><code>frame <span class="preprocessor">#<span class="number">0</span>: <span class="number">0x0000000107a2558c</span> libZXLQYWechatDylib.dylib`+[NSObject(self=SKUIMetricsAppLaunchEvent, _cmd=<span class="string">"load"</span>) load] at TestCategory.m:<span class="number">15</span></span>
frame <span class="preprocessor">#<span class="number">1</span>: <span class="number">0x0000000196767f9c</span> StoreKitUI`+[SKUIMetricsAppLaunchEvent load] + <span class="number">44</span></span>
frame <span class="preprocessor">#<span class="number">2</span>: <span class="number">0x00000001807fa91c</span> libobjc.A.dylib`call_load_methods + <span class="number">184</span></span>
frame <span class="preprocessor">#<span class="number">3</span>: <span class="number">0x00000001807fba84</span> libobjc.A.dylib`load_images + <span class="number">76</span></span>
frame <span class="preprocessor">#<span class="number">4</span>: <span class="number">0x00000001074e6170</span> dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + <span class="number">488</span></span>
frame <span class="preprocessor">#<span class="number">5</span>: <span class="number">0x00000001074f6ce8</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">348</span></span>
frame <span class="preprocessor">#<span class="number">6</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">7</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">8</span>: <span class="number">0x00000001074f6c90</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">260</span></span>
frame <span class="preprocessor">#<span class="number">9</span>: <span class="number">0x00000001074f5d40</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">136</span></span>
frame <span class="preprocessor">#<span class="number">10</span>: <span class="number">0x00000001074f5dfc</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">84</span></span>
frame <span class="preprocessor">#<span class="number">11</span>: <span class="number">0x00000001074e979c</span> dyld`dyld::runInitializers(ImageLoader*) + <span class="number">88</span></span>
frame <span class="preprocessor">#<span class="number">12</span>: <span class="number">0x00000001074f0324</span> dyld`dlopen + <span class="number">976</span></span>
frame <span class="preprocessor">#<span class="number">13</span>: <span class="number">0x0000000180ccf4d4</span> libdyld.dylib`dlopen + <span class="number">116</span></span>
frame <span class="preprocessor">#<span class="number">14</span>: <span class="number">0x0000000189caec58</span> WebCore`initWebFilterEvaluator() + <span class="number">36</span></span>
</code></pre><p>从上述链路看起来：<code>WebCore</code>通过<code>dlopen</code>加载了<code>/System/Library/PrivateFrameworks/StoreKitUI.framework/StoreKitUI</code>这个动态库，然后动态库加载完成后，执行了和主二进制一样的<code>call_load_methods</code>过程。</p>
<p>逐一执行<code>load</code>的过程中，会调用到这个类<code>SKUIMetricsAppLaunchEvent</code>，然后这个类执行的汇编我们看看：</p>
<pre><code>StoreKitUI`+[SKUIMetricsAppLaunchEvent load]:
-&gt;  <span class="number">0x196767f70</span> &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="preprocessor">#<span class="number">0x20</span>             ; =<span class="number">0x20</span> </span>
    <span class="number">0x196767f74</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x196767f78</span> &lt;+<span class="number">8</span>&gt;:  add    x29, sp, <span class="preprocessor">#<span class="number">0x10</span>            ; =<span class="number">0x10</span> </span>
    <span class="number">0x196767f7c</span> &lt;+<span class="number">12</span>&gt;: str    x0, [sp]
    <span class="number">0x196767f80</span> &lt;+<span class="number">16</span>&gt;: adrp   x8, <span class="number">108130</span>
    <span class="number">0x196767f84</span> &lt;+<span class="number">20</span>&gt;: ldr    x8, [x8, <span class="preprocessor">#<span class="number">0xff8</span>]</span>
    <span class="number">0x196767f88</span> &lt;+<span class="number">24</span>&gt;: str    x8, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    <span class="number">0x196767f8c</span> &lt;+<span class="number">28</span>&gt;: adrp   x8, <span class="number">108114</span>
    <span class="number">0x196767f90</span> &lt;+<span class="number">32</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xf70</span>]</span>
    <span class="number">0x196767f94</span> &lt;+<span class="number">36</span>&gt;: mov    x0, sp
    <span class="number">0x196767f98</span> &lt;+<span class="number">40</span>&gt;: bl     <span class="number">0x1902ccaac</span>
    <span class="number">0x196767f9c</span> &lt;+<span class="number">44</span>&gt;: adrp   x8, <span class="number">111804</span>
    <span class="number">0x196767fa0</span> &lt;+<span class="number">48</span>&gt;: ldr    x8, [x8, <span class="preprocessor">#<span class="number">0x6e0</span>]</span>
    <span class="number">0x196767fa4</span> &lt;+<span class="number">52</span>&gt;: cmn    x8, <span class="preprocessor">#<span class="number">0x1</span>                  ; =<span class="number">0x1</span> </span>
    <span class="number">0x196767fa8</span> &lt;+<span class="number">56</span>&gt;: b.ne   <span class="number">0x196767fb8</span>               ; &lt;+<span class="number">72</span>&gt;
    <span class="number">0x196767fac</span> &lt;+<span class="number">60</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x196767fb0</span> &lt;+<span class="number">64</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x20</span>             ; =<span class="number">0x20</span> </span>
    <span class="number">0x196767fb4</span> &lt;+<span class="number">68</span>&gt;: ret    
    <span class="number">0x196767fb8</span> &lt;+<span class="number">72</span>&gt;: adrp   x0, <span class="number">111804</span>
    <span class="number">0x196767fbc</span> &lt;+<span class="number">76</span>&gt;: add    x0, x0, <span class="preprocessor">#<span class="number">0x6e0</span>            ; =<span class="number">0x6e0</span> </span>
    <span class="number">0x196767fc0</span> &lt;+<span class="number">80</span>&gt;: adrp   x1, <span class="number">93832</span>
    <span class="number">0x196767fc4</span> &lt;+<span class="number">84</span>&gt;: add    x1, x1, <span class="preprocessor">#<span class="number">0xf60</span>            ; =<span class="number">0xf60</span> </span>
    <span class="number">0x196767fc8</span> &lt;+<span class="number">88</span>&gt;: bl     <span class="number">0x19684f598</span>               ; symbol stub <span class="keyword">for</span>: __copy_helper_block_<span class="number">.236</span>
    <span class="number">0x196767fcc</span> &lt;+<span class="number">92</span>&gt;: b      <span class="number">0x196767fac</span>               ; &lt;+<span class="number">60</span>&gt;
</code></pre><p>看起来没有关键字<code>stub for objc_msgSend</code>之类的关键字，那我们就重点关注几个跳转指令对应的地址。</p>
<p>排除掉 <code>b      0x196767fac</code>和<code>b.ne   0x196767fb8</code>，因为这两地址就属于本函数。</p>
<p>通过lldb一查询看看剩下的<code>0x1902ccaac</code>是干啥的，卧槽，没结果。那干脆断这个地址试试，然后继续执行，得到如下结果：</p>
<pre><code><span class="number">0x1902ccaac</span>: b      <span class="number">0x1886362ac</span>
<span class="number">0x1902ccab0</span>: b      <span class="number">0x188637ae8</span>
<span class="number">0x1902ccab4</span>: b      <span class="number">0x1886362e8</span>
<span class="number">0x1902ccab8</span>: b      <span class="number">0x1886365a4</span>
<span class="number">0x1902ccabc</span>: b      <span class="number">0x18863ada8</span>
<span class="number">0x1902ccac0</span>: b      <span class="number">0x1886365b4</span>
<span class="number">0x1902ccac4</span>: b      <span class="number">0x18863889c</span>
<span class="number">0x1902ccac8</span>: b      <span class="number">0x188636b2c</span>
</code></pre><p>好吧，看起来这是运行时创建的桥(trampoline)。继续断<code>0x1886362ac</code>，然后执行：</p>
<pre><code><span class="number">0x1886362</span>ac: b      <span class="number">0x18080c62</span>0               <span class="comment">; objc_msgSendSuper2</span>
<span class="number">0x1886362</span>b0: b      <span class="number">0x180814250</span>               <span class="comment">; objc_release</span>
<span class="number">0x1886362</span>b4: b      <span class="number">0x180814190</span>               <span class="comment">; objc_retain</span>
<span class="number">0x1886362</span>b8: b      <span class="number">0x1808165f0</span>               <span class="comment">; objc_retainAutorelease</span>
<span class="number">0x1886362</span>bc: b      <span class="number">0x180816558</span>               <span class="comment">; objc_retainAutoreleaseReturnValue</span>
<span class="number">0x1886362</span>c0: b      <span class="number">0x180816588</span>               <span class="comment">; objc_retainAutoreleasedReturnValue</span>
<span class="number">0x1886362</span>c4: b      <span class="number">0x180802</span>fa8               <span class="comment">; class_addMethod</span>
<span class="number">0x1886362</span>c8: b      <span class="number">0x18080157</span>c               <span class="comment">; class_getInstanceMethod</span>
</code></pre><p>哈哈，看到我们想要的代码了：</p>
<p><strong>0x1886362ac: b      0x18080c620               ; objc_msgSendSuper2</strong></p>
<p>从这段汇编不难看出，在<code>+[SKUIMetricsAppLaunchEvent load]</code>方法里面，会调用<code>[super load]</code>这样的代码。</p>
<h3 id="为啥iOS_10上没有问题">为啥iOS 10上没有问题</h3><p>在iOS 10上其实也有同样的问题，但是由于<code>WebCore</code>不会主动把对应的<strong>StoreKitUI</strong>加载进来，所以也就没出触发这样的问题，但是如果我们主动通过<code>dlopen</code>加载这个系统库，也一样有问题：</p>
<pre><code>__attribute__((<span class="constructor"><span class="keyword">constructor</span>)) void load_private()
</span>{
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        <span class="built_in">void</span> *libHandleIMD = dlopen(<span class="string">"/System/Library/PrivateFrameworks/StoreKitUI.framework/StoreKitUI"</span>, RTLD_LAZY);
        NSLog(@<span class="string">"libHandleIMD is %p"</span>, libHandleIMD);
        <span class="keyword">if</span> (!libHandleIMD) {
            printf(<span class="string">"error is %s\n"</span>, dlerror());
        }
    });
}
</code></pre><h3 id="提醒">提醒</h3><p>对于在系统类上添加的<code>load</code>方法，建议还是做是否是重入的判断或者保护，不然很可能出现与预期不相符的结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/11/02/load-twice/" data-id="ck9fy2gdv000k2ni1lxavscz6" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/11/02/load-twice/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-abort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/18/abort/" class="article-date">
  <time datetime="2017-10-18T14:46:01.000Z" itemprop="datePublished">2017-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/18/abort/">iOS内存abort(Jetsam) 原理探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="招人">招人</h3><p>手淘架构组招人 iOS／Android 皆可，地点杭州，有兴趣的请联系我！！</p>
<h3 id="iOS内存abort(Jetsam)_原理探究">iOS内存abort(Jetsam) 原理探究</h3><p>苹果最近开源了iOS系统上的XNU内核代码，加上最近又开始负责手淘/猫客的稳定性及性能相关的工作，所以赶紧拜读下苹果的大作。今天主要开始想分析跟abort相关的内存Jetsam原理。</p>
<h3 id="什么是Jetsam">什么是Jetsam</h3><p>关于Jetsam，可能有些人还不是很理解。我们可以从<strong>手机设置-&gt;隐私-&gt;分析</strong>这条路径看看系统的日志，会发现手机上有许多<code>JetsamEvent</code>开头的日志。打开这些日志，一般会显示一些内存大小，CPU时间什么的数据。</p>
<p>之所以会发生这么JetsamEvent，主要还是由于iOS设备不存在交换区导致的内存受限，所以iOS内核不得不把一些<strong>优先级不高或者占用内存过大的</strong>杀掉。这些<code>JetsamEvent</code>就是系统在杀掉App后记录的一些数据信息。</p>
<p>从某种程度来说，JetsamEvent是一种另类的Crash事件，但是在常规的Crash捕获工具中，由于iOS上能捕获的信号量的限制，所以因为内存导致App被杀掉是无法被捕获的。为此，许多业界的前辈通过设计<code>flag</code>的方式自己记录所谓的<code>abort</code>事件来采集数据。但是这种采集的abort，一般情况下都只能简单的记录次数，而没有详细的堆栈。</p>
<h3 id="源码探究">源码探究</h3><p>MacOS/iOS是一个从BSD衍生而来的系统。其内核是Mach，但是对于上层暴露的接口一般都是基于BSD层对于Mach包装后的。虽然说Mach是个微内核的架构，真正的虚拟内存管理是在其中进行，但是BSD对于内存管理提供了相对较为上层的接口，同时，各种常见的<strong>JetSam事件也是由BSD产生</strong>，所以，我们从<code>bsd_init</code>这个函数作为入口，来探究下原理。</p>
<p><code>bsd_init</code>中基本都是在初始化各个子系统，比如虚拟内存管理等等。</p>
<p>跟内存相关的包括如下几步可能：</p>
<pre><code><span class="number">1.</span> 初始化BSD内存Zone，这个Zone是基于Mach内核的zone构建
kmeminit();

<span class="number">2.</span> iOS上独有的特性，内存和进程的休眠的常驻监控线程
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_FREEZE</span>
<span class="preprocessor">#<span class="keyword">ifndef</span> CONFIG_MEMORYSTATUS</span>
    <span class="preprocessor">#<span class="keyword">error</span> <span class="string">"CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS"</span></span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
    <span class="comment">/* Initialise background freezing */</span>
    bsd_init_kprintf(<span class="string">"calling memorystatus_freeze_init\n"</span>);
    memorystatus_freeze_init();
<span class="preprocessor">#<span class="keyword">endif</span>&gt;</span>

<span class="number">3.</span> iOS独有，JetSAM（即低内存事件的常驻监控线程）
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_MEMORYSTATUS</span>
    <span class="comment">/* Initialize kernel memory status notifications */</span>
    bsd_init_kprintf(<span class="string">"calling memorystatus_init\n"</span>);
    memorystatus_init();
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_MEMORYSTATUS */</span></span>
</code></pre><p>这两步代码都是调用<code>kern_memorystatus.c</code>里面暴露的接口，主要的作用就是从内核中开启了两个最高优先级的线程，来监控整个系统的内存情况。</p>
<p>首先先来看看<code>CONFIG_FREEZE</code>涉及的功能。当启用这个效果的时候，内核会对<strong>进程</strong>进行冷冻而不是Kill。</p>
<p>这个冷冻的功能是通过在内核中启动一个<code>memorystatus_freeze_thread</code>进行。这个线程在收到信号后调用<code>memorystatus_freeze_top_process</code>进行冷冻。</p>
<p>当然，涉及到进程休眠相关的代码，就需要谈谈苹果系统里面其他相关概念了。扯开又是一个比较大的话题，后续单独开文章来进行阐述。</p>
<p>回到iOS Abort问题上的话，我们只需要关注<code>memorystatus_init</code>即可，去除平台无关的代码后如下：</p>
<pre><code>__private_extern__ <span class="keyword">void</span>
memorystatus_init(<span class="keyword">void</span>)
{
    thread_t thread = THREAD_NULL;
    kern_return_t result;
    <span class="keyword">int</span> i;

    <span class="comment">/* Init buckets */</span>
    <span class="comment">// 注意点1：优先级数组，每个数组都持有了一个同优先级进程的列表</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MEMSTAT_BUCKET_COUNT; i++) {
        TAILQ_INIT(&amp;memstat_bucket[i]<span class="variable">.list</span>);
        memstat_bucket[i]<span class="variable">.count</span> = <span class="number">0</span>;
    }
    memorystatus_idle_demotion_call = thread_call_allocate((thread_call_func_t)memorystatus_perform_idle_demotion, <span class="literal">NULL</span>);

<span class="preprocessor">#if CONFIG_JETSAM</span>

    nanoseconds_to_absolutetime((uint64_t)DEFERRED_IDLE_EXIT_TIME_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_sysprocs_idle_delay_time);
    nanoseconds_to_absolutetime((uint64_t)DEFERRED_IDLE_EXIT_TIME_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_apps_idle_delay_time);

    <span class="comment">/* Apply overrides */</span>
    <span class="comment">// 注意点2：获取一系列内核参数</span>
    PE_get_default(<span class="string">"kern.jetsam_delta"</span>, &amp;delta_percentage, <span class="keyword">sizeof</span>(delta_percentage));
    <span class="keyword">if</span> (delta_percentage == <span class="number">0</span>) {
        delta_percentage = <span class="number">5</span>;
    }
    assert(delta_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_critical_threshold"</span>, &amp;critical_threshold_percentage, <span class="keyword">sizeof</span>(critical_threshold_percentage));
    assert(critical_threshold_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_idle_offset"</span>, &amp;idle_offset_percentage, <span class="keyword">sizeof</span>(idle_offset_percentage));
    assert(idle_offset_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_pressure_threshold"</span>, &amp;pressure_threshold_percentage, <span class="keyword">sizeof</span>(pressure_threshold_percentage));
    assert(pressure_threshold_percentage &lt; <span class="number">100</span>);
    PE_get_default(<span class="string">"kern.jetsam_freeze_threshold"</span>, &amp;freeze_threshold_percentage, <span class="keyword">sizeof</span>(freeze_threshold_percentage));
    assert(freeze_threshold_percentage &lt; <span class="number">100</span>);

    <span class="keyword">if</span> (!PE_parse_boot_argn(<span class="string">"jetsam_aging_policy"</span>, &amp;jetsam_aging_policy,
            <span class="keyword">sizeof</span> (jetsam_aging_policy))) {

        <span class="keyword">if</span> (!PE_get_default(<span class="string">"kern.jetsam_aging_policy"</span>, &amp;jetsam_aging_policy,
                <span class="keyword">sizeof</span>(jetsam_aging_policy))) {

            jetsam_aging_policy = kJetsamAgingPolicyLegacy;
        }
    }

    <span class="keyword">if</span> (jetsam_aging_policy &gt; kJetsamAgingPolicyMax) {
        jetsam_aging_policy = kJetsamAgingPolicyLegacy;
    }

    <span class="keyword">switch</span> (jetsam_aging_policy) {

        <span class="keyword">case</span> kJetsamAgingPolicyNone:
            system_procs_aging_band = JETSAM_PRIORITY_IDLE;
            applications_aging_band = JETSAM_PRIORITY_IDLE;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicyLegacy:
            <span class="comment">/*
             * Legacy behavior where some daemons get a 10s protection once
             * AND only before the first clean-&gt;dirty-&gt;clean transition before
             * going into IDLE band.
             */</span>
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            applications_aging_band = JETSAM_PRIORITY_IDLE;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicySysProcsReclaimedFirst:
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            applications_aging_band = JETSAM_PRIORITY_AGING_BAND2;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> kJetsamAgingPolicyAppsReclaimedFirst:
            system_procs_aging_band = JETSAM_PRIORITY_AGING_BAND2;
            applications_aging_band = JETSAM_PRIORITY_AGING_BAND1;
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
    }

    <span class="comment">/*
     * The aging bands cannot overlap with the JETSAM_PRIORITY_ELEVATED_INACTIVE
     * band and must be below it in priority. This is so that we don't have to make
     * our 'aging' code worry about a mix of processes, some of which need to age
     * and some others that need to stay elevated in the jetsam bands.
     */</span>
    assert(JETSAM_PRIORITY_ELEVATED_INACTIVE &gt; system_procs_aging_band);
    assert(JETSAM_PRIORITY_ELEVATED_INACTIVE &gt; applications_aging_band);

    <span class="comment">/* Take snapshots for idle-exit kills by default? First check the boot-arg... */</span>
    <span class="keyword">if</span> (!PE_parse_boot_argn(<span class="string">"jetsam_idle_snapshot"</span>, &amp;memorystatus_idle_snapshot, <span class="keyword">sizeof</span> (memorystatus_idle_snapshot))) {
            <span class="comment">/* ...no boot-arg, so check the device tree */</span>
            PE_get_default(<span class="string">"kern.jetsam_idle_snapshot"</span>, &amp;memorystatus_idle_snapshot, <span class="keyword">sizeof</span>(memorystatus_idle_snapshot));
    }

    memorystatus_delta = delta_percentage * atop_64(max_mem) / <span class="number">100</span>;
    memorystatus_available_pages_critical_idle_offset = idle_offset_percentage * atop_64(max_mem) / <span class="number">100</span>;
    memorystatus_available_pages_critical_base = (critical_threshold_percentage / delta_percentage) * memorystatus_delta;
    memorystatus_policy_more_free_offset_pages = (policy_more_free_offset_percentage / delta_percentage) * memorystatus_delta;

    <span class="comment">/* Jetsam Loop Detection */</span>
    <span class="keyword">if</span> (max_mem &lt;= (<span class="number">512</span> * <span class="number">1024</span> * <span class="number">1024</span>)) {
        <span class="comment">/* 512 MB devices */</span>
        memorystatus_jld_eval_period_msecs = <span class="number">8000</span>;    <span class="comment">/* 8000 msecs == 8 second window */</span>
    } <span class="keyword">else</span> {
        <span class="comment">/* 1GB and larger devices */</span>
        memorystatus_jld_eval_period_msecs = <span class="number">6000</span>;    <span class="comment">/* 6000 msecs == 6 second window */</span>
    }

    memorystatus_jld_enabled = <span class="literal">TRUE</span>;

    <span class="comment">/* No contention at this point */</span>
    memorystatus_update_levels_locked(<span class="literal">FALSE</span>);

<span class="preprocessor">#endif /* CONFIG_JETSAM */</span>

    memorystatus_jetsam_snapshot_max = maxproc;
    memorystatus_jetsam_snapshot = 
        (memorystatus_jetsam_snapshot_t*)kalloc(<span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) +
        <span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * memorystatus_jetsam_snapshot_max);
    <span class="keyword">if</span> (!memorystatus_jetsam_snapshot) {
        panic(<span class="string">"Could not allocate memorystatus_jetsam_snapshot"</span>);
    }

    nanoseconds_to_absolutetime((uint64_t)JETSAM_SNAPSHOT_TIMEOUT_SECS * <span class="built_in">NSEC_PER_SEC</span>, &amp;memorystatus_jetsam_snapshot_timeout);

    memset(&amp;memorystatus_at_boot_snapshot, <span class="number">0</span>, <span class="keyword">sizeof</span>(memorystatus_jetsam_snapshot_t));

    result = kernel_thread_start_priority(memorystatus_thread, <span class="literal">NULL</span>, <span class="number">95</span> <span class="comment">/* MAXPRI_KERNEL */</span>, &amp;thread);
    <span class="keyword">if</span> (result == KERN_SUCCESS) {
        thread_deallocate(thread);
    } <span class="keyword">else</span> {
        panic(<span class="string">"Could not create memorystatus_thread"</span>);
    }
}
</code></pre><p><strong><b style="color:red">下面先介绍几个知识点</b></strong></p>
<ul>
<li><p>内核里面对于所有的进程都有一个优先级的分布，通过一个数组维护，数组每一项是一个进程的list。这个数组的大小是<code>JETSAM_PRIORITY_MAX + 1</code>。其结构体定义如下：</p>
<pre><code>typedef struct memstat_bucket {
    <span class="type">TAILQ_HEAD</span>(, <span class="keyword">proc</span>) list;
    <span class="type">int</span> count;
} memstat_bucket_t;
</code></pre><p>这结构体非常通俗易懂。</p>
</li>
<li><p>线程在Mach下采用了不同的优先级，其中<code>MAXPRI_KERNEL</code>代表的是分配给内核可用范围内最高优先级的线程。其他级别还有如下这些：</p>
</li>
</ul>
<hr>
<pre><code><span class="keyword">*</span> // 优先级最高的实时线程 (不太清楚谁用)
 <span class="keyword">*</span> 127        Reserved (real-time)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (32 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 96        Reserved (real-time)
 <span class="keyword">*</span> // 给内核用的线程优先级(MAXPRI_KERNEL)
 <span class="keyword">*</span> 95        Kernel mode only
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (16 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 80        Kernel mode only
 <span class="keyword">*</span> // 给操作系统分配的线程优先级
 <span class="keyword">*</span> 79        System high priority
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (16 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 64        System high priority
 <span class="keyword">*</span> // 剩下的全是用户态的普通程序可以用的
 <span class="keyword">*</span> 63        Elevated priorities
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (12 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 52        Elevated priorities
 <span class="keyword">*</span> 51        Elevated priorities (incl. BSD +nice)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (20 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 32        Elevated priorities (incl. BSD +nice)
 <span class="keyword">*</span> 31        Default (default base for threads)
 <span class="keyword">*</span> 30        Lowered priorities (incl. BSD -nice)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (20 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 11        Lowered priorities (incl. BSD -nice)
 <span class="keyword">*</span> 10        Lowered priorities (aged pri's)
 <span class="keyword">*</span>                A
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>            (11 levels)
 <span class="keyword">*</span>                +
 <span class="keyword">*</span>                V
 <span class="keyword">*</span> 0        Lowered priorities (aged pri's / idle)
 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
</code></pre><ul>
<li>从上图不难看出，用户态的应用程序的线程<strong>不</strong>可能高于操作系统和内核。而且，在用户态的应用程序间的线程优先级分配也有区别，前台活动的应用程序优先级高于后台的应用程序。<b style="color:red">iOS上大名鼎鼎的SpringBoard是应用程序中优先级最高的程序。</b></li>
<li>当然线程的优先级也不是一成不变。Mach会针对每一个线程的利用率和整体系统负载动态调整优先级。如果耗费CPU太多就降低优先级，如果一个线程过度挨饿CPU则会提升其优先级。<b style="color:red">但是无论怎么变，程序都不能超过其所在的线程优先级区间范围。</b></li>
</ul>
<p>好，预备知识说完，那苹果究竟是怎么处理<code>JetSam</code>事件呢？</p>
<pre><code><span class="literal">result</span> = kernel_thread_start_priority(memorystatus_thread, <span class="type">NULL</span>, <span class="number">95</span> /* <span class="type">MAXPRI_KERNEL</span> */, &amp;thread);
</code></pre><p>苹果其实处理的思路非常简单。如上述代码，BSD层起了一个内核优先级最高的线程<code>VM_memorystatus</code>，这个线程会在维护两个列表，一个是我们之前提到的基于进程优先级的进程列表，还有一个是所谓的内存快照列表，即保存了每个进程消耗的内存页<code>memorystatus_jetsam_snapshot</code>。</p>
<p>这个常驻线程接受从内核对于内存的守护程序<code>pageout</code>通过内核调用给每个App进程发送的内存压力通知，来处理事件，这个事件转发成上层的UI事件就是平常我们会收到的全局内存警告或者每个ViewController里面的<code>didReceiveMemoryWarning</code>。</p>
<p><b style="color:red">当然，我们自己开发的App是不会主动注册监听这个内存警告事件的，帮助我们在底层完成这一切的都是<code>libdispatch</code>，如果你感兴趣的话，可以钻研下<code>_dispatch_source_type_memorypressure</code>和<code>__dispatch_source_type_memorystatus</code>。</b></p>
<p>那么在哪些情况下会出现内存压力呢？我们来看一看<code>memorystatus_action_needed</code>这段函数： </p>
<pre><code><span class="function"><span class="keyword">static</span> boolean_t
<span class="title">memorystatus_action_needed</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
<span class="preprocessor">#<span class="keyword">if</span> CONFIG_EMBEDDED</span>
    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||
            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||
           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);
<span class="preprocessor">#<span class="keyword">else</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>
    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||
            is_reason_zone_map_exhaustion(kill_under_pressure_cause));
<span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span>
}
</code></pre><p>概括来说：</p>
<p>频繁的的页面换进换出<code>is_reason_thrashing</code>，Mach Zone耗尽了<code>is_reason_zone_map_exhaustion</code>（这个涉及Mach内核的虚拟内存管理了，单独写）以及可用的页低于一个门槛了<code>memorystatus_available_pages</code>。</p>
<p>在这几种情况下，就会准备去Kill 进程了。但是，在这个处理下面，有一段代码特别有意思，我们看看这个函数<code>memorystatus_act_aggressive</code>：</p>
<pre><code><span class="keyword">if</span> ( (jld_bucket_count == <span class="number">0</span>) || 
     (jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs))) {

    <span class="comment">/* 
     * Refresh evaluation parameters 
     */</span>
    jld_timestamp_msecs     = jld_now_msecs;
    jld_idle_kill_candidates = jld_bucket_count;
    *jld_idle_kills         = <span class="number">0</span>;
    jld_eval_aggressive_count = <span class="number">0</span>;
    jld_priority_band_max    = JETSAM_PRIORITY_UI_SUPPORT;
}
</code></pre><p>这段代码很明显，是基于某个时间间隔在做条件判断。如果不满足这个判断，后续真正执行的Kill也不会走到。那我们来看看<code>memorystatus_jld_eval_period_msecs</code>这个变量：</p>
<pre><code><span class="comment">/* Jetsam Loop Detection */</span>
<span class="keyword">if</span> (max_mem &lt;= (<span class="number">512</span> * <span class="number">1024</span> * <span class="number">1024</span>)) {
    <span class="comment">/* 512 MB devices */</span>
    memorystatus_jld_eval_period_msecs = <span class="number">8000</span>;    <span class="comment">/* 8000 msecs == 8 second window */</span>
} <span class="keyword">else</span> {
    <span class="comment">/* 1GB and larger devices */</span>
    memorystatus_jld_eval_period_msecs = <span class="number">6000</span>;    <span class="comment">/* 6000 msecs == 6 second window */</span>
}
</code></pre><p>这个时间窗口是根据设备的物理内存上限来设定的，但是无论如何，看起来至少有个<strong><span style="color:red">6秒</span></strong>的时间可以给我们来做点事情。</p>
<p>当然，如果满足了时间窗口的需求，就会根据我们提到的优先级进程列表进行寻找可杀目标：</p>
<pre><code>proc_list_lock()<span class="comment">;</span>
switch (jetsam_aging_policy) {
case kJetsamAgingPolicyLegacy:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_AGING_BAND1]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
case kJetsamAgingPolicySysProcsReclaimedFirst:
case kJetsamAgingPolicyAppsReclaimedFirst:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[system_procs_aging_band]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    bucket = &amp;memstat_bucket[applications_aging_band]<span class="comment">;</span>
    jld_bucket_count += bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
case kJetsamAgingPolicyNone:
default:
    bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE]<span class="comment">;</span>
    jld_bucket_count = bucket-&gt;count<span class="comment">;</span>
    break<span class="comment">;</span>
}

bucket = &amp;memstat_bucket[JETSAM_PRIORITY_ELEVATED_INACTIVE]<span class="comment">;</span>
elevated_bucket_count = bucket-&gt;count<span class="comment">;</span>
</code></pre><p><b style="color:red">需要注意的是，JETSAM不一定只杀一个进程，他可能会大杀特杀，杀掉N多进程。</b></p>
<pre><code><span class="keyword">if</span> (memorystatus_avail_pages_below_pressure()) {
    <span class="comment">/*
     * Still under pressure.
     * Find another pinned processes.
     */</span>
    <span class="keyword">continue</span>;
} <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="keyword">TRUE</span>;
}
</code></pre><p>至于杀进程的话，最终都会落到函数<code>memorystatus_do_kill</code>-&gt;<code>jetsam_do_kill</code>去执行。</p>
<h3 id="其他">其他</h3><p>看苹果代码的时候，发现了不少内核的参数，一一进行了尝试后，发现<code>sysctlname</code>和<code>sysctl</code>的系统调用都被苹果禁用了，比如这些：</p>
<pre><code><span class="string">"kern.jetsam_delta"</span>
<span class="string">"kern.jetsam_critical_threshold"</span>
<span class="string">"kern.jetsam_idle_offset"</span>
<span class="string">"kern.jetsam_pressure_threshold"</span>
<span class="string">"kern.jetsam_freeze_threshold"</span>
<span class="string">"kern.jetsam_aging_policy"</span>
</code></pre><p>不过，我试了下通过<code>kern.boottime</code>获取机器的开机时间还是可以的，代码示例如下：</p>
<pre><code><span class="keyword">size_t</span> size;
sysctlbyname(<span class="string">"kern.boottime"</span>, <span class="literal">NULL</span>, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);

<span class="keyword">char</span> *boot_time = <span class="built_in">malloc</span>(size);
sysctlbyname(<span class="string">"kern.boottime"</span>, boot_time, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);

<span class="keyword">uint32_t</span> timestamp = <span class="number">0</span>;
<span class="built_in">memcpy</span>(&amp;timestamp, boot_time, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));
<span class="built_in">free</span>(boot_time);

NSDate* bootTime = [NSDate dateWithTimeIntervalSince1970:timestamp];
</code></pre><h3 id="最后">最后</h3><p>嘻嘻，技术原理研究了一些，心里顿时对解决公司的Abort问题有了一定的眉目。嘿嘿，我写了个DEMO验证了我的思路，是可行的。哇咔咔。等我的好消息吧～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/10/18/abort/" data-id="ck9fy2gf3001b2ni12lxcqq1v" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/10/18/abort/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XNU/">XNU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-mainthreadchecker1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/24/mainthreadchecker1/" class="article-date">
  <time datetime="2017-09-24T14:46:43.000Z" itemprop="datePublished">2017-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/mainthreadchecker1/">基于桥的全量方法Hook方案 - 探究苹果主线程检查实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近随着iOS11的正式发布，手淘／天猫也开始逐步用Xcode 9开始编译。在调试过程中，很多同事发现经常报许多API会报线程使用错误的问题。摸索了下，发现是Xcode 9里面带上了一个叫<code>libMainThreadChecker.dylib</code>的动态库，在运行时提供了主线程检查的功能，今天就从探究苹果的实现开始讲起。</p>
<h3 id="0x1_苹果的实现">0x1 苹果的实现</h3><p>把苹果的动态库拖入hopper里面看看，基本上扫一眼以后，比较可疑的是<code>__library_initializer</code>和<code>__library_deintializer</code>。</p>
<blockquote>
<p>我看反汇编，第一直觉就是猜，然后都试一把。</p>
</blockquote>
<p>我们来看看其伪代码实现，可以分为几个部分来探究：</p>
<h4 id="1-1_环境变量">1.1 环境变量</h4><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_1.png?raw=true" alt=""></p>
<p>从图中不难看出，<code>libMainThreadChecker</code>的运行依赖于许多的环境变量，我们可以在<code>Xcode</code>-&gt;<code>Scheme</code>-&gt;<code>Arguments</code>里面一个个输入这些变量进行测试，我发现比较重要的是<code>MTC_VERBOSE</code>这个参数，使用后，可以输出究竟对于哪些类进行了线程监控。</p>
<pre><code>...
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardEmojiCollectionViewCell</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardEmojiSectionHeader</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupPINScrollView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupPINView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupConnectingView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UICollectionViewTableHeaderFooterView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIPrinterSetupDisplayPINView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarMapsCompassItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarCarPlayTimeItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateBarCell</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateBarCell_SecondaryCandidate</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIActionSheetiOSDismissActionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateFloatingArrowView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateGridOverlayBackgroundView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardCandidateGridHeaderContainerView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIStatusBarBreadcrumbItemView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIInterfaceActionGroupView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardFlipTransitionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardAssistantBar</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UITextMagnifier</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIKeyboardSliceTransitionView</span></span>
Swizzling <span class="class"><span class="keyword">class</span>: <span class="typename">UIWKSelectionView</span></span>
Swizzled <span class="number">10717</span> methods <span class="keyword">in</span> <span class="number">384</span> classes.
</code></pre><p>可以看出，苹果会在启动前对于这些类进行所谓的线程监控。</p>
<h4 id="1-2_逻辑">1.2 逻辑</h4><p>看完了输出，我们来看看其中的逻辑实现，如下所示：</p>
<pre><code>CFAbsoluteTimeGetCurrent();
   var_270 = intrinsic_movsd(var_270, xmm0);
   *_indirect__main_thread_checker_on_report = dlsym(<span class="number">0xfffffffffffffffd</span>, <span class="string">"__main_thread_checker_on_report"</span>);
   <span class="keyword">if</span> (objc_getClass(<span class="string">"UIView"</span>) != <span class="number">0x0</span>) {
           *_XXKitImage = dyld_image_header_containing_address(objc_getClass(<span class="string">"UIView"</span>));
           *_CoreFoundationImage = dyld_image_header_containing_address(_CFArrayGetCount);
           rax = objc_getClass(<span class="string">"WKWebView"</span>);
           rax = dyld_image_header_containing_address(rax);
           *_WebKitImage = rax;
           *_InlineCallsMachHeaders = *_XXKitImage;
           *<span class="number">0x1ec3e8</span> = *_CoreFoundationImage;
           *<span class="number">0x1ec3f0</span> = rax;
           *___CATransaction = objc_getClass(<span class="string">"CATransaction"</span>);
           *___NSGraphicsContext = objc_getClass(<span class="string">"NSGraphicsContext"</span>);
           *_SEL_currentState = sel_registerName(<span class="string">"currentState"</span>);
           *_SEL_currentContext = sel_registerName(<span class="string">"currentContext"</span>);
           *_MyOwnMachHeader = dyld_image_header_containing_address(___library_initializer);
           *_classesToSwizzle = CFArrayCreateMutable(<span class="number">0x0</span>, <span class="number">0x200</span>, <span class="number">0x0</span>);
           var_240 = objc_getClass(<span class="string">"UIView"</span>);
           _FindClassesToSwizzleInImage(*_XXKitImage, &amp;var_240, <span class="number">0x2</span>);
           <span class="keyword">if</span> (*_WebKitImage != <span class="number">0x0</span>) {
                   var_230 = objc_getClass(<span class="string">"WKWebView"</span>);
                   *(&amp;var_230 + <span class="number">0x8</span>) = objc_getClass(<span class="string">"WKWebsiteDataStore"</span>);
                   *(&amp;var_230 + <span class="number">0x10</span>) = objc_getClass(<span class="string">"WKUserScript"</span>);
                   *(&amp;var_230 + <span class="number">0x18</span>) = objc_getClass(<span class="string">"WKUserContentController"</span>);
                   *(&amp;var_230 + <span class="number">0x20</span>) = objc_getClass(<span class="string">"WKScriptMessage"</span>);
                   *(&amp;var_230 + <span class="number">0x28</span>) = objc_getClass(<span class="string">"WKProcessPool"</span>);
                   *(&amp;var_230 + <span class="number">0x30</span>) = objc_getClass(<span class="string">"WKProcessGroup"</span>);
                   *(&amp;var_230 + <span class="number">0x38</span>) = objc_getClass(<span class="string">"WKContentExtensionStore"</span>);
                   _FindClassesToSwizzleInImage(*_WebKitImage, &amp;var_230, <span class="number">0x8</span>);
           }
           rcx = CFArrayGetCount(*_classesToSwizzle);
           <span class="keyword">if</span> (rcx != <span class="number">0x0</span>) {
                   rax = <span class="number">0x0</span>;
                   var_278 = rcx;
                   <span class="keyword">do</span> {
                           var_288 = rax;
                           rax = CFArrayGetValueAtIndex(*_classesToSwizzle, rax);
                           var_258 = rax;
                           rbx = objc_getClass(rax);
                           var_290 = dyld_image_header_containing_address(rbx);
                           var_230 = <span class="number">0x0</span>;
                           var_280 = rbx;
                           r14 = class_copyMethodList(rbx, &amp;var_230);
                           <span class="keyword">if</span> (var_230 != <span class="number">0x0</span>) {
                                   rbx = <span class="number">0x0</span>;
                                   <span class="keyword">do</span> {
                                           r13 = *(r14 + rbx * <span class="number">0x8</span>);
                                           r12 = method_getName(r13);
                                           r15 = sel_getName(r12);
                                           <span class="keyword">if</span> ((((((((((((((((*(<span class="keyword">int8_t</span> *)r15 != <span class="number">0x5f</span>) &amp;&amp; (dyld_image_header_containing_address(method_getImplementation(r13)) == var_290)) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreRetainRelease == <span class="number">0x0</span>) || (((<span class="built_in">strcmp</span>(r15, <span class="string">"retain"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"release"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"autorelease"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreDealloc == <span class="number">0x0</span>) || ((<span class="built_in">strcmp</span>(r15, <span class="string">"dealloc"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">".cxx_destruct"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (((*(<span class="keyword">int8_t</span> *)_envIgnoreNSObjectThreadSafeMethods == <span class="number">0x0</span>) || ((((<span class="built_in">strcmp</span>(r15, <span class="string">"description"</span>) != <span class="number">0x0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"debugDescription"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"self"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"class"</span>) != <span class="number">0x0</span>))))) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"beginBackgroundTaskWithExpirationHandler:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"beginBackgroundTaskWithName:expirationHandler:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"endBackgroundTask:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocus"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocusIfCanDraw"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"lockFocusIfCanDrawInContext:"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"unlockFocus"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strcmp</span>(r15, <span class="string">"openGLContext"</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"webThread"</span>, <span class="number">0x9</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"nsli_"</span>, <span class="number">0x5</span>) != <span class="number">0x0</span>)) &amp;&amp; (<span class="built_in">strncmp</span>(r15, <span class="string">"nsis_"</span>, <span class="number">0x5</span>) != <span class="number">0x0</span>)) {
                                                   <span class="keyword">if</span> (*_userSuppressedClasses != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithCStringNoCopy(<span class="number">0x0</span>, var_258, <span class="number">0x8000100</span>, *_kCFAllocatorNull);
                                                           var_244 = CFSetContainsValue(*_userSuppressedClasses, rax) != <span class="number">0x0</span> ? <span class="number">0x1</span> : <span class="number">0x0</span>;
                                                           CFRelease(rax);
                                                   }
                                                   <span class="keyword">else</span> {
                                                           var_244 = <span class="number">0x0</span>;
                                                   }
                                                   <span class="keyword">if</span> (*_userSuppressedSelectors != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithCStringNoCopy(<span class="number">0x0</span>, r15, <span class="number">0x8000100</span>, *_kCFAllocatorNull);
                                                           var_250 = rax;
                                                           <span class="keyword">if</span> (CFSetContainsValue(*_userSuppressedSelectors, rax) != <span class="number">0x0</span>) {
                                                                   var_244 = <span class="number">0x1</span>;
                                                           }
                                                           CFRelease(var_250);
                                                   }
                                                   <span class="keyword">if</span> (*_userSuppressedMethods != <span class="number">0x0</span>) {
                                                           rax = CFStringCreateWithFormat(<span class="number">0x0</span>, <span class="number">0x0</span>, @<span class="string">"-[%s %s]"</span>);
                                                           var_250 = CFSetContainsValue(*_userSuppressedMethods, rax);
                                                           CFRelease(rax);
                                                           rax = var_250 | var_244;
                                                           <span class="keyword">if</span> (rax == <span class="number">0x0</span>) {
                                                                   _addSwizzler(r13, r12, var_258, r15, <span class="number">0x1</span>);
                                                           }
                                                           <span class="keyword">else</span> {
                                                                   *_userSuppressionsCount = *_userSuppressionsCount + <span class="number">0x1</span>;
                                                           }
                                                   }
                                                   <span class="keyword">else</span> {
                                                           <span class="keyword">if</span> (var_244 != <span class="number">0x0</span>) {
                                                                   *_userSuppressionsCount = *_userSuppressionsCount + <span class="number">0x1</span>;
                                                           }
                                                           <span class="keyword">else</span> {
                                                                   _addSwizzler(r13, r12, var_258, r15, <span class="number">0x1</span>);
                                                           }
                                                   }
                                           }
                                           rbx = rbx + <span class="number">0x1</span>;
                                   } <span class="keyword">while</span> (rbx &lt; var_230);
                           }
                           _objc_flush_caches(var_280);
                           <span class="built_in">free</span>(r14);
                           rax = var_288 + <span class="number">0x1</span>;
                           rcx = var_278;
                   } <span class="keyword">while</span> (rax != rcx);
           }
           *_totalSwizzledClasses = rcx;
           <span class="keyword">if</span> (*(<span class="keyword">int8_t</span> *)_envVerbose != <span class="number">0x0</span>) {
                   rdx = *_totalSwizzledMethods;
                   <span class="built_in">fprintf</span>(*___stderrp, <span class="string">"Swizzled %zu methods in %zu classes.\n"</span>, rdx, rcx);
           }
</code></pre><p>代码乍一看很多，其实逻辑非常简单，概述如下：</p>
<ul>
<li>通过获取<code>UIView的类实体</code>(不理解类实体的去看runtime)所在的地址来反推所在的image（二进制产物，基本是动态库），这里基本能猜测是<code>UIKit</code>。</li>
<li>从<code>UIKit</code>中获取所有继承自<code>UIView</code>和<code>UIApplication</code>的类及其子类(这也是你为什么会在刚刚上文提到的输出中发现<code>UIIBApplication</code>这种不知道啥类的原因)，过滤到带<code>_</code>的私有类，然后对剩下的类的所有的方法进行Swizzle。</li>
<li><b style="color:red">对于需要Swizzle的方法，要额外判断是不是真正属于<code>UIKit</code>这个动态库的。</b> 比如我们在调试的时候，Xcode会加载<code>libViewDebugging.dylib</code>等不会用于用于线上的动态库，里面会给<code>UIView</code>填上很多奇奇怪怪的方法。</li>
<li><p>过滤如下的方法，以及以<code>nsli_</code>和<code>nsis_</code>开头的方法。</p>
<pre><code>retain
release
autorelease
.cxx_destruct
description
debugDescription
class
self
beginBackgroundTaskWithExpiratonHandler
<span class="label">beginBackgroundTaskWithName:</span>expirationHandler:
<span class="label">endBackgroundTask:</span>
<span class="label">opneGLContext:</span>
<span class="label">lockFocusIfCanDrawInContext:</span>
lockFocus
lockFocusIfCanDraw
unlockFocus
</code></pre></li>
<li><p>可选，如果还要检查<code>WebKit</code>相关的方法，还可以Hook如下这些类的子类：</p>
<pre><code><span class="title">WKWebView</span>
WKWebsiteDataStore
WKUserScript
WKUserContentController
WKScriptMessage
WKProcessPool
WKProcessGroup
WKContentExtensionStore
</code></pre></li>
</ul>
<h3 id="0x2_自己实现">0x2 自己实现</h3><p>当时看到这，关于苹果的实现我觉得实在是太简单了，即使不用私有API，结合现在Github上的轮子我自己造一个估计1、2个小时就解决了。现在回想起来，自己还是<b style="color:red">too simple, sometimes native</b></p>
<p>大致代码获取<code>UIKit</code>中<code>UIView</code>和<code>UIApplication</code>所有子类的代码如下：</p>
<pre><code><span class="built_in">NSArray</span> *findAll<span class="built_in">UIKitClasse</span>()
{
    <span class="keyword">static</span> <span class="built_in">NSMutableArray</span> *viewClasses = <span class="literal">nil</span>;
    <span class="keyword">if</span> (!viewClasses) <span class="keyword">return</span> classes;

    uint32_t image_count = _dyld_image_count();
    <span class="keyword">for</span> (uint32_t image_index = <span class="number">0</span>; image_index &lt; image_count; image_index++) {
        <span class="keyword">const</span> my_macho_header *mach_header = (<span class="keyword">const</span> my_macho_header *)_dyld_get_image_header(image_index);

        <span class="keyword">const</span> <span class="keyword">char</span> *image_name = _dyld_get_image_name(image_index);

        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithUTF8String:image_name];
        <span class="keyword">if</span> ([imageName hasSuffix:<span class="string">@"UIKit"</span>]) {

            <span class="keyword">unsigned</span> <span class="keyword">int</span> count;
            <span class="keyword">const</span> <span class="keyword">char</span> **classes;
            Dl_info info;

            dladdr(mach_header, &amp;info);
            classes = objc_copyClassNamesForImage(info<span class="variable">.dli_fname</span>, &amp;count);

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {
                <span class="keyword">const</span> <span class="keyword">char</span> *className = (<span class="keyword">const</span> <span class="keyword">char</span> *)classes[i];

                <span class="built_in">NSString</span> *classname = [<span class="built_in">NSString</span> stringWithUTF8String:className];
                <span class="keyword">if</span> ([classname hasPrefix:<span class="string">@"_"</span>]) {
                    <span class="keyword">continue</span>;
                }

                Class cls = objc_getClass(className);
                Class superCls = cls;

                <span class="keyword">bool</span> isNeedChild = <span class="literal">NO</span>;
                <span class="keyword">while</span> (superCls != [<span class="built_in">NSObject</span> class]) {

                    <span class="keyword">if</span> (superCls == <span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>) || superCls == <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>)) {
                        isNeedChild = <span class="literal">YES</span>;
                        <span class="keyword">break</span>;
                    }
                    superCls = class_getSuperclass(superCls);
                }

                <span class="keyword">if</span> (isNeedChild) {
                    <span class="comment">// 备注：需要在这同时对这个类的方法进行Hook。</span>
                    [viewClasses addObject:cls];
                }
            }

            <span class="keyword">break</span>;
        }

    <span class="keyword">return</span> viewClasses;
}
</code></pre><h4 id="2-1_现有方案Hook的缺陷">2.1 现有方案Hook的缺陷</h4><p>到这，我们就只差把这些类的方法都Hook掉就行了。传统的<code>Method Swizzling</code>肯定不行，那样我们需要对每个方法对应实现一个新的方法进行替换，工作量太大。所以我们需要一个思路能够<b>中心重定向整个过程。</b></p>
<p><b style="color:red">之前跟着网易iOS大佬刘培庆</b>学习iOS的时候，了解到了<code>AnyMethodLog</code>，听说能监控所有类所有方法的执行，于是我就直接套用了这个框架，嘿嘿，使用起来真方便，看起来大功告成了，<b>Build &amp; Run</b>。</p>
<p>卧槽，怎么运行了就启动崩了，一脸懵逼。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_2.png?raw=true" alt=""></p>
<p>没事，我换个开源库<code>BigBang</code>改改。卧槽，还是崩了。这下必须要开下源码分析下原因了。</p>
<p>从<code>AnyMethodLog</code>的实现来看，如下所示：</p>
<pre><code><span class="built_in">BOOL</span> qhd_replaceMethod(Class cls, SEL originSelector, <span class="keyword">char</span> *returnType) {
    Method originMethod = class_getInstanceMethod(cls, originSelector);
    <span class="keyword">if</span> (originMethod == <span class="literal">nil</span>) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }
    <span class="keyword">const</span> <span class="keyword">char</span> *originTypes = method_getTypeEncoding(originMethod);
    IMP msgForwardIMP = _objc_msgForward;
<span class="preprocessor">#if !defined(__arm64__)</span>
    <span class="keyword">if</span> (qhd_isStructType(returnType)) {
        <span class="comment">//Reference JSPatch:</span>
        <span class="comment">//In some cases that returns struct, we should use the '_stret' API:</span>
        <span class="comment">//http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html</span>
        <span class="comment">//NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.</span>
        <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:originTypes];
        <span class="keyword">if</span> ([methodSignature<span class="variable">.debugDescription</span> rangeOfString:<span class="string">@"is special struct return? YES"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) {
            msgForwardIMP = (IMP)_objc_msgForward_stret;
        }
    }
<span class="preprocessor">#endif</span>

    IMP originIMP = method_getImplementation(originMethod);

    <span class="keyword">if</span> (originIMP == <span class="literal">nil</span> || originIMP == msgForwardIMP) {
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }

    <span class="comment">//把原方法的IMP换成_objc_msgForward，使之触发forwardInvocation方法</span>
    class_replaceMethod(cls, originSelector, msgForwardIMP, originTypes);

    <span class="comment">//把方法forwardInvocation的IMP换成qhd_forwardInvocation</span>
    class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)qhd_forwardInvocation, <span class="string">"v@:@"</span>);

    <span class="comment">//创建一个新方法，IMP就是原方法的原来的IMP，那么只要在qhd_forwardInvocation调用新方法即可</span>
    SEL newSelecotr = qhd_createNewSelector(originSelector);
    <span class="built_in">BOOL</span> isAdd = class_addMethod(cls, newSelecotr, originIMP, originTypes);
    <span class="keyword">if</span> (!isAdd) {
        DEV_LOG(<span class="string">@"class_addMethod fail"</span>);
    }

    <span class="keyword">return</span> <span class="literal">YES</span>;
}

    <span class="comment">// 中心重定向函数</span>
<span class="keyword">void</span> qhd_forwardInvocation(<span class="keyword">id</span> target, SEL selector, <span class="built_in">NSInvocation</span> *invocation) {
    <span class="built_in">NSArray</span> *argList = qhd_method_arguments(invocation);

    SEL originSelector = invocation<span class="variable">.selector</span>;

    <span class="built_in">NSString</span> *originSelectorString = <span class="built_in">NSStringFromSelector</span>(originSelector);



    [invocation setSelector:qhd_createNewSelector(originSelector)];
    [invocation setTarget:target];

    [invocation invoke];
}
</code></pre><p>作者的意图比较简单，主要可以概述为如下几点：</p>
<ul>
<li>把每个类的<code>forwardInvocation</code>，替换成自己实现的一个C函数。</li>
<li>把需要Hook原来<code>selector</code>获取的<code>method</code>的IMP指向<code>objc_msgForward</code>，通过其触发消息转发，也就是触发forwardInvocation;</li>
<li>对每个需要重定向的<code>selector</code>，生成一个特定的格式的新<code>selector</code>，将其IMP指向原来<code>method</code>的IMP。</li>
<li>对于刚刚重定向的C函数，通过<code>NSInvocation</code>获取要调用的target和selector，再次将这个<code>selector</code>生成特定格式的新<code>selector</code>，反射调用。</li>
</ul>
<blockquote>
<p>为啥能把OC的函数<code>forwardInvocation</code>换成C函数，原因就在于只要补上OC函数隐式的前两个参数<code>self, selector</code>，让其的函数签名一致即可。</p>
</blockquote>
<p><b style="color:red">读到这，看起来没有啥问题吧？为什么会崩溃呢！！<br><br>原因在于这种调用方式，缺少了super上下文。<br></b></p>
<p>假设我们现在对<code>UIView</code>、<code>UIButton</code>都Hook了<code>initWithFrame:</code>这个方法，在调用<code>[[UIView alloc] initWithFrame:]</code>和<code>[[UIButton alloc] initWithFrame:]</code>都会定向到C函数<code>qhd_forwardInvocation</code>中，在<code>UIView</code>调用的时候没问题。但是在<code>UIButton</code>调用的时候，由于其内部实现获取了<code>super initWithFrame:</code>，就产生了循环定向的问题。</p>
<p><b style="color:red">问题本质的原因是，由于我们对于父类、子类同名的方法都换成了同一个IMP，那么不论是走<code>objc_msgSend</code>抑或是<code>objc_msgSendSuper2</code>，获取到的IMP都是一致的。而在Hook之前，<code>objc_msgSendSuper2</code>拿到的是super_imp, <code>objc_msgSend</code>拿到是imp，从而不会有问题。</b> </p>
<h4 id="2-2_基于桥的全量Hook方法">2.2 基于桥的全量Hook方法</h4><p>好，上面的一个小节我们说，如果我们把所有方法都重定向到一个IMP上的时候，就会丧失关于继承关系之间的父子上下文关系，导致重定向循环。所以，我们需要一个思路，能够正确解决上下文的问题。</p>
<p>首先我们来回顾下runtime的消息转发机制：</p>
<pre><code><span class="number">1.</span> 调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。

<span class="number">2.</span> 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。

<span class="number">3.</span> 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。

<span class="number">4.</span> 调用forwardInvocation:方法，将第<span class="number">3</span>步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。

<span class="number">5.</span> 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第<span class="number">3</span>步没能获得一个方法签名，执行该步骤。
</code></pre><p><b style="color:red">对于我们来说，我们至少要在第四步之前（确切的是第三步之前），我们就要保留好<code>super</code>上下文。一旦到了<code>forwardInvocation</code>函数，留给我们的又只有<code>self</code>这样的残缺信息了。 </b></p>
<p><b>哎，我就是卡在这思考了一天，最终我想出了一个思路。</b></p>
<ul>
<li>提供一个桩<code>WZQMessageStub</code>，这个桩保留了class和selector，拼接成不一样的函数名，这样就能区分<code>UIButton</code>和<code>UIView</code>的同名<code>initWithFrame:</code>方法，<b style="color:red">因为不同的selector找到的IMP肯定不一样。</b></li>
<li>在<code>NSObject</code>里面实现<code>forwardingTargetForSelector</code>，在消息转发的时候指定把消息全部转发给<code>WZQMessageStub</code>。</li>
<li><code>WZQMessageStub</code>实现<code>methodSignatureForSelector</code>和<code>forwardInvocation:</code>方法，承担真正的方法反射调用的职责。</li>
</ul>
<p>好，思路确定了，难点还剩一个。对于<code>forwardingTargetForSelector</code>这个函数来说，能拿到的参数也是<code>target</code>和<code>selector</code>。在<code>super</code>和<code>self</code>调用场景下，这个参数毫无价值，因此我们需要从<code>selector</code>上着手。如果不做任何改变，我们这里拿到的<code>selector</code>肯定是诸如<code>initWithFrame:</code>的<code>old selector</code>，所以我们需要在这之前桥一下，可以按照下述流程理解：</p>
<pre><code>每个方法置换到不同的IMP桥上 <span class="subst">-&gt; </span>从桥上反推出当前的调用关系（class和<span class="keyword">select</span><span class="subst">or</span>）<span class="subst">-&gt; </span>构造一个中间态新名字 <span class="subst">-&gt; </span>forwardingTargetForSelect<span class="subst">or</span>(<span class="built_in">self</span>, 中间态新名字) 
</code></pre><p>OK，大功告成。具体桥的实现我待会再单独开篇博客讲一讲。</p>
<p><b style="color:red">嘿嘿，看起来很简单的任务也学习到了不少新知识。一会把代码开源到Github上。</b></p>
<h3 id="0x3_遗留问题">0x3 遗留问题</h3><p>我在开启<code>Main Thread Chekcer</code>后，build了一次产物，但是在通过<code>Mach-O</code>文件中<code>Load Commands</code>部分的时候，却没有发现<code>libMainThreadChecker.dylib</code>的踪影，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/tram_4.png?raw=true" alt=""></p>
<p>符号断点<code>dlopen</code>也并没有发现这个动态库调用的踪影，所以非常好奇苹果是怎么加载这个动态库的，有大佬知道请赐教。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/" data-id="ck9fy2gds000g2ni1imjqoqwy" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-KVO-CRASH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/KVO-CRASH/" class="article-date">
  <time datetime="2017-09-11T15:14:29.000Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/KVO-CRASH/">KVO在不同的二进制中多个符号并存的Crash问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在各大公司的App容纳的功能越来越多，导致应用包大小越来越大。而苹果对于<code>text</code>段的大小现在在60MB，为了避免无法上架的问题，所以很多App都开始用了动态库来避免这个问题。</p>
<p>这两天在帮支付宝开发一个功能的时候，由于支付宝许多模块的代码保密设计，因此只能采用动态库注入的方式进行调试。</p>
<p>一开始都没啥问题，但是当我在调试一个API接口的时候，却出现了一个必现的和MBProgressHUD有关的Crash问题。今天就让我用这个Crash开始，来探讨下<strong><span style="color:red">KVO在不同的二进制中多个符号并存的Crash问题</span></strong>。</p>
<h3 id="不同产物中同名符号的处理问题">不同产物中同名符号的处理问题</h3><p>我们都知道，在同一个编译-&gt;Link的最终产物中，符号（类、MetaClass、甚至是全局的函数符号）定义是不能重复的(当然，我们需要排除weak symbol)。否则在<code>ld</code>期间，就会报<code>duplicate symbol</code>这样的错误。</p>
<p>但是在不同的最终产物里，比如一个主二进制和其相关的动态库，由于这两种MachO类型为产物完全脱离，因此在这两个产物中分别定义相同的符号是完全行得通的。</p>
<p>有人会问了，那我们在主二进制中定义一个类，在动态库中又定义了一个同名的类，当我在主二进制中加载了动态库后，两个同名的类会冲突吗？</p>
<p><strong><span style="color:red">答案是不会的</span></strong>，其原因在于苹果使用的是<code>two level namespace</code>的技术。在这种形式下，符号所在的“库”的名称也会作为符号的一部分。链接的时候，<code>staic linker</code>会标记住在这个符号是来自于哪个库的。这样不仅大大减少了<code>dyld</code>搜索符号所需要的时间，也更好对后续库的更新进行了兼容。</p>
<h3 id="类的加载">类的加载</h3><p>熟悉<code>runtime</code>的人都知道，iOS中的类和其metaClass都是<code>objc_class</code>对象，这些“类”所代表的结构体，在编译期间都存在于Mach-O文件中了，位于<code>objc_data</code>这个section中。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_1.png?raw=true" alt=""></p>
<p>而这个对象所包含的如方法、协议等等，则是以<code>class_ro_t</code>的形式存在于<code>objc_const</code>节中。</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;
    <span class="keyword">property_list_t</span> *baseProperties;

    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> {
        <span class="keyword">return</span> baseMethodList;
    }
};
</code></pre><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_5.png?raw=true" alt=""></p>
<p>无论Mach-O的产物如何，这都是静态的数据。当我们在程序使用的过程中想调用这些类，都需要将这些类从二进制中读取并进行<code>realize</code>变成一个正确的类。而整个<code>realize</code>的过程，是在主二进制程序和其依赖的动态库加载完成后进行调用的，realize的过程如下：</p>
<pre><code><span class="keyword">static</span> Class realizeClass(Class cls)
{
    runtimeLock.assertWriting();

    <span class="keyword">const</span> class_ro_t *ro;
    class_rw_t *rw;
    Class supercls;
    Class metacls;
    <span class="keyword">bool</span> isMeta;

    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;

    <span class="comment">// 1. 如果realize过了，就直接返回了</span>
    <span class="keyword">if</span> (cls-&gt;isRealized()) <span class="keyword">return</span> cls;
    assert(cls == remapClass(cls));

    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span>

     <span class="comment">// 2. 读取刚刚提到的read only data，将其变成rw的data。</span>
    ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();
    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) {
        <span class="comment">// This was a future class. rw data is already allocated.</span>
        rw = cls-&gt;data();
        ro = cls-&gt;data()-&gt;ro;
        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);
    } <span class="keyword">else</span> {
        <span class="comment">// Normal class. Allocate writeable class data.</span>
        rw = (class_rw_t *)calloc(<span class="keyword">sizeof</span>(class_rw_t), <span class="number">1</span>);
        rw-&gt;ro = ro;
        rw-&gt;flags = RW_REALIZED|RW_REALIZING;
        cls-&gt;setData(rw);
    }

    isMeta = ro-&gt;flags &amp; RO_META;

    rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span>


    <span class="comment">// Choose an index for this class.</span>
    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span>
    cls-&gt;chooseClassArrayIndex();

    <span class="keyword">if</span> (PrintConnecting) {
        _objc_inform(<span class="string">"CLASS: realizing class '%s'%s %p %p #%u"</span>, 
                     cls-&gt;nameForLogging(), isMeta ? <span class="string">" (meta)"</span> : <span class="string">""</span>, 
                     (void*)cls, ro, cls-&gt;classArrayIndex());
    }

    <span class="comment">// Realize superclass and metaclass, if they aren't already.</span>
    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span>
    <span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span>

    <span class="comment">// 注意点3：对父类和metaClass先进行realize</span>
    supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()));

#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA
    <span class="comment">// Disable non-pointer isa for some classes and/or platforms.</span>
    <span class="comment">// Set instancesRequireRawIsa.</span>
    <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();
    <span class="keyword">bool</span> rawIsaIsInherited = <span class="keyword">false</span>;
    <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="keyword">false</span>;

    <span class="keyword">if</span> (DisableNonpointerIsa) {
        <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span>
        instancesRequireRawIsa = <span class="keyword">true</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  
             <span class="number">0</span> == strcmp(ro-&gt;name, <span class="string">"OS_object"</span>)) 
    {
        <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span>
        hackedDispatch = <span class="keyword">true</span>;
        instancesRequireRawIsa = <span class="keyword">true</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  
             supercls-&gt;instancesRequireRawIsa()) 
    {
        <span class="comment">// This is also propagated by addSubclass() </span>
        <span class="comment">// but nonpointer isa setup needs it earlier.</span>
        <span class="comment">// Special case: instancesRequireRawIsa does not propagate </span>
        <span class="comment">// from root class to root metaclass</span>
        instancesRequireRawIsa = <span class="keyword">true</span>;
        rawIsaIsInherited = <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (instancesRequireRawIsa) {
        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);
    }
<span class="comment">// SUPPORT_NONPOINTER_ISA</span>
#endif

    <span class="comment">// Update superclass and metaclass in case of remapping</span>
    <span class="comment">// 更新当前类的父类和meta类</span>
    cls-&gt;superclass = supercls;
    cls-&gt;initClassIsa(metacls);

    <span class="comment">// Reconcile instance variable offsets / layout.</span>
    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span>
    <span class="comment">// 如果有的话，对ivar进行重新的布局</span>
    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);

    <span class="comment">// Set fastInstanceSize if it wasn't set already.</span>
    cls-&gt;setInstanceSize(ro-&gt;instanceSize);

    <span class="comment">// Copy some flags from ro to rw</span>
    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) {
        cls-&gt;setHasCxxDtor();
        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) {
            cls-&gt;setHasCxxCtor();
        }
    }

    <span class="comment">// Connect this class to its superclass's subclass lists</span>
    <span class="comment">// 简单理解就是构建层次结构的拓扑关系</span>
    <span class="keyword">if</span> (supercls) {
        addSubclass(supercls, cls);
    } <span class="keyword">else</span> {
        addRootClass(cls);
    }

    <span class="comment">// Attach categories</span>
    <span class="comment">// 把category里面的东西也合并进来进来</span>
    methodizeClass(cls);

    <span class="keyword">return</span> cls;
}
</code></pre><p>从上述代码不难看出，整个过程非常简单，分为几个步骤：</p>
<ul>
<li>把从二进制里面读取的readonly data变成rw data，这也是我们在iOS编程中很多运行时黑魔法的基础。</li>
<li>把父类和metaclass都realize一下，然后建立合理的层次依赖关系。</li>
<li>根据父类的布局，把自己的<code>ivar</code>布局动态更新，这也是大名鼎鼎的<code>non-fragile layout</code></li>
<li>把<code>category</code>里面的东西都加载进来。</li>
<li>整个过程结束。</li>
</ul>
<h3 id="KVO的机制">KVO的机制</h3><p>说了这么多铺垫的知识，我们来开始分析下我们程序在加载动态库后会KVO Crash的原因。处于公司数据保密的原因，我构造了一个最简单的场景，这个主二进制和动态库都包含了<code>MBProgressHUD</code>对应的代码，</p>
<p>我们可以通过<code>nm</code>来查看下符号：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_6.png?raw=true" alt=""></p>
<p>在<code>MBProgressHUD</code>里面，有如下一段代码：</p>
<pre><code>- (<span class="keyword">void</span>)registerForKVO {
    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> [<span class="keyword">self</span> observableKeypaths]) {
        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];
    }
}
</code></pre><p>它会分别对所有的对应属性进行KVO监听，由于KVO本身的机制是通过创建一个“xxxNotify_KVO类”，所以，整体的调用顺序如下图所示:</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_2.png?raw=true" alt=""></p>
<p>概括如下：</p>
<ul>
<li>整个流程会为<code>MBProgressHUD</code>这个类以<code>NSKVONotifying_MBProgressHUD</code>的名称，动态添加一个类。</li>
<li>对这个类构建和原先类的父子关系，注册到全局的类表中。</li>
<li>对KVO中使用到的监听的属性进行<code>setter</code>方法的覆写。</li>
</ul>
<p>这几个流程的代码分别如下：</p>
<ol>
<li><p>创建类代码非常简单，逻辑上就是这父类-子类的关系构建一个新的类出来：</p>
<pre><code><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, 
                             size_t extraBytes)</span>
</span>{
    Class cls, meta;

    <span class="function">rwlock_writer_t <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;

    <span class="comment">// Fail if the class name is in use.</span>
    <span class="comment">// Fail if the superclass isn't kosher.</span>
    <span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="keyword">true</span><span class="comment">/*rootOK*/</span>)) {
        <span class="keyword">return</span> nil;
    }

    <span class="comment">// Allocate new classes.</span>
    cls  = alloc_class_for_subclass(superclass, extraBytes);
    meta = alloc_class_for_subclass(superclass, extraBytes);

    <span class="comment">// fixme mangle the name if it looks swift-y?</span>
    objc_initializeClassPair_internal(superclass, name, cls, meta);

    <span class="keyword">return</span> cls;
}
</code></pre></li>
<li><p>当创建完成后，就会对这个类进行<code>registerClassPair</code>的工作，这一步的目的很简单，就是将类注册到一个全局的map中<code>gdb_objc_realized_classes</code>。</p>
</li>
<li><p>重写<code>setter, class, description</code>之类的</p>
</li>
</ol>
<h3 id="Crash原因">Crash原因</h3><p>知道了原理，我们来分析Crash的原因就非常简单了，我们先看Crash的堆栈。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_3.png?raw=true" alt=""></p>
<p>从汇编中不难看出，<code>[x19, #0x20]</code>对应的地址是个非法访问地址，导致了Crash。而<code>x19</code>寄存器又是从<code>x0</code>中赋值而来，根据函数<code>objc_registerClassPair</code>的参数，<code>x0</code>为<code>Class</code>，那很明显，就是从<code>Class</code>对象的<code>0x20</code>，即32 bytes偏移地方的数据。根据定义，</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> : <span class="title">objc_object</span> {</span>
    /<span class="regexp">/ Class ISA; /</span><span class="regexp">/ 8byte
    Class superclass; /</span><span class="regexp">/ 8byte
    cache_t cache;             /</span><span class="regexp">/ formerly cache pointer and vtable /</span><span class="regexp">/ 4 + 4 + 8
    class_data_bits_t bits;    /</span><span class="regexp">/ class_rw_t * plus custom rr/alloc</span> flags
</code></pre><p>我们要获取的数据就是bits。通过输出寄存器，我们发现<code>x0</code>为0，也就是nil。而<code>x0</code>又是从哪来的呢？</p>
<p>倒推堆栈，我们发现，在函数<code>_NSKVONotifyingCreateInfoWithOriginalClass</code>，我们首先调用了<code>objc_allocateClassPair</code>，将其返回值传入<code>objc_registerClassPair</code>(ARM64 Calling Convention)</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/kvo_crash_4.png?raw=true" alt=""></p>
<p>所以，问题的本质就出现在<code>allocateClassPair</code>返回了nil，而<code>allocateClassPair</code>只有在如下场景下才会返回nil。</p>
<pre><code><span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="constant">true</span><span class="comment">/*rootOK*/</span>)) {
    <span class="keyword">return</span> <span class="constant">nil</span>;
}
</code></pre><p>通过LLDB调试，在根据name查询<code>NSKVONotifying_MBProgressHUD</code>时，由于全局的类表已经存在了对应的类，所以在<code>getClass</code>就会返回之前注册的类，从而使得<code>allocate</code>直接返回了nil。</p>
<pre><code><span class="type">NXMapTable</span> *gdb_objc_realized_classes;  // exported <span class="keyword">for</span> debuggers <span class="keyword">in</span> objc-gdb.h

<span class="keyword">static</span> <span class="type">Class</span> getClass_impl(<span class="keyword">const</span> <span class="type">char</span> *name)
{
    runtimeLock.assertLocked();

    // allocated <span class="keyword">in</span> _read_images
    assert(gdb_objc_realized_classes);

    // <span class="type">Try</span> runtime-allocated table
    <span class="type">Class</span> <span class="literal">result</span> = (<span class="type">Class</span>)<span class="type">NXMapGet</span>(gdb_objc_realized_classes, name);
    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;

    // <span class="type">Try</span> table <span class="keyword">from</span> dyld <span class="literal">shared</span> cache
    <span class="keyword">return</span> getPreoptimizedClass(name);
}

<span class="keyword">static</span> <span class="type">Class</span> getClass(<span class="keyword">const</span> <span class="type">char</span> *name)
{
    runtimeLock.assertLocked();

    // <span class="type">Try</span> name <span class="keyword">as</span>-<span class="keyword">is</span>
    <span class="type">Class</span> <span class="literal">result</span> = getClass_impl(name);
    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;

    // <span class="type">Try</span> <span class="type">Swift</span>-mangled equivalent <span class="keyword">of</span> the given name.
    <span class="keyword">if</span> (<span class="type">char</span> *swName = copySwiftV1MangledName(name)) {
        <span class="literal">result</span> = getClass_impl(swName);
        free(swName);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    <span class="keyword">return</span> <span class="keyword">nil</span>;
}
</code></pre><h3 id="结论">结论</h3><p>当两个产物都有相同的类名时，这两个类都会被realize，都能够被正常调用。但是由于全局类表的存在，在动态创建KVO的子类时，只能产生一个。所以就导致allocate失败，从而引发register过程的Crash问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/09/11/KVO-CRASH/" data-id="ck9fy2gic003o2ni1agrum3ag" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-UITableViewController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/06/UITableViewController/" class="article-date">
  <time datetime="2017-08-06T14:28:23.000Z" itemprop="datePublished">2017-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/06/UITableViewController/">UIKit解剖（-）逆向UITableViewController分析Bug</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在做XXXSDK的时候，我hook的<code>UITableView</code>的<code>setDelegate:</code>方法。整个SDK在接入手淘、天猫以及闲鱼等其他App的时候都没啥问题。</p>
<p>上周，UC的同学突然找到说，给我说了如下图所示的问题：</p>
<p><strong><span style="color:red">商业保密，不显示了</span></strong></p>
<p>卧槽，这下我就懵逼了，看样子是把整个<code>rowHeight</code>给Hook坏了，那这是为什么呢？</p>
<p>从开发<code>UITableView</code>的正向角度来说：我们一般都需要给其提供一个必选的<code>UITableViewDataSource</code>和一个可选的<code>UITableViewDelegate</code>，其中，涉及到高度的是如下这个API：</p>
<pre><code><span class="tag">-</span> (<span class="tag">CGFloat</span>)<span class="rule"><span class="attribute">tableView</span>:<span class="value">(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span></span>;
</code></pre><blockquote>
<p>有人说可以直接通过tableview.rowHeight设置高度，但是对于不同cell不同高度的动态需求，但是这里我们暂不提这种分支情况。</p>
</blockquote>
<p>通过UC同学的协助，我们发现了如下输出：</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/delegate.png?raw=true" alt=""></p>
<p>通过输出不难发现，是最后的<code>delegate</code>被从对应的<code>UIViewController</code>改成了一个乱七八糟没实现对应<code>heightForRowAtIndexPath</code>方法的对象。</p>
<p>为什么会这样呢？</p>
<p>通过如下图所示的调用栈，</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/stack.png?raw=true" alt=""></p>
<p>调用栈最下层是UC同学的代码；</p>
<p><code>self.tableview = [[xxxTableView alloc] init]</code></p>
<p>调用栈最上层是我们的一层防护性hook，其代码如下：</p>
<pre><code>+ (<span class="keyword">void</span>)load {
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
        Swizzle([<span class="built_in">UIScrollView</span> class], <span class="keyword">@selector</span>(init), <span class="keyword">@selector</span>(swizzled_init));
    });
}

- (instancetype)swizzled_init
{
    <span class="keyword">id</span> obj = [<span class="keyword">self</span> swizzled_init];
    <span class="built_in">UIScrollView</span> *scrollView = (<span class="built_in">UIScrollView</span> *)obj;
    <span class="keyword">if</span> (!scrollView<span class="variable">.delegate</span>) {
        <span class="comment">//scrollView.delegate = [UIScrollViewDelegateDummyStub sharedStub];</span>
    }
    <span class="keyword">return</span> obj;
}
</code></pre><p>这段代码是什么作用呢？</p>
<p><span style="color:red"><strong>我们之前提了<code>UITableViewDelegate</code>不是必需，因此，为了能够抓去所有UITableView的代码，我们会提供一个内置的默认delegate(当时的实现存在bug，没有实现heightForRowAtIndexPath方法)</strong></span>。</p>
<p>而且，为了防止我们的delegate覆盖了有delegate的情况，我们还特地做了<code>!scroll.delegate</code>的判断。</p>
<p>按照我们的预期设想，存在两种时间顺序情况：</p>
<ol>
<li>我们的init先执行，此时肯定会进入我们设置默认的逻辑；然后当外部代码调用<code>tableview.delegate = xxx</code>的时候，会把我们这个替换掉，不会影响正常的逻辑。</li>
<li>我们的init后执行（比如某些子类覆盖的情况），那这样的话，当子类已经设置好<code>delegate</code>后，压根不会进入我们的设置逻辑。</li>
</ol>
<p><strong>然而，就是这一小段看起来无错的代码导致了UC的App出现了文章开头的Bug。</strong></p>
<h3 id="逆向分析UITableViewController">逆向分析UITableViewController</h3><p>基于<strong>10.2</strong>的UIKit，我们通过汇编来分析<code>-[UITableViewController setTableView:]</code>的流程：</p>
<pre><code>     <span class="comment">// 保存寄存器</span>
-&gt;  <span class="number">0x18c84c640</span> &lt;+<span class="number">0</span>&gt;:   stp    x26, x25, [sp, <span class="preprocessor">#-<span class="number">0x50</span>]!</span>
    <span class="number">0x18c84c644</span> &lt;+<span class="number">4</span>&gt;:   stp    x24, x23, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x18c84c648</span> &lt;+<span class="number">8</span>&gt;:   stp    x22, x21, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    <span class="number">0x18c84c64c</span> &lt;+<span class="number">12</span>&gt;:  stp    x20, x19, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    <span class="number">0x18c84c650</span> &lt;+<span class="number">16</span>&gt;:  stp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span>

    <span class="comment">// 获取原先UITableViewController的旧tableView</span>
    <span class="number">0x18c84c654</span> &lt;+<span class="number">20</span>&gt;:  add    x29, sp, <span class="preprocessor">#<span class="number">0x40</span>            ; =<span class="number">0x40</span> </span>
    <span class="number">0x18c84c658</span> &lt;+<span class="number">24</span>&gt;:  mov    x20, x0
    <span class="number">0x18c84c65c</span> &lt;+<span class="number">28</span>&gt;:  mov    x0, x2
    <span class="number">0x18c84c660</span> &lt;+<span class="number">32</span>&gt;:  bl     <span class="number">0x1851c8090</span>               ; objc_retain
    <span class="number">0x18c84c664</span> &lt;+<span class="number">36</span>&gt;:  mov    x19, x0
    <span class="number">0x18c84c668</span> &lt;+<span class="number">40</span>&gt;:  adrp   x8, <span class="number">124100</span>
    <span class="number">0x18c84c66c</span> &lt;+<span class="number">44</span>&gt;:  ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xd78</span>]</span>
    <span class="number">0x18c84c670</span> &lt;+<span class="number">48</span>&gt;:  mov    x0, x20
    <span class="number">0x18c84c674</span> &lt;+<span class="number">52</span>&gt;:  bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c678</span> &lt;+<span class="number">56</span>&gt;:  mov    x29, x29
    <span class="number">0x18c84c67c</span> &lt;+<span class="number">60</span>&gt;:  bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue

    <span class="comment">// 比较旧的tableview和新的tableview</span>
    <span class="number">0x18c84c680</span> &lt;+<span class="number">64</span>&gt;:  mov    x21, x0
    <span class="number">0x18c84c684</span> &lt;+<span class="number">68</span>&gt;:  cmp    x21, x19

    <span class="comment">// 如果两个tableView一致，直接返回</span>
    <span class="number">0x18c84c688</span> &lt;+<span class="number">72</span>&gt;:  b.eq   <span class="number">0x18c84c7d4</span>               ; &lt;+<span class="number">404</span>&gt;

    <span class="comment">// 获取旧的tableView的datasource</span>
    <span class="number">0x18c84c68c</span> &lt;+<span class="number">76</span>&gt;:  adrp   x8, <span class="number">124074</span>
    <span class="number">0x18c84c690</span> &lt;+<span class="number">80</span>&gt;:  ldr    x23, [x8, <span class="preprocessor">#<span class="number">0x2e0</span>]</span>
    <span class="number">0x18c84c694</span> &lt;+<span class="number">84</span>&gt;:  mov    x0, x21
    <span class="number">0x18c84c698</span> &lt;+<span class="number">88</span>&gt;:  mov    x1, x23
    <span class="number">0x18c84c69c</span> &lt;+<span class="number">92</span>&gt;:  bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c6a0</span> &lt;+<span class="number">96</span>&gt;:  mov    x29, x29
    <span class="number">0x18c84c6a4</span> &lt;+<span class="number">100</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue


    <span class="comment">// 从self的成员对象便宜792处取出UIFilteredDataSource</span>
    <span class="number">0x18c84c6a8</span> &lt;+<span class="number">104</span>&gt;: mov    x22, x0
    <span class="number">0x18c84c6ac</span> &lt;+<span class="number">108</span>&gt;: adrp   x8, <span class="number">124145</span>
    <span class="number">0x18c84c6b0</span> &lt;+<span class="number">112</span>&gt;: ldrsw  x8, [x8, <span class="preprocessor">#<span class="number">0x7ac</span>]</span>
    <span class="number">0x18c84c6b4</span> &lt;+<span class="number">116</span>&gt;: ldr    x8, [x20, x8]
    <span class="number">0x18c84c6b8</span> &lt;+<span class="number">120</span>&gt;: cmp    x22, x20
    <span class="number">0x18c84c6bc</span> &lt;+<span class="number">124</span>&gt;: ccmp   x22, x8, <span class="preprocessor">#<span class="number">0x4</span>, ne</span>

    <span class="comment">// 如果不一致，把旧的tableview的datasource 置为nil</span>
    <span class="number">0x18c84c6c0</span> &lt;+<span class="number">128</span>&gt;: b.ne   <span class="number">0x18c84c6d8</span>               ; &lt;+<span class="number">152</span>&gt;
    <span class="number">0x18c84c6c4</span> &lt;+<span class="number">132</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c6c8</span> &lt;+<span class="number">136</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c0</span>]</span>
    <span class="number">0x18c84c6cc</span> &lt;+<span class="number">140</span>&gt;: mov    x2, <span class="preprocessor">#<span class="number">0x0</span></span>
    <span class="number">0x18c84c6d0</span> &lt;+<span class="number">144</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c6d4</span> &lt;+<span class="number">148</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 获取旧的tableview的delegate</span>
    <span class="number">0x18c84c6d8</span> &lt;+<span class="number">152</span>&gt;: adrp   x8, <span class="number">124074</span>
    <span class="number">0x18c84c6dc</span> &lt;+<span class="number">156</span>&gt;: ldr    x24, [x8, <span class="preprocessor">#<span class="number">0x7d8</span>]</span>
    <span class="number">0x18c84c6e0</span> &lt;+<span class="number">160</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c6e4</span> &lt;+<span class="number">164</span>&gt;: mov    x1, x24
    <span class="number">0x18c84c6e8</span> &lt;+<span class="number">168</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c6ec</span> &lt;+<span class="number">172</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c6f0</span> &lt;+<span class="number">176</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
        <span class="number">0x18c84c6f4</span> &lt;+<span class="number">180</span>&gt;: mov    x25, x0
    <span class="number">0x18c84c6f8</span> &lt;+<span class="number">184</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release

    <span class="comment">// 判断旧的delegate是不是当前的UITableViewController</span>
    <span class="number">0x18c84c6fc</span> &lt;+<span class="number">188</span>&gt;: cmp    x25, x20
    <span class="number">0x18c84c700</span> &lt;+<span class="number">192</span>&gt;: b.ne   <span class="number">0x18c84c718</span>               ; &lt;+<span class="number">216</span>&gt;
    <span class="number">0x18c84c704</span> &lt;+<span class="number">196</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c708</span> &lt;+<span class="number">200</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c8</span>]</span>

    <span class="comment">// 如果不是，就把旧的tableview的delegate置为nil</span>
    <span class="number">0x18c84c70c</span> &lt;+<span class="number">204</span>&gt;: mov    x2, <span class="preprocessor">#<span class="number">0x0</span></span>
    <span class="number">0x18c84c710</span> &lt;+<span class="number">208</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c714</span> &lt;+<span class="number">212</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c718</span> &lt;+<span class="number">216</span>&gt;: adrp   x8, <span class="number">124080</span>
    <span class="number">0x18c84c71c</span> &lt;+<span class="number">220</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xe80</span>]</span>
    <span class="number">0x18c84c720</span> &lt;+<span class="number">224</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c724</span> &lt;+<span class="number">228</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c728</span> &lt;+<span class="number">232</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c72c</span> &lt;+<span class="number">236</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c730</span> &lt;+<span class="number">240</span>&gt;: mov    x25, x0

    <span class="comment">// 将uitableviewcontroller的tableview通过setView:置为新的</span>
    <span class="number">0x18c84c734</span> &lt;+<span class="number">244</span>&gt;: adrp   x8, <span class="number">124076</span>
    <span class="number">0x18c84c738</span> &lt;+<span class="number">248</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x4b0</span>]</span>
    <span class="number">0x18c84c73c</span> &lt;+<span class="number">252</span>&gt;: mov    x0, x20
    <span class="number">0x18c84c740</span> &lt;+<span class="number">256</span>&gt;: mov    x2, x19
    <span class="number">0x18c84c744</span> &lt;+<span class="number">260</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 新的tableview的datasource判断是不是为空，为空通过_applyDefaultDataSourceToTable将其UIFilteredDataSource</span>
    <span class="number">0x18c84c748</span> &lt;+<span class="number">264</span>&gt;: adrp   x8, <span class="number">124080</span>
    <span class="number">0x18c84c74c</span> &lt;+<span class="number">268</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x810</span>]</span>
    <span class="number">0x18c84c750</span> &lt;+<span class="number">272</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c754</span> &lt;+<span class="number">276</span>&gt;: mov    x2, x25
    <span class="number">0x18c84c758</span> &lt;+<span class="number">280</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c75c</span> &lt;+<span class="number">284</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c760</span> &lt;+<span class="number">288</span>&gt;: mov    x1, x23
    <span class="number">0x18c84c764</span> &lt;+<span class="number">292</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c768</span> &lt;+<span class="number">296</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c76c</span> &lt;+<span class="number">300</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c770</span> &lt;+<span class="number">304</span>&gt;: mov    x23, x0
    <span class="number">0x18c84c774</span> &lt;+<span class="number">308</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c778</span> &lt;+<span class="number">312</span>&gt;: cbnz   x23, <span class="number">0x18c84c790</span>          ; &lt;+<span class="number">336</span>&gt;
    <span class="number">0x18c84c77c</span> &lt;+<span class="number">316</span>&gt;: adrp   x8, <span class="number">124100</span>
    <span class="number">0x18c84c780</span> &lt;+<span class="number">320</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0xd80</span>]</span>
    <span class="number">0x18c84c784</span> &lt;+<span class="number">324</span>&gt;: mov    x0, x20
    <span class="number">0x18c84c788</span> &lt;+<span class="number">328</span>&gt;: mov    x2, x19
    <span class="number">0x18c84c78c</span> &lt;+<span class="number">332</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend

    <span class="comment">// 新的tableview的delegaate判断是不是为空，为空通过将delegate置为self（即当前的UITableViewController）</span>
    <span class="number">0x18c84c790</span> &lt;+<span class="number">336</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c794</span> &lt;+<span class="number">340</span>&gt;: mov    x1, x24
    <span class="number">0x18c84c798</span> &lt;+<span class="number">344</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c79c</span> &lt;+<span class="number">348</span>&gt;: mov    x29, x29
    <span class="number">0x18c84c7a0</span> &lt;+<span class="number">352</span>&gt;: bl     <span class="number">0x1851ca48c</span>               ; objc_retainAutoreleasedReturnValue
    <span class="number">0x18c84c7a4</span> &lt;+<span class="number">356</span>&gt;: mov    x23, x0
    <span class="number">0x18c84c7a8</span> &lt;+<span class="number">360</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release


    <span class="number">0x18c84c7ac</span> &lt;+<span class="number">364</span>&gt;: cbnz   x23, <span class="number">0x18c84c7c4</span>          ; &lt;+<span class="number">388</span>&gt;
    <span class="number">0x18c84c7b0</span> &lt;+<span class="number">368</span>&gt;: adrp   x8, <span class="number">124073</span>
    <span class="number">0x18c84c7b4</span> &lt;+<span class="number">372</span>&gt;: ldr    x1, [x8, <span class="preprocessor">#<span class="number">0x3c8</span>]</span>
    <span class="number">0x18c84c7b8</span> &lt;+<span class="number">376</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c7bc</span> &lt;+<span class="number">380</span>&gt;: mov    x2, x20
    <span class="number">0x18c84c7c0</span> &lt;+<span class="number">384</span>&gt;: bl     <span class="number">0x1851c2f60</span>               ; objc_msgSend
    <span class="number">0x18c84c7c4</span> &lt;+<span class="number">388</span>&gt;: mov    x0, x25
    <span class="number">0x18c84c7c8</span> &lt;+<span class="number">392</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c7cc</span> &lt;+<span class="number">396</span>&gt;: mov    x0, x22
    <span class="number">0x18c84c7d0</span> &lt;+<span class="number">400</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release
    <span class="number">0x18c84c7d4</span> &lt;+<span class="number">404</span>&gt;: mov    x0, x21
    <span class="number">0x18c84c7d8</span> &lt;+<span class="number">408</span>&gt;: bl     <span class="number">0x1851c8150</span>               ; objc_release

    <span class="comment">// 恢复寄存器</span>

    <span class="number">0x18c84c7dc</span> &lt;+<span class="number">412</span>&gt;: mov    x0, x19
    <span class="number">0x18c84c7e0</span> &lt;+<span class="number">416</span>&gt;: ldp    x29, x30, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span>
    <span class="number">0x18c84c7e4</span> &lt;+<span class="number">420</span>&gt;: ldp    x20, x19, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    <span class="number">0x18c84c7e8</span> &lt;+<span class="number">424</span>&gt;: ldp    x22, x21, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    <span class="number">0x18c84c7ec</span> &lt;+<span class="number">428</span>&gt;: ldp    x24, x23, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    <span class="number">0x18c84c7f0</span> &lt;+<span class="number">432</span>&gt;: ldp    x26, x25, [sp], <span class="preprocessor">#<span class="number">0x50</span></span>
    <span class="number">0x18c84c7f4</span> &lt;+<span class="number">436</span>&gt;: b      <span class="number">0x1851c8150</span>               ; objc_release
</code></pre><ul>
<li>一看到adrp, ldr的搭配，基本可以确定是取某个方法进行调用。</li>
<li>看到一大堆的<code>bl objc_retain</code>，<code>bl objc_release</code>，不用管，反正都是ARC帮我们自动插入的。</li>
<li>可以看出，当传入给UITableViewController的tableView含有<code>dataSource</code>和<code>delegate</code>，UITableViewController都不会对其进行处理；否则会进行一个默认的设置。</li>
</ul>
<p>我自己理解后转写的伪代码如下：</p>
<pre><code><span class="built_in">UITableView</span> *oldTableView = [<span class="keyword">self</span> __existingTableView]; 

<span class="keyword">if</span> (oldTableView == xxxtableView) {
    <span class="keyword">return</span> 
} <span class="keyword">else</span> {
    <span class="keyword">id</span> oldDataSource = [oldTableView dataSource];
    <span class="comment">// x21 被赋值成了oldTableView, x22 oldDataSource</span>

    <span class="comment">// 取UITableViewController 792偏移的成员变量 filteredDataSource</span>
    <span class="keyword">id</span> filteredDataSource = [<span class="keyword">self</span> _filteredDataSource];

    <span class="keyword">if</span> (oldDataSource != filteredDataSource) 
    {

    } <span class="keyword">else</span> {
        [oldTableView setDataSource:<span class="literal">nil</span>];
    }

    <span class="keyword">id</span> oldDelegate = [oldTableView delegate];
    <span class="comment">// x25 被赋值了oldDelegate</span>

    <span class="keyword">if</span> (oldeDelegate != <span class="keyword">self</span>)
    {
        <span class="keyword">goto</span> <span class="comment">//</span>
    } <span class="keyword">else</span> {
        [oldTableView setDelegate:<span class="literal">nil</span>];
    }

    <span class="keyword">id</span> oldRefreshControl = [oldTableView _refreshControl];
    <span class="comment">// x25 被赋值了oldRefreshControl</span>

    [<span class="keyword">self</span> setView:xxtableView];
    [xxxtableView _setRefreshControl:oldRefreshControl];

    <span class="keyword">id</span> newDataSource = [xxxtableview dataSource];
    <span class="keyword">if</span> (!newDataSource) {
        [<span class="keyword">self</span> _applyDefaultDataSourceToTable:xxxTableView];
    }

    <span class="keyword">id</span> newDelegate = [xxxtableview delegate];
    <span class="keyword">if</span> (!newDelegate) {
        [xxxTableView setDelegate:<span class="keyword">self</span>];
    }
}
</code></pre><h3 id="结论">结论</h3><p>通过上面对汇编和伪代码的理解，我们可以很轻易的得出结论：当我们处于第一种情形的实现，我们将<code>tableview.delegate</code>设置成了我们的stub。因为不为空，所以<code>UITableViewController</code>默认不会对其进行处理，而由于我们当时没有提供stub对于<code>heightForRowAtIndexPath</code>的实现，导致出现了UC的bug。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/08/06/UITableViewController/" data-id="ck9fy2gfa001g2ni1h3rtnwif" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/08/06/UITableViewController/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-xlog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/30/xlog/" class="article-date">
  <time datetime="2017-07-30T02:05:14.000Z" itemprop="datePublished">2017-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/30/xlog/">微信高性能线上日志系统xlog剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="微信高性能线上日志系统xlog剖析">微信高性能线上日志系统xlog剖析</h3><p>做移动开发的同学经常会遇到一个头疼的问题，就是当用户反馈一些问题，又比较冷僻难以复现的时候（不是Crash），常常就会陷入一筹莫展的境地。因此，很多人就研发了相关的监控系统，比如一些知名的APM来监测帧率、内存、电量等等，将这些数据进行采集、合并再上报至专门的平台供开发测试同学查看。但是这些APM往往都是粗粒度的监控，究其原因就在于如果特别精细的进行监控，线上的性能会吃不消，一些监控反而影响了用户的正常使用。</p>
<p>说了这么多，抛开获取数据方面的难度不提，线上监控的本质还是在于信息（日志）记录，而端上的日志记录存在一个社会主义初级阶段的供需矛盾：</p>
<p><strong>即实时细粒度的日志记录的性能落差和日志的完整不丢失无法兼顾。</strong></p>
<p>如果你要高性能、细粒度的记录日志，那你势必大量使用内存。而大量使用使用内存，万一没电了、程序突然崩了，这些中间态的日志还没持久化，就相当于白费了精力；而如果你想保证可靠性，那你就需要经常实时落盘。我们知道，写磁盘的行为是会设计用户态和内核态的切换，在高流畅性的要求下是绝对会影响性能了，而且这还不是你开多线程能够解决的问题。</p>
<h3 id="写磁盘为什么会非常慢">写磁盘为什么会非常慢</h3><p>现如今、几乎所有的操作系统在管理内存的时候，基本采用了页式管理的策略。即将连续的内存空间（注意空间，不是地址）换成了一个个页式大小。这样的好处有几点：</p>
<ol>
<li>按页这种大小进行管理、可以有效的减少内存碎片的粒度。</li>
<li>按页加载，可以充分利用磁盘上的交换空间，使得程序使用的空间能大大超过内存限制。</li>
</ol>
<blockquote>
<p>当然，iOS设备上不存在交换空间，但是也依然按照页式结构进行内存管理。</p>
</blockquote>
<p>回到为什么写磁盘会慢的问题上。我们一般会把内存中的数据进行持久化储存到磁盘上。但是写入磁盘并不是你想写就立刻写的，数据是通过flush的方式从内存写回到磁盘，一般有如下几种情况：</p>
<ol>
<li>通过页的<code>flag</code>标记为有改动，操作系统定时将这种脏页写回到磁盘上，时机不可控。</li>
<li>调用用户态的写接口-&gt;触发内核态的<code>sys_write</code>-&gt;文件系统将数据写回磁盘。</li>
</ol>
<p><strong><b style="color:red">乍一看上述第二种方式非常适合写日志，但是其包含两个非常明显的问题：</b></strong></p>
<ul>
<li>文件系统处于效率不会立刻将数据写回到磁盘（比如磁道寻址由于机械操作的原因相对非常耗时），而是以Block块的形式缓存在队列中，经过排序、合并到达一定比例之后再写回磁盘。</li>
<li>这种方式在将数据写回到磁盘时，需要经历两次拷贝。一次是把数据从用户态拷贝到内核态，需要经历上下文切换；还有一次是内核空间到硬盘上真正的数据拷贝。当切换次数过于频繁，整体性能也会下降。</li>
</ul>
<p>基于上述这些问题，<code>xlog</code>采用了<code>mmap</code>的方案进行日志系统的设计：</p>
<blockquote>
<p>mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。</p>
</blockquote>
<p>除了系能耐，使用mmap还能保证日志的完整性，因为如下这些情况下回自动回写磁盘：</p>
<ul>
<li>内存不足</li>
<li>进程 crash</li>
<li>调用 msync 或者 munmap</li>
<li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li>
</ul>
<h3 id="xlog源码分析">xlog源码分析</h3><p><code>xlog</code>的代码主要分为两块，面向上层的使用封装<code>xlogger</code>，暴露了一系列的借口。以及核心的<code>appender</code>和<code>log</code>等。</p>
<h4 id="log_buffer">log_buffer</h4><p><code>log_buffer</code>其目的是封装了一个对mmap/传统内存操作的数据结构。其核心思想就是将上层的操作转换对实际开辟出来的日志缓存地址进行读写（也封装了加密压缩操作等等）。我们以写操作为例子进行剖析：</p>
<pre><code><span class="keyword">bool</span> LogBuffer::Write(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _length) {
    <span class="comment">// 一些异常处理，不说了</span>
    <span class="keyword">if</span> (<span class="literal">NULL</span> == _data || <span class="number">0</span> == _length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">if</span> (buff_.Length() == <span class="number">0</span>) {
        <span class="keyword">if</span> (!__Reset()) <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">size_t</span> before_len = buff_.Length();
    <span class="keyword">size_t</span> write_len = _length;

    <span class="keyword">if</span> (is_compress_) {
        <span class="comment">// 是否开启压缩</span>
        cstream_.avail_in = (uInt)_length;
        cstream_.next_in = (Bytef*)_data;

        uInt avail_out = (uInt)(buff_.MaxLength() - buff_.Length());
        cstream_.next_out = (Bytef*)buff_.PosPtr();
        cstream_.avail_out = avail_out;

        <span class="keyword">if</span> (Z_OK != deflate(&amp;cstream_, Z_SYNC_FLUSH)) {
            <span class="keyword">return</span> <span class="literal">false</span>;
        }

        write_len = avail_out - cstream_.avail_out;
    } <span class="keyword">else</span> {
          <span class="comment">// 1. 写入数据到mmap文件或者内存当中</span>
        buff_.Write(_data, _length);
    }

    <span class="comment">// 2. 检查之前尝试加密但是还剩的未能成功加密的数据长度</span>
    before_len -= remain_nocrypt_len_;

    AutoBuffer out_buffer;
    <span class="keyword">size_t</span> last_remain_len = remain_nocrypt_len_;

    <span class="comment">// 3. 异步加密，更新未能加密的数据长度</span>
    log_crypt_-&gt;CryptAsyncLog((<span class="keyword">char</span>*)buff_.Ptr() + before_len, write_len + remain_nocrypt_len_, out_buffer, remain_nocrypt_len_);

    <span class="comment">// 4. 将加密的文本重新写入到之前最后一次加密的数据结尾位置</span>
    buff_.Write(out_buffer.Ptr(), out_buffer.Length(), before_len);

    <span class="comment">// 5. 更新数据</span>
    before_len += out_buffer.Length();
    buff_.Length(before_len, before_len);

    <span class="comment">// 6. 添加一下加密的长度之类的辅助信息补充在真实数据之后，主要用于解密时候用</span>
    log_crypt_-&gt;UpdateLogLen((<span class="keyword">char</span>*)buff_.Ptr(), (<span class="keyword">uint32_t</span>)(out_buffer.Length() - last_remain_len));

    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><p>不难看出，整体上就是对写入的数据进行加密，如果有压缩的需求同时进行压缩。并将修改后的数据存入真正的mmap文件/内存缓存中。</p>
<p>如果不能理解的话，可以看下我画的这幅图进行表示：</p>
<p><img src="https://raw.githubusercontent.com/SatanWoo/BeeHive/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-30%20%E4%B8%8A%E5%8D%889.58.00.png?raw=true" alt=""></p>
<h4 id="appender">appender</h4><p><code>xlog</code>方案真正的核心实际上只有一个appender文件，本质上的思路都比较清晰，将添加日志分为同步写和异步写。异步写的方式比较常用，下文会基于这个分析。</p>
<p><strong><span style="color:red">首先是日志系统的初始化配置</span></strong></p>
<pre><code>assert(_dir);
assert(_nameprefix);

<span class="keyword">if</span> (!sg_log_close) {
    __writetips2file(<span class="string">"appender has already been opened. _dir:%s _nameprefix:%s"</span>, _dir, _nameprefix);
    <span class="keyword">return</span>;
}

 <span class="comment">// 1. 设置真正的添加log信息函数，供上层调用</span>
xlogger_SetAppender(&amp;xlogger_appender);

<span class="comment">//mkdir(_dir, S_IRWXU|S_IRWXG|S_IRWXO);</span>
boost::filesystem::create_directories(_dir);
<span class="keyword">tickcount_t</span> tick;
tick.gettickcount();
__del_timeout_file(_dir);

<span class="keyword">tickcountdiff_t</span> del_timeout_file_time = <span class="keyword">tickcount_t</span>().gettickcount() - tick;

tick.gettickcount();

<span class="keyword">char</span> mmap_file_path[<span class="number">512</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(mmap_file_path, <span class="keyword">sizeof</span>(mmap_file_path), <span class="string">"%s/%s.mmap2"</span>, sg_cache_logdir.empty()?_dir:sg_cache_logdir.c_str(), _nameprefix);

<span class="keyword">bool</span> use_mmap = <span class="literal">false</span>;
<span class="comment">// 2. 尝试使用mmap</span>
<span class="keyword">if</span> (OpenMmapFile(mmap_file_path, kBufferBlockLength, sg_mmmap_file))  {
    sg_log_buff = <span class="keyword">new</span> LogBuffer(sg_mmmap_file.data(), kBufferBlockLength, <span class="literal">true</span>, _pub_key);
    use_mmap = <span class="literal">true</span>;
} <span class="keyword">else</span> {
    <span class="comment">// 3. 失败了回退到普通内存的方案</span>
    <span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[kBufferBlockLength];
    sg_log_buff = <span class="keyword">new</span> LogBuffer(buffer, kBufferBlockLength, <span class="literal">true</span>, _pub_key);
    use_mmap = <span class="literal">false</span>;
}

 <span class="number">4.</span> 注意点<span class="number">1</span>!!!!!!!!!!!!!!!!!!!!
<span class="keyword">if</span> (<span class="literal">NULL</span> == sg_log_buff-&gt;GetData().Ptr()) {
    <span class="keyword">if</span> (use_mmap &amp;&amp; sg_mmmap_file.is_open())  CloseMmapFile(sg_mmmap_file);
    <span class="keyword">return</span>;
}


<span class="number">5.</span> 注意点<span class="number">2</span>!!!!!!!!!!!!!!!!
AutoBuffer buffer;
sg_log_buff-&gt;Flush(buffer);

<span class="function">ScopedLock <span class="title">lock</span><span class="params">(sg_mutex_log_file)</span></span>;
sg_logdir = _dir;
sg_logfileprefix = _nameprefix;
sg_log_close = <span class="literal">false</span>;
appender_setmode(_mode);
lock.unlock();

<span class="keyword">char</span> mark_info[<span class="number">512</span>] = {<span class="number">0</span>};
get_mark_info(mark_info, <span class="keyword">sizeof</span>(mark_info));

<span class="keyword">if</span> (buffer.Ptr()) {
    __writetips2file(<span class="string">"~~~~~ begin of mmap ~~~~~\n"</span>);
    __log2file(buffer.Ptr(), buffer.Length());
    __writetips2file(<span class="string">"~~~~~ end of mmap ~~~~~%s\n"</span>, mark_info);
}

 <span class="number">6.</span> 添加一些关于xlog自身的信息
<span class="keyword">tickcountdiff_t</span> get_mmap_time = <span class="keyword">tickcount_t</span>().gettickcount() - tick;


<span class="keyword">char</span> appender_info[<span class="number">728</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(appender_info, <span class="keyword">sizeof</span>(appender_info), <span class="string">"^^^^^^^^^^"</span> __DATE__ <span class="string">"^^^"</span> __TIME__ <span class="string">"^^^^^^^^^^%s"</span>, mark_info);

xlogger_appender(<span class="literal">NULL</span>, appender_info);
<span class="keyword">char</span> logmsg[<span class="number">64</span>] = {<span class="number">0</span>};
<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"del time out files time: %"</span> PRIu64, (<span class="keyword">int64_t</span>)del_timeout_file_time);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"get mmap time: %"</span> PRIu64, (<span class="keyword">int64_t</span>)get_mmap_time);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_URL: "</span> MARS_URL);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_PATH: "</span> MARS_PATH);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_REVISION: "</span> MARS_REVISION);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_BUILD_TIME: "</span> MARS_BUILD_TIME);
xlogger_appender(<span class="literal">NULL</span>, <span class="string">"MARS_BUILD_JOB: "</span> MARS_TAG);

<span class="built_in">snprintf</span>(logmsg, <span class="keyword">sizeof</span>(logmsg), <span class="string">"log appender mode:%d, use mmap:%d"</span>, (<span class="keyword">int</span>)_mode, use_mmap);
xlogger_appender(<span class="literal">NULL</span>, logmsg);

BOOT_RUN_EXIT(appender_close);
</code></pre><p><strong>有几点需要特别注意点：</strong></p>
<ul>
<li>注意点1:    如果我们尝试打开mmap成功了，但是mmap对应的数据地址是NULL，那我们必须停止映射。因为NULL所代表的地址处于内核态，一旦映射了，势必造成Crash。</li>
<li>注意点2：使用mmap的情况下，如果上次应用断电了、Crash，日志的信息还是存在的，但是并不一定能及时的转换成我们想要的日志文件。因此我们首先检查下mmap文件里面有没有数据，有的话先把这部分转换成日志。</li>
</ul>
<p>而通过上层添加的日志，都会通过之前的<code>xlogger_appender</code>进行调用，进而往下层的<code>__appender_async</code> 记录日志。</p>
<h4 id="__appender_async">__appender_async</h4><p><code>__appender_async</code> 需要和其异步dump线程一起搭配看，是两段非常有意思的代码，它涉及了一个将mmap/内存数据写回到磁盘的策略。</p>
<p><strong><span style="color:red">首先是添加日志：</span></strong></p>
<pre><code><span class="keyword">static</span> void __appender_async(<span class="keyword">const</span> XLoggerInfo* _info, <span class="keyword">const</span> <span class="keyword">char</span>* _log) {
    ScopedLock lock(sg_mutex_buffer_async);
    <span class="keyword">if</span> (NULL == sg_log_buff) <span class="keyword">return</span>;

    <span class="keyword">char</span> temp[<span class="number">16</span>*<span class="number">1024</span>] = {<span class="number">0</span>};       <span class="comment">//tell perry,ray if you want modify size.</span>
    PtrBuffer log_buff(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));
    log_formater(_info, _log, log_buff);

    <span class="keyword">if</span> (sg_log_buff-&gt;GetData().Length() &gt;= kBufferBlockLength*<span class="number">4</span>/<span class="number">5</span>) {
       <span class="keyword">int</span> ret = snprintf(temp, <span class="keyword">sizeof</span>(temp), <span class="string">"[F][ sg_buffer_async.Length() &gt;= BUFFER_BLOCK_LENTH*4/5, len: %d\n"</span>, (<span class="keyword">int</span>)sg_log_buff-&gt;GetData().Length());
       log_buff.Length(ret, ret);
    }

    <span class="keyword">if</span> (!sg_log_buff-&gt;Write(log_buff.Ptr(), (unsigned <span class="keyword">int</span>)log_buff.Length())) <span class="keyword">return</span>;

     <span class="comment">// mmap/内存超出一定限度就写通知异步线程写回到文件中。</span>
    <span class="keyword">if</span> (sg_log_buff-&gt;GetData().Length() &gt;= kBufferBlockLength*<span class="number">1</span>/<span class="number">3</span> || (NULL!=_info &amp;&amp; kLevelFatal == _info-&gt;level)) {
       sg_cond_buffer_async.notifyAll();
    }
}
</code></pre><p><strong><span style="color:red">其次是异步线程Dump成日志</span></strong></p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __async_log_thread() {
    <span class="keyword">while</span> (<span class="literal">true</span>) {

        <span class="function">ScopedLock <span class="title">lock_buffer</span><span class="params">(sg_mutex_buffer_async)</span></span>;

        <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_log_buff) <span class="keyword">break</span>;

        AutoBuffer tmp;
        sg_log_buff-&gt;Flush(tmp);
        lock_buffer.unlock();

        <span class="keyword">if</span> (<span class="literal">NULL</span> != tmp.Ptr())  __log2file(tmp.Ptr(), tmp.Length());

        <span class="keyword">if</span> (sg_log_close) <span class="keyword">break</span>;

        sg_cond_buffer_async.wait(<span class="number">15</span> * <span class="number">60</span> *<span class="number">1000</span>);
    }
}
</code></pre><p>不难看出，整个日志的主要策略就是利用mmap将日志写入到磁盘映射上，当超过三分之一的时候通知异步线程去写日志。</p>
<p>这样就利用了mmap的实时性、完整性打造了一个逻辑非常清晰易懂的日志，整体架构图如下：</p>
<p><img src="https://blog.desmondyao.com/image/mars-xlog/xlog.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/07/30/xlog/" data-id="ck9fy2gd300032ni1h3ap3amt" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/07/30/xlog/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Macho-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/29/Macho-2/" class="article-date">
  <time datetime="2017-06-29T15:22:32.000Z" itemprop="datePublished">2017-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/29/Macho-2/">深入理解Macho文件（二）- 消失的__OBJC段与新生的__DATA段</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上文中，我们提到了有个神秘的<code>__OBJC</code>段，Runtime的许多机制就是依赖于它。但是无论我怎么搜索网上相关的资料、苹果的官方文档，都发现找不到这个段了。</p>
<p>一脸懵逼。没事，打开class-dump，看看它怎么处理的。嘿嘿，果不其然，在Class-Dump的代码里，有着如下注释：</p>
<blockquote>
<p>@0xced Old ABI has an <strong>OBJC segment. New ABI has a </strong>DATA,__objc_info section</p>
</blockquote>
<p>通俗解释来说，我们先如今使用的都是Objective-C2.0，所以原先的<code>__OBJC</code>段的东西都不存在了，而是存入了<code>__DATA</code>段里。所以，我们就以如下这张图来探究下这些与Runtime加载有关的节。</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_1.png?raw=true" alt=""></p>
<h4 id="__objc_imageinfo节"><code>__objc_imageinfo</code>节</h4><p>这个节可以看作是区别Objective-C 1.0与2.0的区别。从苹果的<strong>OBJC源码</strong>中能看到这个节的数据结构定义（去除Swift相关）如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">uint32_t</span> version; <span class="comment">// currently 0</span>
    <span class="keyword">uint32_t</span> flags;
} objc_image_info;
</code></pre><p>其中<code>version</code>这个字段目前永远为0。<code>flags</code>是用于做表示需要支持的特性的，比如是否需要/支持 <code>Garbage Collection</code>。</p>
<pre><code>SupportsGC          = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,  <span class="comment">// image supports GC</span>
  RequiresGC          = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,  <span class="comment">// image requires GC</span>

<span class="keyword">if</span> (ii.flags &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) {
    <span class="comment">// App wants GC. </span>
    <span class="comment">// Don't return yet because we need to </span>
    <span class="comment">// check the AppleScriptObjC exception.</span>
    wantsGC = YES;
}
</code></pre><h4 id="__objc__classlist节"><code>__objc _classlist</code>节</h4><p>这个节列出了所有的<code>class</code>（<strong>metaclass自身也是一种class</strong>）。</p>
<p>以计算器举例：我们先从<strong>MachoView</strong>找出一段数据，这个数据代表的就是class结构体所在的地址，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_2.png?raw=true" alt=""></p>
<p>通过hopper查看地址：<code>000000010002A128</code>，得到如下结果：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_3.png?raw=true" alt=""></p>
<p>内存地址（还没rebase过）中包含一个类本身的含义是什么意思呢？这都需要从Runtime里面来说起。</p>
<p>我们假设说我们有个类A，其父类为AA。有两个A类型的实例<code>a1, a2</code>。</p>
<p>我们都知道在真正调用<code>[a haha]</code>的方法的时候，实质上是通过<code>objc_msgSend</code>执行一系列的函数查询来找到真正的函数IMP，进而产生函数调用的。</p>
<p>由于objc_msgSend的调用返回值是不确定的，需要根据不同的状态来返回，比如ARM64下的<a href="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/">Indirect Result Location</a>。因此其本身的实现需要通过汇编来，我们截取最终要的一段ARM64的汇编如下：</p>
<pre><code><span class="comment">// 1. 定义全局函数符号 _objc_msgSend</span>
ENTRY _objc_msgSend

<span class="comment">// 2. 为Exception做准备</span>
UNWIND _objc_msgSend, NoFrame
MESSENGER_START

<span class="comment">// 3. 逻辑实现体</span>
cmp    x0, #<span class="number">0</span>            <span class="comment">// nil check and tagged pointer check</span>
<span class="tag">b</span><span class="class">.le</span>    LNilOrTagged        <span class="comment">//  (MSB tagged pointer looks negative)</span>
ldr    x13, [x0]        <span class="comment">// x13 = isa</span>
and    x16, x13, <span class="id">#ISA_MASK</span>    <span class="comment">// x16 = class    </span>
LGetIsaDone:
    CacheLookup NORMAL        <span class="comment">// calls imp or objc_msgSend_uncached</span>
</code></pre><ul>
<li>X0是函数调用者，即Self，比较其和nil的关系，如果是nil（或者tagged pointer）就走另外一种分支。<strong><span style="color:red">通过此，我们也不难理解为什么可以对nil发送消息了</span></strong></li>
<li>根据self所在的地址，取其成员变量<code>isa</code>。</li>
<li><code>x16 = x13 &amp; MASK</code>，也就意味着<code>x16</code>指向了内存里面的对应<code>A class</code>对象（<div style="color:red">注意：不是A class的实例对象）</div></li>
<li>上述为什么要对<code>ISA</code>进行一个mask的位与操作，主要原因和Tagged Pointer类似，理由就不再赘述。</li>
<li><p>执行<code>CacheLookUp</code>，具体的代码流程简要如下：</p>
<pre><code><span class="class">.macro</span> CacheLookup
<span class="comment">// x1 = SEL, x16 = isa</span>
ldp    x10, x11, [x16, <span class="hexcolor">#CAC</span>HE]    <span class="comment">// x10 = buckets, x11 = occupied|mask</span>
and    w12, w1, w11        <span class="comment">// x12 = _cmd &amp; mask</span>
add    x12, x10, x12, LSL #<span class="number">4</span>    <span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span>
<span class="comment">// x9 = key, x17 = _imp</span>
ldp    x9, x17, [x12]        <span class="comment">// {x9, x17} = *bucket</span>
<span class="number">1</span>:    cmp    x9, x1            <span class="comment">// if (bucket-&gt;sel != _cmd)</span>
    <span class="tag">b</span><span class="class">.ne</span>    <span class="number">2</span>f            <span class="comment">//     scan more</span>
    CacheHit $<span class="number">0</span>            <span class="comment">// call or return imp</span>

<span class="number">2</span>:    <span class="comment">// not hit: x12 = not-hit bucket</span>
    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span>
    cmp    x12, x10        <span class="comment">// wrap if bucket == buckets</span>
    <span class="tag">b</span><span class="class">.eq</span>    <span class="number">3</span>f
    ldp    x9, x17, [x12, #-<span class="number">16</span>]!    <span class="comment">// {x9, x17} = *--bucket</span>
    <span class="tag">b</span>    <span class="number">1</span>b            <span class="comment">// loop</span>

<span class="number">3</span>:    <span class="comment">// wrap: x12 = first bucket, w11 = mask</span>
    add    x12, x12, w11, UXTW #<span class="number">4</span>    <span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span>

<span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span>
<span class="comment">// The slow path may detect any corruption and halt later.</span>

ldp    x9, x17, [x12]        <span class="comment">// {x9, x17} = *bucket</span>
<span class="number">1</span>:    cmp    x9, x1            <span class="comment">// if (bucket-&gt;sel != _cmd)</span>
    <span class="tag">b</span><span class="class">.ne</span>    <span class="number">2</span>f            <span class="comment">//     scan more</span>
    CacheHit $<span class="number">0</span>            <span class="comment">// call or return imp</span>

<span class="number">2</span>:    <span class="comment">// not hit: x12 = not-hit bucket</span>
    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span>
    cmp    x12, x10        <span class="comment">// wrap if bucket == buckets</span>
    <span class="tag">b</span><span class="class">.eq</span>    <span class="number">3</span>f
    ldp    x9, x17, [x12, #-<span class="number">16</span>]!    <span class="comment">// {x9, x17} = *--bucket</span>
    <span class="tag">b</span>    <span class="number">1</span>b            <span class="comment">// loop</span>

<span class="number">3</span>:    <span class="comment">// double wrap</span>
    JumpMiss $<span class="number">0</span>

.endmacro
</code></pre></li>
</ul>
<p>我们接着再来读读这段汇编。</p>
<ul>
<li><code>x16</code>承接上段汇编，是<code>A class</code>的实体，取出其<code>cache</code>成员变量。</li>
<li><p>按照<code>_cmd</code>和<code>mask</code>的位运算，找出其在bucket数组中的偏移量。取出的数据结构是个<code>bucket_t</code>，如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">bucket_t</span> {
<span class="keyword">private</span>:
    <span class="keyword">cache_key_t</span> _key;
    IMP _imp;
}
</code></pre></li>
<li><p>从上述数据结构不难理解，<code>cache</code>对象里面存了一个bucket数组，用于进行<code>SEL</code>对应的<code>IMP</code>，缓存。<code>key</code>是<code>SEL</code>对应的地址。</p>
</li>
<li>如果地址相同，就代表命中，执行<strong>CacheHit</strong>，其实就是简单的<code>br x17</code>。由于此时<code>x17</code>是IMP，即对应的函数地址，直接跳过去就完事了，这个分支下的<code>objc_msgSend</code>就执行完成了。</li>
<li>那如果不相同，即命中的bucket里面不是我们要的<code>SEL</code>，就检查这个命中的桶是不是没有<code>SEL</code>，如果是空的，执行<code>__objc_msgSend_uncached</code>。这步后续开始就是去查找类方法列表-&gt;父类方法列表了。</li>
<li>如果不为空，否则就执行循环，进行查询。</li>
</ul>
<p>**<span style="color:red">一些细节知识：  </span></p>
<ol>
<li>.macro可以在汇编里面定义一段可以被复用的代码段。   </li>
<li>.1b 代表的是向回找label定义为1的代码片段起始；1f代表向下找label定义为1的代码片段起始。  </li>
<li>为什么在计算isa的时候先要位与一个mask，其原因在于现在的isa是一个兼具多种含义的指针。<br>**</li>
</ol>
<blockquote>
<p>本文重点不在讲述Runtime上，所以objc_msgSend的细节就不去更深入的探究了。</p>
</blockquote>
<p>所以，按照上述步骤来理解，我们可以发现，苹果实例对象的<code>objc_msgSend</code>的机制可以简要抽象如下图例子：</p>
<h4 id="__objc__catlist节"><code>__objc _catlist</code>节</h4><p>该节顾名思义，代表的就是程序里面有哪些<code>Category</code>。我们还是通过MachoView和Hopper来看一看：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_4.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_5.png?raw=trueg" alt=""></p>
<p>从Hopper里面看出的内容我们不难得到，<code>catlist</code>也对应着一个<code>Category_t</code>的实体，会在程序运行的过程中存在于内存中。这个结构体的数据定义如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">category_t</span> {
    <span class="keyword">const</span> <span class="keyword">char</span> *name;
    <span class="keyword">classref_t</span> cls;
    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;
    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;
    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;
    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties;
    <span class="comment">// Fields below this point are not always present on disk.</span>
    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *_classProperties;
}
</code></pre><h4 id="__objc_protolist"><code>__objc_protolist</code></h4><p>该节的理解也非常简单，代表的就是程序里面有哪些<code>Protocol</code>。数据结构定义如下：</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">protocol_t</span> : objc_object {
    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;
    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;
    <span class="keyword">method_list_t</span> *instanceMethods;
    <span class="keyword">method_list_t</span> *classMethods;
    <span class="keyword">method_list_t</span> *optionalInstanceMethods;
    <span class="keyword">method_list_t</span> *optionalClassMethods;
    <span class="keyword">property_list_t</span> *instanceProperties;
    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span>
    <span class="keyword">uint32_t</span> flags;
    <span class="comment">// Fields below this point are not always present on disk.</span>
    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;
    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;
    <span class="keyword">property_list_t</span> *_classProperties;
}
</code></pre><h4 id="__objc_classrefs"><code>__objc_classrefs</code></h4><p>一开始这个节的意义我实在是没看懂。实在不理解在已经存在classlist这个数据节的情况下，为啥还是需要用这个类。后来经过一番实验发现，该节的目的是为了标记这个类究竟有没有被引用</p>
<p>那有没有被引用的意义是什么？<strong><span style="color:red">可以包瘦身。如果在MachoView中都能直观告诉我们没有引用的类甚至是方法，都可以直接剔除了。</span></strong></p>
<blockquote>
<p>但是，作为一名经常奋战在包瘦身一线的同学，我可以直接告诉你，上述的想法是大错特错的。苹果这种可以利用字符串拼接从而调用大量runtime的方法，绝对坑哭了做包瘦身的人。</p>
</blockquote>
<p><strong><span style="color:blue">嘿嘿，不过其实这样也没啥难度，下一篇我会写一个基于Macho的包瘦身方案，绝对轻便简洁，不用基于AST来分析各种调用关系，这里卖个关子。</span></strong></p>
<h4 id="__objc_selrefs"><code>__objc_selrefs</code></h4><p>这节的原理同上，告诉你究竟有哪些SEL对应的字符串被引用了。</p>
<h4 id="__objc_superrefs"><code>__objc_superrefs</code></h4><p>这节虽然中字面意义上我们知道，是对超类（即父类）的引用，但是没理解啊，为什么要有这么一个破玩意。<br>不懂就一点点摸索，从MachoView里面来看，数据对应的地址还是指向一个个在classlist出现的类实体。</p>
<p>通过和classlist里面出现的数据进行diff对比，如下图所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_5.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_6.png?raw=true" alt=""></p>
<p>可以发现，所有出现的<code>objc_superrefs</code>都是会被继承的类。那么，为什么要单独设计这样一个来存放这样的信息呢？</p>
<p><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong><br><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong><br><strong><div style="color:red">哈哈哈：我上面的分析都是错的！！！！</div></strong></p>
<p>真正的原因如下：<br>我们知道，我们在子类调用一个方法的时候，为了调用上层的父类的实现（如果有），常常会写出一个<code>[super message]</code>的代码。而这样的代码，在底层是会转换成调用<code>objc_msgSendSuper2</code>。而其接受的参数，第一个为结构体<code>objc_super2</code>，第二个为<code>SEL</code>。其中<code>objc_super2</code>的定义如下：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> </span>{
    id receiver;
    Class current_class;
};
</code></pre><p>为了构造这样的数据结构体，在汇编层面会将<code>[super message]</code>转换成如下的汇编指令：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_7.png?raw=true" alt=""></p>
<p>注意看红框内的汇编代码，我们来分步骤解释下整体的汇编结构：</p>
<ul>
<li>首先在调用<code>[ViewController viewDidLoad]</code>的时候，x0是self（ViewController的实例），x1是@selector（viewDidLoad）。</li>
<li>0x1000046c0 偏移的地方将<code>sp</code>向下申请了<code>48</code>(0x30)bytes的空间。</li>
<li>0x1000046c4 将<code>SP</code>的地址存到的<code>x8</code>寄存器中。 <div style="color:red">这个X8寄存器会很关键</div></li>
<li>0x1000046d0 通过<strong>adrp</strong>指令加载内存数据中的一个page，根据这个page的offset找到对应的<code>viewDidLoad</code>方法的ref。存入<code>x9</code>。</li>
<li>0x1000046f8 通过<code>x9</code>寄存器中ref指向的地址，以该地址为内存读取真正的SEL，存入<code>x1</code>。</li>
</ul>
<p><strong><span style="color:red">至此，调用objc_msgSendSuper2的第二个参数准备完毕</span></strong>，我们再来看看第一个的参数是如何设置的。</p>
<ul>
<li><p>0x1000046d8 同样的方式，加载一个page的0x78的偏移位置的数据，点进去会发现是个class地址，存到<code>x10</code>中。<br><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_8.png?raw=true" alt=""></p>
</li>
<li><p>然后，就轮到我们的栈空间出场了。我们先把<code>x0</code>存到sp处，然后再把<code>x10</code>，也就是上面说的class地址存入<code>sp+8 (str x10, [sp, #0x8]</code>。</p>
</li>
<li>最后，还记得我们之前提到的<code>x8</code>寄存器吗？我们之前可是将<code>sp</code>的值赋予了<code>x8</code>了。所以，在<code>1000046fc x0, x8</code>这个地方，我们将<code>x8</code>的值赋予了<code>x0</code>。<strong><span style="color:red">至此，调用objc_msgSendSuper2的第一个参数也准备完毕</span></strong></li>
</ul>
<p>最后附上<code>objc_msgSendSuper2</code>的代码供参考，逻辑非常简单，不再赘述。</p>
<pre><code>ENTRY _objc_msgSendSuper2
    UNWIND _objc_msgSendSuper2, NoFrame
    MESSENGER_START

    ldp    x0, x16, <span class="attr_selector">[x0]</span>        <span class="comment">// x0 = real receiver, x16 = class</span>
    ldr    x16, <span class="attr_selector">[x16, #SUPERCLASS]</span>    <span class="comment">// x16 = class-&gt;superclass</span>
    CacheLookup <span class="attribute">NORMAL</span>

    END_ENTRY _objc_msgSendSuper2
</code></pre><p><strong><span style="color:red">等等，心急的读者会问：你说了那么一大堆，你还是没解释到底为什么要存在superrefs?</span></strong></p>
<p><strong>在Objective-C的设计里面，函数就是函数，它并不知道自己属于哪个类里面。换句通俗的话来说，必须是你（编译器）说去哪个class实体的方法列表里面寻找调用，才会真正的去找对应的方法，函数自身不知道是父类还是子类。同时，由于苹果的设计原因，一个类初始化的实例，是不具备了解superclass的条件的，只有通过isa对应的类实体才能获得。因此，在构建<code>objc_msgSendSuper2</code>的第一个参数的时候，就不如指在编译期定其对应的<code>current_class</code>，以方便后续的<code>superclass</code>方法列表查找。</strong></p>
<p><strong><span style="color:red">而且，也必须在编译期间，根据当前的类，去定义<code>current_class</code>这个字段的值，不然当我们有多个层级的继承关系时，在运行时如何从单一的self参数构建正确的向上查找层级，就当前的OC设计里，就做不到了。</span></strong></p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/mach2_9.png?raw=true" alt=""></p>
<blockquote>
<p>C++里面，对于函数来说，是可以明确知道对应的所属类的。究其原因，在于C++的不同类，都是不同的命名空间，调用父类的方法时，需明确指定父类的命名空间，如BASE::method。</p>
</blockquote>
<h4 id="__objc_const"><code>__objc_const</code></h4><p>这个节的含义是所有初始化的常量的都显示在这。但是很多人都对此节有着巨大的误解，认为<strong><span style="color:red"><code>const int k = 5</code></span></strong>对应的数据会存放在<code>__objc_const</code>节中。</p>
<p>但是这是大错特错的，在代码里声明的<code>const</code>类型，实质上都属于<code>__TEXT</code>段，并属于其中的<code>const</code>节。而在<code>__objc_const</code>中存放的，是一些需要在类加载过程中用到的<code>readonly data</code>。具体这个<code>readonly data</code>包含了如下（但不限于）的数据结构：</p>
<pre><code><span class="comment">// 只读数据</span>
<span class="keyword">struct</span> <span class="keyword">class_ro_t</span> {
    <span class="keyword">uint32_t</span> flags;
    <span class="keyword">uint32_t</span> instanceStart;
    <span class="keyword">uint32_t</span> instanceSize;
<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
    <span class="keyword">uint32_t</span> reserved;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;

    <span class="keyword">const</span> <span class="keyword">char</span> * name;
    <span class="keyword">method_list_t</span> * baseMethodList;
    <span class="keyword">protocol_list_t</span> * baseProtocols;
    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;

    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;
    <span class="keyword">property_list_t</span> *baseProperties;

    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> {
        <span class="keyword">return</span> baseMethodList;
    }
};

<span class="comment">// 方法列表</span>
<span class="keyword">struct</span> <span class="keyword">method_list_t</span>:entsize_list_tt {
     <span class="keyword">uint32_t</span> entsizeAndFlags;
     <span class="keyword">uint32_t</span> count;
     Element first;
}

<span class="comment">// 方法实体</span>
<span class="keyword">struct</span> <span class="keyword">method_t</span> {
    SEL name;
    <span class="keyword">const</span> <span class="keyword">char</span> *types;
    IMP imp;
}
</code></pre><p>关于<code>readonly data</code>后续会再开一个章节单独讲解。</p>
<h3 id="结尾">结尾</h3><p>基本上MachO 关于Runtime涉及的主要的类就分析到这了，下一次继续剖析其他细枝末节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/06/29/Macho-2/" data-id="ck9fy2gha002v2ni18iab3x7c" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/06/29/Macho-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Macho-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/13/Macho-1/" class="article-date">
  <time datetime="2017-06-13T15:25:34.000Z" itemprop="datePublished">2017-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/13/Macho-1/">深入剖析Macho (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="起因">起因</h3><p>最近在公司里和一些同事搞了一些东西，略微底层。于是希望借这个机会好好把<code>Macho</code>相关的知识点梳理下。</p>
<p>虽然网上关于<code>Macho</code>的文章介绍一大堆，但是我希望能够从<code>Macho</code>的构成，加载过程以及需要了解的相关背景角度去进行分析，每一个点都力图深入。也会在这篇文章最后打造一个类似<code>class-dump</code>的小型工具。</p>
<h3 id="程序启动加载的过程">程序启动加载的过程</h3><p>当你点击一个icon启动应用程序的时候，系统在内部大致做了如下几件事：</p>
<ul>
<li>内核（OS Kernel）创建一个进程，分配虚拟的进程空间等等，加载动态链接器。</li>
<li>通过动态链接器加载主二进制程序引用的库、绑定符号。</li>
<li>启动程序</li>
</ul>
<p>虽然简要概述很简单，但是有几个需要特别主要的地方：</p>
<ol>
<li>二进制程序的格式是怎么样的？内核是如何加载它的？</li>
<li>内核是如何得知要使用哪种动态链接器的？</li>
<li>动态链接器和静态链接器的区别是啥？</li>
<li>程序在运行前究竟要做哪些步骤？顺序是怎么样的？</li>
</ol>
<p><strong>带着这些问题，我将一步步来剖析整个过程</strong></p>
<h3 id="二进制程序格式">二进制程序格式</h3><p>在MacOS或者iOS上可执行的程序格式叫做<code>Macho-O</code>，它的主要成分如下图所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20150122/1421892661838860.gif" alt=""></p>
<ul>
<li>一个<code>mach_header</code>标记一些元信息，比如架构、CPU、大小端等等</li>
<li>多个<code>Load Command</code>告诉你究竟如何加载每个段的信息。</li>
<li>多个<code>Segement</code>及<code>Section</code>，包含了每个段自身的信息。包括一些数据、代码以及<del>段的执行权限</del>等等。</li>
</ul>
<p><strong><div style="color:red">需要注意的是，不仅仅是可执行文件是<code>Macho-O</code>，目标文件(.o)以及动态库，静态库都是<code>Mach-O</code>格式。</div></strong></p>
<p>所以，下面我们就用64位的定义从每个部分来介绍一下具体的数据结构：</p>
<h3 id="mach_header_64">mach_header_64</h3><p>这个结构体代表的都是<code>Mach-O</code>文件的一些元信息，它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p>
<p>从源码中可以看出，整个结构题定义如下：</p>
<pre><code><span class="keyword">struct</span> mach_header_64 {
    <span class="keyword">uint32_t</span>    magic;        <span class="comment">/* mach magic number identifier */</span>
    <span class="keyword">cpu_type_t</span>    cputype;    <span class="comment">/* cpu specifier */</span>
    <span class="keyword">cpu_subtype_t</span>    cpusubtype;    <span class="comment">/* machine specifier */</span>
    <span class="keyword">uint32_t</span>    filetype;    <span class="comment">/* type of file */</span>
    <span class="keyword">uint32_t</span>    ncmds;        <span class="comment">/* number of load commands */</span>
    <span class="keyword">uint32_t</span>    sizeofcmds;    <span class="comment">/* the size of all the load commands */</span>
    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* flags */</span>
    <span class="keyword">uint32_t</span>    reserved;    <span class="comment">/* reserved */</span>
};
</code></pre><ul>
<li><strong>magic</strong> 用于标识当前设备的是大端序还是小端序。如果是<code>0xfeedfacf(MH_MAGIC_64)</code>就是大端序，而<code>0xcffaedfe(MH_CIGAM_64)</code>是小端序，iOS系统上是小端序。</li>
<li><strong>cputype</strong> 标识CPU的架构，比如ARM，X86，i386等等，进行了宏观划分。</li>
<li><strong>cpusubtype</strong> 具体的CPU类型，区分不同版本的处理器。</li>
<li><strong>filetype</strong> 划分之前我们提到的文件类型，比如是可执行文件还是目标文件。</li>
<li><strong>ncmds</strong> 有几个<code>LoadCommands</code>，每个<code>LoadCommands</code>代表了一种<code>Segment</code>的加载方式。</li>
<li><strong>sizeofcmds</strong> <code>LoadCommand</code>的大小，主要用于划分Mach-O文件的‘区域’。</li>
<li><strong>flags</strong> 标记了一些dyld过程中的参数。</li>
<li><strong>reversed</strong> 没用。</li>
</ul>
<p>这里有个比较有意思的问题是，我为了验证大端序小端序的问题的时候，用了MacOS上的计算器进行<br>验证，本质上这应该是个小端序的应用程序，其二进制如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.12.33.png?raw=true" alt="屏幕快照 2017-06-11 下午3.12.33.png"> </p>
<p>但是在<code>otool</code>和<code>MachoView</code>上看出来都是<code>MH_MAGIC_64</code>，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.13.47.png?raw=true" alt="屏幕快照 2017-06-11 下午3.13.47.png"> </p>
<p>我擦，这下看了懵逼，难道是我理解错了？于是赶紧翻了下<code>class-dump</code>代码，其解析header部分代码如下：</p>
<pre><code>// 解析部分代码
_byteOrder = <span class="type">CDByteOrder_LittleEndian</span>;

<span class="type">CDDataCursor</span> *cursor = [[<span class="type">CDDataCursor</span> alloc] initWithData:data];
_magic = [cursor readBigInt32];
<span class="keyword">if</span> (_magic == <span class="type">MH_MAGIC</span> || _magic == <span class="type">MH_MAGIC_64</span>) {
    _byteOrder = <span class="type">CDByteOrder_BigEndian</span>;
} <span class="keyword">else</span> <span class="keyword">if</span> (_magic == <span class="type">MH_CIGAM</span> || _magic == <span class="type">MH_CIGAM_64</span>) {
    _byteOrder = <span class="type">CDByteOrder_LittleEndian</span>;
} <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="keyword">nil</span>;
}

// readBigInt32的代码
- (uint32_t)readBigInt32;
{
    uint32_t <span class="literal">result</span>;

    <span class="keyword">if</span> (_offset + sizeof(<span class="literal">result</span>) &lt;= [_data length]) {
        <span class="literal">result</span> = <span class="type">OSReadBigInt32</span>([_data bytes], _offset);
        _offset += sizeof(<span class="literal">result</span>);
    } <span class="keyword">else</span> {
        [<span class="type">NSException</span> <span class="keyword">raise</span>:<span class="type">NSRangeException</span> format:@<span class="string">"Trying to read past end in %s"</span>, __cmd];
        <span class="literal">result</span> = <span class="number">0</span>;
    }

    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>我们在用LLDB看下<code>_data</code>里面的内容指向的内存地址：</p>
<pre><code>(lldb) po _<span class="preprocessor">data</span>
&lt;OS_dispatch_data: <span class="preprocessor">data</span>[<span class="number">0x100600b40</span>] = { leaf, size = <span class="number">199520</span>, <span class="keyword">buf </span>= <span class="number">0x100281000</span> }&gt;
</code></pre><p>用<code>Xcode Memory</code>看下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%883.25.06.png?raw=true" alt="屏幕快照 2017-06-11 下午3.25.06.png"> </p>
<p>看起来是没错的。然后由于MacOSX本身是小端序的，<code>CFFAEDFE</code>这样的数据会被自动解析成<code>FE ED FA CF</code>。所以这样是有问题的。因此，<code>class-dump</code>采用了<code>OSReadBigInt32</code>的方式去解析：</p>
<pre><code><span class="constant">OS_INLINE</span>
<span class="constant">UInt32</span>
<span class="constant">OSReadSwapInt32</span>(
    volatile void               * base,
    volatile <span class="constant">UInt</span>                 offset
)
{
    <span class="class"><span class="keyword">union</span> <span class="title">lconv</span> {</span>
    <span class="constant">UInt32</span> ul;
    <span class="constant">UInt8</span>  uc[<span class="number">4</span>];
    } *inp, outv;

    <span class="regexp">//</span> 步骤<span class="number">1</span>
    inp = (<span class="class"><span class="keyword">union</span> <span class="title">lconv</span> *)((<span class="title">UInt8</span> *)<span class="title">base</span> + <span class="title">offset</span>);</span>

    /<span class="regexp">/ 步骤2
    outv.uc[0] = inp-&gt;uc[3];
    outv.uc[1] = inp-&gt;uc[2];
    outv.uc[2] = inp-&gt;uc[1];
    outv.uc[3] = inp-&gt;uc[0];

    ／／ 步骤3
    return (outv.ul);
}</span>
</code></pre><p>这个方法会利用<code>union</code>的特性，进行数据交换。我们还是用刚刚的例子来验证：</p>
<ul>
<li>步骤1按照默认方式读出数据：<code>FE ED FA CF</code>。</li>
<li>步骤2进行交换，地址从低到高，分别是<code>FE ED FA CF</code>。</li>
<li>步骤3利用<code>union</code>的特性，当成一个32的数输出，按照默认小端序解析，会成为<code>CF FA ED FE</code>。也即是<code>MH_CIGAM_64</code>，是小端序。</li>
</ul>
<p><strong>其实按照MachoView的解析方式，将<code>MH_CIGAM_64</code>和<code>MH_MAGIC_64</code>理解成MACHO文件和当前平台的编码顺序是否一致更好，如果解析出来是<code>MH_CIGAM_64</code>则表示不一致；否则一致。</strong></p>
<h3 id="Segment（段）">Segment（段）</h3><p>讲完了<code>Mach-O</code>文件的header部分，我们需要进行Load Commands部分。但是在这之前，我想先大致介绍下Mach-O中的Segment及其下属的Section（节），让大家能更好的理解Load Commands。</p>
<p>从整体上来说，<code>Mach-O</code>里面包含的段有以下这些：</p>
<ul>
<li><strong>__TEXT</strong> 代码段/只读数据段</li>
<li><strong>__PAGEZERO</strong> Catch访问NULL指针的非法操作的段</li>
<li><strong>__DATA</strong> 数据段</li>
<li><strong>__LINKEDIT</strong> 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等。</li>
<li><strong>__OBJC</strong> 包含会被<code>Objective Runtime</code>使用到的一些数据。</li>
</ul>
<blockquote>
<p>关于<code>__OBJC</code>这个段，我是一脸懵逼的，从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述，具体让我研究研究再说。</p>
</blockquote>
<h4 id="Section（节）">Section（节）</h4><p>刚刚我们提到的<code>__TEXT</code>和<code>__DATA</code>段都分别有下属的节。</p>
<p><strong><div style="color:red">之所以按照段-&gt;节的方式组织，是因为同一个段下的节，在内存的权限相同，可以不完全按照页大小进行对齐，节省内存空间。而对外整体暴露段，在装载程序的时候完整映射成一个vma，可以更好的做内存对齐。</div></strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT.</strong>text</td>
<td><strong>只有</strong>可执行的机器码</td>
</tr>
<tr>
<td><strong>TEXT.</strong>cstring</td>
<td>去重后的C字符串</td>
</tr>
<tr>
<td><strong>TEXT.</strong>const</td>
<td>初始化过的常量</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs</td>
<td>符号桩。本质上是一小段会直接跳入lazybinding的表对应项指针指向的地址的代码。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stub_helper</td>
<td>辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>unwind_info</td>
<td>用于存储处理异常情况信息</td>
</tr>
<tr>
<td><strong>TEXT.</strong>eh_frame</td>
<td>调试辅助信息</td>
</tr>
<tr>
<td><strong>DATA.</strong>data</td>
<td>初始化过的可变的数据</td>
</tr>
<tr>
<td><strong>DATA.</strong>nl_symbol_ptr</td>
<td>非lazy-binding的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td><strong>DATA.</strong>la_symbol_ptr</td>
<td>lazy-binding的指针表，每个表项中的指针一开始指向stub_helper</td>
</tr>
<tr>
<td><strong>DATA.</strong>const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td><strong>DATA.</strong>mod_init_func</td>
<td>初始化函数，在main之前调用</td>
</tr>
<tr>
<td><strong>DATA.</strong>mod_term_func</td>
<td>终止函数，在main返回之后调用</td>
</tr>
<tr>
<td><strong>DATA.</strong>bss</td>
<td>没有初始化的静态变量</td>
</tr>
<tr>
<td><strong>DATA.</strong>common</td>
<td>没有初始化过的符号声明</td>
</tr>
</tbody>
</table>
<p>其中，比较难以理解的可能是<code>__la_symbol_ptr</code>，让我们还是来以计算器的例子来理解：</p>
<ul>
<li>我们先从MachoView上找一个<code>stub</code>，比如[xxxx -&gt; _CFRelease]。</li>
<li>其数据是<strong>FF256A7C0000</strong>，结合这个节是在__TEXT段中，我猜测是应该一段汇编代码的16进制表示。</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.48.21.png?raw=true" alt="屏幕快照 2017-06-12 上午10.48.21.png"> </p>
<ul>
<li>从Hopper中打开，查看对应偏移量的stub含义：</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.40.50.png?raw=true" alt="屏幕快照 2017-06-12 上午10.40.50.png"> </p>
<p>我们可以看到这段代码的16进制表达就是：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%883.47.50.png?raw=true" alt="屏幕快照 2017-06-13 下午3.47.50.png"> </p>
<p>从上图不难看出，stub的含义就是跳转到以<code>__la_symbol_ptr</code>对应表项数据所指向地址的代码。</p>
<ul>
<li>跳入以后，我们可以看到如下代码：</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-12%20%E4%B8%8A%E5%8D%8810.41.02.png?raw=true" alt="屏幕快照 2017-06-12 上午10.41.02.png"> </p>
<p>可以看到，在还没加载程序的时候，对应表项的数据还是<code>dq _CFRelease</code>。双击点进去看一下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%883.51.34.png?raw=true" alt="屏幕快照 2017-06-13 下午3.51.34.png"> </p>
<p>这里显示的应该是有点问题，如果全0的话是不可能使用lazy binding的。</p>
<p>我们还是用MachOView来看一下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.04.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.04.png"> </p>
<p>跳转到这个地址看看，没错了，处于stub_helper节里了：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.28.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.28.png"> </p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%884.04.33.png?raw=true" alt="屏幕快照 2017-06-13 下午4.04.33.png"> </p>
<blockquote>
<p><code>__la_symbol_ptr</code> 里面所有表项的数据都会被bind成<code>dyld_stub_helper</code>。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/06/13/Macho-1/" data-id="ck9fy2ghc002x2ni1ilpz4onf" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/06/13/Macho-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-FBTweak" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/FBTweak/" class="article-date">
  <time datetime="2017-06-01T15:43:05.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/FBTweak/">从FBTweak 源码剖析一些中阶知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发的过程中，我们进场要做一些类似于参数调整之类的琐碎问题。如果每次都通过<code>CMD + R</code>来编译运行查看效果，浪费的时间真是得不偿失。因此，在看到了<code>FBTweak</code>这个项目以后，就感觉比较有意思，让我们来对这个项目一探究竟。</p>
<h3 id="晕头转向的宏定义">晕头转向的宏定义</h3><p>打开项目，整个项目非常简单，抛去UI部分，主要使用的主API就是在<code>FBTweakInline.h</code>中的4个宏定义：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakInline</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakInline(category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakValue</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakValue(category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakBind</span><span class="params">(object_, property_, category_, collection_, name_, ...)</span></span> _FBTweakBind(object_, property_, category_, collection_, name_, __VA_ARGS__)

<span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakAction</span><span class="params">(category_, collection_, name_, ...)</span></span> _FBTweakAction(category_, collection_, name_, __VA_ARGS__)
</code></pre><p>看起来很简单，但是随便点一个深入进去看，就会发现如下这些令人头昏脑胀的宏定义。熟悉Facebook开源项目的人可能都知道，它们就好这口。所以在进行整个项目的介绍前，我们先大致分析下各个宏的作用。</p>
<pre><code>#define __FBTweakConcat_<span class="list">(<span class="keyword">X</span>, Y)</span> X ## Y
#define __FBTweakConcat<span class="list">(<span class="keyword">X</span>, Y)</span> __FBTweakConcat_<span class="list">(<span class="keyword">X</span>, Y)</span>

#define __FBTweakIndex<span class="list">(<span class="keyword">_1</span>, _2, _3, value, ...)</span> value
#define __FBTweakIndexCount<span class="list">(...)</span> __FBTweakIndex<span class="list">(<span class="keyword">__VA_ARGS__</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span>

#define __FBTweakDispatch1<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withoutRange
#define __FBTweakDispatch2<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withPossible
#define __FBTweakDispatch3<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __withRange
#define _FBTweakDispatch<span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible, ...)</span> __FBTweakConcat<span class="list">(<span class="keyword">__FBTweakDispatch</span>, __FBTweakIndexCount<span class="list">(<span class="keyword">__VA_ARGS__</span>)</span>)</span><span class="list">(<span class="keyword">__withoutRange</span>, __withRange, __withPossible)</span>
</code></pre><h4 id="_FBTweakBind">_FBTweakBind</h4><p>我们以<code>_FBTweakBind</code>作为突破口，来进行深入分析。</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">FBTweakBind</span><span class="params">(object_, property_, category_, collection_, name_, ...)</span></span> _FBTweakBind(object_, property_, category_, collection_, name_, __VA_ARGS__)
</code></pre><p>这个宏包了层皮，就是接受至少5个参数的可变参数，并将参数传递给<code>_FBTweakBind</code>这个宏。在这层定义中，我们看到了<code>...</code>和<code>__VA_ARGS__</code>。</p>
<p><code>...</code>对于一个宏/函数来说，意味着接受可变参数。这个参数的形参（换句话说，你要使用或者传递给其他函数的载体）就是<code>__VA_ARGS__</code>。</p>
<p>好，接下来我们看下<code>_FBTweakBind</code>，其定义如下：</p>
<pre><code><span class="hexcolor">#def</span>ine _FBTweakBind(object_, property_, category_, collection_, name_, ...) _FBTweakDispatch(_FBTweakBindWithoutRange, _FBTweakBindWithRange, _FBTweakBindWithPossible, __VA_ARGS__)(object_, property_, category_, collection_, name_, __VA_ARGS__)
</code></pre><p>卧槽，一开始看的时候，头大了，怎么两个括号呢？仔细一看，<code>_FBTweakBindWithoutRange</code>，<code>_FBTweakBindWithRange</code>， <code>_FBTweakBindWithPossible</code> 都是不同的宏定义。那么整个<code>_FBTweakBind</code>的作用就是根据可变参数，传递给<code>_FBTweakDispatch</code>，从上述三个宏定义中选择出一个对应的，然后继续调用宏展开。</p>
<p>好，再看<code>__FBTweakDispatch</code>，如下：</p>
<pre><code><span class="hexcolor">#def</span>ine _FBTweakDispatch(__withoutRange, __withRange, __withPossible, ...) __FBTweakConcat(__FBTweakDispatch, __FBTweakIndexCount(__VA_ARGS__))(__withoutRange, __withRange, __withPossible)
</code></pre><p>这个也比较绕，我们继续抽丝剥茧，可以发现，核心的本质就变成：</p>
<ul>
<li><code>__FBTweakIndexCount(args)</code> 返回一个具体数字（1、2、3）</li>
<li><code>__FBTweakConcat(__FBTweakDispatch, 数字)</code> 生成具体的宏定义Token，比如<code>__FBTweakDispatch1</code>，<code>__FBTweakDispatch2</code>之类的。</li>
<li>利用刚刚的token继续做函数展开。</li>
</ul>
<p><b>到这里，整体思路都没啥特别困难的，但是让我有点诧异的如下两个宏定义：</b></p>
<pre><code><span class="hexcolor">#def</span>ine __FBTweakIndex(_1, _2, _3, value, ...) value
<span class="hexcolor">#def</span>ine __FBTweakIndexCount(...) __FBTweakIndex(__VA_ARGS__, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)
</code></pre><p>我们刚刚提到，<code>__FBTweakIndexCount</code>会根据参数返回具体的数字，那它本质上是依靠<code>__FBTweakIndex</code>去返回第4个参数。（<code>_1, _2, _3</code>就是普通的宏展开占位符，别被骗了，和x, y, z没区别）。</p>
<p><b>好，这个<code>__FBTweakIndex</code>按定义来说，至少需要<span style="color:red">4个</span>参数，但是我在试了<code>__FBTweakIndexCount()</code>，他竟然也能给返回<span style="color:red">1</span></b>，这就让我懵逼了。</p>
<p>按照我的理解，当我传递参数为空的时候，<code>__VA_ARGS__</code>就是空，那么宏定义展开的时候，这个应该是不作数的，就导致缺少了一个参数啊？？？</p>
<p><b style="color:red">后来，我发现我思考错了，我从语法分析的角度去分析了这个宏，但是实际上，宏就是简单的“token”展开！！！</b></p>
<p>我们再来看看<code>__FBTweakIndex的定义</code>，展开后其实就是要了第4个参数，前面的都没啥用。</p>
<p>也就是说，我直接写</p>
<pre><code>__FBTweakIndex(..., <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
__FBTweakIndex(,, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
__FBTweakIndex(, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">;</span>
</code></pre><p>这种虽然没意义的、甚至是直觉上觉得都不能编译通过的代码，都是<strong>合理正确的</strong>。</p>
<p>是不是有点懵逼，休息一下，消化一下。</p>
<p>好，我们假设我们获取了数字1，因此，新的宏展开为<code>_FBTweakBindWithoutRange</code>，定义如下：</p>
<pre><code><span class="number">#def</span>ine <span class="number">_</span>FBTweakBindWithoutRange(<span class="keyword">object</span><span class="number">_</span>, property<span class="number">_</span>, category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>) \
((^{ \
  FBTweak *<span class="number">__</span>bind<span class="number">_</span>tweak = <span class="number">_</span>FBTweakInlineWithoutRange(category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>); \
  <span class="number">_</span>FBTweakBindInternal(<span class="keyword">object</span><span class="number">_</span>, property<span class="number">_</span>, category<span class="number">_</span>, collection<span class="number">_</span>, name<span class="number">_</span>, <span class="annotation">default</span><span class="number">_</span>, <span class="number">__</span>bind<span class="number">_</span>tweak); \
})())
</code></pre><p>这写法，也是醉了，我以前只是在JavaScript中看到过这样匿名函数自调用的写法，Facebook太强了。</p>
<p>整个过程继续抽丝剥茧，<code>_FBTweakInlineWithoutRange</code>会调用到如下函数：</p>
<pre><code><span class="comment">#define _FBTweakInlineWithPossibleInternal(category_, collection_, name_, default_, possible_) \</span>
((^{ <span class="string">\</span>
  <span class="comment">/* store the tweak data in the binary at compile time. */</span> <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString category__ = category_; <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString collection__ = collection_; <span class="string">\</span>
  __attribute__((used)) static FBTweakLiteralString name__ = name_; <span class="string">\</span>
  __attribute__((used)) static <span class="literal">void</span> *default__ = (__bridge <span class="literal">void</span> *) ^{ <span class="keyword">return</span> default_; }; <span class="string">\</span>
  __attribute__((used)) static <span class="literal">void</span> *possible__ = (__bridge <span class="literal">void</span> *)  ^{ <span class="keyword">return</span> possible_; }; <span class="string">\</span>
  __attribute__((used)) static char *encoding__ = (char *)<span class="property">@encode</span>(__typeof__(default_)); <span class="string">\</span>
  __attribute__((used)) __attribute__((section (FBTweakSegmentName <span class="string">","</span> FBTweakSectionName))) static fb_tweak_entry entry = <span class="string">\</span>
    { &amp;category__, &amp;collection__, &amp;name__, (<span class="literal">void</span> *)&amp;default__, (<span class="literal">void</span> *)&amp;possible__, &amp;encoding__ }; <span class="string">\</span>
<span class="string">\</span>
  <span class="comment">/* find the registered tweak with the given identifier. */</span> <span class="string">\</span>
  FBTweakStore *store = [FBTweakStore sharedInstance]; <span class="string">\</span>
  FBTweakCategory *category = [store <span class="attribute">tweakCategoryWithName</span>:category__]; <span class="string">\</span>
  FBTweakCollection *collection = [category <span class="attribute">tweakCollectionWithName</span>:collection__]; <span class="string">\</span>
<span class="string">\</span>
  NSString *identifier = _FBTweakIdentifier(&amp;entry); <span class="string">\</span>
  FBTweak *__inline_tweak = [collection <span class="attribute">tweakWithIdentifier</span>:identifier]; <span class="string">\</span>
<span class="string">\</span>
  <span class="keyword">return</span> __inline_tweak; <span class="string">\</span>
})())
</code></pre><p>这里相对来说比较复杂，我们逐个知识点进行查看。</p>
<pre><code>__attribute__<span class="list">(<span class="list">(<span class="keyword">used</span>)</span>)</span> static FBTweakLiteralString category__ = category_<span class="comment">;</span>
</code></pre><p>这个前面出来了<code>__attribute__((used))</code>，它的作用是告诉编译器，我声明的这个符号是需要保留的。我们在开发iOS的过程中，常常会遇到有时候会报警告<code>xxx unused</code>，在某些优化的情况下，编译器甚至都不报警告，直接将我们进行了剔除，<b>这样在编译后(预处理、编译、汇编)生成的目标文件里就<span style="color:red">不</span>存在我们这个符号。</b></p>
<p>继续看这行，又出现了我们新的不熟悉的<code>__attribute__((section (FBTweakSegmentName &quot;,&quot; FBTweakSectionName)))</code></p>
<pre><code>__attribute__((used)) __attribute__((section (FBTweakSegmentName <span class="string">","</span> FBTweakSectionName))) <span class="keyword">static</span> fb_tweak_entry entry = \
       { &amp;category__, &amp;collection__, &amp;name__, (<span class="keyword">void</span> *)&amp;default__, (<span class="keyword">void</span> *)&amp;possible__, &amp;encoding__ };
</code></pre><p>我们知道，iOS里面函数代码一般存在于<code>__TEXT</code>段，数据部分一般存在于<code>__DATA</code>段。但是在每个段中，都存在着许多不同作用的节（section）。比如存储常量字符串的<code>__cfstring</code>等等。</p>
<p>因此，编译器提供了我们一种<code>__attribute__((section(&quot;xxx段，xxx节&quot;)</code>的方式让我们讲一个指定的数据储存到我们需要的节当中。</p>
<p><b style="color:red">上述基础知识很容易理解，但是我在实际读代码理解整个运行机制的时候，还是有点懵逼。</b></p>
<h3 id="令人困惑的指针和数据">令人困惑的指针和数据</h3><p>我们将上章节中的代码简单具象一下：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">NSString</span> *haha = <span class="string">@"Mingyi"</span>;
_attribute__((section (<span class="string">"__DATA, MinyiSpecific"</span>))) <span class="keyword">static</span> <span class="built_in">NSString</span> ** entry = &amp;haha;
</code></pre><p>我们看到，我们将<code>&amp;haha</code>所代表这个数据存入了<code>__DATA</code> Segment的<code>MinyiSpecific</code>Section中。</p>
<p>但是，<code>&amp;haha</code>的类型是一个<code>NSString **</code>，即指向指针的指针。换句话说，这个指针的指针的背后的含义是<code>haha</code>这个变量本身的地址。我们知道，苹果的程序在加载的过程中都会ASLR地址随机化，那我们对一个地址进行存储，有啥用呢？</p>
<p><b style="color:red">上述的理解，有个最大的误区，就是从运行时来理解了地址，而不是从编译后的目标文件来理解程序，什么意思呢？</b> </p>
<p>在我们这里，因为声明了常量字符串@”Mingyi”，在编译(而非程序运行)后，它就存在于可执行文件的<code>cfstring</code>这个节中，如下所示：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.02.43.png?raw=true" alt=""></p>
<p>这个数据格式的起始地址偏移为<code>00000001 00003068</code>。</p>
<p>而由于我们使用的是静态变量<code>haha</code>，在编译后，也会生成一个指向刚刚那个常量字符串地址的数据。这个数据存在于<code>__DATA，__data</code>中，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.07.50.png?raw=true" alt=""></p>
<p>而<code>00000001 00003DC0</code>就是在代码中<code>&amp;haha</code>的含义。</p>
<p>无论是<code>3068</code>抑或是<code>3DC0</code>，它们的含义都是一个地址偏移，在程序加载运行的过程中，都要进行地址<strong>REBASE</strong>，去获得真正正确地址空间中的数据。但是由于我们的</p>
<pre><code>_attribute__<span class="list">(<span class="list">(<span class="keyword">section</span> <span class="list">(<span class="string">"__DATA, MinyiSpecific"</span>)</span>)</span>)</span> static NSString ** entry = &amp;haha<span class="comment">;</span>
</code></pre><p>是一个编译期的行为，因此这行语句的行为表征的还是存储没有rebase之前的相对地址偏移，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%881.11.55.png?raw=true" alt=""></p>
<p>好，至此，我们才将整个数据存入的部分搞懂。</p>
<p><strong>注意，iOS是小端序，即数据的高位在低地址。</strong></p>
<h3 id="镜像数据加载">镜像数据加载</h3><p>说完了数据存储，我们再来看看怎么从编译后的执行文件的节中读取出文件，代码如下：</p>
<pre><code>  <span class="keyword">static</span> <span class="keyword">uint32_t</span> _tweaksLoaded = <span class="number">0</span>;
  <span class="keyword">if</span> (OSAtomicTestAndSetBarrier(<span class="number">1</span>, &amp;_tweaksLoaded)) {
    <span class="keyword">return</span>;
  }

<span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span>
  <span class="keyword">typedef</span> <span class="keyword">uint64_t</span> fb_tweak_value;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> section_64 fb_tweak_section;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header_64 fb_tweak_header;
<span class="preprocessor">#<span class="keyword">define</span> fb_tweak_getsectbynamefromheader getsectbynamefromheader_64</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
  <span class="keyword">typedef</span> <span class="keyword">uint32_t</span> fb_tweak_value;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> section fb_tweak_section;
  <span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header fb_tweak_header;
<span class="preprocessor">#<span class="keyword">define</span> fb_tweak_getsectbynamefromheader getsectbynamefromheader</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>


  FBTweakStore *store = [FBTweakStore sharedInstance];

  <span class="comment">// 1. 注意点</span>
  <span class="keyword">uint32_t</span> image_count = _dyld_image_count();
  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> image_index = <span class="number">0</span>; image_index &lt; image_count; image_index++) {
    <span class="keyword">const</span> fb_tweak_header *mach_header = (<span class="keyword">const</span> fb_tweak_header *)_dyld_get_image_header(image_index);

    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;

    <span class="comment">// 2.注意点</span>
    fb_tweak_entry *data = (fb_tweak_entry *)getsectiondata(mach_header, FBTweakSegmentName, FBTweakSectionName, &amp;size);
    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) {
      <span class="keyword">continue</span>;
    }
    <span class="keyword">size_t</span> count = size / <span class="keyword">sizeof</span>(fb_tweak_entry);
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) {
      fb_tweak_entry *entry = &amp;data[i];
      FBTweakCategory *category = [store tweakCategoryWithName:*entry-&gt;category];
      <span class="keyword">if</span> (category == nil) {
        category = [[FBTweakCategory alloc] initWithName:*entry-&gt;category];
        [store addTweakCategory:category];
      }

      FBTweakCollection *collection = [category tweakCollectionWithName:*entry-&gt;collection];
      <span class="keyword">if</span> (collection == nil) {
        collection = [[FBTweakCollection alloc] initWithName:*entry-&gt;collection];
        [category addTweakCollection:collection];
      }

      NSString *identifier = _FBTweakIdentifier(entry);
      <span class="keyword">if</span> ([collection tweakWithIdentifier:identifier] == nil) {
        FBTweak *tweak = _FBTweakCreateWithEntry(identifier, entry);

        <span class="keyword">if</span> (tweak != nil) {
          [collection addTweak:tweak];
        }
      }
    }
  }
}
</code></pre><ul>
<li>注意点1:通过dyld获取当前程序加载时候的image个数。什么是image个数呢？你的可执行文件就是一个image。那为什么又会存在多个image呢？如果你平时使用的都是静态库，那么在编译连接完成后，静态库这个scope就不存在了，所有的符号都互相匹配完成。但是呢，苹果自身比如<code>UIKIt</code>之类的库又是动态库，因此，你的可执行文件中会存在多个image。</li>
</ul>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-01%20%E4%B8%8A%E5%8D%8811.50.09.png?raw=true" alt=""></p>
<ul>
<li>注意点2:读取macho文件中对应的段和节中我们自己储存的数据。</li>
</ul>
<h3 id="修改同步映射">修改同步映射</h3><p>我们之前看到，在利用<code>FBTweakBind</code>可以将某个对象的属性和操作进行映射，同步修改。这里的机制看起来很复杂，其实非常简单，就是简单的利用了KVO。</p>
<p><code>FBTweak</code>就是想要修改的属性，其包含了多个<code>Observer</code>。在<code>FBTweak</code>的<code>currentValue</code>更改后，会利用观察者模式对每个<code>Observer</code>发送属性更新通知。而<code>FBTweak</code>的属性值改变则是和UI界面，利用KVO进行联动修改。</p>
<p>这里就没什么过于复杂的技术含量了，具体看下<code>FBTweak</code>和<code>_FBTweakColorViewController</code>代码就行。</p>
<h3 id="其余知识点:">其余知识点:</h3><ul>
<li><p><code>objc_precise_lifetime</code>的作用  </p>
<pre><code>__attribute__<span class="list">(<span class="list">(<span class="keyword">objc_precise_lifetime</span>)</span>)</span> id strongObject = _object<span class="comment">;</span>
</code></pre></li>
</ul>
<p>这行代码的作用就是确保ARC不会进行特殊的优化，提前将一些本来认为在Scope最后才释放的对象提前释放了。</p>
<ul>
<li><p><code>_Generic</code>是一个编译时的<a href="http://en.cppreference.com/w/c/language/generic" target="_blank" rel="external">泛型选择</a>，他能根据变量的类型兼容来输出不同的结果，比如：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> cbrt(X) _Generic((X), \</span>
          <span class="keyword">long</span> <span class="keyword">double</span>: cbrtl, \
              <span class="keyword">default</span>: cbrt,  \
<span class="comment">/*for clang*/</span> <span class="keyword">const</span> <span class="keyword">float</span>: cbrtf, \
                <span class="keyword">float</span>: cbrtf  \
)(X)

<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)
</span>{
    <span class="keyword">long</span> <span class="keyword">double</span> x = <span class="number">8.0</span>;
    <span class="keyword">const</span> <span class="keyword">float</span> y = <span class="number">3.375</span>;
    printf(<span class="string">"cbrt(8.0) = %Lg\n"</span>, cbrt(x)); <span class="comment">// selects the default cbrt</span>
    printf(<span class="string">"cbrtf(3.375) = %f\n"</span>, cbrt(y)); <span class="comment">// gcc: converts const float to float,</span>
                                            <span class="comment">// then selects cbrtf</span>
                                            <span class="comment">// clang: selects cbrtf for const float</span>
}
</code></pre></li>
</ul>
<p>上述代码就根据编译器的类型声明，选择不同的函数进行执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/06/01/FBTweak/" data-id="ck9fy2gis00412ni19d6gutv2" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/06/01/FBTweak/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-ARM64IndirectReturn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/23/ARM64IndirectReturn/" class="article-date">
  <time datetime="2017-04-22T19:00:36.000Z" itemprop="datePublished">2017-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/23/ARM64IndirectReturn/">ARM64下Indirect Result Location摸索</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ARM64下Indirect_Result_Location摸索">ARM64下Indirect Result Location摸索</h3><p>之前学习汇编的时候，大概了解了一些ARM64下寄存器的用途，比如<code>x0 - x7</code>作为函数传递使用。同时，<code>x0</code>也可以作为函数返回值时候的寄存器。</p>
<p>但是，今天在研究一些跟返回结构体相关的时候，发现返回值并不是放在<code>X0</code>寄存器中。上网搜索了一下资料，发现在<strong>ARM64下，当一个<code>Callee</code>函数返回的内容大于16bytes的时候，该内容会被存到一个内存地址当中，然后这个内存地址的值会存入寄存器<code>x8</code>。后续<code>Caller</code>函数在使用该返回值的时候，会从<code>X8</code>寄存器中取出内存地址，并从内存地址取出内容的值</strong></p>
<p>是不是有点绕，还是让我们来看个例子吧。</p>
<h3 id="原理">原理</h3><p>首先我根据<strong>大于16 bytes</strong>的要求定义了如下结构体：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">int64_t</span> i;
    <span class="keyword">int64_t</span> j;
    <span class="keyword">int64_t</span> k;
} MYStruct;
</code></pre><p>在ARM64下，该结构体默认按<code>4 bytes</code>对齐，每个<code>int64</code>占用<code>8 bytes</code>，因此结构体大小<code>24 bytes</code></p>
<p>我们定义如下函数，用于返回一个该结构体：</p>
<pre><code>- (MYStruct)testIndirectResultLocation:(int64_t)i1 second:(int64_t)i2 th:(int64_t)i3
{
    MYStruct s<span class="comment">;</span>
    s.i = i1<span class="comment">;</span>
    s.j = i2<span class="comment">;</span>
    s.k = i3<span class="comment">;</span>
    return s<span class="comment">;</span>
}
</code></pre><p>这个函数很简单，传入三个值。然后构造个局部变量<code>MYStruct s</code>，将其对应的成员变量按照刚刚的传入参数赋值，最后返回该结构体。</p>
<p>该函数调用<strong>在未优化的前提下</strong>的汇编结果如下：</p>
<pre><code>IndirectResultLocation`-[ViewController testIndirectResultLocation:second:th:]:
    <span class="comment">// 预留空间</span>
    &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>

    <span class="comment">// 存参</span>
    &lt;+<span class="number">4</span>&gt;:  str    x0, [sp, <span class="preprocessor">#<span class="number">0x38</span>]</span>
    &lt;+<span class="number">8</span>&gt;:  str    x1, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span>
    &lt;+<span class="number">12</span>&gt;: str    x2, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">16</span>&gt;: str    x3, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">20</span>&gt;: str    x4, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>

    <span class="comment">// 赋值</span>
-&gt;  &lt;+<span class="number">24</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x28</span>]</span>
    &lt;+<span class="number">28</span>&gt;: str    x0, [sp]
    &lt;+<span class="number">32</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span>
    &lt;+<span class="number">36</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">40</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x18</span>]</span>
    &lt;+<span class="number">44</span>&gt;: str    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 将结构体存到x8寄存器的值代表的地址去</span>
    &lt;+<span class="number">48</span>&gt;: ldr    x0, [sp]
    &lt;+<span class="number">52</span>&gt;: str    x0, [x8]
    &lt;+<span class="number">56</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">60</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x8</span>]</span>
    &lt;+<span class="number">64</span>&gt;: ldr    x0, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span>
    &lt;+<span class="number">68</span>&gt;: str    x0, [x8, <span class="preprocessor">#<span class="number">0x10</span>]</span>

    <span class="comment">// 释放空间</span>
    &lt;+<span class="number">72</span>&gt;: add    sp, sp, <span class="preprocessor">#<span class="number">0x40</span>             ; =<span class="number">0x40</span> </span>
    &lt;+<span class="number">76</span>&gt;: ret    
</code></pre><p>第一行：SP即<code>Stack Pointer</code>，向下减<code>0x40（64 bytes）</code>的大小，预先分配出函数需要用的栈空间。为什么要预留这么多的大小呢？首先按照<strong>Objective-C的函数调用规定，前两个参数必须是<code>self</code>和<code>selector</code>，也即会使用到寄存器<code>X0</code>和<code>X1</code>。然后该函数有三个形参，使用了<code>X2-X4</code>的寄存器</strong>。<br>上述这五个，大小占用了<strong>self(8 bytes) + selector(8 bytes) + 三个参数(24 bytes) = 40 bytes</strong>。那么还有<code>24 bytes</code>去干嘛了呢？</p>
<p>别忘了，我们在函数中可以声明了一个局部变量<code>MYStruct s</code>，该结构体大小是24 bytes。而在函数调用中使用到的变量，基本上都在栈区中开辟对应的空间进行暂存。</p>
<p>后续第二行到第六行非常简单易懂，就是把上述5个参数存到实际的栈区中去使用。按照这个存法以后，内存布局如下（注意高地址在上，低地址在下，ARM下的栈是向下增长）：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.48.35.png?raw=true" alt=""></p>
<p>将参数都存入到栈以后，我们就要对结构体进行赋值了，这些操作在第七行到第十二行之间。<br>将<strong>1赋值给[SP]，2赋值给[SP + #0x8]，3赋值给[SP + #0x10]</strong>。如果不理解啥意思的话，可以看下我自己转化的伪代码：</p>
<pre><code><span class="keyword">void</span> *address = &amp;s;
*(<span class="keyword">int64_t</span> *)(address) = <span class="number">1</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">8</span>) = <span class="number">2</span>;
*(<span class="keyword">int64_t</span> *)(address + <span class="number">16</span>) = <span class="number">3</span>;
</code></pre><p>赋值完以后，我们可以通过内存分布看下数据是否正确：</p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.30.06.png?raw=true" alt=""></p>
<p><img src="https://github.com/SatanWoo/WZRecyclePhotoStackView/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%882.29.53.png?raw=true" alt=""></p>
<p>当赋值完成后，就要进行结构体的返回了。这里不是简单的<code>mov x0, sp</code>之类的操作，而是一串和<code>X8</code>寄存器相关操作。</p>
<p>其实原理差不多，转化成伪代码的话，基本上是这样：</p>
<pre><code>void <span class="keyword">*</span>toSaveAddress = [x8];
void <span class="keyword">*</span>valueNowAddress = [sp];

<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress) = <span class="keyword">*</span>valueNowAddress;
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 8) = <span class="keyword">*</span>(valueNowAddress + 8);
<span class="keyword">*</span>(int64_t <span class="keyword">*</span>)(toSaveAddress + 16) = <span class="keyword">*</span>(valueNowAddress + 16);
</code></pre><p>操作完成后，释放空间即可。</p>
<h3 id="补充">补充</h3><p>其实ARM64在汇编层面实现的这么复杂， 我们在编程层面只要按照如下方式理解即可：</p>
<pre><code><span class="function">some_struct <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s = foo(<span class="number">1</span>, <span class="number">2</span>);
</code></pre><p>会被编译成：</p>
<pre><code><span class="function">some_struct* <span class="title">foo</span><span class="params">(some_struct* ret_val, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;
some_struct s; 
foo(&amp;s, <span class="number">1</span>, <span class="number">2</span>);
</code></pre><h3 id="后续">后续</h3><p>从本文中我们不难看出，ARM64针对不同大小的返回值都有着对应的<strong>Calling Convention</strong>。下次我准备来摸索下，处于<code>8 bytes - 16 bytes</code>之间的返回值究竟是怎么处理的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/" data-id="ck9fy2gj9004i2ni16yrqjr1e" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/04/23/ARM64IndirectReturn/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-CalculateTwoArrayDiff" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/18/CalculateTwoArrayDiff/" class="article-date">
  <time datetime="2017-04-17T17:15:40.000Z" itemprop="datePublished">2017-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/18/CalculateTwoArrayDiff/">快速计算两组数据源的变化的方法 - Doppelganger 源码剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Doppelganger_源码剖析">Doppelganger 源码剖析</h3><p>性能优化系列一：如何快速的计算UITableView的数据量变换。</p>
<p>今天要介绍的是一个比较精简但是很实用的库：Doppelganger。平时我们经常会和<code>UITableView</code>或者<code>UICollectionView</code>打交道，所以数据源（dataSource）及其变化就非常重要。</p>
<p>如何高效的求解两次数据源之间的删除、增加以及移动（交换位置）就成为了一个可以显著加速的地方。</p>
<blockquote>
<p>备注：这里指的是将一定量的数据计算放在客户端来进行，而不是通过多次发送网络请求获取数据然后整体重新刷新。有人会问，什么情况下会有这样的需求呢？比如，你有个用户选项，可以支持按照倒序或者正序的方式进行布局，那这个时候，你直接在本地进行计算并展示差量布局计算，就要比从网络请求多次拉取整体重新刷新的效果赞很多。</p>
</blockquote>
<p>本文提到的<code>Doppelganger</code>其实就是一种对于上述需求的封装，提供了及其简化的数据源更新机制。抛开其性能不谈，我们先来看看其实现。</p>
<h4 id="数据结构">数据结构</h4><p>从需求不难看出，我们的数据结构需要支持如下潜在数据记录：</p>
<ul>
<li>改动类型：增加、删除、移动</li>
<li>改动索引：增加的话，是插入到哪行、删除的话是删除哪行、移动的话是从哪行移动到哪行。</li>
</ul>
<p>基于此，数据结构的定义就很显而易见了：</p>
<pre><code><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, WMLArrayDiffType) {
    WMLArrayDiffTypeMove,
    WMLArrayDiffTypeInsert,
    WMLArrayDiffTypeDelete
};

<span class="class"><span class="keyword">@interface</span> <span class="title">WMLArrayDiff</span> : <span class="title">NSObject</span></span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) WMLArrayDiffType type;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> previousIndex;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> currentIndex;

<span class="keyword">@end</span>
</code></pre><p>其中，有些字段在某些类型下可以为空。</p>
<h4 id="计算变动">计算变动</h4><p>我们先简化下我们的模型，我们就是两个数组A和B，里面各自一堆不重复的数字，分别代表之前的数据源和现在的数据源。现在我们需要求得这两个数组之前提到的三种变化。</p>
<p><strong>首先是删除的计算，非常简单，只要计算在A中不在B中就可以：</strong></p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>然后是增加的计算，同样简单，只要计算在B中不在A中的：</strong></p>
<pre><code>NSSet *insertedObjects = ({
    NSMutableSet *<span class="keyword">set</span> = [currentSet mutableCopy];
    [<span class="keyword">set</span> minusSet:previousSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p><strong>最后就是计算那些即在A中又在B中的改变，对于这种计算，我们要得到在A中的原索引和现在的新索引。</strong></p>
<pre><code>- (<span class="type">NSArray</span> *)_moveDiffsWithDeletedObjects:(<span class="type">NSSet</span> *)deletedObjects insertedObjects:(<span class="type">NSSet</span> *)insertedObjects {    
    // <span class="type">TODO</span>: <span class="type">Improve</span> on O(n^<span class="number">2</span>)
    __block <span class="type">NSInteger</span> delta = <span class="number">0</span>;
    <span class="type">NSMutableArray</span> *<span class="literal">result</span> = [<span class="type">NSMutableArray</span> <span class="type">array</span>];
    [self.previousArray enumerateObjectsUsingBlock:^(id leftObj, <span class="type">NSUInteger</span> leftIdx, <span class="type">BOOL</span> *stop) {
        <span class="keyword">if</span> ([deletedObjects containsObject:leftObj]) {
            delta++;
            <span class="keyword">return</span>; 
        }
        <span class="type">NSUInteger</span> localDelta = delta;
        <span class="keyword">for</span> (<span class="type">NSUInteger</span> rightIdx = <span class="number">0</span>; rightIdx &lt; self.currentArray.count; ++rightIdx) {
            id rightObj = self.currentArray[rightIdx];
            <span class="keyword">if</span> ([insertedObjects containsObject:rightObj]) {
                localDelta--;
                <span class="keyword">continue</span>;
            }

            <span class="keyword">if</span> (![rightObj isEqual:leftObj]) {
                <span class="keyword">continue</span>;
            }

             //  注意点：          
            <span class="type">NSInteger</span> adjustedRightIdx = rightIdx + localDelta;
            // 首先如果前后索引一致，没有变化的区别，没有必要做diff变化
            // 或者如果你前面删除了一条，自身索引是<span class="number">1</span>，然后这边是<span class="number">0</span>，那也没必要做move变化。
            <span class="keyword">if</span> (leftIdx != rightIdx &amp;&amp; adjustedRightIdx != leftIdx) {
                [<span class="literal">result</span> addObject:[<span class="type">WMLArrayDiff</span> arrayDiffForMoveFromIndex:leftIdx toIndex:rightIdx]];
            }
            <span class="keyword">return</span>;
        }
    }];
    <span class="keyword">return</span> [<span class="literal">result</span> copy];
}
</code></pre><p>上述代码一开始我看了也是懵逼了，我觉得直接二重遍历计算同样数在不同两组数据源中的索引区别不就行了？在读了代码一遍以后确定了，作者的思路是这样的：</p>
<ol>
<li><p>如果在旧数组中和新数组中的数据源一样，那就不更新了，也即<code>leftIdx != rightIdx</code>的判断。</p>
</li>
<li><p>如果在旧数组中，索引为1，但是之前的0索引位置的数据删除了；然后这个索引为1的数据在新数据中位置为索引0，那么也不需要改了，因为之前计算删除变化的时候已经做了这个相同的效果。</p>
</li>
</ol>
<h4 id="时间复杂度">时间复杂度</h4><p>虽然不知道苹果内部的数据结构代码实现是如何的，但是我们可以进行数据模拟，同时也可以看看<a href="http://devstreaming.apple.com/videos/wwdc/2013/224xcx5x1y1yx8ra5jbmfyhf/224/224.pdf" target="_blank" rel="external">苹果WWDC的文章</a> 来进行时间复杂度估算。</p>
<p>而从上面实现的计算变动源代码来看，整个库的实现时间复杂度还是有所欠缺的，到达了O(mn) + O(n) ≈ O(mn)的级别，因此我们可以进行一些优化。</p>
<blockquote>
<p>备注：O(mn)就是二重循环遍历的问题。其中m是数据源A的数据个数，n是数据源b的数据个数。简单来看就是O(n^2)级别的运算耗时。</p>
</blockquote>
<p>怎么优化呢，答案很简单，就是利用动态规划思想来求解最小编辑距离。</p>
<p>我们举个简单的例子，还是没有重复数组的数组，<code>A = [1, 3, 5, 6, 8]</code>以及<code>B = [1, 5, 6, 9, 2]</code>。</p>
<p>怎么样最小变化才能从A变成B呢？</p>
<p>我们列一个二维的矩阵先，如下图：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-25%20%E4%B8%8A%E5%8D%881.22.02.png?raw=true" alt=""></p>
<blockquote>
<p>备注：蓝色为原数据，绿色为新数据，黄色的为最小变化的开销。</p>
</blockquote>
<p>不难看出，这个算法的时间复杂度就是填满整张表的O(mn)。</p>
<p>看到这，有人会问，你的Big(O) 复杂度都是O(mn)啊，这你优化在什么地方啊。</p>
<p>从时间复杂度分析上看，最大数值都是O(mn)没错，但是在大数量的情况下，还是会有比较大的区别。</p>
<p>究竟原因在于作者的算法做了很多重复性的劳动，而利用动态规划的特征可以合理的储存状态，避免重复性的劳动。</p>
<h4 id="一些细节">一些细节</h4><p>在查看源码的时候，查看过一个代码，</p>
<pre><code>NSSet *deletedObject = ({
    NSMutableSet *<span class="keyword">set</span> = [previousSet mutableCopy];
    [<span class="keyword">set</span> minusSet:currentSet];
    [<span class="keyword">set</span> <span class="keyword">copy</span>];
});
</code></pre><p>这里非常有意思，利用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" target="_blank" rel="external">Statements and Declarations in Expressions</a>，具体不多说了，非常巧妙，大开眼界。</p>
<blockquote>
<p>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct</p>
</blockquote>
<p>啥意思呢？就是说这种符合表达式的最后一句必须是一个用分号结尾的表达式，并且这个表达式必须有返回值。而这个返回值就作为整个符号表达式的返回值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/" data-id="ck9fy2gj6004e2ni1x23bpq33" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/04/18/CalculateTwoArrayDiff/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Performance/">Performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-DispatchGroupCrash" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/07/DispatchGroupCrash/" class="article-date">
  <time datetime="2017-01-07T13:44:39.000Z" itemprop="datePublished">2017-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/07/DispatchGroupCrash/">iOS疑难问题排查之深入探究dispatch_group crash</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="起因">起因</h3><p>昨天其他部门的同事突然反馈一起相对来说比较严重的Crash问题（占比达到了yyyy左右，并且从Crash堆栈上可以发现很多情况下是一启动就Crash了）。去掉隐私数据大致堆栈如下：</p>
<pre><code>Thread <span class="number">0</span> Crashed:
<span class="number">0</span>   libdispatch.dylib               <span class="number">0x000000018953e828</span> _dispatch_group_leave :<span class="number">76</span> (in libdispatch.dylib)
<span class="number">1</span>   libdispatch.dylib               <span class="number">0x000000018954b084</span> __dispatch_barrier_sync_f_slow_invoke :<span class="number">320</span> (in libdispatch.dylib)
<span class="number">2</span>   libdispatch.dylib               <span class="number">0x000000018953a1bc</span> __dispatch_client_callout :<span class="number">16</span> (in libdispatch.dylib)
<span class="number">3</span>   libdispatch.dylib               <span class="number">0x000000018953ed68</span> __dispatch_main_queue_callback_4CF :<span class="number">1000</span> (in libdispatch.dylib)
<span class="number">4</span>   CoreFoundation                  <span class="number">0x000000018a65e810</span> ___CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ :<span class="number">12</span> (in CoreFoundation)
<span class="number">5</span>   CoreFoundation                  <span class="number">0x000000018a65c3fc</span> ___CFRunLoopRun :<span class="number">1660</span> (in CoreFoundation)
<span class="number">6</span>   CoreFoundation                  <span class="number">0x000000018a58a2b8</span> _CFRunLoopRunSpecific :<span class="number">444</span> (in CoreFoundation)
<span class="number">7</span>   GraphicsServices                <span class="number">0x000000018c03e198</span> _GSEventRunModal :<span class="number">180</span> (in GraphicsServices)
<span class="number">8</span>   UIKit                           <span class="number">0x00000001905d17fc</span> -[UIApplication _run] :<span class="number">684</span> (in UIKit)
<span class="number">9</span>   UIKit                           <span class="number">0x00000001905cc534</span> _UIApplicationMain :<span class="number">208</span> (in UIKit)
<span class="number">10</span>  xxxiPhone                       <span class="number">0x0000000100041a98</span> main main.m:<span class="number">26</span> (in xxxiPhone)
<span class="number">11</span>  libdyld.dylib                   <span class="number">0x000000018956d5b8</span> _start :<span class="number">4</span> (in libdyld.dylib)
</code></pre><p>一看到这种堆栈，头就大了，除了<strong>Thread 0 的第10行是和程序本身二进制相关的</strong>堆栈，其余的调用栈全部是系统库里面的，并且唯一一行程序本身二进制的代码还是一个完全没作用的<code>main</code>函数。</p>
<p>好吧，只能重新找找其余的线索。从堆栈上来反推当时的场景应该是如下场景：</p>
<pre><code>启动 -&gt; main函数 -&gt; main_queue 执行 -&gt; dispatch_group_leave -&gt; <span class="constant">Crash</span>
</code></pre><p>于是，我们的线索就从最后的<code>_dispatch_group_leave</code>来进行。  </p>
<p>首先先来最简单的方法：下符号断点：<code>dispatch_group_leave</code>。</p>
<p>当然事情没有这么简单，尝试重复多次也没有断到我们想要的符号断点上，于是这条路暂时考虑放弃（结合Crash率也可以发现这并非必现的Crash场景）。</p>
<p>这条路不通，我们先尝试全局搜索<code>dispatch_group_leave</code>，结果发现有如下几条线索：</p>
<ul>
<li>外部开源库</li>
<li>自身工程代码</li>
</ul>
<p>结合Crash出现的版本以及以上上述各库最后升级时间来判断，我们基本确定出在问题出现在自身工程中的代码里，如下：</p>
<pre><code>dispatch_group_t serviceGroup = dispatch_group_create();
dispatch_group_notify(serviceGroup, dispatch_get_main_queue(), ^{
    <span class="built_in">NSLog</span>(<span class="string">@"ttttttt:%@"</span>,t);
});

<span class="comment">// t 是一个包含一堆字符串的数组 </span>
[t enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) {
    dispatch_group_enter(serviceGroup);
    SDWebImageCompletionWithFinishedBlock completion =
    ^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
        dispatch_group_leave(serviceGroup);
        <span class="built_in">NSLog</span>(<span class="string">@"idx:%zd"</span>,idx);
    };
    [[SDWebImageManager sharedManager] downloadImageWithURL:[<span class="built_in">NSURL</span> URLWithString:t[idx]]
                                                    options:SDWebImageLowPriority
                                                   progress:<span class="literal">nil</span>
                                                  completed:completion];
}];
</code></pre><p>这段代码逻辑非常简单吧：给你一个数组，里面是一堆图片地址。你使用多线程进行并发下载，直到所有图片都下载完成（可以失败）进行回调，其中图片下载使用的是<code>SDWebImage</code>。</p>
<p>这段代码里面的的确确出现了可疑的<code>dispatch_group_leave</code>，但是这段代码太常见了。和同事认认真真检查了许久，同时也和天猫、手淘中使用<code>dispatch_group_t</code>的地方进行了对比，没发现任何问题。</p>
<p>好吧，问题一下子陷入了僵局，只好上终极调试大法：<strong>汇编分析法</strong>。</p>
<p>通过文章开头的堆栈我们查找<code>libdispatch.dylib</code>中对应的Crash位置，然后通过汇编解析查看相关指令，结果如下：</p>
<p><img src="https://github.com/SatanWoo/BeeHive/blob/master/hopper.png?raw=true" alt=""></p>
<p>从上图看出，指令挂掉的原因是因为执行了<code>brk</code> （brk可以理解为跳转指令特殊的一种，一旦执行，就会进入某种Exception模式，导致Crash）。</p>
<p>为什么执行<code>dispatch_group_leave</code>会挂？从上述图中汇编不难发现，<code>dispatch_group_leave</code>具有两条分支：比较x9寄存器和0之间的关系，如果是less equal，就跳转到0x180502808(即会crash的逻辑分支)；反之则正确执行ret返回。</p>
<p>那么x9寄存器是什么？我们继续往上看指令<code>ldxr x9, [x10]</code>，x9中的值是以x10寄存器中的内容作为地址，取64位放入x9寄存器中。继续，那么x10中的内存是什么？x10中的内容是指令<code>add x10, x0, #0x30</code>。也就是x10 = x0 + 48(0x30的10进制表示)。那么，函数调用的时候x0是self，也即是一个类或者结构体的首地址。所以这两句指令加起来的含义就是<strong><b style="color:red">取结构体地址偏移48位置的某个成员变量的值。</b></strong></p>
<p>除此之外，汇编解析还完整保留了Crash的字符串提示： <strong>“BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()”</strong></p>
<p>结合这两点，我们查看<code>libdispatch</code>的源码，代码如下：</p>
<pre><code><span class="function"><span class="keyword">void</span>
<span class="title">dispatch_group_leave</span>(<span class="params">dispatch_group_t dg</span>)
</span>{
    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;
    dispatch_atomic_release_barrier();
    <span class="keyword">long</span> <span class="keyword">value</span> = dispatch_atomic_inc2o(dsema, dsema_value);
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);
    }
    <span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == dsema-&gt;dsema_orig)) {
        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);
    }
}
</code></pre><p><em>注：苹果开发的libdispatch源码经过了各种变形修改，不是真正运行的代码，仅供参考。</em></p>
<p>果不其然，这段代码完整复现了我们之前汇编分析的结果：如果<code>dg</code>信号量中的字段<code>dsema_value</code>原子性自加一后等于LONGMIN，就会<strong>CRASH</strong>。为什么会Crash呢？</p>
<p>我们需要关注下LONG_MIN这个数字，<code>LONG_MIN = -LONG_MAX - 1</code>。理解起来很简单，就是可以表征的(该类型合法范围)最大数和最小数。</p>
<p>搜索下LONGMAX，我们发现在<code>dispatch_group_create</code>里面发现了它的踪影：</p>
<pre><code><span class="keyword">dispatch_group_t</span>
dispatch_group_create(<span class="keyword">void</span>)
{
    <span class="keyword">dispatch_group_t</span> dg = _dispatch_alloc(DISPATCH_VTABLE(group),
            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_semaphore_s));
    _dispatch_semaphore_init(LONG_MAX, dg);
    <span class="keyword">return</span> dg;
}
</code></pre><p>好了， 这下豁然开朗。这两段代码的结合告诉了我们一个事实：当<code>dq</code>这个信号量加一导致<strong><b style="color:red">溢出</b></strong>后，<code>dispatch_group_leave</code>就会Crash。</p>
<p>最简单的复现代码如下：</p>
<pre><code>- (<span class="keyword">void</span>)viewDidLoad 
{
    [<span class="keyword">super</span> viewDidLoad];
    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();
    dispatch_group_leave(<span class="keyword">group</span>);
    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span>
}
</code></pre><p><img src="https://github.com/SatanWoo/BeeHive/blob/master/symbol.png?raw=true" alt=""></p>
<p>当然，上述代码相当直白简单，我们一般都不会犯这样低级的错误。</p>
<h3 id="代码究竟出错在哪？">代码究竟出错在哪？</h3><p>了解了<code>dispatch_group_leave</code>的出错原因后，我们再回到我们刚刚认为没问题的代码，一定是哪个地方我们欠考虑了。</p>
<p>上述代码执行流程还是非常简单的，我们用模型简述一遍：</p>
<p><strong>遍历数组，对每个URL进行<code>dispatch_group_enter</code>，然后将其丢入一个下载block交由SDWebImage进行并发下载，下载回调（无论失败或者成功）后执行<code>dispatch_group_leave</code>。</strong></p>
<p>我们举个简单的例子，假设我们有一个包含5个URL的数组：</p>
<ol>
<li>遍历的时候，对信号量<code>dq</code> enter了5次，简单理解信号量减去5次。</li>
<li>SDWebImage下载回调的时候，对信号量<code>dq</code> leave了5次，于是信号量增加了5次。</li>
<li>执行完毕，整个group执行完成。</li>
</ol>
<p><strong><b style="color:red">但是，由于SDWebImage的下载是异步且无法保证时间的，如果在整个group没有执行完毕期间，上述函数整体又被执行到了，会怎么样？</b></strong></p>
<p>我们再用上述的例子来走遍流程。</p>
<ol>
<li>第一次遍历，我们创建了信号量<code>dq1</code>，enter了5次，dq1 现在 = -5。</li>
<li>SDWebImage的下载回调捕捉了<code>dq1</code>，准备留待回调后加回来，我们将这次遍历生成的下载回调block统称为b10, b12, b13, b14, b15。</li>
<li><strong>但是，在第一次SDWebImage下载回调还没执行的时候，第二次函数遍历来了。</strong></li>
<li>第二次遍历，我们创建了信号量<code>dq2</code>，enter了5次，dq2 现在 = -5。</li>
<li>创建第二次遍历对应的回调block，称为b20，b21, b22, b23, b24。</li>
</ol>
<p>通过查阅<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m" target="_blank" rel="external">SDWebImageDownloader.m</a>源码我们发现：</p>
<pre><code><span class="function_or_atom">dispatch_barrier_sync</span>(<span class="function_or_atom">self</span>.<span class="function_or_atom">barrierQueue</span>, ^{
    <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">operation</span> = <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>];
    <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">operation</span>) {
    <span class="function_or_atom">operation</span> = <span class="function_or_atom">createCallback</span>();

    // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意这行<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
    <span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] = <span class="function_or_atom">operation</span>;

    __weak <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">woperation</span> = <span class="function_or_atom">operation</span>;
    <span class="function_or_atom">operation</span>.<span class="function_or_atom">completionBlock</span> = ^{
      <span class="variable">SDWebImageDownloaderOperation</span> *<span class="function_or_atom">soperation</span> = <span class="function_or_atom">woperation</span>;
      <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">soperation</span>) <span class="function_or_atom">return</span>;
      <span class="function_or_atom">if</span> (<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span>[<span class="function_or_atom">url</span>] == <span class="function_or_atom">soperation</span>) {
          [<span class="function_or_atom">self</span>.<span class="variable">URLOperations</span> <span class="function_or_atom">removeObjectForKey:url</span>];
      };
    };
}
</code></pre><p>SDWebImage的下载器会<strong>根据URL做下载任务对应NSOperation映射，也即之前创建的下载回调Block。</strong></p>
<p>好，就是这行导致Crash的发生。为什么呢？</p>
<p>我们设想下，假设在第二次遍历中包含了第一次遍历中的图片URL，比如b20对应的图片URL和b10对应的图片URL一样，那么在SDWebImage的处理回调里，b20就会替换掉b10。<b style="color:red">于是，在第一次遍历创建的5个下载任务回调中，b10回调的时候实际已经执行的是b20，也就是<code>dq2 + 1</code>；而在后续第二次遍历执行下载任务回调的时候，又分别执行了b20-b24的5个任务，导致<code>dq2 + 5</code>。这从导致<code>dq2</code>实际上leave的次数比enter的次数多了1 (6比5)，导致了dq2信号量的数值溢出，从而进入了Crash分支。</b></p>
<h3 id="最后">最后</h3><p>看起来很简单、清晰易懂的代码，没想到也会造成巨大的问题。所以，写代码一定要谨慎谨慎再谨慎。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/" data-id="ck9fy2giw00452ni1v307hvaq" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-JSONRPCKit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/07/JSONRPCKit/" class="article-date">
  <time datetime="2017-01-07T13:40:51.000Z" itemprop="datePublished">2017-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/07/JSONRPCKit/">JSONRPCKit源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近公司参与开源项目<code>BeeHive</code>的开发（第一版的代码是由前辈们写的，已经开源在了GitHub上的Alibaba项目里）。在参与开发的过程中，我一直在思考一个问题：基于Protocol的服务调用真的是最合理的方式吗？这种方式从某种方式来说还是一种强依赖（至少需要引入相对应的整个Protocol的头文件），能否有更通用的方式来进行呢？而且，从目前的实现进度来看，也无法做到对方法级的解耦。</p>
<h3 id="C/S架构">C/S架构</h3><p>在传统的开发框架下，我们一般调用HTTP/HTTPS的请求的方式都是一个API接口，配合一些参数外加GET/POST的调用方式来获取远程服务器的响应返回。如：</p>
<pre><code><span class="collection">[self.manager request:@<span class="string">"api.com"</span> withParams:@<span class="collection">{@<span class="string">"name"</span>:<span class="string">"satanwoo"</span>}</span> withCompletionBlock:^<span class="list">(<span class="keyword">id</span> responseObject)</span><span class="collection">{
    NSLog<span class="list">(@<span class="string">"return response is %@"</span>, responseObject)</span><span class="comment">;</span>
)]</span><span class="comment">;</span></span>
</code></pre><h3 id="JSONRPCKit">JSONRPCKit</h3><p>JSONRPCKit是一套基于JSON RPC 2.0协议的远程服务调用框架。这套框架基于JSON格式（NULL，Boolean，String，Number，Array，Object）来传递请求以及接受返回的响应，是一套应用层之上的协议。</p>
<p>什么意思呢？  </p>
<ol>
<li>所有的客户端请求首先都必须构造成JSON格式  </li>
<li>请求中必须带有JSON RPC 2.0协议要求的字段作为标示符。  </li>
<li>服务端在处理客户端请求的时候，就从协议指定的字段去取调用的方法名、参数、版本号等等。</li>
<li>服务端将请求的结果也封装成复合JSON RPC要求的形式，通过JSON格式传回给客户端。</li>
<li>客户端根据指定的字段解析返回的结果。</li>
</ol>
<p>如果还有不懂的，我们可以看看这篇<a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html#3" target="_blank" rel="external">文章</a>。</p>
<p>所以，JSONRPCKit就是一套封装了该协议的框架，它主要包含如下几个类：</p>
<ul>
<li><code>RequestType</code> 代表着当前的请求</li>
<li><code>BatchType</code>   代表着一个批次（即里面可以一次性包含多个请求，减少调用开销）</li>
<li><code>BatchElementType</code> 将业务请求转换成批次请求的数据结构</li>
<li><code>BatchFactory</code> 构造批次请求的地方</li>
<li><code>JSONRPCError</code>  JSONRPC出错的原因</li>
<li><code>Id</code> 代表着一次（或者一批次）请求的识别符，网络回调要和客户端请求进行ID匹配，否则谁知道哪个请求需要哪个响应。</li>
</ul>
<h4 id="RequestType">RequestType</h4><p>RequestType就是一个符合JSONRPCKit定义的数据结构，包含里几个主要的字段：</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">RequestType</span> </span>{
    <span class="comment">/// If `Response == Void`, request is treated as a notification.</span>
    associatedtype <span class="type">Response</span>

    <span class="keyword">var</span> method: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> parameters: <span class="type">AnyObject</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> extendedFields: [<span class="type">String</span>: <span class="type">AnyObject</span>]? { <span class="keyword">get</span> }
    <span class="keyword">var</span> isNotification: <span class="type">Bool</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromResultObject</span><span class="params">(resultObject: AnyObject)</span></span> throws -&gt; <span class="type">Response</span>
}
</code></pre><ol>
<li><code>method</code> 远程调用的方法名</li>
<li><code>parameters</code> 调用该方法需要传入的参数，顺序需要严格按照方法的入餐，<strong>从左至右</strong>。</li>
<li><code>extendFields</code> 这个在协议中并没有定义，可以理解为自身业务需要，扩展字段。</li>
<li><code>isNotification</code> 在JSON RPC协议中规定，当请求或者相应不带有识别ID的时候，意味着这是一个全局通知，可以没有对应的解析结果。</li>
</ol>
<p>此外，还有一个<code>associatedType Response</code>可以定义响应的类型，用作校验。</p>
<h4 id="BatchElementType">BatchElementType</h4><p>大家都知道，网络调用是有其延迟性和资源消耗的，每次都去建立连接（采用TCP长链接或者HTTP keep alive除外）进行资源传输是非常不划算的话，<strong>尤其是当你的数据payload非常小，在整个传输数据占比非常小的情况下就极其的蛋疼</strong>。因此，JSON RPC 协议定义了一种可以批量传输的方式：就是一批请求包在一次传输；服务端处理好了以后，同样也在一次性将数据响应返回。</p>
<p>有人会问，那一次性批处理的响应怎么和请求对应呢？<br>这就是我们之前提到的<code>ID</code>字段的作用了，这是一个全局唯一性的识别符，请求时的id在服务端处理完后，会同样放在数据中进行返回。</p>
<p>好了，我们来看一下这个数据结构的设计：</p>
<pre><code><span class="comment">// 协议定义</span>
public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchElementType</span> </span>{
    associatedtype <span class="type">Request</span>: <span class="type">RequestType</span>

    <span class="keyword">var</span> request: <span class="type">Request</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> version: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> id: <span class="type">Id</span>? { <span class="keyword">get</span> }
    <span class="keyword">var</span> body: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>
    <span class="func"><span class="keyword">func</span> <span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; <span class="type">Request</span>.<span class="type">Response</span>

    <span class="func"><span class="keyword">func</span> <span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
    <span class="func"><span class="keyword">func</span> <span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Request</span>.<span class="type">Response</span>, <span class="type">JSONRPCError</span>&gt;
}

<span class="comment">// 具体实现</span>
public <span class="class"><span class="keyword">struct</span> <span class="title">BatchElement</span>&lt;<span class="title">Request</span>: <span class="title">RequestType</span>&gt;: <span class="title">BatchElementType</span> </span>{
    public <span class="keyword">let</span> request: <span class="type">Request</span>
    public <span class="keyword">let</span> version: <span class="type">String</span>
    public <span class="keyword">let</span> id: <span class="type">Id</span>?
    public <span class="keyword">let</span> body: <span class="type">AnyObject</span>

    public <span class="keyword">init</span>(request: <span class="type">Request</span>, version: <span class="type">String</span>, id: <span class="type">Id</span>) {
        <span class="keyword">let</span> id: <span class="type">Id</span>? = request.isNotification ? <span class="literal">nil</span> : id
        <span class="keyword">var</span> body: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [
            <span class="string">"jsonrpc"</span>: version,
            <span class="string">"method"</span>: request.method,
        ]

        <span class="keyword">if</span> <span class="keyword">let</span> id = id {
            body[<span class="string">"id"</span>] = id.value
        }

        <span class="keyword">if</span> <span class="keyword">let</span> parameters = request.parameters {
            body[<span class="string">"params"</span>] = parameters
        }

        request.extendedFields?.forEach { key, value <span class="keyword">in</span>
            body[key] = value
        }

        <span class="keyword">self</span>.request = request
        <span class="keyword">self</span>.version = version
        <span class="keyword">self</span>.id = id
        <span class="keyword">self</span>.body = body
    }
}
</code></pre><p>从代码中不难看出，<code>BatchElement</code>是对之前的<code>Request</code>的进一步封装，将所有<code>Request</code>的字段塞到了一个<code>body</code>中（我们可以理解为HTTP Body），这个<code>body</code>是真正用于传输的，其余字段都是用于校验的，总共需要进行如下校验：</p>
<ol>
<li>查看JSON RPC协议是不是2.0。</li>
<li>响应数据的id和请求的id是不是能匹配。</li>
</ol>
<p>为了处理这些默认逻辑，BatchElement基于Protocol Extension提供了默认的实现，具体如下：</p>
<pre><code>func <span class="function"><span class="title">responseFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; Request<span class="class">.Response</span>
func <span class="function"><span class="title">responseFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> throws -&gt; Request<span class="class">.Response</span>

func <span class="function"><span class="title">resultFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
func <span class="function"><span class="title">resultFromBatchObjects</span><span class="params">(objects: [AnyObject])</span></span> -&gt; Result&lt;Request<span class="class">.Response</span>, JSONRPCError&gt;
</code></pre><p>从命名中不难看出，上述4个API分成两组，分别对应单个请求和批处理的。出于篇幅考虑，我们仅以单个批次进行分析。</p>
<pre><code><span class="function"><span class="keyword">public</span> func <span class="title">resultFromObject</span>(<span class="params"><span class="keyword">object</span>: AnyObject</span>) -&gt; Result&lt;Request.Response, JSONRPCError&gt; </span>{
    <span class="keyword">let</span> receivedVersion = <span class="keyword">object</span>[<span class="string">"jsonrpc"</span>] <span class="keyword">as</span>? String
    <span class="comment">// 校验协议版本</span>
    guard version == receivedVersion <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.UnsupportedVersion(receivedVersion))
    }

     <span class="comment">// 校验标识符ID</span>
    guard id == <span class="keyword">object</span>[<span class="string">"id"</span>].flatMap(Id.init) <span class="keyword">else</span> {
        <span class="keyword">return</span> .Failure(.ResponseNotFound(requestId: id, <span class="keyword">object</span>: <span class="keyword">object</span>))
    }


    <span class="keyword">let</span> resultObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"result"</span>]
    <span class="keyword">let</span> errorObject: AnyObject? = <span class="keyword">object</span>[<span class="string">"error"</span>]

      <span class="comment">// 根据错误或者结果进行解析</span>
    <span class="keyword">switch</span> (resultObject, errorObject) {
    <span class="keyword">case</span> (nil, <span class="keyword">let</span> errorObject?):
        <span class="keyword">return</span> .Failure(JSONRPCError(errorObject: errorObject))

    <span class="keyword">case</span> (<span class="keyword">let</span> resultObject?, nil):
        <span class="keyword">do</span> {
            <span class="comment">// 请求还要再单独校验一次</span>
            <span class="keyword">return</span> .Success(<span class="keyword">try</span> request.responseFromResultObject(resultObject))
        } <span class="keyword">catch</span> {
            <span class="keyword">return</span> .Failure(.ResultObjectParseError(error))
        }

    <span class="keyword">default</span>:
        <span class="keyword">return</span> .Failure(.MissingBothResultAndError(<span class="keyword">object</span>))
    }
}
</code></pre><p>根据JSON RPC的协议规定，数据在成功处理后，必须将响应结果放在<code>result</code>字段里；而如果有出错的时候，就必须放在<code>error</code>字段中。并且必须包含<code>error code</code>和<code>error message</code>。</p>
<p>所以，上述代码利用Swift强大的Pattern Match机制，进行对应的解析。<strong>有一点需要注意的是，即使是服务端成功返回了数据，但是该数据可能和我们请求需求的数据类型不一致等等，仍然有可能出错。</strong></p>
<h4 id="BatchType">BatchType</h4><p><code>BatchType</code>顾名思义，就是批次对应的数据结构。简单理解就是包着一堆<code>BatchElement</code>，没啥可以特别讲述的。</p>
<pre><code>public <span class="class"><span class="keyword">protocol</span> <span class="title">BatchType</span> </span>{
    associatedtype <span class="type">Responses</span>
    associatedtype <span class="type">Results</span>

    <span class="keyword">var</span> requestObject: <span class="type">AnyObject</span> { <span class="keyword">get</span> }

    <span class="func"><span class="keyword">func</span> <span class="title">responsesFromObject</span><span class="params">(object: AnyObject)</span></span> throws -&gt; <span class="type">Responses</span>
    <span class="func"><span class="keyword">func</span> <span class="title">resultsFromObject</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">Results</span>

    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">responsesFromResults</span><span class="params">(results: Results)</span></span> throws -&gt; <span class="type">Responses</span>
}
</code></pre><h4 id="BatchFactory">BatchFactory</h4><p>通过上面的讲述不难看出，我们要使用JSON RPC 需要有三步骤：</p>
<ol>
<li>构造一个符合JSON RPC 2.0协议的请求</li>
<li>将其转换成批处理元素</li>
<li>将批处理元素合并，构造成一个批次。</li>
</ol>
<p>这样的步骤虽然不困难，但是每次都这么干，估计使用者要吐血。所以<code>BatchFactory</code>的目的是提供简单的工厂方法。我们以构造包含1-2个请求的批处理为例：</p>
<pre><code><span class="keyword">public</span> func create&lt;<span class="string">Request:</span> RequestType&gt;(<span class="string">request:</span> Request) -&gt; Batch&lt;Request&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement = BatchElement(<span class="string">request:</span> request, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch(<span class="string">batchElement:</span> batchElement)
   }

   <span class="keyword">public</span> func create&lt;<span class="string">Request1:</span> RequestType, <span class="string">Request2:</span> RequestType&gt;(<span class="string">request1:</span> Request1, _ <span class="string">request2:</span> Request2) -&gt; Batch2&lt;Request1, Request2&gt; {
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
       let batchElement1 = BatchElement(<span class="string">request:</span> request1, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       let batchElement2 = BatchElement(<span class="string">request:</span> request2, <span class="string">version:</span> version, <span class="string">id:</span> idGenerator.next())
       dispatch_semaphore_signal(semaphore)

       <span class="keyword">return</span> Batch2(<span class="string">batchElement1:</span> batchElement1, <span class="string">batchElement2:</span> batchElement2)
   }
</code></pre><p>看了代码，简单吧。什么高深的都没干，就是用信号量构造了互斥区域，为什么要这么做？<strong>是为了确保<code>idGenerator</code>生成的标识符是连续的，并且是唯一的。</strong></p>
<h4 id="其他">其他</h4><p>借这里正好复习下<code>dispatch_semaphore</code>相关知识。</p>
<p><code>dispatch_semaphore</code>对应的就是信号量，当有多个线程想要访问一个需要并发保护的资源的时候，信号量可以帮助我们协调并发数。</p>
<p>我们用互斥变量（即信号量为1）来举例：<br>    xxx = dispatch_semaphore_create(1);</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) {</span>
    dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">yyy</span>, <span class="number">0</span>)</span>, ^{
        dispatch_semaphore_wait<span class="list">(<span class="keyword">xxx</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
        [self doSomething]<span class="comment">;</span>
        dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
    })</span><span class="comment">;    </span>
}<span class="comment">;</span></span>
</code></pre><p>就可以保证任意时候，只有一个线程中可以访问到资源了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2017/01/07/JSONRPCKit/" data-id="ck9fy2gif003r2ni12qn1e86r" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2017/01/07/JSONRPCKit/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-multithread-dangling-pointer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/23/multithread-dangling-pointer/" class="article-date">
  <time datetime="2016-10-22T18:43:25.000Z" itemprop="datePublished">2016-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/23/multithread-dangling-pointer/">浅谈一种解决多线程野指针的新思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>无论是xx还是xx，对于整个App的稳定性要求都非常之高。因此，那些前辈大牛们为了解决一些常见的问题，比如空指针、数组越界等等，开发了xxxxxx这样的底层SDK，用于解决问题。</p>
<p>但是随着业务逐渐的复杂化以及愈发严格的性能要求，xxApp绝大多数的Crash开始往野指针方面靠拢。这些野指针的问题，除了一些<strong>iOS7上delegate是assign声明导致的历史遗留问题以外，绝大多数都是多线程的赋值导致的野指针问题。</strong></p>
<p><span style="color:red">而这些多线程的野指针问题，至今仍未有一个比较好的统一解决方案。因此，今天就想稍微聊下我自身研究的一个方案。</span></p>
<h3 id="什么是多线程的野指针问题">什么是多线程的野指针问题</h3><p>之前在《浅谈多线程编程误区》一文中，曾经举过如下这样的<strong>多线程setter</strong>例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>如果这个<code>self.data</code>是个<code>nonatomic</code>的属性的话，就会造成在多次释放导致的野指针问题。（具体可以见《浅谈多线程编程误区》的原理解释）。</p>
<p>从原理解释中不难发现，本质上会产生野指针的场景是由于我们没有对临界区进行保护。导致赋值替换的操作不是原子性的。</p>
<p>有些人会说，例子中你刻意构建了一万个线程才会导致Crash。而我们平时就用用几个线程，不会有问题的。<br><strong>理论上一万个线程只不过是把两个线程中可能出现问题的概率放大了而已。在一万个线程中会出现的多线程野指针问题在两个线程中一定也会发生。</strong></p>
<h3 id="传统业界方案：赋值加锁">传统业界方案：赋值加锁</h3><p>既然原子性是导致野指针的罪魁祸首，那么我们只要在对应可能产生冲突的临界区内加锁就好了，比如：</p>
<pre><code>[<span class="operator"><span class="keyword">lock</span> <span class="keyword">lock</span>];</span>
self.data = [[NSMutableData alloc] init];
[<span class="operator"><span class="keyword">lock</span> <span class="keyword">unlock</span>]</span>
</code></pre><p>按照这样的做法，同一时间不管有多少线程试图对<code>self.data</code>进行赋值，最终都只有一个线程能够抢到锁对其赋值。</p>
<p>但是这样的做法从安全性角度来说是解决了原子赋值的问题。但是这样的做法却对开发要求比较严格，因为<strong>任意非基础类型的对象(Int, Bool)</strong>都有可能产生多线程赋值的野指针，所以开发需要牢记自身的属性变量究竟有哪些会在多线程场景中被使用到。</p>
<p><b style="color:red">而且，这样的方案还有一个非常大的不确定性！</b></p>
<p>当你开发了一个底层SDK，对外暴露了一些公共的<strong>readwrite</strong>的Property。别人对你的property赋值的时候，你怎么确定他们一定会做到线程安全？</p>
<h3 id="我的方案：runtime追踪对象初始化的GCD_Queue">我的方案：runtime追踪对象初始化的GCD Queue</h3><p>我们都知道，在<code>Objective-C</code>中，对于一个<code>property</code>的赋值最终都会转化成对于<code>ivar</code>的setter方法。所以，如果我们能确保<code>setter</code>方法的线程安全性，就能确保多线程赋值不会产生野指针。</p>
<p>好，按照这个思路进行操作的话，我们大致需要如下几个步骤：</p>
<ol>
<li>获取第一次setter调用的时机及对应的线程。</li>
<li>将这个线程记录下来。</li>
<li>后续调用setter的时候，判断当前setter调用的线程是不是我们之前记录的线程，如果是，直接赋值。如果不是，派发到对应的线程进行调用。</li>
<li>获取所有的setter，重复实现上述步骤。</li>
</ol>
<p>看起来思路很简单，具体实现起来却有一定的难度，容我由浅入深慢慢道来：</p>
<h4 id="1-_获取第一次赋值的线程并记录">1. 获取第一次赋值的线程并记录</h4><p>由于我们不能通过成员变量就记录每个ivar对应的setter的初始化线程(这样setter的个数就无限增长了)，因此本质上我们只有通过局部静态变量的方式来作为存储。同时由于我们只需要在初次执行时进行记录，所以很理所当然就想到了<code>dispatch_once</code>。</p>
<p>具体代码如下：</p>
<pre><code><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> initQueue;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueKey;
<span class="keyword">static</span> <span class="keyword">void</span>* initQueueContext;

<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{

    <span class="comment">// 1. 主队列</span>
    <span class="keyword">if</span> ([<span class="built_in">UIApplication</span> isMainQueue]) {
        initQueue = dispatch_get_main_queue();
        initQueueKey = [<span class="built_in">UIApplication</span> mainQueueKey];
        initQueueContext = [<span class="built_in">UIApplication</span> mainQueueContext];
    } <span class="keyword">else</span> {
        <span class="comment">// 2. 非主队列</span>
        <span class="keyword">const</span> <span class="keyword">char</span> *label = [<span class="built_in">NSStringFromSelector</span>(_cmd) UTF8String];
        initQueueKey = &amp;initQueueKey;
        initQueueContext = &amp;initQueueContext;
        initQueue = dispatch_queue_create(label, <span class="literal">nil</span>);
        dispatch_queue_set_specific(initQueue, initQueueKey, initQueueContext, <span class="literal">nil</span>);
    }
});
</code></pre><p>从代码中不难发现，由于主队列是全局共用的，所以如果这次setter的赋值是在主队列进行的，那么就直接复用主队列即可；而如果当前的队列我们自身都不确定的话，那么就干脆<strong>开辟一个串行的队列</strong>用语这个setter的后续赋值，并将其记录下来。</p>
<p><strong>细心的读者可能会发现，我们标题里写的是线程，但是在代码中记录的却是GCD的队列（Queue）。而且，我们判断的是主队列而不是主线程。这是为什么呢？</strong></p>
<p>嘿嘿，容我卖个关子，文章最后会有详细的阐述。</p>
<h4 id="2-_判断后续赋值是否是记录的线程">2. 判断后续赋值是否是记录的线程</h4><p>由于我们之前记录的是队列，所以我们是无法直接使用诸如如下代码的方式进行是否是同一个线程的判断  </p>
<pre><code><span class="string">[NSThread currentThread]</span> == xxxThread
</code></pre><p>在iOS7之前，苹果提供了<code>dispatch_get_current_queue()</code>用于获取当前正在执行的队列，如果有这个方法，我们就可以很容易判断这个队列和我们记录的队列是否是同一个了。但是很不幸的是，该方法已经被从GCD的Public API中移除了，一时间研究陷入了僵局。</p>
<p>不过好在<code>libdispatch</code>是开源的，经过一段时间的摸索，我发现了这个方法<code>dispatch_get_specific</code>，其自身实现如下：</p>
<pre><code><span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span> *
<span class="title">dispatch_get_specific</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span>
</span>{
    <span class="keyword">if</span> (slowpath(!key)) {
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }
    <span class="keyword">void</span> *ctxt = <span class="literal">NULL</span>;
    <span class="comment">// 1. 获取当前线程的执行队列</span>
    <span class="keyword">dispatch_queue_t</span> dq = _dispatch_queue_get_current();

    <span class="keyword">while</span> (slowpath(dq)) {
        <span class="comment">// 2. 如果进行过标记</span>
        <span class="keyword">if</span> (slowpath(dq-&gt;dq_specific_q)) {
            ctxt = (<span class="keyword">void</span> *)key;
            dispatch_sync_f(dq-&gt;dq_specific_q, &amp;ctxt,
                    _dispatch_queue_get_specific);
            <span class="keyword">if</span> (ctxt) <span class="keyword">break</span>;
        }
        <span class="comment">// 3. 向上传递至target Queue</span>
        dq = dq-&gt;do_targetq;
    }
    <span class="keyword">return</span> ctxt;
}
</code></pre><p>通过上述代码不难理解，系统会自动获取当前线程正在执行的队列的。如果进行该队列进行过标记，就根据我们传入的key去获取key对应的value(ctxt)。如果查询到了，就返回。否则按照目标队列层层上查，直至root_queue也没找到为止。（关于libdispatch的具体原理，我下周还会专门写篇细细分析的文章）。</p>
<p>通过这个方法，我们可以在直接记录初始化队列的时候对其进行特殊的标定：</p>
<pre><code>dispatch_queue_set_specific<span class="list">(<span class="keyword">initQueue</span>, initQueueKey, initQueueContext, <span class="literal">nil</span>)</span><span class="comment">;</span>
</code></pre><p>随后在后续setter执行的时候通过如下代码进行判断并进行相应的直接赋值或者队列重新派发：</p>
<pre><code><span class="comment">// 如果是当前队列</span>
<span class="keyword">if</span> (dispatch_get_specific(initQueueKey) == initQueueContext) {
    _threadSafeArray = threadSafeArray;
} <span class="keyword">else</span> {
     <span class="comment">// 不是当前队列</span>
    <span class="built_in">dispatch_sync</span>(initQueue, ^{
        _threadSafeArray = threadSafeArray;
    });
}
</code></pre><h4 id="3-_遍历所有的setter，重复上述过程">3. 遍历所有的setter，重复上述过程</h4><p>由于我们的目的是减轻其他开发的负担，所以不得不借助了runtime的Method Swizzling技术。但是传统的Method Swizzling技术是将函数实现两两交换。如果按照这个思路，我们就需要为每一个setter编写一个对应的<code>hook_setter</code>，这工作量无疑太巨大了。</p>
<p>所以，在这里我们需要的一个中心重定向的过程：即，将所有的setter都转移到一个hook_proxy中。代码如下：</p>
<pre><code>- (<span class="function_or_atom">void</span>)<span class="function_or_atom">hookAllPropertiesSetter</span>
{
    <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">outCount</span>;
    <span class="function_or_atom">objc_property_t</span> *<span class="function_or_atom">properties</span> = <span class="function_or_atom">class_copyPropertyList</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], &amp;<span class="function_or_atom">outCount</span>);

    <span class="variable">NSMutableArray</span> *<span class="function_or_atom">readWriteProperties</span> = [[<span class="variable">NSMutableArray</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCapacity:outCount</span>];
    <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">i</span> = <span class="number">0</span>; <span class="function_or_atom">i</span> &lt; <span class="function_or_atom">outCount</span>; <span class="function_or_atom">i</span>++) {
        <span class="function_or_atom">objc_property_t</span> <span class="function_or_atom">property</span> = <span class="function_or_atom">properties</span>[<span class="function_or_atom">i</span>];
        <span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> = [[<span class="variable">NSString</span> <span class="function_or_atom">alloc</span>] <span class="function_or_atom">initWithCString:property_getName</span>(<span class="function_or_atom">property</span>) <span class="function_or_atom">encoding</span>:<span class="variable">NSUTF8StringEncoding</span>];

        <span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">attrCount</span>;
        <span class="function_or_atom">objc_property_attribute_t</span> *<span class="function_or_atom">attrs</span> = <span class="function_or_atom">property_copyAttributeList</span>(<span class="function_or_atom">property</span>, &amp;<span class="function_or_atom">attrCount</span>);

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">BOOL</span> <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">NO</span>;
        <span class="function_or_atom">for</span> (<span class="function_or_atom">unsigned</span> <span class="function_or_atom">int</span> <span class="function_or_atom">j</span> = <span class="number">0</span>; <span class="function_or_atom">j</span> &lt; <span class="function_or_atom">attrCount</span>; <span class="function_or_atom">j</span>++) {
            <span class="function_or_atom">if</span> (<span class="function_or_atom">attrs</span>[<span class="function_or_atom">j</span>].<span class="function_or_atom">name</span>[<span class="number">0</span>] == <span class="string">'R'</span>) {
                <span class="function_or_atom">isReadOnlyProperty</span> = <span class="variable">YES</span>;
                <span class="function_or_atom">break</span>;
            }
        }
        <span class="function_or_atom">free</span>(<span class="function_or_atom">attrs</span>);

        <span class="function_or_atom">if</span> (<span class="exclamation_mark">!</span><span class="function_or_atom">isReadOnlyProperty</span>) {
            [<span class="function_or_atom">readWriteProperties</span> <span class="function_or_atom">addObject:propertyName</span>];
        }
    }
    <span class="function_or_atom">free</span>(<span class="function_or_atom">properties</span>);

    <span class="function_or_atom">for</span> (<span class="variable">NSString</span> *<span class="function_or_atom">propertyName</span> <span class="function_or_atom">in</span> <span class="function_or_atom">readWriteProperties</span>) {

        <span class="variable">NSString</span> *<span class="function_or_atom">setterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"set%@%@:"</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringToIndex</span>:<span class="number">1</span>].<span class="function_or_atom">uppercaseString</span>, [<span class="function_or_atom">propertyName</span> <span class="function_or_atom">substringFromIndex</span>:<span class="number">1</span>]];

        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>特别注意<span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
        <span class="variable">NSString</span> *<span class="function_or_atom">hookSetterName</span> = [<span class="variable">NSString</span> <span class="function_or_atom">stringWithFormat</span>:@<span class="string">"hook_set%@:"</span>, <span class="function_or_atom">propertyName</span>];

        <span class="variable">SEL</span> <span class="function_or_atom">originSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">setterName</span>);
        <span class="variable">SEL</span> <span class="function_or_atom">newSetter</span> = <span class="variable">NSSelectorFromString</span>(<span class="function_or_atom">hookSetterName</span>);

        <span class="function_or_atom">swizzleMethod</span>([<span class="function_or_atom">self</span> <span class="function_or_atom">class</span>], <span class="function_or_atom">originSetter</span>, <span class="function_or_atom">newSetter</span>);
    }
}
</code></pre><p>在这里有两点需要注意的地方：</p>
<ol>
<li><strong>readonly</strong>的property是不具备setter功能的，所以将其过滤。</li>
<li>将每个setter，比如<code>setThreadSafeArray</code>都<strong>swizzle</strong>成了<code>hook__setThreadSafeArray</code>。即为每一个setter都定制了一个对应的hook_setter。</li>
</ol>
<p>哎，有人会问，你刚刚不才说为每一个setter编写对应的hook_setter是费时费力的吗？怎么自己打自己脸啊？</p>
<p>别急，容我慢慢道来。</p>
<p>在Method Swizzling的时候，我们需要调用<code>class_getInstanceMethod</code>来进行对应方法名的函数查找。整个过程简述如下：</p>
<pre><code><span class="keyword">method</span> cache list -&gt; <span class="keyword">method</span> list -&gt; 动态方法决议 -&gt; 方法转交 (forward <span class="type">Invocation</span>)
</code></pre><p>其中，在动态方法决议这步，如果我们添加了之前的没找到的方法，那么整个查找过程又会重新开始一遍。</p>
<p><strong><span style="color:red">由于那些hook_setter是压根不会存在于method list中的，所以在查找这些函数的时候，一定会走到动态决议这一步。</span></strong></p>
<p>基于此，我实现了如下的动态决议函数：</p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *selName = NSStringFromSelector(sel);

    <span class="keyword">if</span> ([selName hasPrefix:@<span class="string">"hook_"</span>]) {
        <span class="function"><span class="keyword">Method</span> <span class="title">proxyMethod</span> =</span> class_getInstanceMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">hook_proxy</span>:));</span>
        class_addMethod([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>], <span class="title">sel</span>, <span class="title">method_getImplementation</span>(<span class="title">proxyMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">proxyMethod</span>));</span>
        <span class="keyword">return</span> YES;
    }

    <span class="keyword">return</span> [<span class="variable">super</span> resolveInstanceMethod:sel];
}
</code></pre><p>从代码中很容易发现，如果是之前那么hook_setter的函数名，我就讲这些方法的<strong>函数实现</strong>全部重定向到函数<code>hook__proxy</code>上。</p>
<h4 id="4-_寻找上下文">4. 寻找上下文</h4><p>在传统的Method Swizzling技术中，由于我们是两两交换，因此我们不需要上下文这一个步骤，直接调用hook_setter就可以重新返回对应的原setter方法。</p>
<p>可是在本文的实现中，由于我们将所有的setter都重定向到了<code>hook__proxy</code>中，所以我们需要在<code>hook_proxy</code>中寻找究竟是给哪个property赋值。</p>
<p><strong><span style="color:red">如果对Method Swizzling的理解只停留在表面，是很难想到后续步骤的。</span></strong></p>
<p>Method Swizzling的原理是只是交换IMP，即函数实现。而我们在Objective-C的函数调用统统是通过objc_msgSend结合函数的Selector(可以简单理解为函数名)来找到真正的函数实现。</p>
<p><strong>因此，swizzle后的Selector没变，变的是IMP。</strong></p>
<p>有了这个理解，我们就可以在hook_proxy使用<b style="color:red">__cmd</b>这个隐藏变量，它会指引我们究竟是哪个Setter当前正在被调用，具体代码如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">hook_proxy:</span>(NSObject *)proxyObject
{
    <span class="comment">// 只是实现被换了，但是selector还是没变</span>
    NSString *originSelector = NSStringFromSelector(_cmd);
    NSString *propertyName = [[originSelector <span class="string">stringByTrimmingCharactersInSet:</span>[NSCharacterSet <span class="string">characterSetWithCharactersInString:</span>@<span class="string">":"</span>]] <span class="string">stringByReplacingOccurrencesOfString:</span>@<span class="string">"set"</span> <span class="string">withString:</span>@<span class="string">""</span>];
    <span class="keyword">if</span> (propertyName.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;

    NSString *ivarName = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"_%@%@"</span>, [propertyName <span class="string">substringToIndex:</span><span class="number">1</span>].lowercaseString, [propertyName <span class="string">substringFromIndex:</span><span class="number">1</span>]];

    <span class="comment">//NSLog(@"hook_proxy is %@ for property %@", proxyObject, propertyName);</span>

    重复之前步骤即可。
}
</code></pre><h4 id="5-_其他拓展">5. 其他拓展</h4><p><strong>本文中只是探索了下没有重载setter的那些ivar，因此只需要简单对ivar进行赋值即可。</strong><br>如果你碰到了大量自定义setter的ivar，那么也一样很简单，你只需要维护一个ivar 到对应自定义的setter的imp映射，在hook_proxy将<code>setValue:ForKey:</code>替换成直接的IMP调用即可。</p>
<h3 id="一些额外细节">一些额外细节</h3><ul>
<li><ol>
<li>线程和GCD Queue并不是一一对应的关系。</li>
</ol>
</li>
</ul>
<p>前面提到了，我们要记录的是队列而不是线程。相信很多人可能一开始都不能理解，那么我用如下这样的代码进行解释：</p>
<pre><code><span class="tag">if</span> ([NSThread isMainThread]) {
    <span class="attr_selector">[self doSomeThing]</span>;
} <span class="tag">else</span> {
    <span class="tag">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="attr_selector">[self doSomething]</span>;
    });
}
</code></pre><p>上述代码想必大家非常熟悉，就是全包在主线程执行一些操作，比如UI操作等等。但是事实上，这里有个误区：</p>
<p><strong>主队列一定在主线程执行，而主线程不一定只执行主队列。</strong></p>
<p><b style="color:red">换句话说：上述代码的if 和 else是不等价的。</b> </p>
<p>有时候，主线程有可能会被调度到执行其他队列（其他线程亦是如此），比如如下代码：</p>
<pre><code><span class="comment">// 在主线程创建</span>
dispatch\_queue\_t dq = dispatch\_queue\_create(<span class="string">'com.mingyi.dashuaibi'</span>, <span class="keyword">NULL</span>);
dispatch_sync(dq, ^{
    NSLog(@<span class="string">"current thread is %@"</span>, [NSThread currentThread]);
});
</code></pre><p>具体效果，大家可以自己尝试下，看看Log输出的结果是不是主线程。</p>
<ul>
<li><ol>
<li>为什么不能直接将所有的setter直接hook到hook_proxy，非要通过动态决议来进行。</li>
</ol>
</li>
</ul>
<p>我们举个简单的例子，假设我们有两个property，分别叫A和B。那么在执行下述代码的时候：</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 2; i++) {</span>
     SEL originSetter = NSSelectorFromString<span class="list">(<span class="keyword">setterName</span>)</span><span class="comment">;</span>
     SEL newSetter = NSSelectorFromString<span class="list">(<span class="keyword">hook_proxy</span>)</span><span class="comment">;</span>
     swizzleMethod<span class="list">([self class], originSetter, newSetter)</span><span class="comment">;</span>
}</span>
</code></pre><p>第一次交换的时候，Setter A的 IMP和 hook_proxy的 IMP进行了交换，这一步没问题。<br>第二次交换的时候，Setter B的 IMP和 hook_proxy的 IMP进行了交换，而此时hook_proxy的IMP已经指向了Setter A的IMP，因此导致的结果就是交换错乱了，调用setter B实质上是调用了setter A。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/" data-id="ck9fy2gdp000e2ni1xdxxbz5d" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-uiwindow-iOS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/17/uiwindow-iOS/" class="article-date">
  <time datetime="2016-09-17T14:51:46.000Z" itemprop="datePublished">2016-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/17/uiwindow-iOS/">浅谈iOS的多Window处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>想必做iOS的人都知道，我们的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个<code>UIWindow</code>，也就是AppDelegate在<code>applicationDidFinishLaunching</code>里面创建出来的。</p>
<p>但是即使我们什么都不做，在我们的APP里面也会有其他的<code>UIWindow</code>:</p>
<ol>
<li>键盘对应的UITextEffectWindow</li>
<li>状态栏对应的UIStatusBarWindow</li>
</ol>
<p>只不过上述两种<code>UIWindow</code>我们一般不太容易去操作罢了，因此很多问题都无形被掩盖住了。所以接下来我们就说说如果在多个UIWindow状态下存在的一些问题吧。</p>
<p>那么在什么情况下会导致我们想要创建多<code>UIWindow</code>的状态呢？我总结了一下，包括但不限于：</p>
<ol>
<li>全局性的自定义HUD，Alert效果（SCAlert）等等。</li>
<li>需要展示的界面需要盖住UIStatusBar。</li>
</ol>
<p>其中，第一种方案其实不一定需要创建一个新的<code>UIWindow</code>实例，我们也可以将这些自定义的全局性界面添加到AppDelegate的window上。但是这样就会产生一个问题，由于在<strong>iOS8之前</strong>，UIWindow的bounds是不会随着旋转而改变的，拿到的永远是处于<strong>Portrait</strong>模式下的坐标系坐标。因此，<b>对于直接添加在UIWindow上的视图，我们需要自己根据  <code>UIApplicationDidChangeStatusBarOrientationNotification</code>来进行转换处理。</b></p>
<p>苹果这篇<a href="https://developer.apple.com/library/content/qa/qa1688/_index.html" target="_blank" rel="external">Q&amp;A</a>讲述了比较具体的原因：<b style="color:red">UIWindow并不会处理rotation事件，而是UIWindow的rootViewController去处理。</b></p>
<p>而对于第二种问题，添加一个盖在UIStatusBar上的界面，就必须依赖我们自己创建一个新的UIWindow，究其原因在于UIStatusBar本身并不属于我们App内可控的一个控件，而是一个系统级创建出来的产物。<br>因此，<strong>我们必须创建一个WindowLevel大于UIWindowStatusBar的新Window盖在上面才行。</strong></p>
<p>有人会问：咦，奇怪了，为什么你在自己App内添加一个WindowLevel大于statusbar的就可以了呢？你只是在你自身应用内添加了一个UIView（UIWindow的子类），竟然能影响系统级的控件？</p>
<p><b style="color:red">是的，不知道大家有没有了解过<code>CALayer</code>这层有个属性叫zIndex。通过操纵这个属性，我们可以调整视图渲染的前后关系。即使有的UIView在构建<span style="color:black">层级树</span>的时候被后加的UIView所遮盖，但是在构建<span style="color:black">渲染树</span>的时候，zIndex越高的视图就会越处于视觉前方进行渲染。 而渲染树构建完成之后，并不是在我们的App内部进行渲染，而是通过IPC通信，统一交由一个第三方进程<span style="color:black">Render Server</span>进行渲染。而在我们这里处理盖住StatusBar的多Window的情形也是基于这个原理进行。</b></p>
<h3 id="横屏及旋转">横屏及旋转</h3><p>现在绝大多数的iPhone应用都是竖屏应用，即只支持<strong>Portrait</strong>模式。但是随着视频、直播的风口到来，在新闻、购物等等APP内都会插入视频播放这一特性，而视频播放需要的全屏播放特性势必要用到横屏，也就意味着会牵扯到旋转。</p>
<p>横屏旋转分为两种，一种是强制性的，一种是随着设备进行旋转的。什么意思呢？<br>大家还记得手机上有旋转锁这一个开关吧，你将旋转锁开启的时候，手机就保持在锁定对应的模式下，无法自动根据你旋转设备而旋转。在这种模式下，如果你需要更改APP界面对应的UIInterfaceOrientation，就必须要么在对应的<strong>viewcontroller</strong>里面提供实现如下的方法：</p>
<pre><code>- (<span class="built_in">NSUInteger</span>)supportedInterfaceOrientations
{
    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>; <span class="comment">// 表示支持水平右方向</span>
}

- (<span class="built_in">BOOL</span>)shouldAutorotate
{
    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>这样，当你展现到这个页面的时候，就会触发系统检查一下当前页面应该所处的Orientation，从而达到正确的显示效果。</p>
<p><strong>但需要注意的是，如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</strong></p>
<p>PS: <strong><i>其实这个道理和<code>hideBottomBarWhenPushed</code>是一个道理。很多人用了这个属性，发现隐藏Tabbar的时机经常错乱了</i></strong>，这个就在于没有仔细阅读文档，需要在整个导航栈里面的topmostViewController提供正确的属性设置才行。</p>
<blockquote>
<p>The value of this property on the topmost view controller determines whether the toolbar is visible. If the value of this property is true, the toolbar is hidden. If the value of this property is false, the bar is visible</p>
</blockquote>
<p>或者你可以将你需要横屏的ViewController通过present的形势展现出来（有人觉得会狠突兀，那你自己实现专场动画过渡就可以了）。<strong>不过呢，这种实现方式会有一个超级大坑，待会我们细细说。</strong></p>
<p>上面这种就是强制性的。</p>
<p>而自动旋转的就是打开旋转锁，让界面随着<strong>设备的旋转而进行旋转</strong>，这种旋转是物理特性的，非强制性的。</p>
<p>Q: 那么这两种旋转的区别在哪？<br>A: <strong>UIInterfaceOrientation（UIStatusBar的所处方向）和UIDeviceOrientation</strong>是否一致。</p>
<p>Q: 那么有什么问题呢？<br>A: 在iOS8之后，UIScreen的bounds是随着物理设备的旋转而更改的。如果你需要获取iOS8之前的bounds效果，需要使用<strong>nativeBounds</strong>。但是要记得，nativeBounds是像素级别的，你需要换算到对应的point单位来，所以关系是：</p>
<pre><code>bounds<span class="list">( <span class="keyword">&lt;</span> iOS8.<span class="number">0</span>)</span> = nativeBounds / nativeScale<span class="comment">;</span>
</code></pre><p>大家可以参考苹果的<a href="https://developer.apple.com/reference/uikit/uiscreen/1617838-bounds" target="_blank" rel="external">文档</a>来更确切的掌握一下。</p>
<h3 id="坑">坑</h3><p>上面的内容我们曾经提及在采用多<code>UIWindow</code>时候的几个大坑，如果你现在有自定义的界面，想要添加到除了<code>delegate window</code>之外的window，可能会遇到如下几个问题。</p>
<h4 id="直接将自定义的视图作为Subview添加到UIWindow上">直接将自定义的视图作为Subview添加到UIWindow上</h4><p>从理论上来说UIWindow继承于UIView，这种直接用法在认知上没有任何的问题。但是如果涉及的应用牵扯到横屏模式而且又要支持iOS7的话（我相信现在没有哪个产品还需要支持iOS6）吧，那么针对iOS7需要单独处理横屏的坐标系转换。我们摘录一段著名的开源库<strong>MBProgressHUD</strong>的代码作为示例：</p>
<pre><code><span class="preprocessor">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="title">&lt; 80000
    // Only needed pre iOS 8 when added to a window
    BOOL iOS8OrLater = kCFCoreFoundationVersionNumber &gt;</span>= kCFCoreFoundationVersionNumber_iOS_8_0;</span>
    <span class="keyword">if</span> (iOS8OrLater || ![<span class="keyword">self</span><span class="variable">.superview</span> isKindOfClass:[<span class="built_in">UIWindow</span> class]]) <span class="keyword">return</span>;

    <span class="comment">// Make extension friendly. Will not get called on extensions (iOS 8+) due to the above check.</span>
    <span class="comment">// This just ensures we don't get a warning about extension-unsafe API.</span>
    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
    <span class="keyword">if</span> (!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) <span class="keyword">return</span>;

    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="built_in">UIInterfaceOrientation</span> orientation = application<span class="variable">.statusBarOrientation</span>;
    <span class="built_in">CGFloat</span> radians = <span class="number">0</span>;

    <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsLandscape</span>(orientation)) {
        radians = orientation == <span class="built_in">UIInterfaceOrientationLandscapeLeft</span> ? -(<span class="built_in">CGFloat</span>)M_PI_2 : (<span class="built_in">CGFloat</span>)M_PI_2;
        <span class="comment">// Window coordinates differ!</span>
        <span class="keyword">self</span><span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);
    } <span class="keyword">else</span> {
        radians = orientation == <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> ? (<span class="built_in">CGFloat</span>)M_PI : <span class="number">0.</span>f;
    }

        <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(radians);
<span class="preprocessor">#endif</span>
</code></pre><h4 id="通过rootViewController的view添加子视图">通过rootViewController的view添加子视图</h4><p>这种方式就是通过将<code>window.rootViewController = vc</code>，然后我们所有的子视图都添加到<code>vc.view</code>。</p>
<p>这种使用的好处是我们无需去考虑版本兼容的问题，通过vc.view拿到的坐标系对于我们来说都是和<strong>UIInterfaceOrientation</strong>正确转换过的。</p>
<p>在iOS7之前，坐标系的转换是系统通过设置<code>vc.transform</code>更改；而在iOS8之后，vc和window的旋转会根据<strong>UIDeviceOrientation</strong>和viewcontroller自身<code>supportedInterfaceOrientations</code>进行<strong>交集</strong>的操作。</p>
<p>总之，<strong>需要支持横屏的自定义界面，全部放在viewcontroller.view上来做，是准没错的。</strong></p>
<p>而且，在iOS9以后，苹果推荐每个<code>UIWindow</code>都必须有一个rootViewController。否则<span style="color:red">在启动过程使用了不包含rootViewController的UIWindow中会导致必现的crash</span>。</p>
<h4 id="presentViewController的大坑">presentViewController的大坑</h4><p>我们前面提过，如果想要让viewcontroller单独横屏有两种方式。</p>
<blockquote>
<ol>
<li><p>如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的<code>supportedInterfaceOrientations</code>实现，否则就无法得到正确的效果。</p>
</li>
<li><p>或者你可以将你需要横屏的ViewController通过present的形势展现出来</p>
</li>
</ol>
</blockquote>
<p>第二种方案在实现过程中，会产生一个非常隐晦的大坑，容我慢慢道来。<br>首先我们需要了解下整体响应旋转变化的事件流程，简单来说如下：</p>
<pre><code><span class="constant">UIScreen </span>-&gt; <span class="constant">UIWindow </span>-&gt; <span class="constant">UIViewController </span>-&gt; <span class="constant">ChildViewControllers </span>-&gt; <span class="constant">View </span>-&gt; <span class="constant">Subviews</span>
</code></pre><p>其中，UIWindow对应的处理方法是：<code>supportedInterfaceOrientationsForWindow</code>；而UIViewController对应的处理方法是<code>supportedInterfaceOrientations</code>。</p>
<p>也就是说，当系统通过这个流程向我们请求界面的UIInterfaceOrientation的时候，我们必须确保我们能够提供正确的返回参数。</p>
<p>而这个流程在使用<code>presentViewController</code>弹出<strong>modalViewController</strong>会产生一些问题：即当你想从<strong>modalViewController</strong> 返回（dismiss）原先的界面的时候，你会发现虽然原先界面强制设置了portrait模式，但是如果<strong>设备锁关闭且设备仍然处于水平状态</strong>，那么此时的UIInterfaceOrientation，仍然是不准确的。</p>
<p>其原因在于：当你想要dismiss的时候，系统的确发起了一次新的请求流程。但是此时，modalViewController正处于dismissing的状态中，请求到的<code>supportedInterfaceOrientations</code>还是针对modalViewController的。所以，如果你的modalViewController是横屏模式，那么返回后的效果就是横屏模式，除非你人为的旋转一下设备，让其回到竖直方向。</p>
<p>Q: 那么这种问题有没有解决办法呢？<br>A: 你可以在<code>supportedInterfaceOrientations</code>里面判断下当前的viewcontroller是不是处于<strong>isBeingDismissed</strong>，如果是的话，取其<strong>presentingViewController</strong>的<code>supportedInterfaceOrientations</code>作为返回值。</p>
<p>Q: 有些同学会问，我们怎么从来没遇到过这个问题？<br>A: 那是因为你们使用的<code>UIWindow</code> 99%的可能都是默认的<code>delegate window</code>，对于这个window，所有的旋转事件都自动帮你校准了，因此无需担忧。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li><a href="https://jkyin.me/uiwindow/" target="_blank" rel="external">UIWindow in iOS</a></li>
<li><a href="http://stackoverflow.com/questions/8598315/after-rotation-uiview-coordinates-are-swapped-but-uiwindows-are-not" target="_blank" rel="external">After rotation UIView coordinates are swapped but UIWindow’s are not?</a></li>
<li><a href="http://chun.tips/blog/2014/10/23/xiang-jie-uicoordinatespacehe-uiscreenzai-ios-8shang-de-zuo-biao-wen-ti/" target="_blank" rel="external">详解UICoordinateSpace和UIScreen在iOS 8上的坐标问题</a></li>
<li><a href="http://stackoverflow.com/questions/25391564/ios-7-dismiss-modal-view-controller-and-force-portrait-orientation" target="_blank" rel="external">iOS 7+ Dismiss Modal View Controller and Force Portrait Orientation</a></li>
<li><a href="http://swiftiostutorials.com/ios-orientations-landscape-orientation-one-view-controller/" target="_blank" rel="external">iOS Orientations: Landscape orientation for only one View Controller</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/09/17/uiwindow-iOS/" data-id="ck9fy2gdd00072ni12toihgua" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/09/17/uiwindow-iOS/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-immutable-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/10/immutable-thread/" class="article-date">
  <time datetime="2016-07-10T09:03:47.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/immutable-thread/">从Immutable来谈谈对于线程安全的理解误区</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>毫不夸张的说，80%的程序员对于多线程的理解都是浅陋和错误的。就拿我从事的iOS行业来说，虽然很多程序员可以对异步、GCD等等与线程相关的概念说的天花乱坠。但是实质上深挖本质的话，大多数人并不能很好的区分Race Condition，Atomic，Immutable对象在线程安全中真正起到的作用。</p>
<p>所以今天就以这篇文章来谈谈我所理解的线程安全。</p>
<p>首先就允许我从Immutable来开始整篇话题吧。</p>
<h3 id="Swift中的Immutable">Swift中的Immutable</h3><p>用过Swift的人都知道，Swift相较于Objective-C有一个比较明显的改动就是将结构体（Struct）和类型（Class）进行了分离。从某种方面来说，Swift将值类型和引用类型进行了明显的区分。为什么要这么做？</p>
<ol>
<li>避免了引用类型在被作为参数传递后被他人持有后修改，从而引发比较难以排查的问题。</li>
<li>在某些程度上提供了一定的线程安全（因为多线程本身的问题很大程序上出在<strong>写修改</strong>的不确定性）。而Immutable 数据的好处在于一旦创建结束就无法修改，因此相当于任一一个线程在使用它的过程中仅仅是使用了读的功能。</li>
</ol>
<p>看到这，很多人开始欢呼了（嘲讽下WWDC那些“托”一般的粉丝，哈哈），觉得线程安全的问题迎刃而解了。</p>
<p>但事实上，我想说的是<strong>使用Immutable不直接等同于线程安全</strong>，不然在使用NSArray，NSDictionary等等Immutable对象之后，为啥还会有那么多奇怪的bug出现？</p>
<h3 id="指针与对象">指针与对象</h3><p>有些朋友会问，Immutable都将一个对象变为不可变的“固态”了，为什么还是不安全呢，在各个线程间传递的只是一份只读文件啊。</p>
<p>是的，对于一个Immutable的对象来说，它自身是不可变了。但是在我们的程序里，我们总是需要有“东西”去指向我们的对象的吧，那这个“东西”是什么？<strong>指向对象的指针</strong>。</p>
<p>指针想必大家都不会陌生。对于指针来说，其实它本质也是一种对象，我们更改指针的指向的时候，实质上就是对于指针的一种赋值。所以想象这样一种场景，当你用一个指针指向一个Immutable对象的时候，在多线程更改的时候，你觉得你的指针修改是线程安全的吗？这也就是为什么有些人碰到一些跟<strong>NSArray</strong>这种Immutable对象的在多线程出现奇怪bug的时候会显得一脸懵逼。</p>
<p>举例：  </p>
<pre><code><span class="comment">// Thread A 其中immutableArrayA count 7</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayA;

<span class="comment">// Thread B 其中immutableArrayB count 4</span>
<span class="built_in">self</span><span class="built_in">.</span>xxx = <span class="built_in">self</span><span class="built_in">.</span>immutableArrayB 

<span class="comment">// main Thread</span>
<span class="preprocessor">[</span><span class="built_in">self</span><span class="built_in">.</span>xxx objectAtIndex:<span class="number">5</span><span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>上述这个代码片段，绝对是存在线程的安全的隐患的。</p>
<h3 id="锁">锁</h3><p>既然想到了多线程对于指针（或者对象）的修改，我们很理所当然的就会想到用锁。在现如今iOS博客泛滥的年代，大家都知道NSLock, OSSpinLock之类的可以用于短暂的Critical Section竞态的锁保护。</p>
<p>所以对于一些多线程中需要使用共享数据源并支持修改操作的时候，比如NSMutableArray添加一些object的时候，我们可以写出如下代码：</p>
<pre><code>OSSpinLock(&amp;_lock)<span class="comment">;</span>
[self.array addObject:@"hahah"]<span class="comment">;</span>
OSSpinUnlock(&amp;_lock)<span class="comment">;</span>
</code></pre><p>乍一看，这个没问题了，这个就是最基本的写保护锁。如果有多个代码同时尝试添加进入<code>self.array</code>，是会通过锁抢占的方式一个一个的方式的添加。</p>
<p>但是，这个东西有啥卵用吗？原子锁只能解决Race Condition的问题，但是它并不能解决任何你代码中需要有时序保证的逻辑。</p>
<p>比如如下这段代码：</p>
<pre><code>if (<span class="literal">self</span>.xxx) {
    [<span class="literal">self</span>.dict <span class="built_in">set</span>Object:@<span class="string">"ah"</span> <span class="keyword">for</span>Key:<span class="literal">self</span>.xxx];
}
</code></pre><p>大家第一眼看到这样的代码，是不是会认为是正确的？因为在设置key的时候已经提前进行了<code>self.xxx</code>为<strong>非nil</strong>的判断，只有非nil得情况下才会执行后续的指令。<strong>但是，如上代码只有在单线程的前提下才是正确的。</strong></p>
<p>假设我们将上述代码目前执行的线程为<code>Thread A</code>，当我们执行完<code>if (self.xxx)</code>的语句之后，此时CPU将执行权切换给了<code>Thread B</code>，而这个时候Thread B中调用了一句<strong><em><code>self.xxx = nil</code></em></strong>。<div style="color:red"><b>嘿嘿，后果如何，想必我不用多说了吧。</b></div></p>
<p>那对于这种问题，我们有没有比较好的解决方案呢？答案是存在的，就是使用<strong>局部变量</strong>。<br>针对上述代码，我们进行如下修改：</p>
<pre><code>__strong id <span class="function"><span class="keyword">val</span> =</span> self.xxx;
<span class="keyword">if</span> (<span class="function"><span class="keyword">val</span>) {</span>
    [self.dict setObject:@<span class="string">"ah"</span> forKey:<span class="function"><span class="keyword">val</span>];</span>
}
</code></pre><p>这样，无论多少线程尝试对<code>self.xxx</code>进行修改，本质上的<code>val</code>都会保持现有的状态，符合非nil的判断。</p>
<h3 id="Objective-C的Property_Setter多线程并发bug">Objective-C的Property Setter多线程并发bug</h3><p>最后我们回到经常使用的Objective-C来谈谈现实生活中经常出现的问题。相信各位对于Property的Setter概念都不陌生，<code>self.xxx = @&quot;kks&quot;</code>其实就是调用了<code>xxx</code>的setter方法。而Setter方法本质上就是如下这样一段代码逻辑：</p>
<pre><code>- (void)setXxx:(NSString *)newXXX {
      if (newXXX != _xxx) {
          [newXXX retain]<span class="comment">;</span>
          [_xxx release]<span class="comment">;</span>
          _userName = newXXX<span class="comment">;</span>
      }
}
</code></pre><p>比如<strong>Thread A 和 B</strong>同时对<code>self.xxx</code>进行了赋值，当两者都越过了<code>if (newXXX != _xxx)</code>的判断的时候，就会产生<code>[_xxx release]</code>执行了两次，造成过度释放的crash危险。</p>
<p>有人说，呵呵，你这是MRC时代的写法，我用了ARC，没问题了吧。</p>
<p>ok，那让我们来看看ARC时代是怎么处理的，对于ARC中不复写Setter的属性（我相信是绝大多数情况），Objective-C的<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm" target="_blank" rel="external">底层源码</a>是这么处理的。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, 
  ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) 
{
    <span class="keyword">id</span> oldValue;
    <span class="comment">// 计算结构体中的偏移量</span>
    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);

    <span class="keyword">if</span> (<span class="keyword">copy</span>) {
        newValue = [newValue copyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:<span class="literal">NULL</span>];
    } <span class="keyword">else</span> {
        <span class="comment">// 某些程度的优化</span>
        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;
        newValue = objc_retain(newValue);
    }

    <span class="comment">// 危险区</span>
    <span class="keyword">if</span> (!atomic) {
         <span class="comment">// 第一步</span>
        oldValue = *slot;

        <span class="comment">// 第二步</span>
        *slot = newValue;
    } <span class="keyword">else</span> {
        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
        _spin_lock(slotlock);
        oldValue = *slot;
        *slot = newValue;        
        _spin_unlock(slotlock);
    }

    objc_release(oldValue);
}
</code></pre><p>由于我们一般声明的对象都是<strong>nonatomic</strong>，所以逻辑会走到上述注释<strong>危险区</strong>处。还是设想一下多线程对一个属性同时设置的情况，我们首先在线程A处获取到了执行第一步代码后的<strong>oldValue</strong>，然后此时线程切换到了B，B也获得了第一步后的oldValue，所以此时就有两处持有oldValue。然后无论是线程A或者线程B执行到最后都会执行<strong>objc_release(oldValue);</strong>。</p>
<div style="color:red"><b>于是，重复释放的场景就出现了，crash在向你招手哦！</b></div>

<p>如果不相信的话，可以尝试如下这个小例子：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        self.data = [[NSMutableData alloc] init];
    });
}
</code></pre><p>相信你很容易就能看到如下错误log：<strong>error for object: pointer being freed was not allocated</strong>。</p>
<h3 id="结语">结语</h3><p>说了这么多，本质上线程安全是个一直存在并且相对来说是个比较困难的问题，没有绝对的银弹。用了Immutable不代表可以完全抛弃锁，用了锁也不代表高枕无忧了。希望这篇文章能够帮助大家更深入的思考下相关的问题，不要见到线程安全相关的问题就直接回答加锁、使用Immutable数据之类的。</p>
<p><strong>当然，其实Stick To GCD (dispatch_barrier)是最好的解决方案。</strong></p>
<p>本文写于头昏脑涨之中，写错之处请大神多多指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/07/10/immutable-thread/" data-id="ck9fy2ge3000o2ni1savso44c" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/07/10/immutable-thread/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Spotify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/02/Spotify/" class="article-date">
  <time datetime="2016-05-02T08:34:03.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/Spotify/">为什么Spotify的付费用户转化率惊人的高？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本文由本人独自翻译，同步发表在稀土上</strong></p>
<p>在 2015 年的时候，The Fader <a href="http://www.thefader.com/2015/06/10/new-spotify-statistics" target="_blank" rel="external">报道</a>了一则关于 Spotify 的重磅新闻：在其 7500 万月活跃用户中，有 2000 万左右是付费用户。</p>
<p>26.6% 的转化率对于免费增值产品来说是令人难以置信的。正如 Jason Chen <a href="http://blog.asmartbear.com/freemium.html" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>“如果说免费用户到收费用户的转化率可以达到 4%，那就已经可以说是很不错了，比如 DropBox。但是通常来说，转化率一般都处于 1% 上下浮动，这还是用户十分活跃的情况下才会达到。”</p>
</blockquote>
<p>如果说 1% 是普遍的水准，然后 <a href="https://www.process.st/dropbox-vs-google-drive/" target="_blank" rel="external">DropBox</a> 4% 的转化率是非常不错的话，那26.6%绝对可以称的上是令人匪夷所思了。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/1.jpg" alt=""></p>
<p>至于用户留存率，<a href="http://expandedramblings.com/index.php/spotify-statistics/" target="_blank" rel="external">80%</a>的用户（包括免费用户和付费用户）每周都会多次使用 Spotify。</p>
<p>我写这篇文章的原因在于我在使用 Spotify 仅仅 11 天后，就成为了它的付费用户（似乎我当时还经历了一个 7 天 A/B 测试的试用阶段）。所以，我想从产品、<a href="https://medium.com/@benjbrandall/astonishment-expectations-and-reality-in-user-experience-decb6cc18e28" target="_blank" rel="external">用户体验</a>和市场运营的视角来真正探究一下其中深层次的原因，究竟是什么导致了 Spotify 有如此大的魔力让用户乐意为其付费。</p>
<p>所以，出于这次研究的目的，我又重新注册了一个账号。</p>
<p>我用了一个新账号并且从一个新用户的视角来使用 Spotify，一个个去剖析那些容易激发用户付费的诱因，并调查这些诱因是如何保证如此高的转化率以及用户留存率。</p>
<p><em>在我们开始前，我们需要留意一点:</em> <a href="https://www.process.st/slack-review/" target="_blank" rel="external">Slack</a> 也因为它那令人咋舌的用户转化率而出名，<a href="http://www.nirandfar.com/2014/11/slack.html" target="_blank" rel="external">最新的数据</a>显示它们的转化率达到了 30% 左右。但要注意的是，Slack 是一个 B2B 软件，它的用户群体相对来说是付费能力和意愿比较强的高端用户。但是Spotify 有超过 <a href="http://www.statista.com/statistics/475821/spotify-users-age-usa/" target="_blank" rel="external">20%</a>的用户是处于 13 到 18 岁年龄段。与企业精英不惜代价寻找一种合适的解决方案相比，这个年龄段的用户一般能成为付费用户的可能性很低的…所以，Spotify 真的很令人难以置信。</p>
<h2 id="步骤_1：减少使用障碍，通过_Facebook_注册来形成病毒式营销">步骤 1：减少使用障碍，通过 Facebook 注册来形成病毒式营销</h2><p>Spotfiy 通过 Facebook 获取信息的注册方法是令人称道的。对于那些已经在手机上登录 Facebook 的用户来说，这种注册方式可以直接从 Facebook 获取你的用户数据，意味着你就不用再笨拙地输入你的邮件地址和密码。这无疑会减少用户注册账号的抵触心理。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/2.png" alt=""></p>
<p>只要仅仅一次点击，允许数据导入，你就注册成功了。</p>
<p>除了作为一种注册方式以外，导入 Facebook 的数据还完成了其余两件事：</p>
<ul>
<li>将用户的喜好展示给他们的朋友</li>
<li>可以让你的朋友了解 Spotify，并吸引他们也来注册使用 Spotify</li>
</ul>
<p>正如 Helpshift <a href="https://www.helpshift.com/blog/app-retention-20000-mau/" target="_blank" rel="external">所说</a></p>
<blockquote>
<p>80% 的手机用户拥有 Facebook 账户。所以，当一个应用的注册只需要轻轻点击蓝色按钮的时候，用户的转化率瞬间就能有 20% 的提升。</p>
</blockquote>
<p>所以使用 Facebook 进行注册，对于 Spotify 的营销来说是起了一个非常关键的作用。正如报道中所说的那样，<strong><a href="https://www.digitalmusicnews.com/2015/06/16/for-every-paying-subscriber-spotify-adds-5-free-accounts/" target="_blank" rel="external">每一个付费用户都带来了3个免费用户</a></strong></p>
<h2 id="步骤_2：精挑细选的播放列表可以满足特定的需求">步骤 2：精挑细选的播放列表可以满足特定的需求</h2><p>Spotify 的目的就是帮助用户发现音乐。它在你初次使用的时候会鼓励你使用它“精心调配”的播放列表。</p>
<p>通过选择一个包含你熟悉歌曲的播放列表，或者一个和你品味相契合的主题，Spotify 会循环播放这些歌，并在其中穿插播放一些你所不了解的歌。</p>
<p>对于一首喜爱却又不了解的歌，人们通常的反应是会去寻找这首歌的歌手、所属专辑或者其他具有相似特征的播放列表。这种寻找的流程在 Spotify 的应用中被设计的极其简单，并且会被推荐到你看到的第一屏当中。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/3.png" alt=""></p>
<p>但这里有个需要注意的点：<strong>如果你是一个免费用户，那么你就无法在任意时刻切换到你想听的歌。</strong>即使你已经制作了你自己的播放列表，歌曲也会是随机出现的。</p>
<p>所以对于我来说，我成为付费用户的一个主要原因就在于：在 Spotify 那不可思议却又十分“对味”的推荐算法指引下，我就很自然而然的养成了一种新的并在不断改进的听歌风格。在这个过程中，许许多多的歌曲都会被加入到你的听歌列表中。但一旦加入，随机播放列表就再也不会将其剔除。因此，其中有部分可能是你不怎么想要再听到的歌曲。比如我就不再想听到任何 Brain Food 里的歌。我想要的是可以自由自在的挑选歌曲、对它们进行排序，并对我自己的歌曲列表有绝对的控制权。如果我不是付费用户的话，即使我特别想听 Stars Wars Headspace 专辑中的几首歌，但是我所能做的仅仅是不断地随机跳过我不喜欢的歌曲，直到从 Spotify 听到我想听的歌。</p>
<p>人们会尝试去“挑战”这个系统来听到他们想要听的歌，但是 Spotify 让这种想法近乎不可能。一般来说，在一个随机播放的列表中，你可能需要跳过8首歌才能听到你想要的歌。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/4.png" alt=""></p>
<h2 id="步骤3：Spotify_会强调歌曲和你息息相关的">步骤3：Spotify 会强调歌曲和你息息相关的</h2><p>首页下面是根据心情情况和流派推荐的播放列表。作为一名有音乐文化背景的研究生，我了解到人们听音乐的根本原因在于音乐能够加强情感共鸣。最好的音乐作曲家，如 <a href="https://en.wikipedia.org/wiki/Lester_Bangs" target="_blank" rel="external">Lester Bangs</a>，就曾写到这样的乐评:音乐就像一剂猛药，伴随并强化着你的听音乐体验。</p>
<p>Spotify 通过一些描述性的分类，并在其中播放与描述非常贴切的音乐来引发共鸣，让听众产生一种“音乐就是我人生不可分割的轨迹”、或“这就是我现在的感受”的心境。</p>
<p>比如在 Chill 心情分类中可以找到一些让你冷静下来的歌曲，每首歌曲又会与地点、’亚情绪’及个人听歌品味相契合。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/5.png" alt=""></p>
<p>歌曲列表包含艺术、排版以及<a href="http://blog.tryadhawk.com/content-marketing/headline-checklist/" target="_blank" rel="external">文案</a>。这些东西对于拥有不同审美的用户来说充满诱惑力。因此对用户来说，很容易就会忽略掉那些不重要的。然后立刻识别出那些诉诸于你的音乐。</p>
<p>通过鼓励你多使用播放列表，并将其和你平时的生活习惯紧紧联系到一起，Spotify 就会变得越来越智能：成为一个能够生成适应任何场景的音乐播放器。<strong>构建一个能融入用户日常生活习惯的产品是一个非常有效<a href="https://www.process.st/customer-retention-strategies/" target="_blank" rel="external">提升用户留存率</a>的方法。</strong>而 Spotify 又采用了非常人性化的手段来达成这个目的：通过理解你听音乐时候的场景和心情。比如你聚会时听得音乐；抑或是跑步、学习时听的音乐。一旦你因为这些目的使用过一次播放列表，当失去它的时候你就会非常想念它。</p>
<h2 id="步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。">步骤4：你把应用“培养”得迎合你的喜好，就相当于做了一笔投资。</h2><p>我之前看过一篇关于<a href="http://usabilitygeek.com/first-time-use-how-to-reduce-initial-friction-of-app-usage/" target="_blank" rel="external"> Flipboard 的入职流程</a>的分析，让用户将应用“培养”<br>成迎合他们自身的喜好是一个久经考验能够提升用户留存率的办法。因为在这个过程中，用户相当于在应用内做了一笔“投资”：如果他们不升级成付费用户，就意味着他们之前所耗费的精力和时间都白白浪费了。</p>
<p>Spotify 也采用了这个策略。他们的做法是允许用户将音乐存储到自己的账户中、建立自己的音乐合集、通过 Facebook 以及Spotify 自己的社交网络和朋友进行分享。</p>
<p><strong>当然，这种投资并是金钱投资，因此你不会感到是被强制消费了。（事实上，现在如果还采用收费合同来绑定用户的行为是不能被容忍的）。但是这种投资对于个人来说，却显得更为重要，因为这是一种跟时间相关的投资，每个人都很珍惜时间，不是吗?</strong></p>
<p>将 Spotify 和 Facebook 打通又是另外一种投资。在不同的应用之间建立依赖关系意味着你需要承担更多的责任。比如，你的朋友喜欢你的播放列表、喜欢听你喜欢的歌。这就意味着你在你的朋友圈中成为了一个传播品味的大师，可以给朋友宣传最新最酷的潮流。我想，你肯定不会因为不想成为付费用户就失去这得之不易的品味大师的头衔吧！</p>
<p>Spotify 并不会强求你选择一个你喜欢的音乐类型，也不会给你许多听歌的建议，它所做的只是让你自行探索音乐。因为自行探索出来的音乐会让你更加感同身受，而且和别人分享这些音乐的时候，也会让你更有成就感。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/6.png" alt="Spotify Personalization"></p>
<p>当你在你自己的设备上使用 Spotify 的时候，除了生成个性化的播放列表，Spotify 并不会耗费你大量的精力。事实上，它根本就不需要。Spotify 的推荐算法已经足够强大，能够理解你的需求。而且多半时候，推荐出来的东西都正是你想要的。所以，你只需要在培养属于你自己喜好的 Spotify 的时候耗费一点精力而已。<strong>_你的_Spotify其实比你自己更懂你的喜好</strong></p>
<h2 id="这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感">这些要求你进行付费的广告并不会让人感到特别烦扰，但是却巧妙的破坏了听音乐时候的代入感</h2><p>另一个能让 Spotify 的付费策略成功伪装成是不激进的原因的是（实际上是非常激进的）你没有意识到你究竟会被一些负面因素激怒到何种程度。</p>
<p><img src="http://i.imgur.com/CIKcZnV.jpg" alt=""></p>
<p>音乐一个非常关键的作用就是它给人带来的代入感。在 Spotify 上，有一些非常流行的播放列表来帮助用户专注于工作，比如学习、<a href="https://www.process.st/writing-process/" target="_blank" rel="external">写作</a>或者要求注意力非常集中的情形。</p>
<p>_你听了15分钟的 chill Brian Eno soundscape。突然，一个刺耳的、极不匹配的流行音乐开始播放。紧跟着出现了一个广告，一个人告诉了你一个你现在毫不关心的东西。然后又过了 30 秒，这些乱七八糟的东西终于结束了，你终于可以听你想要的音乐了。如果是你，你是什么感受？。</p>
<p>对我来说，摆脱广告的烦扰并不是一个足够有说服力可以让我进行付费的理由。我并不把它们当成是对听音乐有着巨大负面影响的因素。因为只要等广告结束了，我就能继续听我想听的音乐。</p>
<p>而且和 <strong>Spotify 会让你跳过 8 首歌才能听过你想要的歌曲</strong>相比，广告是微不足道的，更何况它出现的频率也很低，低到很容易被忽略。但尽管如此，广告对于转化率也有着很大的作用。</p>
<h2 id="允许用户在30天的试用期下载离线音乐是极其明智的">允许用户在30天的试用期下载离线音乐是极其明智的</h2><p>没有什么可以比把你曾经拥有的东西强行夺走更会让你抓狂。</p>
<p>通过允许用户下载歌曲离线使用，又在一段时间后限制他们只能听在线音乐，<strong>这 30 天试用期带来的自由绝对你产生巨大的落差感</strong>。</p>
<p>一个月的试用期对于用户来说完全足够在这段时间内建立起一个音乐合集。更何况 Spotify 大大减少了探索音乐需要耗费的时间：它每天给用户推荐 20 张专辑，而且还会根据你当前的品味和习惯变化。所以 Spotify 通过试用期，给用户画了很大的一个“饼”：如果你们升级成付费用户的话，你们就能享受到多么棒听歌的特权啊。</p>
<p>一旦获得了离线听歌的特权，用户就会囤积尽可能多的歌曲。用他们的话来说，这是<em>属于你的音乐</em>。但囤积的越多，就会让你陷得越深，你再也不会愿意变回免费用户了。</p>
<h2 id="无论用户如何使用_Spotify,_最后都会被引导向升级付费">无论用户如何使用 Spotify, 最后都会被引导向升级付费</h2><p>在用户的使用过程中，有时候 Spotify 会明确的要求用户升级为会员，或者提示这个功能仅仅开放给付费用户。</p>
<p>其中，明确的要求你升级（或者说强迫式的推荐）出现在<strong>一些看似可用的功能实质上仅仅开放给付费用户</strong></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/8.jpg" alt=""></p>
<p>而在如下几种情况当中，Spotify 会采用暗示的方式提示你如果升级到付费用户，使用体验会更好：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/9.jpg" alt=""></p>
<p>所以即使 Spofity 有着巨大基数的免费用户，也很容易就能说明为什么它的付费转化率如此之高。</p>
<p><strong>只要你是音乐的发烧友、渴望发现那些令你狂热的音乐、存储音乐并想要打造出专属你品味的 Spotify。那么，是时候升级成付费用户了。（当然，你也可以选择不升级）</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/05/02/Spotify/" data-id="ck9fy2gfx001x2ni1vvj0m516" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/05/02/Spotify/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Growth/">Growth</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-blank-space-in-html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/blank-space-in-html/" class="article-date">
  <time datetime="2016-04-26T15:21:22.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/blank-space-in-html/">HTML中的“空白符”，你真的懂了吗？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天由于某项任务，暂时转型了成为了前端码农（实际上就是个写初级CSS的屌丝）。在这期间，我有一个需求大致是这样的：</p>
<p>我有一个父类容器，比如<strong>div</strong>，这个<strong>div</strong>的宽度是固定的。我现在要在这个<strong>div</strong>中插入5个<strong>img</strong>，这5个<strong>img</strong>等宽。同时伴随这5个<strong>img</strong>的当然还有四个间隙，这四个间隙也是等宽的。</p>
<p><strong>当然</strong>，需要根据百分比宽度进行简单适配。<br>是不是觉得很简单呢？呵呵，别说专业的前端工程师，我这种半吊子都觉得简单。<br>根据PSD效果图，我量出了对应的百分比尺寸，于是写出来如下的<strong>HTML</strong>和<strong>CSS</strong>代码：</p>
<pre><code><span class="comment">// HTML 文件</span>
&lt;div <span class="keyword">class</span>=<span class="string">"parent"</span>&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
    &lt;img <span class="keyword">class</span>=<span class="string">"element"</span> src=<span class="string">"http://xxxxxxx.com/shshshshs.png"</span> /&gt;
&lt;/div&gt;

<span class="comment">// css 文件</span>
.parent {
    width:x%;
}

.parent img {
    width:y%;
    height:auto;
    margin-left:k%;
}

.parent img:first-child {
    margin-left:<span class="number">0</span>;
}
</code></pre><p>这段代码相当简洁明了吧，我通过量好的百分比，对各个图片和之间的间距进行了控制，基本上业界大多数也是这么做的吧。</p>
<p>按理说事情到这基本就结束了，毕竟img是个<strong>行内可替换元素</strong>，会自动布局在一行之内，<strong>当然前提是父容器宽度足够的前提下</strong>。不过既然我都身体力行的量过了，那自然不应该出现问题。</p>
<p>但是，卧槽，你越担心的事就越会发生。整个界面出现了非常奇葩的现象：</p>
<pre><code>这是正常情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图] 

这是实际情况：
[图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>图<span class="tag">&lt;<span class="title">-</span>&gt;</span>］
图]
</code></pre><p>卧槽，竟然宽度不够，换行了。尝试了很长时间，后来发现，将<code>.parent img</code>中添加<code>float:left</code>就可以完美解决，但这什么原因呢?</p>
<h3 id="原因">原因</h3><p>经过一番探索研究，我发现，这是由于<strong>空白符</strong>对<strong>inline</strong>类型的元素造成的影响。</p>
<ul>
<li>首先，<strong>img</strong>元素是一种行内可替代元素，效果基本可以理解为<strong>inline-block</strong>。</li>
<li><p>第二，我们在HTML的时候，为了在编辑器内写的美观，常常会使用回车，而回车在HTML中会被识别为空白符。</p>
<pre><code>比如
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;（空白符）
&lt;<span class="tag">img</span> src = <span class="string">"xxxx"</span> /&gt;
</code></pre></li>
<li><p>第三，空白符具备宽度（和font-size有关），不具备高度。</p>
</li>
</ul>
<p><strong>所以，表面上我们根据设计好的图片进行了</strong>精准<strong>的测量，构造了完全匹配父类宽度的元素和间距，但是实际上却由于空白符所具备的宽度而产生了偏差。</strong></p>
<p>用一张图来表示拥有空白符后的效果：</p>
<pre><code><span class="list">[<span class="keyword">图</span><span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;图<span class="list">(<span class="keyword">空白</span>)</span>&lt;-&gt;
图&lt;-&gt;］</span>
</code></pre><h3 id="为什么float可以解决这个问题">为什么float可以解决这个问题</h3><blockquote>
<p>A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float</p>
</blockquote>
<p>看到这个关于float的定义了吗？<strong>float要么依赖前一个（或者后一个）float元素的边界，要么就依赖于父元素的边界。而一个空白符，既不是包含块（父容器）的边界，也不是另一个float元素，因此不受影响，也不会对其余float元素有影响。</strong></p>
<p>所以，当你对<code>.parent img</code>启用<code>float:left</code>之后，效果就成了下图所示：</p>
<pre><code>[<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>&lt;-&gt;<span class="built_in">float</span>]
[空白符]
</code></pre><p>这次我们测量的宽度正好匹配完全，所以将空白符自然而然的挤到了下一行。还记得我们前面说过空白符不具备高度吗？因此，这个空白符压根没起作用！</p>
<blockquote>
<p>文中的 [] 代表父容器，&lt;-&gt; 代表间隔。</p>
</blockquote>
<h3 id="其余方案">其余方案</h3><ol>
<li>将父容器的<code>font-size</code>设置为<strong>0</strong>。</li>
<li>避免换行，写出<img src=""><img src=""><img src=""><img src=""> 这样的代码。</li>
<li>启用HTML压缩。</li>
</ol>
<p>最后：<strong>感谢美团大神FTR和淘宝大神YWJ对本菜比的指导。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/04/26/blank-space-in-html/" data-id="ck9fy2gf000192ni16fwyi92k" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/04/26/blank-space-in-html/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-dispatch-once" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/dispatch-once/" class="article-date">
  <time datetime="2016-04-10T16:41:09.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/dispatch-once/">滥用单例之dispatch_once死锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="现象">现象</h3><p>上周排查了一个bug，现象很简单，就是个Crash问题。但是读了一下crash Log以后，却发现堆栈报的错误信息却是第一次见到（<strong>吹牛的说，我在国内的iOS也能算第十二人了</strong>），包含以下还未符号化信息：</p>
<pre><code>Application Specific Information:
com.xxx.yyy failed to scene-<span class="operator"><span class="keyword">create</span> <span class="keyword">in</span> <span class="keyword">time</span>

Elapsed total CPU <span class="keyword">time</span> (seconds): hhh秒 (<span class="keyword">user</span> hhh, <span class="keyword">system</span> <span class="number">0.000</span>), <span class="keyword">k</span>% CPU
Elapsed application CPU <span class="keyword">time</span> (seconds): <span class="number">0.</span>h秒, <span class="keyword">k</span>% CPU

<span class="keyword">Thread</span> <span class="number">0</span> <span class="keyword">name</span>:  Dispatch queue: com.apple.<span class="keyword">main</span>-<span class="keyword">thread</span>
<span class="keyword">Thread</span> <span class="number">0</span>:
<span class="number">0</span>   libsystem_kernel.dylib            <span class="number">0x36cb2540</span> semaphore_wait_trap + <span class="number">8</span>
<span class="number">1</span>   libsystem_platform.dylib          <span class="number">0x36d3d430</span> _os_semaphore_wait + <span class="number">8</span>
<span class="number">2</span>   libdispatch.dylib                 <span class="number">0x36be04a6</span> dispatch_once_f + <span class="number">250</span>
<span class="number">3</span>   xxxx                              偏移量 <span class="number">0x4000</span> + <span class="number">947290</span>
...
...</span>
</code></pre><p>无符号化的crash 堆栈暂时不去管它，我们重点关注<strong>com.xxx.yyy failed to scene-create in time</strong>。如果理解无误的话，这句话提示我们：我们的应用程序在规定的时间没能加载成功，无法显示。看起来这个原因是启动加载过长直接被干掉。那么问题来了，原因具体是啥？</p>
<h3 id="查看堆栈">查看堆栈</h3><p>首先我们需要符号化一下，这里涉及公司内部信息，所以我们自己构造个demo试试。<br>demo的代码很简单，如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">"ManageA.h"</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageA</span></span>

+ (ManageA *)sharedInstance
{
    <span class="keyword">static</span> ManageA *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageA alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageB sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ManageB</span></span>

+ (ManageB *)sharedInstance
{
    <span class="keyword">static</span> ManageB *manager = <span class="literal">nil</span>;
    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> token;

    <span class="built_in">dispatch_once</span>(&amp;token, ^{
        manager = [[ManageB alloc] init];
    });

    <span class="keyword">return</span> manager;
}

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [ManageA sharedInstance];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>运行后的堆栈基本如下：</p>
<pre><code><span class="preprocessor">#<span class="number">0</span>    <span class="number">0x000000011054acd2</span> in semaphore_wait_trap ()</span>
<span class="preprocessor">#<span class="number">1</span>    <span class="number">0x00000001101b1b1a</span> in _dispatch_thread_semaphore_wait ()</span>
<span class="preprocessor">#<span class="number">2</span>    <span class="number">0x00000001101b1d48</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">3</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">4</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">5</span>    <span class="number">0x000000010d01cad8</span> in -[ManageB init] at ManageA.m:<span class="number">54</span></span>
<span class="preprocessor">#<span class="number">6</span>    <span class="number">0x000000010d01ca42</span> in __25+[ManageB sharedInstance]_block_invoke at ManageA.m:<span class="number">44</span></span>
<span class="preprocessor">#<span class="number">7</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">8</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">9</span>    <span class="number">0x000000010d01c9e7</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">10</span>    <span class="number">0x000000010d01c9c9</span> in +[ManageB sharedInstance] at ManageA.m:<span class="number">43</span></span>
<span class="preprocessor">#<span class="number">11</span>    <span class="number">0x000000010d01c948</span> in -[ManageA init] at ManageA.m:<span class="number">29</span></span>
<span class="preprocessor">#<span class="number">12</span>    <span class="number">0x000000010d01c8b2</span> in __25+[ManageA sharedInstance]_block_invoke at ManageA.m:<span class="number">19</span></span>
<span class="preprocessor">#<span class="number">13</span>    <span class="number">0x00000001101c649b</span> in _dispatch_client_callout ()</span>
<span class="preprocessor">#<span class="number">14</span>    <span class="number">0x00000001101b1e28</span> in dispatch_once_f ()</span>
<span class="preprocessor">#<span class="number">15</span>    <span class="number">0x000000010d01c857</span> in _dispatch_once [inlined] at once.h:<span class="number">68</span></span>
<span class="preprocessor">#<span class="number">16</span>    <span class="number">0x000000010d01c839</span> in +[ManageA sharedInstance] at /ManageA.m:<span class="number">18</span></span>
<span class="preprocessor">#<span class="number">17</span>    <span class="number">0x000000010d01c5cc</span> in -[AppDelegate application:didFinishLaunchingWithOptions:]         at /AppDelegate.m:<span class="number">21</span></span>
</code></pre><p>从中我们可以发现，的确在这段调用栈中，出现了多次敏感字样<code>sharedInstance</code>和<code>dispatch_once_f</code>字样。</p>
<p>在查阅相关资料后，感觉是<code>dispatch_once_f</code>函数造成了信号量的永久等待，从而引发死锁。那么，为什么<code>dispatch_once</code>会死锁呢？以前说的<strong>最安全的单例构造方式</strong>还正确不正确呢？</p>
<p>所以，我们一起来看看下面关于<code>dispatch_once</code>的源码分析。</p>
<h3 id="dispatch_once源码分析">dispatch_once源码分析</h3><p>从<a href="git://git.macosforge.org/libdispatch.git" target="_blank" rel="external">libdispatch</a>获取最新版本代码，进入对应的文件<strong>once.c</strong>。去除注释后代码如下，共<strong>66</strong>行代码，但是真的是有很多奇妙的地方。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"internal.h"</span></span>

<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once</span>
<span class="preprocessor">#<span class="keyword">undef</span> dispatch_once_f</span>

<span class="keyword">struct</span> _dispatch_once_waiter_s {
    <span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;
    <span class="keyword">_dispatch_thread_semaphore_t</span> dow_sema;
};

<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~<span class="number">0l</span>)</span>

<span class="preprocessor">#<span class="keyword">ifdef</span> __BLOCKS__</span>
<span class="comment">// 1. 我们的应用程序调用的入口</span>
<span class="function"><span class="keyword">void</span>
<span class="title">dispatch_once</span><span class="params">(dispatch_once_t *val, dispatch_block_t block)</span>
</span>{
    <span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;

    <span class="comment">// 2. 内部逻辑</span>
    dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);
}
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="function">DISPATCH_NOINLINE
<span class="keyword">void</span>
<span class="title">dispatch_once_f</span><span class="params">(dispatch_once_t *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span>
</span>{
    <span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval =
            (<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;

    <span class="comment">// 3. 地址类似于简单的哨兵位</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = { <span class="literal">NULL</span>, <span class="number">0</span> };

    <span class="comment">// 4. 在Dispatch_Once的block执行期进入的dispatch_once_t更改请求的链表</span>
    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;

    <span class="comment">// 5.局部变量，用于在遍历链表过程中获取每一个在链表上的更改请求的信号量</span>
    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;

    <span class="comment">// 6. Compare and Swap（用于首次更改请求）</span>
    <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, <span class="literal">NULL</span>, &amp;dow)) {
        dispatch_atomic_acquire_barrier();

        <span class="comment">// 7.调用dispatch_once的block</span>
        _dispatch_client_callout(ctxt, func);

        dispatch_atomic_maximally_synchronizing_barrier();
        <span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span>

        <span class="comment">// 8. 更改请求成为DISPATCH_ONCE_DONE(原子性的操作)</span>
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);
        tail = &amp;dow;

        <span class="comment">// 9. 发现还有更改请求，继续遍历</span>
        <span class="keyword">while</span> (tail != tmp) {

            <span class="comment">// 10. 如果这个时候tmp的next指针还没更新完毕，等一会</span>
            <span class="keyword">while</span> (!tmp-&gt;dow_next) {
                _dispatch_hardware_pause();
            }

            <span class="comment">// 11. 取出当前的信号量，告诉等待者，我这次更改请求完成了，轮到下一个了</span>
            sema = tmp-&gt;dow_sema;
            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 12. 非首次请求，进入这块逻辑块</span>
        dow.dow_sema = _dispatch_get_thread_semaphore();
        <span class="keyword">for</span> (;;) {
            <span class="comment">// 13. 遍历每一个后续请求，如果状态已经是Done，直接进行下一个</span>
            <span class="comment">// 同时该状态检测还用于避免在后续wait之前，信号量已经发出(signal)造成</span>
            <span class="comment">// 的死锁</span>
            tmp = *vval;
            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) {
                <span class="keyword">break</span>;
            }
            dispatch_atomic_store_barrier();
            <span class="comment">// 14. 如果当前dispatch_once执行的block没有结束，那么就将这些</span>
            <span class="comment">// 后续请求添加到链表当中</span>
            <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) {
                dow.dow_next = tmp;
                _dispatch_thread_semaphore_wait(dow.dow_sema);
            }
        }
        _dispatch_put_thread_semaphore(dow.dow_sema);
    }
}
</code></pre><p>根据以上注释对源代码的分析，我们可以大致知道如下几点：</p>
<ol>
<li><code>dispatch_once</code>并不是简单的只执行一次那么简单</li>
<li><code>dispatch_once</code>本质上可以接受多次请求，会对此维护一个请求链表</li>
<li>如果在block执行期间，多次进入调用同类的<code>dispatch_once</code>函数（即单例函数），会导致整体链表无限增长，造成永久性死锁。(<strong>其实只要进入两次就完蛋，其原因在于<code>block_invoke</code>的完成依赖于第二次进入的请求的完成，而第二次请求的完成又必须依赖之前信号量的出发。可是第一次block不结束，信号量压根不会触发</strong>)</li>
</ol>
<h3 id="备注">备注</h3><ol>
<li>根据以上分析，相对应地写了一个简易的死锁Demo，就是在两个单例的初始化调用中直接相互调用。A&lt;-&gt;B。也许这个Demo过于简单，大家轻易不会犯。但是如果是A-&gt;B-&gt;C-&gt;A，甚至是更多个模块的相互引用，那又该如何轻易避免呢？</li>
<li>以上的Demo，如果在Xcode模拟器测试环境下，是不会死锁从而导致应用启动被杀。这是因为模拟器不具备守护进程，如果要观察现象，可以输出Log或者直接利用真机进行测试。</li>
<li>有时候，启动耗时是因为占用了太多的CPU资源。但是从我们的Crash Log中可以发现，我们仅仅占用了<strong>Elapsed application CPU time (seconds): 0.h秒, k% CPU</strong>。通过这个，我们也可以发现，CPU占用率高并不是导致启动阶段APP Crash的唯一原因。</li>
</ol>
<h3 id="反思">反思</h3><p>虽然这次的问题直接原因是<code>dispatch_once</code>引出的<strong>死锁</strong>问题，但是个人认为，这却是滥用单例造成的后果。各位可以打开自己公司的app源代码查看一下，究竟存在着多少的单例。</p>
<p>实话实说，单例和全局变量几乎没有任何区别，不仅仅占用了全生命周期的内存，还对解耦造成了巨大的负作用。写起来容易，但是对于整个项目的架构梳理却是有着巨大的影响，因为在不读完整个相关代码的前提下，你压根不知道究竟哪里会触发单例的调用。</p>
<p>因此在这里，谈谈个人认为可以不使用单例的几个方面：</p>
<ol>
<li>仅仅使用一次的模块，可以不使用单例，<strong>可以采用在对应的周期内维护成员实例变量进行替换</strong>。</li>
<li>和状态无关的模块，<strong>可以采用静态（类）方法直接替换</strong>。</li>
<li>可以通过页面跳转进行依赖注入的模块，<strong>可以采用依赖注入或者变量传递等方式解决</strong>。</li>
</ol>
<p><strong>当然，的确有一些情况我们仍然需要使用单例。那在这种情况，也请将<code>dispatch_once</code>调用的block内减少尽可能多的任务，最好是仅仅负责初始化，剩下的配置、调用等等在后续进行。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/04/11/dispatch-once/" data-id="ck9fy2gei000z2ni1esgpmvax" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/04/11/dispatch-once/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-dispatch-in-swift" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/22/dispatch-in-swift/" class="article-date">
  <time datetime="2016-03-22T09:14:34.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/22/dispatch-in-swift/">Swift 中的静态Dispatch VS 动态Dispatch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="C++_VS_Swift">C++ VS Swift</h3><p>虽然我很早就了解了Swift（2014年的WWDC），但是在粗略看了一下Swift的语法后，我认为这不过是许多语言语法的大杂烩，感觉和C++没有啥区别。但是实际上，在我使用Swift的这几个月中，我发现了许多问题值得注意的地方，比如</p>
<ul>
<li>函数的返回值可以作为推断函数签名的依据。</li>
<li>Swift中的函数静态Dispatch VS 动态函数Dispatch</li>
</ul>
<p>而第二点，也是本文要阐述的重点。</p>
<p>在展开本文的内容前，如果你曾经有C++的开发背景，不妨回忆下C++中RTTI机制，这也是多态发生的先决条件。简单来说，就是C++的多态函数是基于运行时的，我们可以看看下面这个例子：</p>
<pre><code><span class="keyword">class</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm A"</span>;}
}

<span class="keyword">class</span> B: <span class="keyword">public</span> A
{
    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm B"</span>;}
}

A *b = <span class="keyword">new</span> B();
b-&gt;print();
</code></pre><p>相信大家一眼就能知道这个答案，会输出<code>I&#39;m B</code>。那么，Swift中也存在<code>class</code>，那么对于Swift中的函数调用是否和C++一致呢？</p>
<h3 id="Swift_Class">Swift Class</h3><p>首先我们先来验证下最基本的<code>class</code>中的行为。我们采用和C++中相同例子，定义如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>根据Swift的<code>Type Inference</code> 我们分别验证了如下几种调用方式：</p>
<pre><code>let b1:B = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let b2:A = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a1:A = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let a2 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b3 = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b3.<span class="function"><span class="title">printInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>如果你自己的思考结果和这个一模一样，至少你理解了运行期和编译期的概念，恭喜你，你的C++是过关了。以<code>class B</code>举例，无论是<strong>b1, b2, b3中的哪一个，尽管其中有部分声明的类型是A，但是在实际运行时还是会走类似virtual function那套确认实际类型为B</strong>。但是，事情在Swift中真是这么简单吗？让我们接着往下看。 </p>
<h3 id="Protocol_Extension">Protocol Extension</h3><p>去年，<strong>Swift 2.0</strong>发布，随之而来，一个概念悄然兴起：面向协议的编程。而这种编程范式不可或缺的必要条件就是<strong>Protocol Extension</strong>。在<code>Swift &lt; 2.0</code> 时代，<code>Protocol</code>的作用更类似于一种表征特征的约束。而有了<code>Protocol Extension</code>以后，<code>Protocol</code>更类似于一种插件装配的概念（写过Ruby的人相信会有体会），可以在无须编写代码的情况下，更自定义的元素添加行为能力。</p>
<p>哎？你上面说了这么一大段废话，和我们的文章主题有啥关系？</p>
<p>好，首先我们先看如下定义：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span> {
        <span class="built_in">print</span>(<span class="string">"I'm B"</span>)
    }
}
</code></pre><p>然后，我们进行如下调用：</p>
<pre><code>let a1 = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b1 = <span class="function"><span class="title">B</span><span class="params">()</span></span>     
b1.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>

let a2:Testable = <span class="function"><span class="title">A</span><span class="params">()</span></span>
a2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm A</span>

let b2:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
b2.<span class="function"><span class="title">dynamicInfo</span><span class="params">()</span></span> <span class="comment">// I'm B</span>
</code></pre><p>到这里，事情还是还是按照C++那套逻辑在走，如果你把<code>class B</code>中的<code>dynamicInfo</code>删除，那么对应B类型的<code>dynamicInfo</code>函数调用就会输出<strong>I’m Testable</strong>。</p>
<p>好，现在问题来了，如果我们将<code>Testable Protocol Extension</code>添加一下东西，同时保持<code>protocol Testable</code>不变，如下所示：</p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
}

<span class="class"><span class="keyword">extension</span> <span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable"</span>)
    }

    <span class="comment">// ### 新添加的 ###</span>
    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm Testable Static"</span>)
    }
}
</code></pre><p>如果这个时候，我们进行如下代码的测试：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">Testable</span>
</span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dynamicInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A"</span>)
    }

    <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm A Static"</span>)
    }
}

<span class="keyword">let</span> a1 = <span class="type">A</span>()     
a1.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a2:<span class="type">A</span> = <span class="type">A</span>()
a2.staticInfo() <span class="comment">// I'm A Static</span>

<span class="keyword">let</span> a3:<span class="type">Testable</span> = <span class="type">A</span>()
a3.staticInfo() <span class="comment">// I'm Testable Static</span>
</code></pre><p>看到没？最后一行的输出是不是出乎了大家的意料，竟然输出了<strong>I’m Testable Static</strong>。 </p>
<p>这是咋回事？回顾下之前我们改变的地方，发现我们在<strong>Protocol Extension中添加了一个<code>func staticInfo()</code>，但是却没在对应的<code>Testable Protocol</code>进行声明</strong>。但是这还不够，我们必须将调用<code>staticInfo</code>的地方的类型显式的声明成<strong>let a3:Testable</strong>。</p>
<p><div style="color:red">也就是说，Swift方法的静态Dispatch必须严格满足如下条件：</div>  </p>
<ul>
<li>方法在Extension中提供了实现，但是在对应的protocol中没有声明。</li>
<li>调用方法的时候必须显示的声明成protocol的类型。</li>
</ul>
<p>如果不好理解，我画了张图帮助大家加深印象：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/Slice%201.png" alt=""></p>
<p><strong>还有一点需要注意的是，Swift中的静态Dispatch不以类的层级和override而转移</strong>，也就是说，如下这种定义：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>
</span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">staticInfo</span><span class="params">()</span></span>
    {
        <span class="built_in">print</span>(<span class="string">"I'm B Static"</span>)
    }
}
</code></pre><p>当我们使用  </p>
<pre><code>let a4:Testable = <span class="function"><span class="title">B</span><span class="params">()</span></span>
a4.<span class="function"><span class="title">staticInfo</span><span class="params">()</span></span>
</code></pre><p>一样会输出<code>I&#39;m Testable Static</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/03/22/dispatch-in-swift/" data-id="ck9fy2gem00112ni1ypu2r0e3" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/03/22/dispatch-in-swift/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-RxSwift" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/RxSwift/" class="article-date">
  <time datetime="2016-03-13T16:21:50.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/RxSwift/">RxSwift的第一印象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>声明：本文由本人独立翻译完成，同步发表在稀土掘金</strong></p>
<p>去年整整一年，我都在试图理解响应式编程的原理是什么，并且试图验证如果在我的app中使用这种编程范式是否会带来好处。于是，我查询了许多相关的解决方案，从<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> &amp; Objective-C开始，及其Swift版本<a href="https://blog.alltheflow.com/reactive-swift-upgrading-to-reactivecocoa-3-0/" target="_blank" rel="external">ReactiveCocoa with Swift</a>，再到我朋友实现的一个轻量级的框架<a href="https://github.com/bvic23/VinceRP" target="_blank" rel="external">VinceRP</a>。上述这些都是令人赞叹不已的项目，ReactiveCocoa的项目成熟度非常高，但是十分复杂；而VinceRP的实现非常容易，所以理解起来非常简单。</p>
<p>在学习的过程中，我写了一系列关于<a href="https://blog.alltheflow.com/tag/reactive" target="_blank" rel="external">我学习响应式编程的经历</a>的文章，所以经常会被读者问到一些关于<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>的问题。惭愧地说，我还从没有使用RxSwift来编写一个项目。实际上我还从来没用过任何语言的<a href="http://reactivex.io/languages.html" target="_blank" rel="external">Rx</a>框架，所以我一直认为，对于那些曾在别的开发环境中有使用Rx经历的人来说，理解RxSwift是非常容易的。既然如此，我也是时候来尝试一把了。</p>
<h2 id="Rx">Rx</h2><p>Rx是最常使用的一个响应式编程框架。它与其他RP框架的一大不同是它的跨平台特性，同时，它有着最大的开源社区，无数的文档以及有参考价值的问题讨论，许许多多的人不断地对其进行改进。</p>
<h2 id="Swift">Swift</h2><p>这门语言在去年一年中飞速的成长，并且现在也进行了<a href="https://github.com/apple/swift" target="_blank" rel="external">开源</a>了。一些像RxSwift之类的项目也随着其一起成长。因此，没有什么理由可以再阻止你去使用这些框架。当然，一些重大的改动仍然被列在radar上，但它们很可能在短时间内不会被解决，这就意味着这个项目会不断地被改进，这不是很好吗？</p>
<h2 id="使用RxSwift开发一个app">使用RxSwift开发一个app</h2><p>如果你从未阅读过<a href="https://blog.alltheflow.com" target="_blank" rel="external">我的博客</a>，可能你现在会猜我使用RxSwift开发了一个app。没错，你是对的。这是个很耗时的习惯，但是我不喜欢依赖于一个理想的环境，所以通常我都会写一个例子来让我有那么一点感觉。通过这种方式，我可以学会如何让成功得运行这个框架。（意译：这里我想说一点个人感受，对于解决问题来说，你所选用的框架只是万千可用方案中的一种，因此，方案的选择是因人而异的。而这些选择所带来的多样性，正是我如此热爱编程的一大原因。）</p>
<p>我所写的这个应用名叫<a href="https://github.com/alltheflow/iCopyPasta" target="_blank" rel="external">iCopyPasta</a>，是一个在去年<a href="http://2015.funswiftconf.com/" target="_blank" rel="external">Functional Swift Conf</a>上展示的免费Mac剪贴板应用<a href="https://github.com/alltheflow/copypasta" target="_blank" rel="external">CopyPasta</a>的iOS姐妹版。显而易见，它们并不是一个完整的产品所以并不可以被用来上架。我现在每天都使用Mac版本的CopyPasta，但是我可能存在某些偏见。我的计划是将来会发布Mac版本和iOS版本的CopyPasta应用，并可能会将这两个版本进行打通。</p>
<blockquote>
<p>难道这不是我一直以来的计划吗？  </p>
</blockquote>
<h3 id="Observables">Observables</h3><p>我首先对<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPasteboard_Class/index.html" target="_blank" rel="external"><code>UIPasteboard</code></a>注册了观察者。 这些观察者会对你拷贝东西时出现在<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>类型进行观察。</p>
<pre><code><span class="keyword">let</span> pasteboard = <span class="type">NSNotificationCenter</span>.defaultCenter().rx_notification(<span class="string">"UIPasteboardChangedNotification"</span>, object: <span class="literal">nil</span>)
<span class="number">_</span> = pasteboard.<span class="built_in">map</span> { [<span class="keyword">weak</span> <span class="keyword">self</span>] (notification: <span class="type">NSNotification</span>) -&gt; <span class="type">PasteboardItem</span>? <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> pb = notification.object <span class="keyword">as</span>? <span class="type">UIPasteboard</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> string = pb.valueForPasteboardType(kUTTypeUTF8PlainText <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(string)
        }
        <span class="keyword">if</span> <span class="keyword">let</span> image = pb.valueForPasteboardType(kUTTypeImage <span class="keyword">as</span> <span class="type">String</span>) {
            <span class="keyword">return</span> <span class="keyword">self</span>?.pasteboardItem(image)
        }
    }
    <span class="keyword">return</span> <span class="literal">nil</span>
}
</code></pre><p>之前我的方法是直接对<code>UIPasteboard</code>中的<code>字符串</code>和<code>图像</code>直接进行观察，但是这个方法是不正确的。原因在于<code>UIPasteboard</code>可能不是一个KVO安全的类型（具体请看下方的评论）。参考别人的建议后，我使用RxSwift另一个非常棒的功能<a href="https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxCocoa/Common/Observables/NSNotificationCenter%2BRx.swift#L23" target="_blank" rel="external"><code>rx_notification</code></a>来监听<code>UIPasteboardChangedNotification</code></p>
<pre><code>.subscribeNext { [<span class="keyword">weak</span> <span class="keyword">self</span>] pasteboardItem <span class="keyword">in</span>
    <span class="keyword">if</span> <span class="keyword">let</span> item = pasteboardItem {
        <span class="keyword">self</span>?.addPasteboardItem(item)
    }
}
</code></pre><p>这里的<code>pasteboard</code>是一个<code>Observable&lt;NSNotification&gt;</code>，这也是为什么可以很容易得订阅其<code>.Next</code>事件同时相应地去更新<code>tableView</code>。而<code>map</code>则是从监听到的通知所涉及的对象中获取字符串或者图像，并将获取到的结果转换成<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>。</p>
<h3 id="Dispose_bags">Dispose bags</h3><p>订阅信号会产生<code>Disposable</code>。如果不终止订阅，那么这些生成的<code>Disposable</code>将会一直存在，这无疑是非常耗内存的。所以，你要么对这些订阅调用<code>dispose</code>，要么你可以像我一样，使用<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#dispose-bags" target="_blank" rel="external">dispose bags</a>来自动销毁相关的订阅。</p>
<pre><code>.<span class="function"><span class="title">addDisposableTo</span><span class="params">(disposeBag)</span></span>
</code></pre><h3 id="UIKit/Appkit_bindings">UIKit/Appkit bindings</h3><p>你可以很容易地通过<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L46" target="_blank" rel="external"><code>rx_itemsWithCellIdentifier</code></a>将<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences" target="_blank" rel="external"><code>Observable</code></a>序列绑定到table view上。<code>element</code>来自于我定义的<a href="https://github.com/alltheflow/iCopyPasta/blob/master/iCopyPasta/PasteboardItem.swift#L41" target="_blank" rel="external"><code>PasteboardItem</code></a>枚举类型，这也是为什么我会采用Switch来处理这个对象，这样可以根据其具体的枚举值来显示不同的样式。</p>
<pre><code>pasteViewModel.pasteboardItems()
    .bindTo(tableView.rx_itemsWithCellIdentifier(<span class="string">"pasteCell"</span>, cellType: UITableViewCell.self)) { (row, element, cell) <span class="keyword">in</span>
     <span class="keyword">switch</span> element {
     <span class="keyword">case</span> .Text(let <span class="keyword">string</span>):
         cell.textLabel?.<span class="keyword">text</span> = String(<span class="keyword">string</span>)
     <span class="keyword">case</span> .Image(let <span class="keyword">image</span>):
         cell.imageView?.<span class="keyword">image</span> = <span class="keyword">image</span>
}.addDisposableTo(disposeBag)
</code></pre><p>另外一个很棒的补充是<a href="https://github.com/ReactiveX/RxSwift/blob/b00d35a5ef13dbcf57257f47fb14a60a2c924d19/RxCocoa/iOS/UITableView%2BRx.swift#L204" target="_blank" rel="external"><code>rx_modelSelected</code></a>。你可以通过它来获取你触发选择事件时对应的<code>element</code>。简单来说，它是一个对<code>tableView:didSelectRowAtIndexPath:</code>的封装，可以将代码变得非常简洁。</p>
<pre><code><span class="tag">tableView</span>
    <span class="class">.rx_modelSelected</span>(PasteboardItem)
    <span class="class">.subscribeNext</span> { <span class="attr_selector">[weak self]</span> <span class="tag">element</span> <span class="tag">in</span>
        <span class="tag">self</span>?<span class="class">.pasteViewModel</span><span class="class">.addItemsToPasteboard</span>(element)
    }<span class="class">.addDisposableTo</span>(disposeBag)
</code></pre><p>你可以通过如下链接来查看所以关于UIKit/AppKit（RxCocoa）的扩展<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md#rxcocoa-extensions" target="_blank" rel="external">RxSwift’s GitHub</a>。</p>
<h2 id="总体感受">总体感受</h2><p>到目前为止，我还只是探索了RxSwift能力的一小部分，但是我已经感受到RxSwift是一个非常棒的框架。如果能够更深入理解它的机制并学会基于它的设计思路进行思考，那肯定会更好。</p>
<p>我非常喜欢一些像<a href="https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground" target="_blank" rel="external">Rx.playground</a>，<a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>这样的资料及<a href="https://github.com/ReactiveX" target="_blank" rel="external">great community</a>这样的社区。这些资料给了我很多的灵感，所以我也乐于将我的学习经验分享给<a href="http://bitrise.io" target="_blank" rel="external">bitrise.io</a>的用户。还有一些比较重要的内容，比如<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md#custom-schedulers" target="_blank" rel="external">schedulers</a>还未被涉及，但是绝对值得研究一番。</p>
<p>对我来说，我还需要一段时间来更好地理解Rx。与我尝试ReactiveCocoa只有个把小时不同，我现在可以每天都在工作中使用RxSwift，并且坚持使用超过了一年。这都得感谢<a href="https://twitter.com/bvic23" target="_blank" rel="external">在Prezi的伙伴们</a>.</p>
<p>作为一个曾经学习过ReactiveCocoa的人来说，我现在更倾向于使用RxSwift，可能是因为我现在自认为已经对于RxSwift已经足够了解，并且使用它可以很快得完成我的编码任务。当然，在将来我可能会同时使用两者，但是我认为对于两者之间任一框架的熟练使用不代表会在学习另外一个框架的时候给你带来很大的优势。它们在几个方面有着<a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons/32581824#32581824" target="_blank" rel="external">不同</a>。同时，这两个框架（概括来说应该是所有的响应式编程框架）都有着陡峭的学习曲线。对于我来说，我已经度过了学习ReactiveCocoa最难的那段时光，但如果你是一个初学者，我建议你自己动手尝试这两种框架，甚至更多。</p>
<h2 id="深入阅读">深入阅读</h2><p>如果你还在思考应该使用哪个响应式编程的框架，那么我建议你去读一读Ash Furrow所写的关于如何挑选响应式编程框架的<a href="https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/" target="_blank" rel="external">文章</a>。</p>
<p>你也可以看看其他一些在iOS中使用响应式编程的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6" target="_blank" rel="external">视频及文章</a>，这些内容都非常得棒，相信你会受益匪浅。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/03/14/RxSwift/" data-id="ck9fy2gg800292ni1mj8dwcoo" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/03/14/RxSwift/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-SizeUp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/SizeUp/" class="article-date">
  <time datetime="2016-03-13T16:20:57.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/SizeUp/">逆向工程SizeUp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天把《汇编语言》好好复习一遍，心里痒痒，就想找个软件来逆向破解一发。破啥好呢？网上逆向工程的教程一大堆，主要都是<em>Sketch</em>啦，<em>Reveal</em>啦，那我照着做一遍也没啥意思啊，体现不出我中国iOS第12人的特点啊。干脆我找个小众一点的软件破解吧。于是，我就盯上了我每天都非常喜欢使用的<strong>SizeUp</strong>，这是一款非常快速的窗口管理软件，可以通过快捷键将窗口扩展到指定的大小和位置，配合外接显示屏简直酷炫到飞起。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-09%20%E4%B8%8B%E5%8D%8810.46.45.png" alt=""></p>
<p>但是这个App有个很大的问题，虽然它是免费的，但是它每次启动的时候，包括你使用的过程中，都会时不时蹦出一个提示你购买的弹框，而且弹框上的取消按钮一定要过5秒才能点击关闭，真是让人蛋疼。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.22.04.png" alt=""></p>
<p>所以，我就讲逆向的目标定在了将这个<strong>可恶的</strong>弹窗给干掉。</p>
<h4 id="准备工作">准备工作</h4><p>首先破解必须要准备的就是逆向工具了，由于这是个Mac app，所以我们无需使用到iPhone。所以，我简单的将SizeUp进行了一次备份就开始了。</p>
<p>逆向一个app，我们当然要去分析其汇编代码，因此必不可少的工具就是IDA或者<strong>Hopper</strong>。在这里，请允许我个人强烈推荐Hopper，那傻瓜式的操作，非常适合我这种高智商人才，哇哈哈。Hopper也是支持免费的，但是免费版不能重新生成可执行文件，所以我先从网上下载了一个破解版的Hopper。</p>
<h4 id="逆向开始">逆向开始</h4><p>首先我们将SizeUp拖入Hopper，得到一系列的汇编代码。这么多的代码我们从哪里下手呢? 答案是<strong>关键字</strong>。在弹窗提示我们购买的界面中，出现了很多关键字，比如<code>license</code>抑或是<code>demo</code>。首先让我们从license开始尝试。我们在Hopper界面左上侧的搜索框中输入license，会得到如下结果：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.09.png" alt=""></p>
<p>从结果来看，我们大致猜测SizeUp的逻辑如下：</p>
<ol>
<li>初始化程序</li>
<li>检查存储的license</li>
<li>（如果有）多个，检查最好的一个（可能是有效期最长的）</li>
<li>和服务器进行验证</li>
</ol>
<p>上述这段逻辑主要来自于高亮的<code>+[License xxx]</code>函数调用。</p>
<p>从上述这段逻辑，我们可以看出，想要伪造license是不可能的了，这是因为牵涉了服务器验证。所以我们只能把想法转变成，干掉本地相关的逻辑。本地逻辑不外乎判断某种分支条件，根据结果进行某些页面的跳转，<strong>比如弹出Demo界面</strong>。</p>
<p>好，现在我们来试试<strong>Demo</strong>关键字，搜索结果如下：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.24.28.png" alt=""></p>
<p>从这个关键字的搜索结果来看，我们得到了不少有价值的信息，比如<strong>DemoDialogController</strong>。哈哈哈哈，苹果经典的MVC设计模式这时候起了很大的作用，搞过开发的人一般都会知道Controller一般对应的就是一个ViewController。如果你不信，我们继续往下看，可以看到一个<code>-[DemoDialogController showDemoDialog]</code>，这个提示够明显了吧，这分明就是说：老子就是那个界面，你快来把我干掉吧。</p>
<p>好，大功告成一半了，我们已经找到了我们要干掉的界面，现在我们只要干掉分支判断逻辑就好了。于是，我们继续跟着Demo关键字走，不久，我们发现了<code>+[License isDemo]</code>这个嫌疑犯。卧槽，这时候，我这天赋异禀的大脑中形成了这样一段代码：</p>
<pre><code><span class="tag">if</span> ([License isDemo]) {
    <span class="attr_selector">[[[DemoDialogController alloc]</span> <span class="tag">init</span>] <span class="tag">showDemoDialog</span>]
} <span class="tag">else</span> {
    <span class="comment">// Follow your heart</span>
}
</code></pre><p>是不是和我猜测的一样呢？</p>
<p>去掉前面的函数压栈，我们来着重看看这段代码：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-13%20%E4%B8%8B%E5%8D%8811.51.30.png" alt=""></p>
<pre><code><span class="keyword">mov</span> <span class="literal">edx</span>, <span class="number">0x1</span>
<span class="keyword">test</span> <span class="literal">al</span>, <span class="literal">al</span>
<span class="keyword">je</span> <span class="number">0x1000008bd9</span>
....
....
<span class="keyword">mov</span> <span class="literal">eax</span>, <span class="literal">edx</span>
</code></pre><p>这段代码不熟悉汇编的人可能不太懂，我将其转换一下。</p>
<pre><code>edx = <span class="literal">true</span>(YES)
<span class="keyword">if</span> al == <span class="number">0</span>
{
    <span class="keyword">goto</span> <span class="number">0x1000008bd9</span>
}

... <span class="number">0x1000008bd9</span>:
val = edx(<span class="literal">true</span>)
<span class="keyword">return</span> val
</code></pre><p>理解了吧，就是首先将0x1（即YES）放入<code>edx</code>寄存器，然后判断<code>al</code>代表的某种分支条件是不是0，如果是0，通过<code>je</code>命令跳转到<code>0x1000008bd9</code>地址。这个地址后面的指令就是讲<code>edx</code>的值塞入<code>eax</code>中，而<code>eax</code>是<strong>x86指令集中默认存放函数返回值的寄存器</strong>。</p>
<p>事情到这，是不是基本理清思路了？我们只需要将je跳转的条件极其后面语句干掉就好了。我在这里采用了更暴力的做法，直接在函数一开始就讲false塞入<code>eax</code>寄存器，然后直接调用<code>ret</code>进行返回。</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-14%20%E4%B8%8A%E5%8D%8812.00.45.png" alt=""></p>
<h4 id="结语">结语</h4><p>是不是逆向工程看起来也没那么难呢？其实，SizeUp这种利用函数返回至做文章的逆向是最简单的，下次我们来挑战下更难的逆向目标！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/03/14/SizeUp/" data-id="ck9fy2gfz00202ni13dmq7sy1" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/03/14/SizeUp/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-DXXcodeConsoleUnicodePlugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/DXXcodeConsoleUnicodePlugin/" class="article-date">
  <time datetime="2016-03-13T16:18:52.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/DXXcodeConsoleUnicodePlugin/">DXXcodeConsoleUnicodePlugin源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Xcode插件开发">Xcode插件开发</h4><p>嘿嘿，今天带大家学习一下基于Xcode的插件开发。可能很多人一听到插件开发，想到的都是Sublime Text，Atom这样轻量级的编辑器的扩展插件，但是实际上，无论是VisualStudio, Eclipse以及Xcode这样重量级的IDE，都是支持自定义的插件开发的。学习好了Xcode的插件开发，不仅可以打造度身定做的<strong>神器</strong>，也有助于你将来进行<strong>Mac OS</strong>的应用开发。</p>
<h4 id="DXXcodeConsoleUnicodePlugin">DXXcodeConsoleUnicodePlugin</h4><p>DXXcodeConsoleUnicodePlugin是一个帮助你自动将<code>\u6061</code>这样的unicode码转换成对应的汉字的插件。</p>
<p>这个有什么用呢？想想看，我们在网络传输的时候，服务器如果返回的数据是中文（<strong>或者非ASCII码</strong>），通过NSLog在console输出的内容是不直观的，基本都是类似<code>\u6061</code>这种，这对于我们开发调试来说是非常困难的。</p>
<p>因此，这款插件可以自动帮助我们将检测到的Unicode字符进行转换，直接输出成我们想要的对应内容。怎么样？让我们赶快来一探究竟吧！</p>
<p><strong> 在开始探讨实现之前，我个人首先强调一点，基于Unicode检测对应的字符是一个非常难的问题。不仅仅是中文，韩文、日文、big-5字符等等都属于Unicode，这些字符集之间好常常有交集。现有比较好的开源实现是</strong>Mozilla的UcharSet**。</p>
<h4 id="实现">实现</h4><p>首先打开工程，文件结构如下：</p>
<ul>
<li>DXXcodeConsoleUnicodePlugin.h/.m</li>
<li>RegExCategories.h/.m</li>
</ul>
<p>其中，<code>DXXcodeConsoleUnicodePlugin</code>是入口。同传统的iOS/Mac OS开发不同，插件开发并不存在传统意义上的main函数，更多的是利用所谓的<code>Template Method</code>设计模式将你需要的自定义部分进行复写。</p>
<p>于是，我们可以看到如下三段函数：</p>
<pre><code>+ (<span class="keyword">void</span>)pluginDidLoad:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
  <span class="built_in">NSString</span> *currentApplicationName = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleName"</span>];
  <span class="keyword">if</span> ([currentApplicationName isEqual:<span class="string">@"Xcode"</span>]) {
    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
      sharedPlugin = [[<span class="keyword">self</span> alloc] initWithBundle:plugin];

      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
                                               selector:<span class="keyword">@selector</span>(menuDidChange)
                                                   name:<span class="built_in">NSMenuDidChangeItemNotification</span>
                                                 object:<span class="literal">nil</span>];
    });
  }
}

- (<span class="keyword">id</span>)initWithBundle:(<span class="built_in">NSBundle</span> *)plugin
{
  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
    <span class="comment">// reference to plugin's bundle, for resource acccess</span>
    <span class="keyword">self</span><span class="variable">.bundle</span> = plugin;

    <span class="comment">// Create menu items, initialize UI, etc.</span>

    <span class="comment">// Sample Menu Item:</span>
    [<span class="keyword">self</span> createMenu];

    I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span> = ReplaceInstanceMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEConsoleItem"</span>), <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:),
                                                                   [XcodeConsoleUnicode_IDEConsoleItem class], <span class="keyword">@selector</span>(initWithAdaptorType:content:kind:));
  }

  <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)createMenu
{
  <span class="built_in">NSMenuItem</span> *menuItem = [[<span class="built_in">NSApp</span> mainMenu] itemWithTitle:<span class="string">@"Edit"</span>];
  <span class="keyword">if</span> (menuItem &amp;&amp; !<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>) {
    [[menuItem submenu] addItem:[<span class="built_in">NSMenuItem</span> separatorItem]];

    <span class="built_in">NSMenuItem</span> *convertItem = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicode"</span> action:<span class="keyword">@selector</span>(convertAction) keyEquivalent:<span class="string">@"c"</span>];
    [convertItem setKeyEquivalentModifierMask:<span class="built_in">NSAlternateKeyMask</span>];
    [convertItem setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:convertItem];

    <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> = [[<span class="built_in">NSMenuItem</span> alloc] initWithTitle:<span class="string">@"ConvertUnicodeInConsole"</span>
                                                           action:<span class="keyword">@selector</span>(convertUnicodeInConsoleAction)
                                                    keyEquivalent:<span class="string">@""</span>];
    [<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span> setTarget:<span class="keyword">self</span>];
    [[menuItem submenu] addItem:<span class="keyword">self</span><span class="variable">.convertInConsoleItem</span>];

    sIsConvertInConsoleEnabled = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:sConvertInConsoleEnableKey];
    <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOnState</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">self</span><span class="variable">.convertInConsoleItem</span><span class="variable">.state</span> = <span class="built_in">NSOffState</span>;
    }
  }
}
</code></pre><p>上面三段函数我们一一进行解析。</p>
<ol>
<li><p><code>pluginDidLoad</code>，大家可以理解为插件的程序入口，在这个入口中我们通过单例进行我们自己开发的插件加载。**之所以使用单例是因为这个<code>pluginDidLoad</code>可能会由于加载多个插件而被多次触发。</p>
</li>
<li><p><code>initWithBundle</code>函数是我们自定义插件的构造函数，我们通过它进行自己任务的创建和调用。</p>
</li>
<li><p><code>createMenu</code>则是对Xcode编辑器上的菜单添加属于我们自己的选项。</p>
</li>
</ol>
<p>在这里，作者在<strong>Edit</strong>菜单下创建了属于自己的<strong>ConvertUnicode</strong>以及<strong>ConvertUnicodeInConsole</strong>，并对这些选项进行了快捷键绑定。</p>
<p>这些东西，除了自定义的菜单项及操作需要我们自己写以外，我们都可以通过<code>Plugin Template</code>这个插件自动生成。</p>
<p>到现在，我们还没有看到任何实质性的转换内容，别急，在<code>initWithBundle</code>中，作者通过<strong>Method Swizzling</strong>将<code>IDEConsoleItem</code>的<code>- (id)initWithAdaptorType:(id)arg1 content:(id)arg2 kind:(int)arg3</code>和自己实现的<code>XcodeConsoleUnicode_IDEConsoleItem</code>进行的调换。</p>
<p>然后在替换后的方法中，实现解析，代码如下：</p>
<pre><code>- (<span class="keyword">id</span>)initWithAdaptorType:(<span class="keyword">id</span>)arg1 content:(<span class="keyword">id</span>)arg2 kind:(<span class="keyword">int</span>)arg3
{
  <span class="keyword">id</span> item = I<span class="built_in">MP_IDEConsoleItem_initWithAdaptorType</span>(<span class="keyword">self</span>, _cmd, arg1, arg2, arg3);

  <span class="keyword">if</span> (sIsConvertInConsoleEnabled) {
    <span class="built_in">NSString</span> *logText = [item valueForKey:<span class="string">@"content"</span>];
    <span class="built_in">NSString</span> *resultText = [DXXcodeConsoleUnicodePlugin convertUnicode:logText];
    [item setValue:resultText forKey:<span class="string">@"content"</span>];
  }

  <span class="keyword">return</span> item;
}
</code></pre><p>这个方法非常简单，通过原方法获取console中的<strong>item</strong>，并获取对应的<strong>content</strong>进行解析。而解析也仅仅是采用了<code>UTF8StringEncoding</code>直接进行转换。</p>
<h4 id="补充知识：NSRegularExpression和正则表达式">补充知识：NSRegularExpression和正则表达式</h4><p>在本文的实现当中，作者对于中文字符的Unicode的表达方式<strong>\u4582</strong>这样的格式，采用了正则表达式进行了提取。在传统的Unicode的格式中，<strong>单独一个<code>\</code></strong>表示为转义字符，不能直接表达一般字符。所以，在正则表达式中，我们需要采用<strong><code>\\</code></strong>来表示一个<code>\</code>。同时，对于4582这样的字符，我们当然可以认为其模式为四个连续的字符，所以我们可以采用<code>\w{4}</code>。（<strong>切记，不能采用<code>\W</code></strong>。大写的<code>\W</code>表征的是非字符。）然后<code>{4}</code>表示前面的模式重复<strong>4次</strong>，即<code>\w</code>连续出现4次。</p>
<p>好了，综上所述，我们不难写出针对中文Unicode提取的正则表达式：<strong><code>\\u\w{4}</code></strong></p>
<p>但是，在作者的代码中，作者的正则表达式却是：<code>\\\\[uU]\\w{4}</code>，那这个是怎么回事呢？<br>原因在于， 对于在字符串形式出现的正则表达式，首先解析的是字符串规则，然后才是正则表达式引擎的解析。</p>
<p>所以，<code>\\\\</code>被字符串解析成<code>\\</code>，然后正则解析成<code>\</code>。然后对于<code>[uU]</code>，是一个组，表示或者u或者U，因为有些输出的文本里，对于U的大小写并没有规定，所以两种情况都需要考虑。</p>
<p>后面的就不再赘述了，原理一致。大家有兴趣的自己深入学习下吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/" data-id="ck9fy2gj0004a2ni19n0dp1cn" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/03/14/DXXcodeConsoleUnicodePlugin/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-check-manifest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/check-manifest/" class="article-date">
  <time datetime="2016-02-27T10:23:21.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/check-manifest/">Check Pods Manifest.lock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>初次看到这个题目的你，可能还不了解这是个啥。但是，我想下面这个错误提示，你肯定会非常熟悉：</p>
<pre><code><span class="keyword">error</span>: The sandbox <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> sync <span class="keyword">with</span> <span class="keyword">the</span>  
Podfile.lock. Run 'pod install' <span class="keyword">or</span> update 
your CocoaPods installation.
</code></pre><p>没错，当我们使用<code>cocoapods</code>的时候，经常会遇到的一个问题。其原因在于我们本地的<code>manifest.lock</code>和通过<code>git</code>同步的<code>Pod.lock</code>的产生了差异。</p>
<p><strong>注：manifest.lock简单可以理解为我们在本地执行一次<code>pod install</code>后生成的当前Podfile的状态的表征文件。而Pod.lock是同步他人更新过Podfile后的状态。</strong></p>
<p>那么，这个差异报错的原因是什么呢？我们可以打开Xcode项目中对应的<code>Target</code>的<code>Build Phase</code>，可以发现，其中存在在一项名为<code>Check Pods Manifest.lock</code>，是一个<code>shell script</code>，内容如下：</p>
<pre><code>// <span class="number">1.</span>
diff <span class="string">"${PODS_ROOT}/../Podfile.lock"</span> <span class="string">"${PODS_ROOT}/Manifest.lock"</span> &gt; /dev/null

// <span class="number">2.</span>
<span class="keyword">if</span> <span class="string">[[ $? != 0 ]]</span> ; <span class="keyword">then</span>

// <span class="number">3.</span>
    cat &lt;&lt; EOM
<span class="built_in">error</span>: The sandbox is <span class="keyword">not</span> <span class="keyword">in</span> sync with the Podfile.lock. Run <span class="string">'pod install'</span> <span class="keyword">or</span> update your CocoaPods installation.
EOM
    exit <span class="number">1</span>
fi
</code></pre><p>我们来解读下这段代码的意思：</p>
<ol>
<li><p>通过diff命令来检查<code>Podfile.lock</code>和<code>Manifest.lock</code>的区别。这个命令中的<code>&gt; /dev/null</code> 可以视为一个<strong>黑洞</strong>，等价于一个只读文件，所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到。由于在执行<code>diff</code>命令的过程中可能产生大量的标准输出，可能会干扰我们的的工作流程执行，所以我们将它们全部丢弃给<strong>黑洞</strong>，只关心<strong>返回值</strong>。</p>
</li>
<li><p><code>if [[ $? != 0 ]] then</code>这个命令指的上一个命令的返回值如果不等于0，就执行xxxx。其中$?也就代表着上一个命令<code>diff</code>的返回值。</p>
</li>
<li><p>好，如果返回值不为0，说明有差异，因此通过<code>cat &lt;&lt; EOM</code> 和 <code>EOM</code>将处于这两者之前的内容输出到标准输出。</p>
</li>
</ol>
<h3 id="改造脚本">改造脚本</h3><p>好，既然我们已经读懂了上述的<code>shell script</code>，我们不如将这个错误的提示来进行整改，当有差异的情况下，自动去进行<code>pod install</code>。</p>
<p>整体改造后的代码如下：</p>
<pre><code><span class="comment">// 1.</span>
diff <span class="string">"<span class="subst">${PODS_ROOT}</span>/../Podfile.lock"</span> <span class="string">"<span class="subst">${PODS_ROOT}</span>/Manifest.lock"</span> &gt; /dev/<span class="keyword">null</span>

<span class="comment">// 2.</span>
<span class="keyword">if</span> [[ $? != <span class="number">0</span> ]] ; then

<span class="comment">// 3.</span>
    pod install --project-directory=<span class="string">"<span class="subst">${PODS_ROOT}</span>/../"</span>
fi
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/02/27/check-manifest/" data-id="ck9fy2gew00162ni1hxfqh85r" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/02/27/check-manifest/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/">shell</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-pod-install-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/pod-install-plugin/" class="article-date">
  <time datetime="2016-02-27T10:23:09.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/pod-install-plugin/">开发一个简单的Pod Install 插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前几天刚刚粗略了学习了一下Xcode的插件开发，一时心痒，就准备做个简单的插件练练手。</p>
<p>哎哟我擦，正当我准备大展身手的时候，我突然想到我该做个啥呢?  我这真是有了程序员，只差一个好Idea了。</p>
<p>好吧，正巧这个时候，我发现我和朋友协作的一个iOS项目在两个分支上同步开发，每次要合并后拉下分支，都发现Pod.lock文件都产生了变化，无法编译成功。每当这个时候，我都要进入<code>terminal</code>输入一大堆的<code>cd ..</code>进入对应的文件目录执行<code>pod install</code>命令，甚是繁琐。</p>
<p>当然啦，你可以通过<code>alias</code> 配置快速的执行命令，但是，你仍然得切换出Xcode的窗口，对于我们这种效率控来说不能接受。</p>
<p>所以，我就想到了，在Xcode中利用插件集成一下关于pod的一些功能，同时绑定快捷键提高操作效率。</p>
<p>说干就干。</p>
<p>首先我们利用Xcode的plugin template生成项目的一些基本流程结构。关于插件的具体思路可以参考我之前的一篇文章《DXXcodeConsoleUnicodePlugin源码解析》</p>
<p>在这里，我们着重介绍一下利用 <code>NSTask</code> 去执行诸如<code>pod install</code>这样的命令。</p>
<h4 id="实现思路">实现思路</h4><p>在实现真正的<code>Objective-C</code>代码之前，我们首先现在<code>terminal</code>中随便找个安全的目录敲入<code>pod install</code>来试试看结果，如下所说：</p>
<pre><code>pod install
[!] <span class="keyword">No</span> <span class="label">`Podfile'</span> found <span class="keyword">in</span> the project directory.
</code></pre><p>从这个错误提示中我们可以大致了解，<code>pod install</code>的命令依赖于所谓的<code>Podfile</code>。于是，我们输入<code>pod install --help</code>查看其对应的帮助手册：</p>
<pre><code>-<span class="ruby">-project-directory=<span class="regexp">/project/dir</span><span class="regexp">/   The path to the root of the project
</span></span>                                       directory
-<span class="ruby"><span class="regexp">-no-clean                          Leave SCM dirs like `.git` and `.svn`
</span></span>                                       intact after downloading
-<span class="ruby"><span class="regexp">-no-integrate                      Skip integration of the Pods libraries
</span></span>                                       in the Xcode project(s)
-<span class="ruby"><span class="regexp">-no-repo-update                    Skip running `pod repo update` before
</span></span>                                       install
-<span class="ruby"><span class="regexp">-silent                            Show nothing
</span></span>-<span class="ruby"><span class="regexp">-verbose                           Show more debugging information
</span></span>-<span class="ruby"><span class="regexp">-no-ansi                           Show output without ANSI codes
</span></span>-<span class="ruby"><span class="regexp">-help                              Show help banner of specified command</span></span>
</code></pre><p>从第一条帮助命令张，我们可以看到，我们需要通过<strong>–project-directory=</strong>来设置<code>pod install</code>的根目录，也即<code>Podfile</code>的所在。</p>
<p>好，事情到这里，我们在编写插件前需要的准备工作就基本完成了，我们现在只需利用<code>NSTask</code>将我们在命令行中输入的命令执行即可。</p>
<p>让我们来看看实现的代码：</p>
<pre><code> <span class="comment">// 1.</span>
 [<span class="keyword">self</span> searchMainProjectPath];

 <span class="comment">// 2.</span>
 <span class="built_in">NSTask</span> *podInstallAction = [[<span class="built_in">NSTask</span> alloc] init];
 podInstallAction<span class="variable">.currentDirectoryPath</span> = <span class="keyword">self</span><span class="variable">.mainProjectPath</span>;
 podInstallAction<span class="variable">.arguments</span> = @[<span class="string">@"install"</span>];
 podInstallAction<span class="variable">.launchPath</span> = <span class="string">@"/usr/bin/pod"</span>;

 <span class="comment">// 3.</span>
 <span class="built_in">NSPipe</span> *pipeOut = [<span class="built_in">NSPipe</span> pipe];
 [podInstallAction setStandardOutput:pipeOut];
 <span class="built_in">NSFileHandle</span> *output = [pipeOut fileHandleForReading];

 [output setReadabilityHandler:^(<span class="built_in">NSFileHandle</span> * _Nonnull fileHandler) {
   <span class="built_in">NSData</span> *data = [fileHandler availableData];
   <span class="built_in">NSString</span> *text = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSASCIIStringEncoding</span>];

   <span class="built_in">NSLog</span>(<span class="string">@"text is %@"</span>, text);
 }];

[podInstallAction launch];
[podInstallAction waitUntilExit];
</code></pre><ol>
<li>我们首先要寻找到当前项目的主目录，也就是<code>Podfile</code>的路径</li>
<li>然后我们构建NSTask，将其的执行目录设置成我们的主目录，然后<code>/usr/bin</code>中调出<code>pod</code>的可执行文件，执行<code>pod install</code>。</li>
<li>我们利用NSPipe将默认的NSTask的输出(stdout)重定向到我们的指定的地方，这样有助于我们查看log或者进行流程工程。</li>
</ol>
<p>到这里，基本上一个简单的小插件就完成了，但是我在这里想要强调一点关于主工程路径搜索的一些问题，我们首先来看代码：</p>
<pre><code><span class="built_in">NSArray</span> *workspaceWindowControllers = [<span class="built_in">NSClassFromString</span>(<span class="string">@"IDEWorkspaceWindowController"</span>) workspaceWindowControllers];
[workspaceWindowControllers enumerateObjectsUsingBlock:^(<span class="keyword">id</span> controller, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) {
  <span class="keyword">if</span> ([[controller valueForKey:<span class="string">@"window"</span>] isMainWindow]) {
    <span class="keyword">id</span> workspace = [controller valueForKey:<span class="string">@"_workspace"</span>];
    <span class="built_in">NSString</span> *filePath = [[workspace valueForKey:<span class="string">@"representingFilePath"</span>] valueForKey:<span class="string">@"pathString"</span>];
    <span class="built_in">NSString</span> *projectName = [[filePath lastPathComponent] stringByDeletingPathExtension];
    <span class="built_in">NSLog</span>(<span class="string">@"CocoaPodUI::ProjectName::%@"</span>, projectName);

    <span class="built_in">NSString</span> *text = [[filePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:<span class="string">@"Podfile"</span>];

    <span class="keyword">self</span><span class="variable">.mainProjectPath</span> = [filePath stringByDeletingLastPathComponent];

    <span class="built_in">NSLog</span>(<span class="string">@"pod ifle is %@"</span>, text);
  }
}];
</code></pre><p><strong>基于Xcode的插件开发实际上利用了大量的私有头文件。由于Objective-C著名的runtime特性，因此，很多时候，我们可以利用key-value-coding的方式获取我们普通途径下无法得到的结果。<br>同时，当有一个类的方法是私有方法的时候，你可以利用一个<code>category</code>声明同样的函数签名，不需要实现，<code>Objective-C</code>的runtime会自动帮你转发对应的<code>message passing</code>。</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/02/27/pod-install-plugin/" data-id="ck9fy2gdk000c2ni1yqc2ki0t" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/02/27/pod-install-plugin/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-FBKVOController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/FBKVOController/" class="article-date">
  <time datetime="2016-02-27T10:21:55.000Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/FBKVOController/">FBKVOController 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开发过iOS的app已经不计其数了，在不同的项目中采用的架构也各不相同，有传统的<strong>MVC</strong>，简化的<strong>VIPER</strong>，以及一些简单的<strong>MVVM</strong>。</p>
<p>这其中，我最不推荐的就是<strong>VIPER</strong>，谁写谁知道，，绝对是增加了项目的复杂性。<strong>MVVM</strong>由于自己总是受限于传统的<code>Object-Oriented</code>的思路，总是想不出真正的Functional Programming的代码，因此，绝大多数情况，写着写着都回归到了<strong>MVC</strong>。</p>
<p>其实，相较于网上大家总喜欢提到的<strong>Massive View Controller</strong>问题，我更想说的是这种传统架构中对于信息流的不友好。</p>
<p>在一个典型的iOS的问题中，我们的代码执行流程，通常都是从View Controller的<strong>生命周期</strong>开始，如果是一个完全基于顺序执行的应用，那整个app的信息流是<strong>单向可跟踪的</strong>。但是往往事情并不会那么简单，我们会包含至少如下这些潜在打乱信息流的<em>坏蛋</em></p>
<ul>
<li>Delegate回调</li>
<li>NSNotification</li>
<li>UIView控件的Target-Action</li>
<li>KVO</li>
</ul>
<p>在这里，你可能会以为我想谈谈<strong>ReactiveCocoa</strong>和<strong>RxSwift</strong>，那你错啦，那个开源项目我暂时还没有能力去深究，所以我想从KVO事件入手，读一读Facebook出品的<strong>FBKVOController</strong>。</p>
<h4 id="FBKVOController">FBKVOController</h4><p>简单来说，FBKVOController是对KVO机制的一层封装，同时提供了线程安全的特性和并对如下这个<strong>臭名昭著</strong>的函数进行了封装，提供了干净的block的回调，避免了处理这个函数的逻辑散落的到处都是。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary *)change <span class="string">context:</span>(<span class="typename">void</span> *)context
</code></pre><h4 id="源码分析">源码分析</h4><p>整个项目的结构非常简单，包含如下四个文件：</p>
<ul>
<li>FBKVOController.h/.m</li>
<li>NSObject+FBKVOController.h/.m</li>
</ul>
<p>其中，<code>NSObject+FBKVOController</code>只是通过<code>AssociateObject</code>给NSObject提供了一个<code>retain</code>及一个<code>非retain</code>型的KVOController。</p>
<p>这两种不同类型的KVOController有啥区别，我们稍后再提，我们将重点投向<code>FBKVOController</code>这个文件。</p>
<p>打开这个<code>FBKVOController.m</code>文件，哎呀，600多行文件，有点蛋疼。没事，配合头文件粗略扫一眼以后，可以发现其中很多方法都是<code>convenience method</code>。</p>
<p>简单剥离一下数据结构以后，我们可以发现，主要的数据结构有如下三个。</p>
<ul>
<li>FBKVOInfo</li>
<li>FBKVOSharedController</li>
<li>FBKVOController</li>
</ul>
<h4 id="FBKVOController-1">FBKVOController</h4><p>既然我们前面通过<code>NSObject+FBKVOController</code>知道了每个对象都会有其对应的<code>FBKVOController</code>，那我们就先来看看这个类吧。</p>
<pre><code><span class="comment">//1.</span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">FBKVOController</span></span>
{
  <span class="built_in">NSMapTable</span> *_objectInfosMap;
  OSSpinLock _lock;
}

<span class="comment">//2.</span>
- (instancetype)initWithObserver:(<span class="keyword">id</span>)observer retainObserved:(<span class="built_in">BOOL</span>)retainObserved
{
  <span class="keyword">self</span> = [<span class="keyword">super</span> init];
  <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) {
    <span class="comment">// 2.</span>
    _observer = observer;

    <span class="comment">// 3.</span>
    <span class="built_in">NSPointerFunctionsOptions</span> keyOptions = retainObserved ? <span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span> : <span class="built_in">NSPointerFunctionsWeakMemory</span>|<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>;
    _objectInfosMap = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:keyOptions valueOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>|<span class="built_in">NSPointerFunctionsObjectPersonality</span> capacity:<span class="number">0</span>];

    <span class="comment">// 4.</span>
    _lock = OS_SPINLOCK_INIT;
  }
  <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><ol>
<li><p>首先我们看到，这个对象持有一个<code>OSSpinLock</code>及一个<code>NSMapTable</code>。其中<code>OSSpinLock</code>即为自旋锁，当多个线程竞争相同的<strong>critical section</strong>时，起到保护作用。<code>NSMapTable</code>可能大家接触不是很多，我们在后文会详细介绍，这里大家可以先理解为一个高级的NSDictionary。</p>
</li>
<li><p>在构造函数中，首先将传入的observer进行<code>weak</code>持有，这主要为了避免<strong>Retain Cycle</strong>。</p>
</li>
<li><p>这一段的内容可能大家不太熟悉，<code>NSPointerFunctionsOptions</code>简单来说就是定义<code>NSMapTable</code>中的key和value采用何种内存管理策略，包括<code>strong</code>强引用，<code>weak</code>弱引用以及<code>copy</code>（要支持NSCopying协议）</p>
</li>
<li><p>初始化自旋锁  </p>
</li>
</ol>
<p>接下来，使我们通过<code>FBKVOController</code>来对一个对象的某个或者某些keypath进行观察。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">keyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)options <span class="string">block:</span>(FBKVONotificationBlock)block
{
  NSAssert(<span class="number">0</span> != keyPath.length &amp;&amp; NULL != block, @<span class="string">"missing required parameters observe:%@ keyPath:%@ block:%p"</span>, object, keyPath, block);
  <span class="keyword">if</span> (nil == object || <span class="number">0</span> == keyPath.length || NULL == block) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// 1. create info</span>
  _FBKVOInfo *info = [[_FBKVOInfo alloc] <span class="string">initWithController:</span>self <span class="string">keyPath:</span>keyPath <span class="string">options:</span>options <span class="string">block:</span>block];

  <span class="comment">// 2. observe object with info</span>
  [self <span class="string">_observe:</span>object <span class="string">info:</span>info];
}
</code></pre><ol>
<li>对于传入的参数，构建一个内部的FBKVOInfo数据结构</li>
<li>调用<code>[self _observe:object info:info];</code></li>
</ol>
<p>接下来，我们来跟踪一下<code>[self _observe:object info:info];</code>，内容如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">_observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="comment">// lock</span>
  OSSpinLockLock(&amp;_lock);

  <span class="comment">// 1.</span>
  NSMutableSet *infos = [_objectInfosMap <span class="string">objectForKey:</span>object];

  <span class="comment">// 2. </span>
  _FBKVOInfo *existingInfo = [infos <span class="string">member:</span>info];
  <span class="keyword">if</span> (nil != existingInfo) {
    NSLog(@<span class="string">"observation info already exists %@"</span>, existingInfo);

    <span class="comment">// unlock and return</span>
    OSSpinLockUnlock(&amp;_lock);
    <span class="keyword">return</span>;
  }

  <span class="comment">// lazilly create set of infos</span>
  <span class="keyword">if</span> (nil == infos) {
    infos = [NSMutableSet set];
    [_objectInfosMap <span class="string">setObject:</span>infos <span class="string">forKey:</span>object];
  }

  <span class="comment">// add info and oberve</span>
  [infos <span class="string">addObject:</span>info];

  <span class="comment">// unlock prior to callout</span>
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 3.</span>
  [[_FBKVOSharedController sharedController] <span class="string">observe:</span>object <span class="string">info:</span>info];
}
</code></pre><p>抛开Facebook自身标记的注释，有三处比较值得我们注意：</p>
<ol>
<li><p>根据被观察的object获取其对应的<strong>infos set</strong>。这个主要作用在于避免多次对同一个keyPath添加多次观察，避免crash。<strong>因为每调用一次<code>addObserverForKeyPath</code>就要有一个对应的<code>removeObserverForKey</code>。</strong></p>
</li>
<li><p>从<strong>infos set</strong>判断是不是已经有了与此次info相同的观察。</p>
</li>
<li><p>如果以上都顺利通过，将观察的信息及关系注册到<code>_FBKVOSharedController</code>中。</p>
</li>
</ol>
<p>至此，FBKVOController的任务基本都结束，<code>unObserve</code>相关的任务逻辑大同小异，不再赘述。</p>
<h4 id="FBKVOSharedController">FBKVOSharedController</h4><p>初次看到这个类的时候，我的脑海中浮现了两个问题，FBKVOSharedController是干嘛的?为什么FBKVOController还需要将观察的信息转交呢？</p>
<p><strong>其实我个人觉得这一层不是必要的</strong>，但是按照Facebook的理念来说就是将所有的观察信息统一交由一个<code>FBKVOSharedController</code>的<strong>单例</strong>进行维护。如果大家读过Facebook出品的<strong>Flux</strong>架构，也会发现，Facebook经常喜欢维护一个类似于中间件的注册表，在这里，<code>FBKVOSharedController</code>承担的也是类似的职责。</p>
<p>于是，通过如下方法，我们像使用注册表一样将对KVOInfo注册。</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">observe:</span>(id)object <span class="string">info:</span>(_FBKVOInfo *)info
{
  <span class="keyword">if</span> (nil == info) {
    <span class="keyword">return</span>;
  }

  <span class="comment">// register info</span>
  OSSpinLockLock(&amp;_lock);
  [_infos <span class="string">addObject:</span>info];
  OSSpinLockUnlock(&amp;_lock);

  <span class="comment">// 1.</span>
  [object <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>info-&gt;_keyPath <span class="string">options:</span>info-&gt;_options <span class="string">context:</span>(<span class="typename">void</span> *)info];
}
</code></pre><ol>
<li>代表所有的观察信息都首先由<code>FBKVOSharedController</code>进行接受，随后进行转发。</li>
</ol>
<p>实现<code>observeValueForKeyPath:ofObject:Change:context</code><br>来接收通知。</p>
<pre><code>- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context
{
  <span class="built_in">NSAssert</span>(context, <span class="string">@"missing context keyPath:%@ object:%@ change:%@"</span>, keyPath, object, change);

  _FBKVOInfo *info;

  {
    <span class="comment">// 1. </span>
    OSSpinLockLock(&amp;_lock);
    info = [_infos member:(__bridge <span class="keyword">id</span>)context];
    OSSpinLockUnlock(&amp;_lock);
  }

  <span class="keyword">if</span> (<span class="literal">nil</span> != info) {

    <span class="comment">// take strong reference to controller</span>
    FBKVOController *controller = info-&gt;_controller;
    <span class="keyword">if</span> (<span class="literal">nil</span> != controller) {

      <span class="comment">// take strong reference to observer</span>
      <span class="keyword">id</span> observer = controller<span class="variable">.observer</span>;
      <span class="keyword">if</span> (<span class="literal">nil</span> != observer) {

        <span class="comment">// dispatch custom block or action, fall back to default action</span>
        <span class="keyword">if</span> (info-&gt;_block) {
          info-&gt;_block(observer, object, change);
        } <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;_action) {
<span class="preprocessor">#pragma clang diagnostic push</span>
<span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span>
          [observer performSelector:info-&gt;_action withObject:change withObject:object];
<span class="preprocessor">#pragma clang diagnostic pop</span>
        } <span class="keyword">else</span> {
          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];
        }
      }
    }
  }
}
</code></pre><ol>
<li>根据context上下文获取对应的KVOInfo</li>
<li>判断当前<code>info</code>的<code>observer</code>和<code>controller</code>，是否仍然存在（因为之前我们采用的weak持有）</li>
<li>根据    <code>info</code>的<code>block</code>或者<code>selector</code>或者<code>override</code>进行消息转发。</li>
</ol>
<p>到这里，<code>FBKVOController</code>整体的实现就介绍完了，怎么样，是不是局部看自己都会实现，但是一结合起完整的设计思路，就觉得，不亏是Facebook呢。</p>
<h3 id="NSMapTable">NSMapTable</h3><p>之前我们在前文中提到了<code>NSMapTable</code>，现在我们来详细介绍他一下。<br>我们在平常的开发中都使用过<code>NSDictionary</code>或者<code>NSMutableDictionary</code>，但是这两种数据结构有其的局限性。</p>
<p>以<code>NSDictionary</code>为例，<code>NSDictionary</code>将<code>key</code>的<code>hash</code>值作为索引，存储对应的<code>value</code>。因此，<code>key</code>的要求是不能更改。所以，<code>NSDictionary</code>为了确保安全，对于<code>key</code>采用了<strong>copy</strong>的策略。</p>
<p>默认情况下，支持<strong>NSCopying</strong>协议的类型都可以作为key。但是考虑到copy带来的开销，一般情况下我们都使用简单的诸如数字或者字符串作为key。</p>
<p>那么，如果要使用<code>Object</code>作为key，想构建<strong>Object to Object</strong>的关系怎么办呢？这个时候就用到<code>NSMapTable</code>。我们可以通过NSFunctionsPointer来分别定义对key和value的储存关系，简单可以分类为<code>strong</code>,<code>weak</code>以及<code>copy</code>。而当利用<code>object</code>作为key的时候，可以定义评判相等的标准，如：<strong>use shifted pointer hash and direct equality, object description或者size</strong>。</p>
<p>具体你需要去override如下几种方法：</p>
<pre><code><span class="comment">// pointer personality functions</span>
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">BOOL</span> (*isEqualFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item1, <span class="keyword">const</span> <span class="keyword">void</span>*item2, <span class="built_in">NSUInteger</span> (* __nullable size)(<span class="keyword">const</span> <span class="keyword">void</span> *item));
<span class="keyword">@property</span> (nullable) <span class="built_in">NSUInteger</span> (*sizeFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
<span class="keyword">@property</span> (nullable) <span class="built_in">NSString</span> * __nullable (*descriptionFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *item);
</code></pre><p>在<code>FBKVOController</code>自定义的可以作为key的结构<code>FBKVOInfo</code>，就复写了</p>
<pre><code>- (<span class="type">NSUInteger</span>)hash
{
  <span class="keyword">return</span> [_keyPath hash];
}

- (<span class="type">BOOL</span>)isEqual:(id)<span class="class"><span class="keyword">object</span>
</span>{
  <span class="keyword">if</span> (nil == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">if</span> (self == <span class="class"><span class="keyword">object</span>) {</span>
    <span class="keyword">return</span> <span class="type">YES</span>;
  }
  <span class="keyword">if</span> (![<span class="class"><span class="keyword">object</span> <span class="title">isKindOfClass</span>:</span>[self <span class="class"><span class="keyword">class</span>]]) {</span>
    <span class="keyword">return</span> <span class="type">NO</span>;
  }
  <span class="keyword">return</span> [_keyPath isEqualToString:((_FBKVOInfo *)<span class="class"><span class="keyword">object</span>)<span class="title">-&gt;_keyPath</span>];</span>
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/02/27/FBKVOController/" data-id="ck9fy2giu00432ni1w57e6nhz" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/02/27/FBKVOController/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-DGRunKeeperSwitch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/05/DGRunKeeperSwitch/" class="article-date">
  <time datetime="2016-02-05T14:35:57.000Z" itemprop="datePublished">2016-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/05/DGRunKeeperSwitch/">DGRunKeeperSwitch 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DGRunKeeperSwitch是非常有趣的自定义的<em>Segment Control</em>的实现，从其Github上的展现效果来看，可以发现在 <em>同一个</em> UILabel中的文本竟然可以展现出两种不同的颜色，是不是很奇妙？今天就让我们来看看它是如何实现的。</p>
<p><img src="https://raw.githubusercontent.com/gontovnik/DGRunkeeperSwitch/master/DGRunkeeperSwitch.gif" alt=""></p>
<h3 id="源码分析">源码分析</h3><p>打开项目，发现这个项目真的很简单，就一个文件，<code>DGRunkeeperSwitch.swift</code>，并且实现也只有接近260行左右。</p>
<p>既然这个项目是个UI的开源库，我们主要还是先从界面层级入手。和<a href="http:glowing.com" target="_blank" rel="external">Glow的开源库(GLCalendar)</a>不同，这个是纯手写的控件，因此无法从<strong>.xib</strong>文件来快速了解，所以我们把目标首先投向相关的UIKit子属性，包括如下：</p>
<pre><code><span class="comment">// 1. </span>
private <span class="tag">var</span> titleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> leftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> rightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 2.</span>
private <span class="tag">var</span> selectedTitleLabelsContentView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedLeftTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>
private <span class="tag">var</span> selectedRightTitleLabel = <span class="function"><span class="title">UILabel</span><span class="params">()</span></span>

<span class="comment">// 3.</span>
<span class="function"><span class="title">private</span><span class="params">(set)</span></span> <span class="tag">var</span> selectedBackgroundView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span> 
private <span class="tag">var</span> titleMaskView: UIView = <span class="function"><span class="title">UIView</span><span class="params">()</span></span>
</code></pre><p>其中第一部分我们一看命名就很容易理解了，有一个<code>ContentView</code>作为<code>container</code>，包含了<code>segment control</code>对应的左右两个Label。</p>
<p>然后来看第二部分，第二部分从命名上也很直观，感觉上和第一部分是一致的，但是却<strong>可能代表的是选中的状态</strong>。不过我们很奇怪，作者为什么要构建一个一模一样的来表征不同的状态呢，直接用一个变量比如 <code>var selected = false</code> 进行样式的控制不可以吗？</p>
<p>好，先别急，这里卖个关子，我们继续往下看。</p>
<p>第三部分，<code>selectedBackgroundView</code>和<code>titleMaskView</code>，从名字看，也不能一下子了解含义，我们先全局搜索下相关连的代码，与<code>titleMaskView</code>相关的内容如下：</p>
<pre><code>titleMaskView<span class="class">.backgroundColor</span> = .<span class="function"><span class="title">blackColor</span><span class="params">()</span></span>
selectedTitleLabelsContentView<span class="class">.layer</span><span class="class">.mask</span> = titleMaskView.layer
</code></pre><p>看起来是用<code>titleMaskView</code>给之前<strong>可能的选中状态的</strong><code>selectedTitleLabelsContentView</code>加了一层遮罩。</p>
<p>由于遮罩是白色的地方不显示，黑色的地方（准确来说是非白色的区域）显示，因此我们可以理解上述代码是通过<code>titleMaskView</code>来显示<code>selectedTitleLabelsContentView</code>中的内容（<strong>也就是两个UILabel</strong>），非<code>titleMaskView</code>区域自动隐藏了。</p>
<pre><code>addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"selectedBackgroundView.frame"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)

<span class="keyword">override</span> public <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> {
    <span class="keyword">if</span> keyPath == <span class="string">"selectedBackgroundView.frame"</span> {
        titleMaskView.frame = selectedBackgroundView.frame
    }
}
</code></pre><p>哦，看完上述这段代码，我开始有点恍然大悟了，通过监听<code>selectedBackgroundView.frame</code>，我们实时改变<code>titleMaskView</code>的<code>frame</code>。而通过实际运行项目，我们可以很容易理解<code>selectedBackgroundView</code>就是用户可拖拽的选项高亮条。</p>
<p>到这，我渐渐有点理解作者为什么要构建两个完全一样的contentView，并都包含左右两个UILabel了。</p>
<p>作者应该是对于<code>titleLabelsContentView</code>设定为普通状态的Label，左右两个Label都是未选中的颜色状态，同时将<code>selectedTitleLabelsContentView</code>设定为选定状态，左右Label都使用了选中时候的颜色状态，然后通过<code>titleMaskView</code>进行遮罩，这样，<code>selectedTitleLabelsContentView</code>其余部分就被隐藏，会显示出下部<code>titleLabelsContentView</code>普通状态的Label颜色。</p>
<p>嘿嘿，读一下剩下的源代码，和我的猜测一致，不得不说，<strong>我真是太聪明了</strong>，这个思路真是太赞了。</p>
<h3 id="如何真正实现一个好的UI库">如何真正实现一个好的UI库</h3><p>看到这个小标题，可能有人会产生疑惑，实现好一个UI库不就是功能正确，效果正常吗？错！</p>
<p>我认为这只是基本的两点，还有如下几点需要包含：</p>
<ul>
<li>使用正确的类型</li>
<li>在正确的函数中做正确的事</li>
<li>暴露不过多也不过少的属性</li>
<li>抛出、监听相对应的事件</li>
<li>根据不同屏幕大小、屏幕方向进行适配</li>
<li>横竖屏情况都能展示良好</li>
</ul>
<ol>
<li><p>第一，从DGRunkeeperSwitch来看，首先由于其模仿的是UISegmentControl，所以自然而然的应该继承与<strong>UIControl</strong>而不是UIView。有人要问有啥区别，简单来说就是<strong>UIControl将UIView中能接受的Touch事件，转换成了更高级的UIEvent，比如UITouchUpInside。</strong></p>
</li>
<li><p>第二，作者通过init函数进行初始化，通过layoutSubview进行页面布局，而不是像很多人自己写代码时将很多东西一窝蜂的堆到了init中。</p>
</li>
<li><p>提供了颜色、字体、边距以及动画弹性等属性给外部调用，同时将不应该暴露的内部UIKit变量进行私有化，并将<code>selectedIndex</code>通过<code>private(set)</code>对外设置为只读。</p>
</li>
<li><p>在切换Segment选择后，抛出了相应的<code>sendActionsForControlEvents(.ValueChanged)</code> 用于给外部监听。</p>
</li>
</ol>
<h3 id="效果之外的重点">效果之外的重点</h3><p>作者在实现这个项目之中，有几点是比较值得注意的：</p>
<h4 id="利用元组同时赋值多个属性">利用元组同时赋值多个属性</h4><pre><code><span class="keyword">public</span> var leftTitle: <span class="keyword">String</span> {
    <span class="built_in">set</span> { (leftTitleLabel.<span class="built_in">text</span>, selectedLeftTitleLabel.<span class="built_in">text</span>) = (newValue, newValue) }
    <span class="built_in">get</span> { <span class="keyword">return</span> leftTitleLabel.<span class="built_in">text</span>! }
}
</code></pre><p>在Swift中引入了一个元组的新类型，我们可以利用这个数据结构同时给多个属性赋值。</p>
<h4 id="private(set)">private(set)</h4><pre><code><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="variable"><span class="keyword">var</span> selectedIndex</span>: <span class="typename">Int</span> = <span class="number">0</span>
</code></pre><p>作者在实现过程中保留了一个<code>selectedIndex</code> 变量，但是这个类对外只读，对内可以读写，因此用了<strong>private(set)</strong>。</p>
<p><strong>这相当于在Objective-C时代，我们在.h文件中声明  <code>@property(nonatomic, strong, readonly) Class *A</code><br>然后又在.m文件中，声明  <code>@property(nonatomic, strong, readwrite) Class *A</code></strong></p>
<h4 id="UIView和CALayer">UIView和CALayer</h4><p>很多人写iOS的时候，分不清UIView和CALayer之间的区别，很多人都理解成了继承的关系。大错特错！</p>
<ul>
<li>实际上UIView里面有个成员变量是CALayer，而CALayer的delegate是UIView(这会涉及到很多的隐式动画之类的，不展开了)</li>
<li>UIView可以接受Touch事件，而Layer不行</li>
<li>UIView有个layerClass的类型方法，可以被复写，用于改变这个UIView对应的基础Layer类型，比如你可以将赋值CAGradientLayer给这个View</li>
</ul>
<p>在本项目中，作者复写了layerClass，如下：</p>
<pre><code><span class="keyword">override</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">layerClass</span>() -&gt; <span class="title">AnyClass</span> </span>{
    <span class="keyword">return</span> DGRunkeeperSwitchRoundedLayer.self
}
</code></pre><p>好啦，今天就差不多到这啦~下周再见。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/" data-id="ck9fy2gj2004c2ni17j9etm6y" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/02/05/DGRunKeeperSwitch/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-PureLayout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/05/PureLayout/" class="article-date">
  <time datetime="2016-02-05T14:33:20.000Z" itemprop="datePublished">2016-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/05/PureLayout/">PureLayout 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开始这篇文章之前，想必大家都应该使用过Autolayout方式的界面布局，相信大家都有过类似于如下这样的API调用：    </p>
<pre><code>[NSLayoutConstraint(item: self.viewA, attribute: .CenterY, relatedBy: .Equal, toItem: self.viewB, attribute: .CenterY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0.0</span>)]
</code></pre><p>抑或是Visual Format Language</p>
<pre><code>NSLayoutConstraint.constraintsWithVisualFormat(<span class="string">"|-(leftPadding)-[imageView(imageViewWidth)]-(rigntPadding)-[labelA]-(4)-[labelB]-(&gt;=44)-|"</span>, <span class="string">options:</span> NSLayoutFormatOptions(<span class="string">rawValue:</span> <span class="number">0</span>), <span class="string">metrics:</span> methics, <span class="string">views:</span> views)
</code></pre><p>这种冗长而又晦涩的代码，真是恶心人啊。因此在Github上涌现了一大堆简化布局的开源库，如SnapKit, Mansory以及今天我们要说的PureLayout。  </p>
<p>在这之中，PureLayout是最轻量级的，它仅仅是对Autolayout现成的语法进行了一层封装，相较于Mansory引入的一些<strong>新概念</strong>，Purelayout更直接易懂。</p>
<h3 id="源码解析">源码解析</h3><p>Purelayout的源码基本没什么难懂的地方，我们首先来看一下其项目结构：</p>
<ul>
<li>PurelayoutDefines.h</li>
<li>ALView + PureLayout.h/.m</li>
<li>NSArray + PureLayout.h/.m</li>
<li>NSLayoutConstraint + Purelayout.h/.m</li>
</ul>
<h4 id="PurelayoutDefines">PurelayoutDefines</h4><p>首先从PurelayoutDefines上入手，这个文件主要是进行一些类似<strong>Domain Specific Language</strong>定义的转化，如：</p>
<pre><code>typedef NS_ENUM(NSInteger, ALEdge) {
    /** The <span class="built_in">left</span> edge of the view. */
    ALEdgeLeft = NSLayoutAttributeLeft,
    /** The <span class="built_in">right</span> edge of the view. */
    ALEdgeRight = NSLayoutAttributeRight,
    /** The top edge of the view. */
    ALEdgeTop = NSLayoutAttributeTop,
    /** The bottom edge of the view. */
    ALEdgeBottom = NSLayoutAttributeBottom,
    /** The leading edge of the view (<span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeLeading = NSLayoutAttributeLeading,
    /** The trailing edge of the view (<span class="built_in">right</span> edge <span class="keyword">for</span> <span class="built_in">left</span>-<span class="keyword">to</span>-<span class="built_in">right</span> languages like English, <span class="built_in">left</span> edge <span class="keyword">for</span> <span class="built_in">right</span>-<span class="keyword">to</span>-<span class="built_in">left</span> languages like Arabic). */
    ALEdgeTrailing = NSLayoutAttributeTrailing
};
</code></pre><p>上述这段代码，就是将传统的UIKit中的NSLayoutAttribute的枚举类型全部转换成对应的PureLayout中的定义，如ALEdgeRight对应到NSLayoutAttributeRight。</p>
<p><strong>LayoutMargins</strong><br>在这里补充一点题外知识，在iOS8中，苹果为Autolayout引入了LayoutMargins这一概念。这个概念乍一听可能都不了解，但是大家回忆下，比如在Storyboard中，我们拖拽一个UIView到ViewController的view并设置边距的时候，上边距和下边距对应的限制都是layout guide，如下图所示：</p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.55.37.png" alt=""></p>
<p><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.23.png" alt=""><br><img src="http://7lrzqz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-26%20%E4%B8%8B%E5%8D%882.56.13.png" alt=""></p>
<p><strong>简单来说，在iOS7上就已经存在了LayoutMargin了，当时的作用是用来限制view的真实内容不会被UINavigationBar（上部）以及UIToolbar（下部）所遮盖</strong>。而从iOS8中开始，苹果将这一技术引入到了任意一个UIView中。</p>
<h4 id="ALView_+_Purelayout">ALView + Purelayout</h4><p><strong>ALView实际上是UIView或者NSView的别名，通过添加ALView的分类，可以通过Define在编译期进行替换，避免为NSView和UIView各创建一份重复的代码</strong>。这个类中的API过多，因此我们以轴对齐为典型的例子来分解下源码：</p>
<ol>
<li>轴对齐<br>在PureLayout中，包括<code>Vertical</code>, <code>Horizontal</code>, <code>Baseline</code>等几种轴对齐方式，其中Baseline指的是View中潜在包含文字的Baseline。</li>
</ol>
<p>好，我们来看看相关的API</p>
<pre><code><span class="comment">/** Aligns an axis of the view to the same axis of another view. */</span>
<span class="tag">-</span> (<span class="tag">NSLayoutConstraint</span> *)<span class="rule"><span class="attribute">autoAlignAxis</span>:<span class="value">(ALAxis)axis toSameAxisOfView:(ALView *)otherView</span></span>;
</code></pre><p>从该API的名称，我们可以直观的感觉出其作用是用于将两个View按照同一个轴对齐。这个API是一个<strong>Convenience Init</strong>，其层层传递</p>
<pre><code>- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView
{
    <span class="keyword">return</span> [self <span class="string">autoAlignAxis:</span>axis <span class="string">toSameAxisOfView:</span>otherView <span class="string">withOffset:</span><span class="number">0.0</span>];
}

- (NSLayoutConstraint *)<span class="string">autoAlignAxis:</span>(ALAxis)axis <span class="string">toSameAxisOfView:</span>(ALView *)otherView <span class="string">withOffset:</span>(CGFloat)offset
{
    <span class="keyword">return</span> [self <span class="string">autoConstrainAttribute:</span>(ALAttribute)axis <span class="string">toAttribute:</span>(ALAttribute)axis <span class="string">ofView:</span>otherView <span class="string">withOffset:</span>offset];
}
</code></pre><p>最后调用了</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoConstrainAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>attribute toAttribute:<span class="params">(<span class="variable">ALAttribute</span>)</span>toAttribute ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView withOffset:<span class="params">(<span class="variable">CGFloat</span>)</span>offset`</span>
</code></pre><p>好，那就让我们来看看这个上述这个函数的实现，如下所示：</p>
<pre><code><span class="comment">//1.</span>
self.translatesAutoresizingMaskIntoConstraints = NO;

<span class="comment">//2.</span>
NSLayoutAttribute layoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>attribute];
NSLayoutAttribute toLayoutAttribute = [NSLayoutConstraint <span class="string">al_layoutAttributeForAttribute:</span>toAttribute];

<span class="comment">//3.</span>
NSLayoutConstraint *constraint = [NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>layoutAttribute <span class="string">relatedBy:</span>relation <span class="string">toItem:</span>otherView <span class="string">attribute:</span>toLayoutAttribute <span class="string">multiplier:</span><span class="number">1.0</span> <span class="string">constant:</span>offset];

<span class="comment">//4.</span>
[constraint autoInstall];
<span class="keyword">return</span> constraint;
</code></pre><ul>
<li>1.首先将translatesAutoresizingMaskIntoConstraints设置为false，对于要使用autolayout的UIView，必须设置为false，也就是不将传统frame布局中的Autoresizing Mask转换成约束。</li>
<li>2.根据传入的<strong>PureLayout属性</strong>转换成对应的NSLayoutAttribute</li>
<li>3.调用冗长恶心的Autolayout API构建约束</li>
<li>4.添加约束</li>
</ul>
<p>在这里，我们需要注意一下这个<code>[constraint autoInstall]</code>，让我们来探一探实现：</p>
<pre><code>- (<span class="keyword">void</span>)autoInstall
{
<span class="comment">// 1. iOS8+</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10</span>
    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(setActive:)]) {
        [<span class="built_in">NSLayoutConstraint</span> al_applyGlobalStateToConstraint:<span class="keyword">self</span>];
        <span class="comment">// 1.1</span>
        <span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_preventAutomaticConstraintInstallation]) {         
            [[<span class="built_in">NSLayoutConstraint</span> al_currentArrayOfCreatedConstraints] addObject:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
        <span class="comment">// 1.2 </span>
            <span class="keyword">self</span><span class="variable">.active</span> = <span class="literal">YES</span>;
        }
        <span class="keyword">return</span>;
    }
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 || __PureLayout_MinBaseSDK_OSX_10_10 */</span>

<span class="comment">// 2. iOS 7</span>
    <span class="built_in">NSAssert</span>(<span class="keyword">self</span><span class="variable">.firstItem</span> || <span class="keyword">self</span><span class="variable">.secondItem</span>, <span class="string">@"Can't install a constraint with nil firstItem and secondItem."</span>);
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.firstItem</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.secondItem</span>) {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]] &amp;&amp; [<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if both items are views."</span>);
            ALView *commonSuperview = [<span class="keyword">self</span><span class="variable">.firstItem</span> al_commonSuperviewWithView:<span class="keyword">self</span><span class="variable">.secondItem</span>];
            [commonSuperview al_addConstraint:<span class="keyword">self</span>];
        } <span class="keyword">else</span> {
            <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.firstItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
            [<span class="keyword">self</span><span class="variable">.firstItem</span> al_addConstraint:<span class="keyword">self</span>];
        }
    } <span class="keyword">else</span> {
        <span class="built_in">NSAssert</span>([<span class="keyword">self</span><span class="variable">.secondItem</span> isKindOfClass:[ALView class]], <span class="string">@"Can only automatically install a constraint if the item is a view."</span>);
        [<span class="keyword">self</span><span class="variable">.secondItem</span> al_addConstraint:<span class="keyword">self</span>];
    }
}
</code></pre><p>整个实现的部分被一分为二，上半部分专门针对iOS8+的，下半部分针对iOS7（<strong>事实上在整个PureLayout的设计中，大部分地方的处理方式都一分为二了</strong>）</p>
<p>我们暂时也不管<code>al_applyGlobalStateToConstraint:self</code> 以及 <code>al_preventAutomaticConstraintInstallation</code>的作用，我们从1.2看起。</p>
<ul>
<li>在iOS8上，启用或者禁用一个AutoLayout的Constraint变得更加容易了，仅仅需要设置active即可</li>
<li>在iOS7上，需要手动的addConstraint或者removeConstraint</li>
<li>在处理iOS7的逻辑当中，需要判断当前这个Constraint是否是针对两个Item的，如果是，找到他们的公共父View，在父View在添加约束，比如添加View A和View B之间的间距；而如果是单一一个View，比如是设置高度或者宽度的，直接在当前View添加即可。</li>
<li>通过调用<code>al_addConstraint</code>进行约束实际的添加。</li>
</ul>
<p>而<strong>al_addConstraint</strong>的实现则如下所示：</p>
<pre><code><span class="attr_selector">[NSLayoutConstraint al_applyGlobalStateToConstraint:constraint]</span>;
<span class="tag">if</span> ([NSLayoutConstraint al_preventAutomaticConstraintInstallation]) {
    <span class="attr_selector">[[NSLayoutConstraint al_currentArrayOfCreatedConstraints]</span> <span class="tag">addObject</span><span class="pseudo">:constraint</span>];
} <span class="tag">else</span> {
    <span class="attr_selector">[self addConstraint:constraint]</span>;
}
</code></pre><p>这里又出现了<code>al_applyGlobalStateToConstraint:constraint</code>以及<code>al_preventAutomaticConstraintInstallation</code>了，这次我们可不能再躲着它了，赶紧瞧一瞧。</p>
<p>首先是<code>al_applyGlobalStateToConstraint:constraint</code>，这个参数对应的是一个全局静态变量，用于判断：</p>
<pre><code><span class="keyword">if</span> ([<span class="built_in">NSLayoutConstraint</span> al_isExecutingPriorityConstraintsBlock]) {
    constraint<span class="variable">.priority</span> = [<span class="built_in">NSLayoutConstraint</span> al_currentGlobalConstraintPriority];
}
</code></pre><p>而这个<code>al_isExecutingPriorityConstraintsBlock</code>则是用于如下这个函数：</p>
<pre><code>+ (void)autoSetPriority:(ALLayoutPriority)priority forConstraints:(ALConstraintsBlock)<span class="keyword">block
</span>{
    NSAssert(<span class="keyword">block, </span><span class="comment">@"The constraints block cannot be nil.");</span>
    <span class="preprocessor">if</span> (<span class="keyword">block) </span>{
        [[<span class="keyword">self </span>al_globalConstraintPriorities] <span class="keyword">addObject:@(priority)];
</span>        <span class="keyword">block();
</span>        [[<span class="keyword">self </span>al_globalConstraintPriorities] removeLastObject]<span class="comment">;</span>
    }
}
</code></pre><p>这里可能大家有点晦涩，主要在于PureLayout对于给Constraint设置Priority定义了一个Block-based的方法，也就是<code>autoSetPriority</code>。在回调的Block中，可以对多个Constraint设置同一个大小的Priority。（<strong>其实我也不是很理解这个集体加Priority设计的目的</strong>）</p>
<p><strong>不过需要有一点可以肯定的是，设置Constraint的Priority的时机一定要在<code>addConstraint</code>或者<code>active = true</code>之前</strong></p>
<p>而对于<code>al_preventAutomaticConstraintInstallation</code>这个变量，作者在API中描述了如下一段话：</p>
<blockquote>Creates all of the constraints in the block, then installs (activates) them all at once.<br> All constraints created from calls to the PureLayout API in the block are returned in a single array.<br> This may be more efficient than installing (activating) each constraint one-by-one.</blockquote>

<p>简而言之，一次性添加所有约束（实际上调用了UIKit的API<code>activateConstraints</code>），比一个个添加要有效率。<strong>然而，Purelayout的这个特性对于iOS7来说，用不上，只能通过<code>addConstraint</code>一个个装，哈哈，么么哒</strong></p>
<h4 id="NSArray_+_Purelayout">NSArray + Purelayout</h4><p>说完了ALView的layout，我们接下来说说另外的NSArray + Purelayout。顾名思义，该分类的主要目的就是给一个NSArray中的所有UIView添加约束。</p>
<p>比如这个API：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoDistributeViewsAlongAxis:<span class="list">(<span class="keyword">ALAxis</span>)</span>axis
                                                           alignedTo:<span class="list">(<span class="keyword">ALAttribute</span>)</span>alignment
                                                    withFixedSpacing:<span class="list">(<span class="keyword">CGFloat</span>)</span>spacing
                                                        insetSpacing:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldSpaceInsets
                                                        matchedSizes:<span class="list">(<span class="keyword">BOOL</span>)</span>shouldMatchSizes</span>
</code></pre><p>其实现如下：</p>
<pre><code><span class="built_in">NSAssert</span>([<span class="keyword">self</span> al_containsMinimumNumberOfViews:<span class="number">1</span>], <span class="string">@"This array must contain at least 1 view to distribute."</span>);

<span class="comment">//1. 第一部分</span>
    ALDimension matchedDimension;
    ALEdge firstEdge, lastEdge;
    <span class="keyword">switch</span> (axis) {
        <span class="keyword">case</span> ALAxisHorizontal:
        <span class="keyword">case</span> ALAxisBaseline: <span class="comment">// same value as ALAxisLastBaseline</span>
<span class="preprocessor">#if __PureLayout_MinBaseSDK_iOS_8_0</span>
        <span class="keyword">case</span> ALAxisFirstBaseline:
<span class="preprocessor">#endif /* __PureLayout_MinBaseSDK_iOS_8_0 */</span>
            matchedDimension = ALDimensionWidth;
            firstEdge = ALEdgeLeading;
            lastEdge = ALEdgeTrailing;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ALAxisVertical:
            matchedDimension = ALDimensionHeight;
            firstEdge = ALEdgeTop;
            lastEdge = ALEdgeBottom;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="built_in">NSAssert</span>(<span class="literal">nil</span>, <span class="string">@"Not a valid ALAxis."</span>);
            <span class="keyword">return</span> <span class="literal">nil</span>;
    }
    <span class="built_in">CGFloat</span> leadingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;
    <span class="built_in">CGFloat</span> trailingSpacing = shouldSpaceInsets ? spacing : <span class="number">0.0</span>;

<span class="comment">//2. 第二部分  </span>
    __<span class="built_in">NSMutableArray_of</span>(<span class="built_in">NSLayoutConstraint</span> *) *constraints = [<span class="built_in">NSMutableArray</span> new];
    ALView *previousView = <span class="literal">nil</span>;
    <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> <span class="keyword">self</span>) {
        <span class="keyword">if</span> ([object isKindOfClass:[ALView class]]) {
            ALView *view = (ALView *)object;
            view<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;
            <span class="keyword">if</span> (previousView) {
                <span class="comment">// Second, Third, ... View</span>
                [constraints addObject:[view autoPinEdge:firstEdge toEdge:lastEdge ofView:previousView withOffset:spacing]];
                <span class="keyword">if</span> (shouldMatchSizes) {
                    [constraints addObject:[view autoMatchDimension:matchedDimension toDimension:matchedDimension ofView:previousView]];
                }
                [constraints addObject:[view al_alignAttribute:alignment toView:previousView forAxis:axis]];
            }
            <span class="keyword">else</span> {
                <span class="comment">// First view</span>
                [constraints addObject:[view autoPinEdgeToSuperviewEdge:firstEdge withInset:leadingSpacing]];
            }
            previousView = view;
        }
    }
    <span class="keyword">if</span> (previousView) {
        <span class="comment">// Last View</span>
        [constraints addObject:[previousView autoPinEdgeToSuperviewEdge:lastEdge withInset:trailingSpacing]];
    }
    <span class="keyword">return</span> constraints;            
</code></pre><ol>
<li>这个API的目的是将一组UIView按照Spacing间距进行均分，同时每个UIView的宽度或者高度保持一致。</li>
<li>第一部分是根据传入的轴，进行判断，是在竖直方向均分还是水平方向均分，同时影响的还有是宽度一致还是高度一致。</li>
<li>第二部分是根据传入的轴（比如水平方向），将前一个View的右边距和后一个View的左边距添加间距，循环添加，直至最后一个View的右边距和父View的右边距添加完成约束。  </li>
</ol>
<p>其他方面，这个分类的作用基本和<code>ALView + PureLayout一致</code>，也就不再重复解释了。<br>至此，PureLayout的源码解析基本上差不多了，其余类似于边对齐的API，如：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSLayoutConstraint</span> *)</span>autoPinEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>edge toEdge:<span class="params">(<span class="variable">ALEdge</span>)</span>toEdge ofView:<span class="params">(<span class="variable">ALView</span> *)</span>otherView;</span>
</code></pre><p>又或者是约束尺寸的，如：</p>
<pre><code>- <span class="list">(<span class="keyword">__NSArray_of</span><span class="list">(<span class="keyword">NSLayoutConstraint</span> <span class="variable">*) *</span>)</span>autoSetDimensionsToSize:<span class="list">(<span class="keyword">CGSize</span>)</span>size<span class="comment">;</span></span>
</code></pre><p>都大同小异，在此就不一一赘述了。</p>
<p>最后，<strong>强调一点</strong>：</p>
<ol>
<li>PureLayout必须在主线程使用，其本身实现非常依赖于静态的全局变量。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2016/02/05/PureLayout/" data-id="ck9fy2gh1002n2ni1i2zxsz7i" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2016/02/05/PureLayout/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Refactor-Mega-ViewController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/30/Refactor-Mega-ViewController/" class="article-date">
  <time datetime="2015-12-29T16:37:56.000Z" itemprop="datePublished">2015-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/30/Refactor-Mega-ViewController/">重构你的ViewController</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章来自阅读<a href="https://realm.io/news/andy-matuschak-refactor-mega-controller/" target="_blank" rel="external">Let’s Play: Refactor the Mega Controller!</a></p>
<p>在该文中，作者阐述了如何使用Swift重构一个臭名昭著的Massive View Controller。从中，我们可以一窥Swift诸多优秀的特性以及如何利用这些特性将ViewController的职责进行解耦。</p>
<p>但是作者由于时间有限，并没有讲述完全，因此本文是我阅读<a href="https://github.com/andymatuschak/refactor-the-mega-controller" target="_blank" rel="external">源码</a>后的理解。</p>
<p><strong>建议大家在阅读本文之前，能够先去看看链接中的视频。</strong></p>
<h3 id="Let’s_get_started">Let’s get started</h3><p>首先我们下载源码，可以看到如下文件：</p>
<pre><code>-<span class="ruby"> <span class="constant">NavigationController</span>.swift
</span>-<span class="ruby"> <span class="constant">ViewController</span>.swift
</span>-<span class="ruby"> <span class="constant">AddViewController</span>.swift</span>
</code></pre><p>其中，<code>ViewController.swift</code>是项目的核心，代码行数超过<strong>246</strong>行。在这里我要强调一下，并不是代码行数多不好，而是要看你这个职责是不是相关。如果246行都是在实现一个数据结构或者算法，当然可行。但是如果246行里面包含了逻辑业务、网络请求、数据持久化，那必然是可以分离一部分职责出去。</p>
<p>在本文的<code>ViewController.swift</code>，这个类在初始状态下包含了<code>UITableViewDataSource</code>, <code>UITableViewDelegate</code>, <code>UIViewControllerTransitioningDelegate</code>, <code>UIViewControllerAnimatedTransitioning</code>, <code>NSFetchedResultsController</code>以及一系类跟UI显示相关的代码。</p>
<h4 id="1-_干掉UINavigationBar相关的内容">1. 干掉UINavigationBar相关的内容</h4><p>作者在app中构建了可变化的NavigationBar，因此bar的样式是根据不同状态进行改变的。原来的逻辑整体写在了<code>ViewController.swift</code>中，如下所示：</p>
<pre><code> func updateNavigationBar() {
        <span class="keyword">switch</span> fetchedResultsController!<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
        <span class="keyword">case</span> <span class="number">0.</span>.<span class="number">.3</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = <span class="literal">nil</span>
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        <span class="keyword">default</span>:
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.barTintColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.titleTextAttributes</span> = [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
            navigationController!<span class="variable">.navigationBar</span><span class="variable">.tintColor</span> = <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }

override func preferredStatusBarStyle() -&gt; <span class="built_in">UIStatusBarStyle</span> {
    <span class="keyword">switch</span> fetchedResultsController?<span class="variable">.fetchedObjects</span>!<span class="variable">.count</span> {
    <span class="keyword">case</span> <span class="variable">.Some</span>(<span class="number">0.</span>.<span class="number">.3</span>), <span class="variable">.None</span>:
        <span class="keyword">return</span> <span class="variable">.Default</span>
    <span class="keyword">case</span> <span class="variable">.Some</span>(_):
        <span class="keyword">return</span> <span class="variable">.LightContent</span>
    }
}
</code></pre><p>同时，还在几个事件回调的地方，如Core Data的<code>controllerDidChange</code>，调用了<code>setNeedsStatusBarAppearanceUpdate()</code>。</p>
<p>这个想法粗略想想并没什么问题，因为我们需要根据一系列的事件变化来改变我们的界面样式，这是很明显的业务逻辑。而我们都很清楚，ViewController就是用来写业务逻辑的地方。</p>
<p>先抛开ViewController是否是应该写业务逻辑的地方这一个有待商榷的论点之外，我们先看看，我们可以如何重构现有代码。</p>
<p><strong>首先</strong>，<code>updateNavigationBar</code>中多个case中的代码有了重复，因此我们可以将其重构成一个函数，接受三个关于样式的参数，如下：</p>
<pre><code>func applyTheme(<span class="string">barTintColor:</span>newBarTintColor, <span class="string">tintColor:</span>newTintColor, <span class="string">titleTextAttributes:</span>newTextAttributes) {
    barTintColor = <span class="string">barTintColor:</span>newBarTintColor
    tintColor = <span class="string">tintColor:</span>newTintColor
    titleTextAttributes = <span class="string">titleTextAttributes:</span>newTextAttributes
}
</code></pre><p>重构完函数以后，我们发现在多个样式中用到了switch case进行业务逻辑参数转换样式参数的过程。<strong>这说明什么，我们可以将转换逻辑和switch case一起通过Enum进行重构（这里说的东西都是基于你懂Enum）</strong></p>
<pre><code><span class="keyword">enum</span> NavigationTheme {
    <span class="keyword">case</span> Normal
    <span class="keyword">case</span> Warning
    <span class="keyword">case</span> Doomed

    var statusBarStyle: <span class="built_in">UIStatusBarStyle</span> {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>: <span class="keyword">return</span> <span class="variable">.Default</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>: <span class="keyword">return</span> <span class="variable">.LightContent</span>
        }
    }

    var barTintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">235</span>/<span class="number">255</span>, green: <span class="number">156</span>/<span class="number">255</span>, blue: <span class="number">77</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        <span class="keyword">case</span> <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span>(red: <span class="number">248</span>/<span class="number">255</span>, green: <span class="number">73</span>/<span class="number">255</span>, blue: <span class="number">68</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
        }
    }

    var titleTextAttributes: [String: <span class="built_in">NSObject</span>]? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> [<span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()]
        }
    }

    var tintColor: <span class="built_in">UIColor</span>? {
        <span class="keyword">switch</span> <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="variable">.Normal</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">case</span> <span class="variable">.Warning</span>, <span class="variable">.Doomed</span>:
            <span class="keyword">return</span> <span class="built_in">UIColor</span><span class="variable">.whiteColor</span>()
        }
    }
}

extension NavigationTheme {
    init(numberOfImminentTasks: Int) {
        <span class="keyword">switch</span> numberOfImminentTasks {
        <span class="keyword">case</span> -Int<span class="variable">.max</span> ... <span class="number">3</span>:
            <span class="keyword">self</span> = <span class="variable">.Normal</span>
        <span class="keyword">case</span> <span class="number">4.</span>.<span class="number">.9</span>:
            <span class="keyword">self</span> = <span class="variable">.Warning</span>
        <span class="keyword">default</span>:
            <span class="keyword">self</span> = <span class="variable">.Doomed</span>
        }
    }
}    
</code></pre><p>由于Enum在swift中是一等公民，因此可以可以在其中构建大量的<strong>Computed Properties</strong>，这些计算变量依赖于当前enum的状态。不仅如此，我们还将之前分散的三种样式，组合成了一个<strong>紧凑的结构体</strong>，大大简化了变量传输。</p>
<p>重构结束后，我们在<code>Viewcontroller.swift</code>中设置一个计算变量<code>navigationTheme</code>，其的构造函数是之前的<code>fetchedResultsController?.fetchedObjects?.count</code>。</p>
<p>最后是在相应的事件后触发更新UINavigationBar即可，在本文的视线中，是采用了closure的形式完成：</p>
<pre><code>navigationThemeDidChangeHandler = { [<span class="keyword">weak</span> <span class="keyword">self</span>] theme <span class="keyword">in</span>
            <span class="keyword">if</span> <span class="keyword">let</span> navigationController = <span class="keyword">self</span>?.navigationController {
                navigationController.navigationBar.applyTheme(theme)
                navigationController.statusBarStyle = theme.statusBarStyle
            }
        }
</code></pre><h3 id="2-_干掉时间相关的转换逻辑">2. 干掉时间相关的转换逻辑</h3><p>相信很多人做app的时候遇到过，服务器返回的是一系列标准时间参数，而你需要将其转换成界面需要的生日、星座、年龄等等，这又是一大堆的业务逻辑。为了解决这种逻辑代码和ViewController的耦合，很多人提出了<code>ViewModel</code>，将部分弱业务逻辑代码剥离出来，单独写在一个地方。</p>
<p><strong>但是，我需要强调一点，这种形式的剥离，并不能叫ViewModal，而是一个简单的adapter而已。</strong></p>
<p>在本文中，列表Cell里面需要根据日期距离当前时间的差距显示成昨天、今天、明天等等。因此，其构建了一个单独的的DateFormatter，根据传入的两个Date进行转换，代码如下：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">RelativeTimeDateFormatter</span> </span>{
    <span class="keyword">let</span> calendar: <span class="type">NSCalendar</span>

    <span class="keyword">init</span>(calendar: <span class="type">NSCalendar</span> = <span class="type">NSCalendar</span>.autoupdatingCurrentCalendar()) {
        <span class="keyword">self</span>.calendar = calendar
    }

    <span class="func"><span class="keyword">func</span> <span class="title">stringForDate</span><span class="params">(date: NSDate, relativeToDate baseDate: NSDate)</span></span> -&gt; <span class="type">String</span> {
        <span class="keyword">var</span> beginningOfDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>
        <span class="keyword">var</span> beginningOfBaseDate: <span class="type">NSDate</span>? = <span class="literal">nil</span>

        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfDate, interval: <span class="literal">nil</span>, forDate: date)
        calendar.rangeOfUnit(.<span class="type">Day</span>, startDate: &amp;beginningOfBaseDate, interval: <span class="literal">nil</span>, forDate: baseDate)
        <span class="keyword">let</span> numberOfCalendarDaysBetweenDates = calendar.components(<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, fromDate: beginningOfBaseDate!, toDate: beginningOfDate!, options: <span class="type">NSCalendarOptions</span>()).day

        <span class="keyword">switch</span> numberOfCalendarDaysBetweenDates {
        <span class="keyword">case</span> -<span class="type">Int</span>.<span class="built_in">max</span> ... -<span class="number">2</span>:
            <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="built_in">abs</span>(numberOfCalendarDaysBetweenDates)</span>) days ago"</span>
        <span class="keyword">case</span> -<span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Yesterday"</span>
        <span class="keyword">case</span> <span class="number">0</span>:
            <span class="keyword">return</span> <span class="string">"Today"</span>
        <span class="keyword">case</span> <span class="number">1</span>:
            <span class="keyword">return</span> <span class="string">"Tomorrow"</span>
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="string">"In <span class="subst">\(numberOfCalendarDaysBetweenDates)</span> days"</span>
        }
    }
}
</code></pre><p><strong>这里需要注意的是，NSCalendar的初始化非常耗时，过去在Objective-C时代常常使用dispatch_once构建单例传输，在这里通过结构体中的成员变量维护了一份，作用是同样的。</strong></p>
<h3 id="3-_干掉NSPredicate">3. 干掉NSPredicate</h3><p>对于NSPredicate，有些人可能还不熟悉，他就是类似于SQLite中的查询语句，只不过其应用范围是CoreData。咦，查询语句还能重构？</p>
<p>其实在本文中，对于NSPredicate的使用只有原先这一句  <code>fetchRequest.predicate = NSPredicate(format: &quot;dueDate &lt;= %@&quot;, argumentArray: [NSCalendar.currentCalendar().dateByAddingUnit(.Day, value: 10, toDate: NSDate(), options: NSCalendarOptions())!])</code></p>
<p>这段代码从重复性上来说是不需要重构的。但是，我们可以看到，在这里的构造参数里面，我们还是进行了一定的业务逻辑转换。所以，和DateFormatter一样，我们也可以将这部分所谓为的”弱业务逻辑”代码进行剥离：</p>
<pre><code>extension NSPredicate {
    convenience init(forTasksWithinNumberOfDays <span class="string">numberOfDays:</span> Int, ofDate <span class="string">date:</span> NSDate, <span class="string">calendar:</span> NSCalendar = NSCalendar.currentCalendar()) {
        self.init(<span class="string">format:</span> <span class="string">"dueDate &lt;= %@"</span>, <span class="string">argumentArray:</span> [calendar.dateByAddingUnit(.Day, <span class="string">value:</span> numberOfDays, <span class="string">toDate:</span> date, <span class="string">options:</span> NSCalendarOptions())!])
    }
}
</code></pre><p><strong>除了业务逻辑剥离之外，其实我们也可以看到，在这个NSPredicate的新构造参数，可以接受一个<code>calendar</code>，这对于测试用例编写的依赖注入是非常有好处的。</strong></p>
<h3 id="4-_Core_Data_Stack">4. Core Data Stack</h3><p>用过Core Data的人都知道，Core Data的使用非常麻烦，需要配置大量的选项，照着苹果源码写的经历相信大家都有过，那恶心的200-300行配置代码，真是么么哒了。</p>
<p><strong>但是，这几百行代码又是无法省略的</strong>，那该怎么办呢？</p>
<p>一个比较好的解决方案就<code>Core Data Stack</code>    。意为将CoreData的初始化以及多个NSManagerObjectContext封装进<code>CoreDataStack</code> 维护。 </p>
<p>在本文中，因为只是使用了一个主线程的NSManagerObjectContext，所以可能读者在阅读源码的时候可能觉得这个重构只是将CoreData配置从View剥离了。但是实际上，使用CoreDataStack可以做到更多，建议大家阅读Github上相关项目。</p>
<h3 id="5-_干掉NSFetchedResultsControllerDelegate">5. 干掉NSFetchedResultsControllerDelegate</h3><p>NSFetchedResultsController大家可以简单理解为获取CoreData数据的一个中介层。根据传输进入的谓语NSPredicate进行查询，查询结束后通过相应的Delegate事件回调。</p>
<p>在作者的代码中，作者通过构建<code>manager</code>的方式剥离了NSFetchedResultsController的职责，将NSFetchedResultsController的初始化、回调封装进了<code>UpcomingTaskDataManager.swift</code>中。</p>
<p><strong>不过值得注意的一点是，尽管作者封装的NSFetchedResultsControllerDelegate的回调，但是为了让调用者可以自定义处理事件，实际上作者还是需要暴露一些的Delegate，当然，新的回调相对来说进行了一定的简化，同时在数据回调时经过了业务转化。</strong></p>
<pre><code><span class="class"><span class="keyword">protocol</span> <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerWillChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManagerDidChangeContent</span><span class="params">(dataManager: UpcomingTaskDataManager)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didInsertRowAtIndexPath indexPath: NSIndexPath)</span></span>
    <span class="func"><span class="keyword">func</span> <span class="title">dataManager</span><span class="params">(dataManager: UpcomingTaskDataManager, didDeleteRowAtIndexPath indexPath: NSIndexPath)</span></span>
}
</code></pre><h3 id="6-_CoreDataModel_&lt;=&gt;_Model">6. CoreDataModel &lt;=&gt; Model</h3><p>这一步是将从Core Data中获取的NSManagedObject Model 转换成业务中使用的Model。为什么要这么做呢？原因有三个：  </p>
<ul>
<li>CoreData中的属性一更改，就会触发NSFetchedResultsController，这会很影响性能。</li>
<li>CoreData中的属性存在很多bug</li>
<li>NSManagedObject不是一个struct类型，很有可能<strong>误伤</strong></li>
</ul>
<pre>
import CoreData  
import Foundation

struct Task: Equatable {
    var id: String
    var title: String
    var dueDate: NSDate
}

func ==(lhs: Task, rhs: Task) -> Bool {
    return lhs.id == rhs.id && lhs.title == rhs.title && lhs.dueDate == rhs.dueDate
}

extension Task {
    init(managedTask: NSManagedObject) {
        self.id = managedTask.valueForKey("id") as! String
        self.title = managedTask.valueForKey("title") as! String
        self.dueDate = managedTask.valueForKey("dueDate") as! NSDate
    }
}
</pre>

<p>作者用以上的Task类型替换了CoreData中的ManagedObject，可以有效的避免以上问题。</p>
<h3 id="7-封装数据结构">7.封装数据结构</h3><p>在这一步里，我将作者自定义<code>TaskTableViewCell</code>和构建<code>AddCompletionSegue</code>合并到了一块说。</p>
<p>这两步的重构，看似简单，但是其实也蕴含了一个思想：<strong>类型越确定，编程越容易，运行越安全</strong></p>
<p>在原文的实现，一开始作者都是通过采用基础的数据结构UITableViewCell和UISegue。这样带来的坏处就是类型不明确导致的职责不明确。对于基础的数据结构，我们常常还要进行类型判断和转换，容易犯错。</p>
<h3 id="8-干掉UITableViewDelegate和UITableViewDataSource">8.干掉UITableViewDelegate和UITableViewDataSource</h3><p>这一步想必大家都很熟悉了，微博上整天热传了<em>用ViewModel重构你的ViewController</em>经常提及的就是干掉UITableViewDelegate和UITableViewDataSource。</p>
<p>那说了那么多，我们来看看究竟如何干掉它。</p>
<p>毫无以为，我们首先要构建一个类型，来实现UITableViewDelegate和DataSource，如下所示：</p>
<pre><code><span class="comment">// 1. </span>
<span class="class"><span class="keyword">class</span> <span class="title">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="title">CellType</span>: <span class="title">UITableViewCell</span>&gt;: <span class="title">NSObject</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UpcomingTaskDataManagerDelegate</span> </span>{
    private <span class="keyword">let</span> tableView: <span class="type">UITableView</span>
    private <span class="keyword">let</span> upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>
    private <span class="keyword">let</span> cellReuseIdentifier: <span class="type">String</span>
    private <span class="keyword">let</span> cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; ()
    private <span class="keyword">let</span> didChangeHandler: () -&gt; <span class="type">Void</span>

<span class="comment">// .2</span>
    <span class="keyword">init</span>(tableView: <span class="type">UITableView</span>, upcomingTaskDataManager: <span class="type">UpcomingTaskDataManager</span>, cellReuseIdentifier: <span class="type">String</span>, cellConfigurationHandler: (<span class="type">CellType</span>, <span class="type">Task</span>) -&gt; (), didChangeHandler: () -&gt; <span class="type">Void</span>) {
        <span class="keyword">self</span>.tableView = tableView
        <span class="keyword">self</span>.upcomingTaskDataManager = upcomingTaskDataManager
        <span class="keyword">self</span>.cellReuseIdentifier = cellReuseIdentifier
        <span class="keyword">self</span>.cellConfigurationHandler = cellConfigurationHandler
        <span class="keyword">self</span>.didChangeHandler = didChangeHandler

        <span class="keyword">super</span>.<span class="keyword">init</span>()
    }

<span class="comment">// 3.</span>
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> {
        upcomingTaskDataManager.deleteTask(upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row])
    }

    <span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].title
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> upcomingTaskDataManager.taskSections[section].items.<span class="built_in">count</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> {
        <span class="keyword">let</span> task = upcomingTaskDataManager.taskSections[indexPath.section].items[indexPath.row]
        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellReuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">CellType</span>
        cellConfigurationHandler(cell, task)
        <span class="keyword">return</span> cell
    }
</code></pre><ol>
<li>这个<code>UpcomingTaskDataManagerTableViewAdapter</code>通过传入一个CellType支持泛型。  </li>
<li>通过接受几个closure来进行自定义的配置，包括cell的样式配置以及tableview数据更新后的回调。  </li>
<li>实现的UITableViewDataSource</li>
</ol>
<p>同样，由于职责的重新分配，我们要将跟<code>TaskManager</code>（包括NSFetchedResultsController）相关的划入到这个adapter中。</p>
<h3 id="大结局">大结局</h3><p>最后重构后的ViewController，只有<strong>37</strong>代码，效果如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UITableViewController</span> </span>{
    <span class="keyword">var</span> navigationThemeDidChangeHandler: ((<span class="type">NavigationTheme</span>) -&gt; <span class="type">Void</span>)?
    <span class="keyword">var</span> navigationTheme: <span class="type">NavigationTheme</span> {
        <span class="keyword">return</span> <span class="type">NavigationTheme</span>(numberOfImminentTasks: upcomingTaskDataManager.totalNumberOfTasks)
    }

    private <span class="keyword">let</span> upcomingTaskDataManager = <span class="type">UpcomingTaskDataManager</span>()
    private <span class="keyword">var</span> upcomingTaskDataManagerTableViewAdapter: <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>&lt;<span class="type">TaskTableViewCell</span>&gt;!

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
        <span class="keyword">super</span>.viewDidLoad()

        upcomingTaskDataManagerTableViewAdapter = <span class="type">UpcomingTaskDataManagerTableViewAdapter</span>(
            tableView: tableView,
            upcomingTaskDataManager: upcomingTaskDataManager,
            cellReuseIdentifier: <span class="string">"Cell"</span>,
            cellConfigurationHandler: { cell, task <span class="keyword">in</span>
                cell.viewData = <span class="type">TaskTableViewCell</span>.<span class="type">ViewData</span>(task: task, relativeToDate: <span class="type">NSDate</span>())
            },
            didChangeHandler: { [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="keyword">self</span>?.updateNavigationBar() }
        )
        upcomingTaskDataManager.delegate = upcomingTaskDataManagerTableViewAdapter
        tableView.dataSource = upcomingTaskDataManagerTableViewAdapter

        updateNavigationBar()
    }

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> <span class="literal">true</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">updateNavigationBar</span><span class="params">()</span></span> {
        navigationThemeDidChangeHandler?(navigationTheme)
    }

    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">unwindFromAddController</span><span class="params">(segue: AddCompletionSegue)</span></span> {
        upcomingTaskDataManager.createTaskWithTitle(segue.taskTitle, dueDate: segue.taskDueDate)
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/" data-id="ck9fy2ggl002i2ni1ghnesiwn" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2015/12/30/Refactor-Mega-ViewController/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Learn-R-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/20/Learn-R-2/" class="article-date">
  <time datetime="2015-12-20T08:43:31.000Z" itemprop="datePublished">2015-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/Learn-R-2/">一步步学R（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="系列连载">系列连载</h3><p><a href="http://satanwoo.github.io/2015/12/13/Learn-R-1/">一步步学R（1）</a><br><a href="http://satanwoo.github.io/2015/12/20/Learn-R-2/">一步步学R（2）</a></p>
<h3 id="If-Else">If-Else</h3><p>R 种的If-Else结构并没有比较特殊的地方，仍然支持两种结构：</p>
<pre><code><span class="tag">if</span> (condition) {
    <span class="comment">// Do Something</span>
} <span class="tag">else</span> {
   <span class="comment">// Do Otherthing</span>
}
</code></pre><p>或者如下：</p>
<pre><code><span class="keyword">if</span> (condition) {
    // <span class="keyword">Do</span> Something
} <span class="keyword">else</span> <span class="keyword">if</span> (condition2) {
   // <span class="keyword">Do</span> Otherthing
} <span class="keyword">else</span> {
   // <span class="keyword">Do</span> <span class="keyword">Else</span>
}
</code></pre><p>但是在R中，对于If-else有一个可以简化的地方，如：</p>
<pre><code><span class="keyword">if</span> (x &gt; <span class="number">100</span>) {
    y &lt;- <span class="number">10</span>
} <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">100</span>) {
   y &lt;- <span class="number">11</span>
} <span class="keyword">else</span> {
   y &lt;- <span class="number">5</span>
}
</code></pre><p>可以简化成：</p>
<pre><code>y &lt;- <span class="keyword">if</span> (x &gt; <span class="number">100</span>) {
    <span class="number">10</span>
} <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">100</span>) {
   <span class="number">11</span>
} <span class="keyword">else</span> {
   <span class="number">5</span>
}
</code></pre><h3 id="For">For</h3><p>For语句的语法也非常简单：</p>
<pre><code><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) {
    <span class="built_in">print</span>(i)
}
</code></pre><p><strong>seq_along</strong> 函数是for循环中可以注意的一个点。它的参数是一个vector，如<code>x &lt;- c(&#39;a&#39;, &#39;b&#39;)</code>，调用<code>seq_along(x)</code>会得到一个序列，长度为2，值为1，2。因此，<code>print(x[1])</code> 就等于 <code>a</code>。</p>
<h3 id="While">While</h3><p>同样简单：</p>
<pre><code><span class="keyword">while</span> <span class="comment">(condition)</span> {
   <span class="comment">// Do studyy</span>
}
</code></pre><h3 id="Repeat">Repeat</h3><p>repeat是R中特有的一种逻辑结构，简单来理解就是<strong>死循环</strong>，想要退出的唯一方式是<strong>显式使用<code>break</code>。</strong></p>
<pre><code>repeat {
    x &lt;- something()

    <span class="keyword">if</span> (<span class="literal">A</span>) {
        <span class="keyword">break</span>
    } <span class="keyword">else</span> {
        x &lt;- x + <span class="number">1</span>
    }
}
</code></pre><h3 id="Next">Next</h3><p><code>next</code>就是其他语言中的<code>continue</code></p>
<pre><code><span class="keyword">for</span> (i in <span class="number">1</span>:<span class="number">100</span>) {
     <span class="keyword">if</span> (i &lt; <span class="number">20</span>) {
         next
     }

     <span class="comment">// Do other</span>
}
</code></pre><h3 id="函数">函数</h3><p>R中的函数可以没有显式的<code>return</code>，默认返回最后一句语句。</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>{
     x + y
}
</code></pre><p>和其他语言一样，你可以给参数设置默认值，如</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y = 10)</span> </span>{
     x + y
}
</code></pre><p>R中的函数参数优点类似于JavaScript，<strong>可以不用赋值完全，前提是你用不到</strong>。而且，对于R中的参数，你可以打乱参数传递，只要你前面加上了行参的名称，</p>
<p>比如</p>
<pre><code>add2 &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>{
     x + y
}
</code></pre><p>你可以通过<code>add2(y = 5, x = 7)</code>来进行调用。</p>
<h4 id="可变参数">可变参数</h4><p>在R中也是有可变参数的，即<code>...</code>。</p>
<pre><code>myplot &lt;- <span class="function"><span class="keyword">function</span><span class="params">(x, y, type = 1, <span class="rest_arg">...) {
    plot</span>(x, y, type, <span class="rest_arg">...)
}</span></span></span>
</code></pre><p>同样，<code>...</code>也可以用在泛型函数中，后续学习中我们会说到。</p>
<p>**不过，与其他编程语言所不同的是，R中的可变参数可以放在函数列表的前面，如</p>
<p><code>function(..., sep = &quot; &quot;, collsape = NULL)</code></p>
<p>调用如上的这种函数，必须<strong>显式的</strong>通过函数参数名称来调用后续参数，如</p>
<p><code>function(&quot;haha&quot;, &quot;heihei&quot;, sep = &quot;,&quot;)</code></p>
<h3 id="变量作用域">变量作用域</h3><h4 id="使用变量">使用变量</h4><p>当你使用一个R语言中的变量时，比如x，你有没有想过x究竟是存在于哪里呢？</p>
<p>有些人会说，我定义的呀，比如<code>x &lt;- 5</code>，那么对于那些默认函数，比如<code>vector()</code>呢？</p>
<p>所以，这就涉及到R中的<strong>Symbol binding</strong>（其他语言的变量查找）了。</p>
<p>在R中，查找顺序是这样的。</p>
<pre><code>[<span class="number">1</span>] <span class="string">".GlobalEnv"</span>        <span class="string">"tools:rstudio"</span>     <span class="string">"package:stats"</span>     <span class="string">"package:graphics"</span>  <span class="string">"package:grDevices"</span>
[<span class="number">6</span>] <span class="string">"package:utils"</span>     <span class="string">"package:datasets"</span>  <span class="string">"package:methods"</span>   <span class="string">"Autoloads"</span>         <span class="string">"package:base"</span> 
</code></pre><p>默认查找的是<strong>.GlobalEnv</strong>，依次类推。</p>
<p>如果你还通过<code>library()</code>函数加载了其他package，如ggplot2，那么查找顺序是</p>
<pre><code> [<span class="number">1</span>] <span class="string">".GlobalEnv"</span>        <span class="string">"package:ggplot2"</span>   <span class="string">"tools:rstudio"</span>     <span class="string">"package:stats"</span>     <span class="string">"package:graphics"</span> 
 [<span class="number">6</span>] <span class="string">"package:grDevices"</span> <span class="string">"package:utils"</span>     <span class="string">"package:datasets"</span>  <span class="string">"package:methods"</span>   <span class="string">"Autoloads"</span>        
[<span class="number">11</span>] <span class="string">"package:base"</span>     
</code></pre><p>也就是用户加载的package会自动加到除了<strong>.GlobalEnv</strong>之外的任意搜索顺序前。</p>
<p>如果要查看最新的搜索顺序，可以通过<code>search()</code></p>
<h4 id="作用域">作用域</h4><p>R中的作用域，是Lexical Scoping，也就是静态作用域，也就是<strong>JavaScript的作用域</strong>。</p>
<p>好了，我不多说了，如果想学习更多冠以静态作用域的话，看我的JavaScript博客部分。</p>
<p>当然，如果你不懂，你可以通过如下函数帮助你理解。</p>
<p><code>ls(environment(functionName))</code><br><code>get(variableName, environment(functionName))</code></p>
<p><strong>一言以蔽之，lexcial scoping可以简单理解为你函数中需要的变量，是通过其定义时环境进行查找。</strong></p>
<h4 id="Data_and_Times">Data and Times</h4><p>R中的时间表示，采用了一种特殊的数据结构。</p>
<p>Date是通过<strong>Date</strong>这一数据结构表示，而Time是通过POSIXct或者POSIXlt表示。</p>
<ul>
<li>Date是不包含Time的，只显示年、月、日。</li>
<li>Date的内部储存是计算1970-01-01到当前时间之间的天数。</li>
<li>Time的内部储存是计算1979-01-01到当前时间之间的秒数。</li>
</ul>
<p>可以采用<code>as.Date</code>构建Date，如<code>as.Date(&quot;1970-01-01&quot;)</code></p>
<p>而Time相对来说比较复杂，我们首先来看看<code>Posixlt</code>的表现形式。</p>
<p>我们输入<code>p&lt;- Sys.time()</code>获取当前时间，结果是<code>&quot;2015-12-27 00:59:18 CST&quot;</code>，然后我们调用<code>unclass(p)</code>来看看其构成，结果如下：</p>
<pre><code>[<span class="number">1</span>] <span class="string">"sec"</span>    <span class="string">"min"</span>    <span class="string">"hour"</span>   <span class="string">"mday"</span>   <span class="string">"mon"</span>    <span class="string">"year"</span>   <span class="string">"wday"</span>   <span class="string">"yday"</span>   <span class="string">"isdst"</span>  <span class="string">"zone"</span>   <span class="string">"gmtoff"</span>
</code></pre><p><strong>这表明，通过<code>Posixlt</code>表征的<code>Time</code></strong>，其内部是由一系列成分组成的集合。我们可以通过<br><code>p$wday</code> 来查看今天是周几。  </p>
<p>而<code>Posixct</code>就是就算1970-01-01到当前时间的描述，是个非常大的<strong>Integer</strong>。</p>
<p>你可以对Date或者Time进行大小比较操作，但是注意，<strong>不能讲Date和Time混合操作</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2015/12/20/Learn-R-2/" data-id="ck9fy2ghp00382ni1g9olx6sy" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2015/12/20/Learn-R-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
    <article id="post-Regression-Model-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/15/Regression-Model-1/" class="article-date">
  <time datetime="2015-12-14T16:31:35.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/Regression-Model-1/">Regression Model</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Regression_Model是什么">Regression Model是什么</h3><p>Regression Model是一种基本的数据分析模型，通俗点来说就是我们在中学时期学习的截距式直线方程。通过斜率和截距来定义一种诸如 <code>y = kx + b</code>的方程。一旦有了这样的方程，我们就可以通过我们现有的数据集，比如一堆<code>x</code> 来预测y。</p>
<p>今天就让我们来研究研究这一种数据模型</p>
<h4 id="Centering">Centering</h4><p>Centering是一种常用的数学用语，意为 <em>集中化</em>。什么意思呢？就是说如果我有从x1, x2 … xn 这n个数据构成的数据集{x}，我可以求出他们的平均值为<em>XM</em>。我可以构建 <code>bi = xi - XM</code> 这样一个数列，这样的话，{b}这个数据集的平均值就为0，这一个过程就叫Centering。</p>
<h4 id="Variances（方差）">Variances（方差）</h4><p>方式的定义是:</p>
<blockquote>
<p>求出一个数据集的平均数XM, 对于{x} 中的每一个数，求其与平均数差的平方。再这这些差的平房加在一起求和，最后用和除以n - 1，这里的n是数据集中数据的个数。</p>
</blockquote>
<p>而标准差就是方差的平方根。 <strong>通过构建<code>bi = xi / 标准差s</code> 可以得到{b}数据集，它的标准差为1，这一过程也叫做Scaling</strong></p>
<h4 id="Normalization">Normalization</h4><p>将数据集先Centering再Scaling的过程叫做Normalization。</p>
<h4 id="Covariance（协方差）">Covariance（协方差）</h4><p>协方差的定义其实和方差类似，只不过针对的是一对数据集{x, y}。</p>
<blockquote>
<p>求出数据集{x}的平均数M，求出数据集{y}的平均数N，对于每一个i，求和<code>(xi - M) * (yi - N)</code>，最后和除以<code>n - 1</code>，其中n是数据集中数据的个数。</p>
</blockquote>
<h4 id="Corrleation（两个数据集的关联）">Corrleation（两个数据集的关联）</h4><p>Correlation就是将两个数据集的协方差除以{x}的标准差和{y}的标准差的乘积。<br><strong>Correlation的值域从－1到1，越接近两端表示两个数据集关联度越大，越靠近0表示越小。</strong></p>
<h3 id="重点">重点</h3><p>对于 y = kx + b 来说，可以通过如下公式求解方程：</p>
<p><code>k = cor(y, x) * s(y) / s(x)</code>  以及 <code>b = mean(y) - k * mean(x)</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://satanwoo.github.io/2015/12/15/Regression-Model-1/" data-id="ck9fy2ggi002f2ni1x82rxjiy" class="article-share-link">Share</a>
      
        <a href="http://satanwoo.github.io/2015/12/15/Regression-Model-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>

    </footer>
  </div>
  
</article>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://satanwoo-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                
  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/">Assembly</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly-Language/">Assembly Language</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Growth/">Growth</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/">Performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/">R</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reverse-Engineering/">Reverse Engineering</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XNU/">XNU</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">46</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Assembly/" style="font-size: 10px;">Assembly</a> <a href="/tags/Assembly-Language/" style="font-size: 10px;">Assembly Language</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Growth/" style="font-size: 10px;">Growth</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 10px;">Math</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/R/" style="font-size: 12.5px;">R</a> <a href="/tags/Reverse-Engineering/" style="font-size: 17.5px;">Reverse Engineering</a> <a href="/tags/Swift/" style="font-size: 17.5px;">Swift</a> <a href="/tags/XNU/" style="font-size: 12.5px;">XNU</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/26/TrampolineHookOpenSource/">基于桥的全量方法 Hook 方案（3）- 开源 TrampolineHook</a>
          </li>
        
          <li>
            <a href="/2020/04/22/NewBridgeHook/">基于桥的全量方法 Hook 方案（2） - 全新升级</a>
          </li>
        
          <li>
            <a href="/2020/04/07/Selective-Search/">目标检测之 Selective Search</a>
          </li>
        
          <li>
            <a href="/2020/02/06/MNN-Visual/">实现 MNN 模型的可视化工具</a>
          </li>
        
          <li>
            <a href="/2019/12/01/SIMD-1/">了解 SIMD 指令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 SatanWoo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/sitemap.xml" class="mobile-nav-link">map</a>
  
</nav>
    
<script>
  var disqus_shortname = 'satanwoo-2';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>